BEGIN
--EMP产品版本版本信息表
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='LF_VERSION') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE LF_VERSION
(
	ID INT PRIMARY KEY  NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                    START WITH +1
                    INCREMENT BY +1
                    MINVALUE +1
                    MAXVALUE +2147483647
                    NO CYCLE
                    NO CACHE
                    NO ORDER ),		--自增ID
	PRODUCT_ID INT DEFAULT 0 NOT NULL,	 			--产品编号:1000：EMP系统
	PROCESS_ID INT DEFAULT 0 NOT NULL,				--程序编号:1000: EMP-WEB,2000: EMP-网关WBS,3000: EMP-网关SPGATE
	MODULE_ID INT DEFAULT 0	NOT NULL,				--模块编号模块编号四位（WEB前端模块以1开头，WBS以2开头，SPGATE以3开头）
	MODULE_NAME VARCHAR(32) DEFAULT '' '' NOT NULL,	--模块名称
	VERSION VARCHAR(16) DEFAULT ''0'' NOT NULL,		--模块版本号
	UPDATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP ,	--更新时间
	CREATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP ,	--创建时间
	MEMO VARCHAR(128) DEFAULT '' '' NOT NULL --备注
) IN EMP_TABLESPACE
			';
      END;
    END IF;

    --EMP产品版本版本信息历史表,LF_VERSION_HIS
     IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='LF_VERSION_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE LF_VERSION_HIS
(
	ID INT PRIMARY KEY  NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                    START WITH +1
                    INCREMENT BY +1
                    MINVALUE +1
                    MAXVALUE +2147483647
                    NO CYCLE
                    NO CACHE
                    NO ORDER ),     --自增ID
	PRODUCT_ID INT DEFAULT 0 NOT NULL, --产品编号1000：EMP系统
	PROCESS_ID INT DEFAULT 0 NOT NULL, --程序编号1000: EMP-WEB,2000: EMP-网关WBS,3000: EMP-网关SPGATE
	MODULE_ID INT DEFAULT 0	NOT NULL,  --模块编号四位（WEB前端模块以1开头，WBS以2开头，SPGATE以3开头）
	MODULE_NAME VARCHAR(32) DEFAULT '' '' NOT NULL,--模块名称
	VERSION VARCHAR(16) DEFAULT ''0'' NOT NULL,--模块版本号
	UPDATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP ,--更新时间
	CREATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP, --创建时间
	MEMO VARCHAR(128) DEFAULT '' '' NOT NULL --备注
)IN EMP_TABLESPACE
			';
      END;
    END IF;

    --EMP产品数据库版本信息表
     IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='LF_DB_SCRIPT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE LF_DB_SCRIPT
(
ID INT PRIMARY KEY  NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                    START WITH +1
                    INCREMENT BY +1
                    MINVALUE +1
                    MAXVALUE +2147483647
                    NO CYCLE
                    NO CACHE
                    NO ORDER ),			  --自增ID
VERSION VARCHAR(16) DEFAULT ''0'' NOT NULL, --脚本版本号
UPDATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP ,	  --更新时间
CREATETIME TIMESTAMP NOT NULL WITH DEFAULT CURRENT TIMESTAMP ,	  --创建时间
CURRENT_NO INT DEFAULT 0 NOT NULL,			--当前脚本序号
TOTAL INT DEFAULT 0	NOT NULL,			--总脚本个数
STATE INT DEFAULT 1 NOT NULL,	--1执行中；2执行成功；
MEMO VARCHAR(128) DEFAULT '' '' NOT NULL --备注
)IN EMP_TABLESPACE
			';
      END;
    END IF;

END &&



BEGIN ATOMIC
DECLARE VERSIONSTR VARCHAR(32);
DECLARE DBVERSIONSTR VARCHAR(32);
DECLARE WBSVERSIONSTR VARCHAR(32);
DECLARE SPGATEVERSIONSTR VARCHAR(32);
DECLARE NUMSTR INT;
DECLARE TOTALSTR INT;
SET VERSIONSTR = '7.3.9.664.SP9';
SET DBVERSIONSTR = '73.09';
SET WBSVERSIONSTR = '8.6.5.220';
SET SPGATEVERSIONSTR = '6.1.53.345';
SET NUMSTR=1;
SET TOTALSTR=3;
--EMP产品版本记录
IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
--EMP-WEB
INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,1000,VERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'EMP-WEB');
END IF;

IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE VERSION=WBSVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
--EMP_GATEWAY
INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,2000,WBSVERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'EMP-GATEWAY');
END IF;

IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE VERSION=SPGATEVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
--SMT_SPGATE
INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,3000,SPGATEVERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'SMT_SPGATE');
END IF;

--EMP产品版本历史记录
IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
--EMP-WEB
INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,1000,VERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'EMP-WEB');
END IF;

IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
--EMP_GATEWAY
INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,2000,WBSVERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'EMP_GATEWAY');
END IF;

IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
--SMT_SPGATE
INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
VALUES(1000,3000,SPGATEVERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,'SMT_SPGATE');
END IF;

IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR AND CURRENT_NO=NUMSTR AND TOTAL=TOTALSTR) THEN
--EMP产品数据库版本信息表
INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
VALUES(DBVERSIONSTR,CURRENT TIMESTAMP,CURRENT TIMESTAMP,NUMSTR,TOTALSTR,1,'1号脚本');
END IF;
END  &&





BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='AGENTACCOUNT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
				CREATE TABLE "AGENTACCOUNT"
				("LOGINID"        CHARACTER(11)   NOT NULL  DEFAULT ''''   constraint PK_AGENTACCOUNT primary key,
				"DESCRIPTION"    VARCHAR(100)    NOT NULL  DEFAULT ''代理帐号'',
				"PRIVILEGE"      INTEGER         NOT NULL  DEFAULT 11,
				"USERFEEFLAG"    INTEGER         NOT NULL  DEFAULT 1,
				"PRIVILEGEINFO"  VARCHAR(1000)   NOT NULL  DEFAULT ''具有代理帐号权限'',
				"ISTRANSIT"      SMALLINT        NOT NULL  DEFAULT 2
				)
			DATA CAPTURE NONE
			IN "TPACCMGR"
			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='AGENTACCOUNT' AND INDNAME='PK_AGENTACCOUNT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_AGENTACCOUNT"
  ON "AGENTACCOUNT"
 ("LOGINID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

COMMIT;
END  &&


ALTER TABLE "AGENTACCOUNT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='ATTIME_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
						CREATE TABLE "ATTIME_TASK"
 ("ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_ATTIMETASK primary key,
  "LOGINID"    VARCHAR(11)     NOT NULL  DEFAULT '''',
  "TASKID"     INTEGER         NOT NULL  DEFAULT 0,
  "BMTMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "ATTIME"     BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"  BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='ATTIME_TASK' AND INDNAME='IX_ATTMTASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_ATTMTASK"
  ON "ATTIME_TASK"
 ("LOGINID" ASC,
  "TASKID"  ASC,
  "BMTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS ';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='ATTIME_TASK' AND INDNAME='PK_ATTIMETASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_ATTIMETASK"
  ON "ATTIME_TASK"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


COMMIT;
END  &&


ALTER TABLE "ATTIME_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_CHANNELMAP') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
 CREATE TABLE "A_CHANNELMAP"
 ("ID"        INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "SPNUMBER"  VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"      VARCHAR(21)     NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.KEYCOLUSE  WHERE TABNAME='A_CHANNELMAP' AND COLNAME='CPNO' AND CONSTNAME='IX_A_CHMAP_CPNO') THEN
        BEGIN ATOMIC
			EXECUTE IMMEDIATE 'ALTER TABLE "A_CHANNELMAP" ADD CONSTRAINT "IX_A_CHMAP_CPNO" UNIQUE("CPNO")';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.KEYCOLUSE  WHERE TABNAME='A_CHANNELMAP' AND COLNAME='SPNUMBER' AND CONSTNAME='IX_A_CHMAP_SPNO') THEN
        BEGIN ATOMIC
			EXECUTE IMMEDIATE 'ALTER TABLE "A_CHANNELMAP"
  ADD CONSTRAINT "IX_A_CHMAP_SPNO" UNIQUE
   ("SPNUMBER"
   )';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_CHANNELMAP' AND INDNAME='IX_A_CHMAP_CPNO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_A_CHMAP_CPNO" ON "A_CHANNELMAP" ("CPNO" ASC)  PCTFREE 10 ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_CHANNELMAP' AND INDNAME='IX_A_CHMAP_SPNO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_A_CHMAP_SPNO" ON "A_CHANNELMAP" ("SPNUMBER" ASC) PCTFREE 10 ALLOW REVERSE SCANS';
        END;
    END IF;
COMMIT;
END  &&

ALTER TABLE "A_CHANNELMAP"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_CMDQUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
	CREATE TABLE "A_CMDQUE"
 ("ID"          INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint PK_A_CMDQUE primary key,
  "GWNO"        INTEGER         NOT NULL  DEFAULT 2999,
  "GWTYPE"      INTEGER         NOT NULL  DEFAULT 4000,
  "CMDTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "CMDINFO"     VARCHAR(512)    NOT NULL  DEFAULT '''',
  "CMDPARAM"    VARCHAR(1024)   NOT NULL  DEFAULT '''',
  "DEALSTATUS"  INTEGER         NOT NULL  DEFAULT 1,
  "RESULTCODE"  VARCHAR(32)     NOT NULL  DEFAULT ''SUCCESS'',
  "REQTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "DONETIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
COMMIT;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_CMDQUE' AND INDNAME='PK_A_CMDQUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_CMDQUE"
  ON "A_CMDQUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


END  &&


ALTER TABLE "A_CMDQUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_CMDQUE_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
					CREATE TABLE "A_CMDQUE_HIS"
 ("ID"          INTEGER         NOT NULL,
  "GWNO"        INTEGER         NOT NULL  DEFAULT 2999,
  "GWTYPE"      INTEGER         NOT NULL  DEFAULT 4000,
  "CMDTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "CMDINFO"     VARCHAR(512)    NOT NULL  DEFAULT '''',
  "CMDPARAM"    VARCHAR(1024)   NOT NULL  DEFAULT '''',
  "DEALSTATUS"  INTEGER         NOT NULL  DEFAULT 1,
  "RESULTCODE"  VARCHAR(32)     NOT NULL  DEFAULT ''SUCCESS'',
  "REQTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "DONETIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
COMMIT;
END   &&


ALTER TABLE "A_CMDQUE_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWACCOUNT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
				CREATE TABLE "A_GWACCOUNT"
 ("GWNO"           INTEGER         NOT NULL  DEFAULT 100,
  "PTACCUID"       INTEGER         NOT NULL  DEFAULT 0,
  "PTACCID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PTACCPWD"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "SPACCID"        VARCHAR(32)     NOT NULL  DEFAULT '''',
  "SPACCPWD"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "SPID"           VARCHAR(32)     NOT NULL  DEFAULT '''',
  "SERVICETYPE"    VARCHAR(32)     NOT NULL  DEFAULT '''',
  "FEEUSERTYPE"    INTEGER         NOT NULL  DEFAULT 2,
  "SPIP"           VARCHAR(32)     NOT NULL  DEFAULT ''127.0.0.1'',
  "SPPORT"         INTEGER         NOT NULL  DEFAULT 7890,
  "SPEEDLIMIT"     INTEGER         NOT NULL  DEFAULT 100,
  "PROTOCOLCODE"   INTEGER         NOT NULL  DEFAULT 5,
  "PTPORT"         INTEGER         NOT NULL  DEFAULT 7892,
  "PTIP"           VARCHAR(32)     NOT NULL  DEFAULT ''127.0.0.1'',
  "PTACCNAME"      VARCHAR(64)     NOT NULL  DEFAULT '''',
  "PROTOCOLPARAM"  VARCHAR(1024)   NOT NULL  DEFAULT '''',
  "SPTYPE"         SMALLINT        NOT NULL  DEFAULT 0,
  "FEEURL"         VARCHAR(256)    NOT NULL DEFAULT '''',
  "BALANCE"        INTEGER	       NOT NULL DEFAULT 0,
  "BALANCETH"      INTEGER	       NOT NULL DEFAULT 0,
  "UPDATETIME"     TIMESTAMP       NOT NULL DEFAULT CURRENT TIMESTAMP,
  "SPFEEFLAG"      INTEGER         NOT NULL DEFAULT 1,
   "PTNODE"        VARCHAR(1024)   NOT NULL DEFAULT ''''
  )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
	IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='A_GWACCOUNT' AND CONSTNAME='PK_A_GWACCOUNT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "A_GWACCOUNT"
  ADD CONSTRAINT "PK_A_GWACCOUNT" PRIMARY KEY
   ("GWNO",
    "PTACCUID"
   )';
        END;
END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWACCOUNT' AND INDNAME='PK_A_GWACCOUNT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_GWACCOUNT"
  ON "A_GWACCOUNT"
 ("GWNO"     ASC,
  "PTACCUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

COMMIT;
END  &&

ALTER TABLE "A_GWACCOUNT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWDBCONF') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
					CREATE TABLE "A_GWDBCONF"
 ("DBTYPE"  INTEGER         NOT NULL  DEFAULT 2,
  "DBIP"    VARCHAR(64)     NOT NULL  DEFAULT ''127.0.0.1'',
  "DBPORT"  INTEGER         NOT NULL  DEFAULT 1521,
  "DBNAME"  VARCHAR(64)     NOT NULL  DEFAULT ''EMPSVR'',
  "DBUSER"  VARCHAR(64)     NOT NULL  DEFAULT ''EMPSVR'',
  "DBPWD"   VARCHAR(64)     NOT NULL  DEFAULT ''123456''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
COMMIT;
END  &&


ALTER TABLE "A_GWDBCONF"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&




BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWLOGS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "A_GWLOGS"
 ("ID"        INTEGER       NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_A_GWLOGS primary key,
  "GWNO"      INTEGER       NOT NULL  DEFAULT 2999,
  "GWTYPE"    INTEGER       NOT NULL  DEFAULT 4000,
  "LOGTYPE"   INTEGER       NOT NULL  DEFAULT 0,
  "LOGLEVEL"  INTEGER       NOT NULL  DEFAULT 0,
  "LOGTIME"   TIMESTAMP     NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "LOGS"      LONG VARCHAR  NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWLOGS' AND INDNAME='PK_A_GWLOGS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_GWLOGS"
  ON "A_GWLOGS"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

COMMIT;
END  &&


ALTER TABLE "A_GWLOGS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWPARAMCONF') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '

			CREATE TABLE "A_GWPARAMCONF"
 ("GWTYPE"          INTEGER         NOT NULL  DEFAULT 4000,
  "PARAMITEM"       VARCHAR(64)     NOT NULL  DEFAULT  '''',
  "PARAMNAME"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "PARAMATTRIBUTE"  INTEGER         NOT NULL  DEFAULT 0,
  "PARAMMEMO"       VARCHAR(256)    NOT NULL  DEFAULT '''',
  "DEFAULTVALUE"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "VALUERANGE"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "CONTROLTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "HKPARAMNAME"     VARCHAR(256)    NOT NULL  DEFAULT '''',
  "HKPARAMMEMO"     VARCHAR(512)    NOT NULL  DEFAULT '''',
  "ENPARAMNAME"     VARCHAR(256)    NOT NULL  DEFAULT '''',
  "ENPARAMMEMO"     VARCHAR(512)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;

		IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='A_GWPARAMCONF' AND CONSTNAME='PK_A_GWPARAMCONF') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "A_GWPARAMCONF"
  ADD CONSTRAINT "PK_A_GWPARAMCONF" PRIMARY KEY
   ("GWTYPE",
    "PARAMITEM"
   )';
        END;
END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWPARAMCONF' AND INDNAME='PK_A_GWPARAMCONF') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_GWPARAMCONF"
  ON "A_GWPARAMCONF"
 ("GWTYPE"    ASC,
  "PARAMITEM" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


END  &&


ALTER TABLE "A_GWPARAMCONF"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWPARAMTMPL') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
				CREATE TABLE "A_GWPARAMTMPL"
 ("GWTYPE"     INTEGER         NOT NULL  DEFAULT 4000,
  "PARAMITEM"  VARCHAR(64)     NOT NULL  DEFAULT '''',
  "PARAMVALUE" VARCHAR(255)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
COMMIT;
END  &&


ALTER TABLE "A_GWPARAMTMPL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWPARAMVALUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "A_GWPARAMVALUE"
 ("GWNO"       INTEGER         NOT NULL  DEFAULT 99,
  "GWTYPE"     INTEGER         NOT NULL  DEFAULT 4000,
  "PARAMITEM"  VARCHAR(64)     NOT NULL  DEFAULT '''',
  "PARAMVALUE" VARCHAR(256)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
	IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='A_GWPARAMVALUE' AND CONSTNAME='PK_A_GWPARAMVALUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "A_GWPARAMVALUE"
  ADD CONSTRAINT "PK_A_GWPARAMVALUE" PRIMARY KEY
   ("GWNO",
    "GWTYPE",
    "PARAMITEM"
   )';
        END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWPARAMVALUE' AND INDNAME='PK_A_GWPARAMVALUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_GWPARAMVALUE"
  ON "A_GWPARAMVALUE"
 ("GWNO"      ASC,
  "GWTYPE"    ASC,
  "PARAMITEM" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


COMMIT;
END  &&


ALTER TABLE "A_GWPARAMVALUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWSPBIND') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
					CREATE TABLE "A_GWSPBIND"
 ("GATEID"    INTEGER  NOT NULL  DEFAULT 0,
  "PTACCUID"  INTEGER  NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
COMMIT;
END  &&


ALTER TABLE "A_GWSPBIND"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_PROINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "A_PROINFO"
 ("SERIALNUM"  VARCHAR(32)     NOT NULL  DEFAULT ''''  constraint PK_A_PROINFO primary key,
  "PROTYPE"    INTEGER         NOT NULL  DEFAULT 1,
  "PROSTATUS"  INTEGER         NOT NULL  DEFAULT 100,
  "VALIDDAYS"  INTEGER         NOT NULL  DEFAULT 0,
  "CORPNAME"   VARCHAR(128)    NOT NULL  DEFAULT '''',
  "STATUSINFO" VARCHAR(1024)   NOT NULL  DEFAULT '''',
  "SENDSPEED"  INTEGER         NOT NULL  DEFAULT 100
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
COMMIT;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_PROINFO' AND INDNAME='PK_A_PROINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_PROINFO"
  ON "A_PROINFO"
 ("SERIALNUM" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;



END  &&

ALTER TABLE "A_PROINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_PROTOCOLTMPL') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "A_PROTOCOLTMPL"
 ("PROTOCOLCODE"  INTEGER         NOT NULL  DEFAULT 40  constraint PK_A_PROTOCOLTMPL primary key,
  "PROTOCOL"      VARCHAR(32)     NOT NULL  DEFAULT '''',
  "PROTOCOLPARAM" VARCHAR(1024)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
COMMIT;


IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='A_PROTOCOLTMPL' AND CONSTNAME='PK_A_PROTOCOLTMPL') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "A_PROTOCOLTMPL"
  ADD CONSTRAINT "PK_A_PROTOCOLTMPL" PRIMARY KEY
   ("PROTOCOLCODE"
   )';
        END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_PROTOCOLTMPL' AND INDNAME='PK_A_PROTOCOLTMPL') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_A_PROTOCOLTMPL"
  ON "A_PROTOCOLTMPL"
 ("PROTOCOLCODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "A_PROTOCOLTMPL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='BATCH_MT_REQ') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "BATCH_MT_REQ"
 ("ID"           INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_BAT_MT_REQ primary key,
  "MSGID"        BIGINT          NOT NULL  DEFAULT 0,
  "BMTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "LOGINID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERUID"      INTEGER         NOT NULL  DEFAULT 0,
  "SERVICETYPE"  VARCHAR(10)     NOT NULL  DEFAULT '''',
  "TASKID"       INTEGER         NOT NULL  DEFAULT 0,
  "TITLE"        VARCHAR(500)    NOT NULL  DEFAULT '''',
  "MSG"          VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 15,
  "REMOTEURL"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LOCALPATH"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"    SMALLINT        NOT NULL  DEFAULT 0,
  "ATTIME"       CHARACTER(14)   NOT NULL  DEFAULT '''',
  "VALIDTIME"    CHARACTER(14)   NOT NULL  DEFAULT '''',
  "SENDSTATUS"   SMALLINT        NOT NULL  DEFAULT 1,
  "ERRORCODE"    CHARACTER(7)    NOT NULL  DEFAULT '''',
  "RECVTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTYPE"     SMALLINT        NOT NULL  DEFAULT 1,
  "ATTIMEFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "SA"           VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SVRTYPE"      VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"    BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"     INTEGER         NOT NULL  DEFAULT 0,
  "RETFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "SENDNUM"      INTEGER         NOT NULL  DEFAULT 0,
  "TOTALNUM"     INTEGER         NOT NULL  DEFAULT 0,
  "TASKTYPE"     INTEGER         NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "CLUPATH"	VARCHAR(256) 	NOT NULL DEFAULT '''',
  "CLUGWNO"	INTEGER         NOT NULL DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_BMTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_BATMTREQ_BMTMSGID"
  ON "BATCH_MT_REQ"
 ("BMTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_LGNID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMTREQ_LGNID"
  ON "BATCH_MT_REQ"
 ("LOGINID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_MSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMTREQ_MSGID"
  ON "BATCH_MT_REQ"
 ("MSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_SDSTS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMTREQ_SDSTS"
  ON "BATCH_MT_REQ"
 ("SENDSTATUS" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_TASKID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMTREQ_TASKID"
  ON "BATCH_MT_REQ"
 ("TASKID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMTREQ_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMTREQ_USRID"
  ON "BATCH_MT_REQ"
 ("USERID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='PK_BAT_MT_REQ') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_BAT_MT_REQ"
  ON "BATCH_MT_REQ"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ' AND INDNAME='IX_BATMT_BATCHID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATMT_BATCHID"
  ON "BATCH_MT_REQ"
 ("BATCHID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&


ALTER TABLE "BATCH_MT_REQ"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='BATCH_MT_REQ_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "BATCH_MT_REQ_HIS"
 ("ID"           INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "MSGID"        BIGINT          NOT NULL  DEFAULT 0,
  "BMTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "LOGINID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERUID"      INTEGER         NOT NULL  DEFAULT 0,
  "SERVICETYPE"  VARCHAR(10)     NOT NULL  DEFAULT '''',
  "TASKID"       INTEGER         NOT NULL  DEFAULT 0,
  "TITLE"        VARCHAR(500)    NOT NULL  DEFAULT '''',
  "MSG"          VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 15,
  "REMOTEURL"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LOCALPATH"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"    SMALLINT        NOT NULL  DEFAULT 0,
  "ATTIME"       CHARACTER(14)   NOT NULL  DEFAULT '''',
  "VALIDTIME"    CHARACTER(14)   NOT NULL  DEFAULT '''',
  "SENDSTATUS"   SMALLINT        NOT NULL  DEFAULT 1,
  "ERRORCODE"    CHARACTER(7)    NOT NULL  DEFAULT '''',
  "RECVTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTYPE"     SMALLINT        NOT NULL  DEFAULT 1,
  "ATTIMEFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "SA"           VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SVRTYPE"      VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"    BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"     INTEGER         NOT NULL  DEFAULT 0,
  "RETFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "SENDNUM"      INTEGER         NOT NULL  DEFAULT 0,
  "TOTALNUM"     INTEGER         NOT NULL DEFAULT 0,
  "TASKTYPE"     INTEGER         NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "CLUPATH"	VARCHAR(256) 	NOT NULL DEFAULT '''',
  "CLUGWNO"	INTEGER         NOT NULL DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"

			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ_HIS' AND INDNAME='IX_BATHIS_BATCHID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATHIS_BATCHID"
  ON "BATCH_MT_REQ_HIS"
 ("BATCHID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='BATCH_MT_REQ_HIS' AND INDNAME='IX_BATHIS_RECVTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_BATHIS_RECVTIME"
  ON "BATCH_MT_REQ_HIS"
 ("RECVTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&

ALTER TABLE "BATCH_MT_REQ_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GT_PORT_USED') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
					CREATE TABLE "GT_PORT_USED"
 ("ID"             INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "GATETYPE"       INTEGER         NOT NULL  DEFAULT 1,
  "SPGATE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"           VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PORTTYPE"       INTEGER         NOT NULL  DEFAULT 0,
  "USERCODE"       VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SPISUNCM"       INTEGER         NOT NULL  DEFAULT 0,
  "ROUTEFLAG"      INTEGER         NOT NULL  DEFAULT 0,
  "STATUS"         INTEGER         NOT NULL  DEFAULT 0,
  "USERID"         VARCHAR(11)     NOT NULL  DEFAULT '''',
  "LOGINID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPNUMBER"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "FEEFLAG"        INTEGER         NOT NULL  DEFAULT 1,
  "MEMO"           VARCHAR(100)    NOT NULL  DEFAULT '''',
  "SIGNSTR"        VARCHAR(20)     NOT NULL  DEFAULT '''',
  "SIGNLEN"        INTEGER         NOT NULL  DEFAULT 70,
  "MAXWORDS"       INTEGER         NOT NULL  DEFAULT 360,
  "SINGLELEN"      INTEGER         NOT NULL  DEFAULT 70,
  "MULTILEN1"      INTEGER         NOT NULL  DEFAULT 67,
  "MULTILEN2"      INTEGER         NOT NULL  DEFAULT 57,
  "SENDTIMEBEGIN"  CHARACTER(8)    NOT NULL  DEFAULT ''00:00:00'',
  "SENDTIMEEND"    CHARACTER(8)    NOT NULL  DEFAULT ''23:59:59'',
  "MOBIAREA"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "GATESEQ"        SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTMSPAN"     VARCHAR(512)    NOT NULL  DEFAULT ''00:00:00-23:59:59'',
  "FORBIDTMSPAN"   VARCHAR(512)    NOT NULL  DEFAULT ''00:00:00-00:00:00'',
  "ENSIGNSTR" VARCHAR(20) NOT NULL default '''' ,
  "ENSIGNLEN" INTEGER NOT NULL default 20 ,
  "ENMAXWORDS" INTEGER NOT NULL default 720 ,
  "ENSINGLELEN" INTEGER NOT NULL default 160,
  "ENMULTILEN1" INTEGER NOT NULL default 153,
  "ENMULTILEN2" INTEGER NOT NULL default 133
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GT_PORT_USED' AND INDNAME='IX_GTPORT_LGNID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_GTPORT_LGNID"
  ON "GT_PORT_USED"
 ("LOGINID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GT_PORT_USED' AND INDNAME='IX_GTPORT_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_GTPORT_USRID"
  ON "GT_PORT_USED"
 ("USERID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='GT_PORT_USED' AND CONSTNAME='PK_GT_PORT_USED') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "GT_PORT_USED"
  ADD CONSTRAINT "PK_GT_PORT_USED" PRIMARY KEY
(
	"SPGATE",
	"CPNO",
	"SPISUNCM",
	"ROUTEFLAG",
	"MOBIAREA" ,
	"USERID" ,
	"GATESEQ",
  "GATETYPE"
)';
        END;
END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GT_PORT_USED' AND INDNAME='PK_GT_PORT_USED') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_GT_PORT_USED"
  ON "GT_PORT_USED"
 ("SPGATE" ASC,
	"CPNO" ASC,
	"SPISUNCM" ASC,
	"ROUTEFLAG" ASC,
	"MOBIAREA" ASC,
	"USERID" ASC,
	"GATESEQ" ASC,
  "GATETYPE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "GT_PORT_USED"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='KEYWORD_BLACK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "KEYWORD_BLACK"
 ("ID"       INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  ,
  "KEYTYPE"  INTEGER         NOT NULL  DEFAULT 1,
  "KEYLEVEL" INTEGER         NOT NULL  DEFAULT 1,
  "KEYWORD"  VARCHAR(64)     NOT NULL  DEFAULT '''' constraint PK_KEYWORD_BLACK primary key,
  "OPTTYPE"  INTEGER         NOT NULL  DEFAULT 1,
  "CREATETIME" TIMESTAMP      NOT NULL DEFAULT CURRENT TIMESTAMP,
  "COMMENTS" VARCHAR(512)    NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='KEYWORD_BLACK' AND INDNAME='PK_KEYWORD_BLACK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_KEYWORD_BLACK"
  ON "KEYWORD_BLACK"
 ("KEYWORD" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "KEYWORD_BLACK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='KF_CORPBASE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "KF_CORPBASE"
 ("ECID"            INTEGER         NOT NULL  constraint PK_KF_CORPBASE primary key,
  "CORPACCOUNT"     VARCHAR(32)     NOT NULL  DEFAULT '''',
  "CORPNAME"        VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LICENSE"         VARCHAR(10)     NOT NULL  DEFAULT '''',
  "OPTYPE"          VARCHAR(8)      NOT NULL  DEFAULT ''0'',
  "STATUS"          INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ECCPNO"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ECSIGN"          CHARACTER(16)   NOT NULL  DEFAULT '''',
  "MAXPERDAY"       INTEGER         NOT NULL  DEFAULT 10000000,
  "WHITEVER"        INTEGER         NOT NULL  DEFAULT 0,
  "ORDERTIME"       TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "CANCELTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODITIME"        TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "EXPANLIMIT"      INTEGER         NOT NULL  DEFAULT 10,
  "STAFFLIMIT"      INTEGER         NOT NULL  DEFAULT 10,
  "MAINNOLIMIT"     INTEGER         NOT NULL  DEFAULT 10,
  "NEEDSIGN"        INTEGER         NOT NULL  DEFAULT 0,
  "WHTLEVEL"        INTEGER         NOT NULL  DEFAULT 0,
  "SPEEDLIMIT"      INTEGER         NOT NULL  DEFAULT 1000,
  "ORDERNUM"        INTEGER         NOT NULL  DEFAULT 0,
  "EXPRIEDDATE"     CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ECMANGER"        CHARACTER(11)   NOT NULL  DEFAULT  '''',
  "ECMEMO"          VARCHAR(100)    NOT NULL  DEFAULT '''',
  "ECIDBAK"         INTEGER         NOT NULL  DEFAULT 0,
  "CORPACCOUNTBAK"  VARCHAR(32)     NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"
			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='KF_CORPBASE' AND INDNAME='PK_KF_CORPBASE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_KF_CORPBASE"
  ON "KF_CORPBASE"
 ("ECID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&



ALTER TABLE "KF_CORPBASE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='KF_PARAMS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "KF_PARAMS"
 ("PARACODE"  INTEGER         NOT NULL  constraint PK_KF_PARAMS primary key,
  "PARAVAL1"  INTEGER         NOT NULL,
  "PARAVAL2"  VARCHAR(256)    NOT NULL,
  "PARAINFO"  VARCHAR(100)    NOT NULL
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='KF_PARAMS' AND INDNAME='PK_KF_PARAMS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_KF_PARAMS"
  ON "KF_PARAMS"
 ("PARACODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&

ALTER TABLE "KF_PARAMS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_PTMSGID_SEQ') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MMS_PTMSGID_SEQ"
           ("PTMSGID"  INTEGER  NOT NULL  constraint PK_MMS_PTMSGID primary key)
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
			 EXECUTE IMMEDIATE '
               COMMENT ON "MMS_PTMSGID_SEQ"
               (
                "PTMSGID" IS ''彩信消息自增编号，仅一条记录，用于生成消息编号''
               )
               ';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_PTMSGID_SEQ' AND INDNAME='PK_MMS_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MMS_PTMSGID"
  ON "MMS_PTMSGID_SEQ"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "MMS_PTMSGID_SEQ"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_SEND_HISTORY') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '

			CREATE TABLE "MMS_SEND_HISTORY"
 ("PTMSGID"    VARCHAR(20)     NOT NULL  constraint PK_MMS_SND_HIS primary key,
  "USERID"     VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"   VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MESSAGE"    VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "TASKID"     INTEGER         NOT NULL  DEFAULT 0,
  "TMS_PATH"   VARCHAR(512)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"  SMALLINT        NOT NULL  DEFAULT 5,
  "SENDTYPE"   SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"     SMALLINT        NOT NULL  DEFAULT 0,
  "SUBMITTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SPMSGID"    VARCHAR(64)     NOT NULL  DEFAULT '''',
  "RPTTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDFLAG"   INTEGER         NOT NULL  DEFAULT 0,
  "STATUS"     VARCHAR(20)     NOT NULL  DEFAULT '''',
  "ERRORCODE"  INTEGER         NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"

			';

			EXECUTE IMMEDIATE '
               COMMENT ON "MMS_SEND_HISTORY"
 ("PTMSGID" IS ''平台消息编号'',
  "USERID" IS ''用户帐号'',
  "SPGATE" IS ''主端口'',
  "CPNO" IS ''扩展端口'',
  "SPNUMBER" IS ''发送端口'',
  "PHONE" IS ''手机号码'',
  "MESSAGE" IS ''彩信主题'',
  "TASKID" IS ''客户自带任务ID'',
  "TMS_PATH" IS ''TMS文件路径'',
  "SENDLEVEL" IS ''彩信发送级别'',
  "SENDTYPE" IS ''发送类型'',
  "UNICOM" IS ''号码类型'',
  "SUBMITTIME" IS ''客户提交彩信时间'',
  "SENDTIME" IS ''彩信发送时间'',
  "SPMSGID" IS ''SP消息编号'',
  "RPTTIME" IS ''收到回执时间'',
  "SENDFLAG" IS ''发送标识'',
  "STATUS" IS ''回执状态'',
  "ERRORCODE" IS ''回执错误码''
 )
               ';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_SEND_HISTORY' AND INDNAME='PK_MMS_SND_HIS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MMS_SND_HIS"
  ON "MMS_SEND_HISTORY"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "MMS_SEND_HISTORY"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_SEND_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '

			CREATE TABLE "MMS_SEND_TASK"
 ("PTMSGID"    VARCHAR(20)     NOT NULL  constraint PK_MT_TASK_PTMSGID primary key,
  "USERID"     VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PHONE_CNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SPGATE"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"      VARCHAR(6000)   NOT NULL  DEFAULT '''',
  "TASKID"     INTEGER         NOT NULL  DEFAULT 0,
  "TMS_PATH"   VARCHAR(512)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"  SMALLINT        NOT NULL  DEFAULT 5,
  "SENDTYPE"   SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"     SMALLINT        NOT NULL  DEFAULT 0,
  "SUBMITTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"    VARCHAR(1000)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';

			 EXECUTE IMMEDIATE '

			 COMMENT ON "MMS_SEND_TASK"
 ("PTMSGID" IS ''平台消息编号'',
  "USERID" IS ''用户帐号'',
  "PHONE_CNT" IS ''手机个数'',
  "SPGATE" IS ''发送主通道'',
  "CPNO" IS ''通道扩展号码'',
  "PHONE" IS ''手机号码,多个号码用半角逗号隔开,最多支持500个号码(单个长度11)'',
  "TASKID" IS ''客户自带任务ID'',
  "TMS_PATH" IS ''TMS文件路径'',
  "SENDLEVEL" IS ''彩信发送级别'',
  "SENDTYPE" IS ''发送类型'',
  "UNICOM" IS ''号码类型'',
  "SUBMITTIME" IS ''客户提交彩信时间'',
  "MESSAGE" IS ''彩信主题''
 )
			 ';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_SEND_TASK' AND INDNAME='PK_MT_TASK_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_TASK_PTMSGID"
  ON "MMS_SEND_TASK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "MMS_SEND_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MO_DATAREPORT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MO_DATAREPORT"
 ("IYMD"      INTEGER         NOT NULL  DEFAULT 0,
  "USERID"    VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "IHOUR"     SMALLINT        NOT NULL  DEFAULT 0,
  "ICOUNT"    INTEGER         NOT NULL  DEFAULT 0,
  "IMONTH"    SMALLINT        NOT NULL  DEFAULT 0,
  "IYEAR"     SMALLINT        NOT NULL  DEFAULT 0,
  "ID"        INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "RECVDATE"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SPISUNCM"  SMALLINT        NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"

			';
      END;
    END IF;

	IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='MO_DATAREPORT' AND CONSTNAME='PK_MO_DATAREPORT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "MO_DATAREPORT"
  ADD CONSTRAINT "PK_MO_DATAREPORT" PRIMARY KEY
   ("USERID",
    "SPGATE",
    "SPISUNCM",
    "IYMD",
    "IYEAR",
    "IMONTH",
    "IHOUR"
   )';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_DATAREPORT' AND INDNAME='PK_MO_DATAREPORT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MO_DATAREPORT"
  ON "MO_DATAREPORT"
 ("USERID"   ASC,
  "SPGATE"   ASC,
  "SPISUNCM" ASC,
  "IYMD"     ASC,
  "IYEAR"    ASC,
  "IMONTH"   ASC,
  "IHOUR"    ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&


ALTER TABLE "MO_DATAREPORT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MO_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '

			CREATE TABLE "MO_TASK"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MO_TASK primary key ,
  "PTMSGID"      BIGINT          NOT NULL  DEFAULT 0,
  "UID"          INTEGER         NOT NULL  DEFAULT 0,
  "ORGUID"       INTEGER         NOT NULL  DEFAULT 0,
  "ECID"         INTEGER         NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SERVICEID"    VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SENDSTATUS"   SMALLINT        NOT NULL  DEFAULT 2,
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 15,
  "TP_PID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TP_UDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "DELIVERTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "PHONE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MSGCONTENT"   VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "STATUS"       SMALLINT        NOT NULL  DEFAULT 1,
  "UNICOM"       SMALLINT        NOT NULL  DEFAULT 0,
  "LONGMSGSEQ"   SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"     SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"      SMALLINT        NOT NULL  DEFAULT 1,
  "PTNOTICE"     SMALLINT        NOT NULL  DEFAULT 0,
  "RESENDCNT"    SMALLINT        NOT NULL  DEFAULT 0,
  "CMDID"        BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='PK_MO_TASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MO_TASK"
  ON "MO_TASK"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='IX_MOTASK_ORGUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOTASK_ORGUID"
  ON "MO_TASK"
 ("ORGUID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='IX_MOTASK_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MOTASK_PTID"
  ON "MO_TASK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='IX_MOTASK_SDSTS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOTASK_SDSTS"
  ON "MO_TASK"
 ("SENDSTATUS" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='IX_MOTASK_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOTASK_UID"
  ON "MO_TASK"
 ("UID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK' AND INDNAME='IX_MOTASK_UIDSTS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOTASK_UIDSTS"
  ON "MO_TASK"
 ("UID"        ASC,
  "SENDSTATUS" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MO_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MO_TASK_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '

			CREATE TABLE "MO_TASK_HIS"
 ("ID"           BIGINT          NOT NULL  DEFAULT 0  constraint PK_MOTASK_HIS primary key,
  "PTMSGID"      BIGINT          NOT NULL  DEFAULT 0,
  "UID"          INTEGER         NOT NULL  DEFAULT 0,
  "ORGUID"       INTEGER         NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PHONE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SERVICEID"    VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SENDSTATUS"   SMALLINT        NOT NULL  DEFAULT 0,
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 0,
  "TP_PID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TP_UDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "DELIVERTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RESENDCNT"    SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"       SMALLINT        NOT NULL  DEFAULT 0,
  "ECID"         INTEGER         NOT NULL  DEFAULT 0,
  "MSGCONTENT"   VARCHAR(3000)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"
			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_TASK_HIS' AND INDNAME='PK_MOTASK_HIS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MOTASK_HIS"
  ON "MO_TASK_HIS"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&



ALTER TABLE "MO_TASK_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MO_WAIT_A') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE "MO_WAIT_A"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MO_WAIT_A primary key,
  "ECID"         INTEGER         NOT NULL  DEFAULT 0,
  "USERUID"      INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"     INTEGER         NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PTMSGID"      BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "DELIVERTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"      VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "SPGATE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "UNICOM"       SMALLINT        NOT NULL  DEFAULT 0,
  "TP_UDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "TP_PID"       SMALLINT        NOT NULL  DEFAULT 0,
  "LONGMSGSEQ"   SMALLINT        NOT NULL  DEFAULT 0,
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 15,
  "PKNUMBER"     SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"      SMALLINT        NOT NULL  DEFAULT 1,
  "PTNOTICE"     SMALLINT        NOT NULL  DEFAULT 0,
  "SERVICEID"    VARCHAR(10)     NOT NULL  DEFAULT '''',
  "CPNO"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CMDID"        BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_A' AND INDNAME='IX_MOWAITA_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOWAITA_PTID"
  ON "MO_WAIT_A"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_A' AND INDNAME='IX_MOWAITA_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOWAITA_UID"
  ON "MO_WAIT_A"
 ("USERUID" ASC,
  "LOGINUID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_A' AND INDNAME='PK_MO_WAIT_A') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MO_WAIT_A"
  ON "MO_WAIT_A"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MO_WAIT_A"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MO_WAIT_C') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE "MO_WAIT_C"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MO_WAIT_C primary key,
  "PTMSGID"      BIGINT          NOT NULL  DEFAULT 0,
  "UID"          INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SERVICEID"    VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SENDSTATUS"   SMALLINT        NOT NULL  DEFAULT 0,
  "STATUS"       SMALLINT        NOT NULL  DEFAULT 0,
  "MSGFMT"       SMALLINT        NOT NULL  DEFAULT 15,
  "TP_PID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TP_UDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "DELIVERTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "PHONE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MSGCONTENT"   VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "LOGINID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "UNICOM"       SMALLINT        NOT NULL  DEFAULT 0,
  "LONGMSGSEQ"   SMALLINT        NOT NULL  DEFAULT 1,
  "PKNUMBER"     SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"      SMALLINT        NOT NULL  DEFAULT 1,
  "PTNOTICE"     SMALLINT        NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_C' AND INDNAME='PK_MO_WAIT_C') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MO_WAIT_C"
  ON "MO_WAIT_C"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS;';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_C' AND INDNAME='IX_MOWAITC_LGNID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOWAITC_LGNID"
  ON "MO_WAIT_C"
 ("LOGINID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_C' AND INDNAME='IX_MOWAITC_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MOWAITC_PTID"
  ON "MO_WAIT_C"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MO_WAIT_C' AND INDNAME='IX_MOWAITC_SPGATE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MOWAITC_SPGATE"
  ON "MO_WAIT_C"
 ("SPGATE" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MO_WAIT_C"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MR_SPGATE_WATCH') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE "MR_SPGATE_WATCH"
 ("GATEID"        INTEGER         NOT NULL,
  "SPGATE"        CHARACTER(21)   NOT NULL,
  "PTCODE"        CHARACTER(10)   NOT NULL  DEFAULT ''0'',
  "STATE"         INTEGER                   DEFAULT 1,
  "LSSENDTIME"    TIMESTAMP                 DEFAULT CURRENT TIMESTAMP,
  "LSRECVTIME"    TIMESTAMP                 DEFAULT CURRENT TIMESTAMP,
  "DELAYSS"       INTEGER                   DEFAULT 0,
  "WATCHNUM"      INTEGER                   DEFAULT 0,
  "WATCHSUCC"     INTEGER                   DEFAULT 0,
  "WATCHDELAY"    INTEGER                   DEFAULT 0,
  "NUMMT"         INTEGER                   DEFAULT 0,
  "NUMRPT"        INTEGER                   DEFAULT 0,
  "NUMMO"         INTEGER                   DEFAULT 0,
  "SPEEDMT"       INTEGER                   DEFAULT 0,
  "SPEEDMO"       INTEGER                   DEFAULT 0,
  "SPEEDRPT"      INTEGER                   DEFAULT 0,
  "UPDATETIME"    TIMESTAMP                 DEFAULT CURRENT TIMESTAMP,
  "DEALFLAG"      INTEGER                   DEFAULT 1,
  "ERRORINFO"     VARCHAR(200)              DEFAULT '''',
  "USRID"         CHARACTER(7),
  "ONLINESTATUS"  INTEGER                   DEFAULT 0,
  "TOTALRPTSEND"  INTEGER                   DEFAULT 0,
  "TOTALMOSEND"   INTEGER                   DEFAULT 0,
  "HAVESENDMO"    INTEGER                   DEFAULT 0,
  "HAVESENDRPT"   INTEGER                   DEFAULT 0,
  "RECVMT"        INTEGER                   DEFAULT 0,
  "REMAINEDMT"    INTEGER                   DEFAULT 0,
  "TIMERSENDMT"   INTEGER                   DEFAULT 0,
  "REMAINEDRPT"   INTEGER                   DEFAULT 0,
  "REMAINEDMO"    INTEGER                   DEFAULT 0,
  "RECVSPEED"     INTEGER                   DEFAULT 0,
  "PARAM1"        INTEGER,
  "PARAM2"        INTEGER,
  "PARAM3"        INTEGER,
  "PARAM4"        INTEGER,
  "PARAM5"        INTEGER,
  "PARAM6"        VARCHAR(100),
  "PARAM7"        VARCHAR(100)
 )
 DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;
    END IF;
END  &&


ALTER TABLE "MR_SPGATE_WATCH"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_DATAREPORT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE TABLE "MT_DATAREPORT"
 ("USERID"       VARCHAR(11)     NOT NULL,
  "TASKID"       INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"       VARCHAR(21)     NOT NULL,
  "IYMD"         INTEGER         NOT NULL,
  "IHOUR"        SMALLINT        NOT NULL,
  "PTCODE"       VARCHAR(10)     NOT NULL  DEFAULT ''JH'',
  "IMONTH"       SMALLINT        NOT NULL,
  "ICOUNT"       INTEGER         NOT NULL  DEFAULT 0,
  "SUCC"         INTEGER         NOT NULL  DEFAULT 0,
  "FAIL1"        INTEGER         NOT NULL  DEFAULT 0,
  "FAIL2"        INTEGER         NOT NULL  DEFAULT 0,
  "FAIL3"        INTEGER         NOT NULL  DEFAULT 0,
  "NRET"         INTEGER         NOT NULL  DEFAULT 0,
  "RSUCC"        INTEGER         NOT NULL  DEFAULT 0,
  "RFAIL1"       INTEGER         NOT NULL  DEFAULT 0,
  "RFAIL2"       INTEGER         NOT NULL  DEFAULT 0,
  "RNRET"        INTEGER         NOT NULL  DEFAULT 0,
  "RELEASEFLAG"  SMALLINT        NOT NULL  DEFAULT 1,
  "STARTTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ID"           INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "Y"            SMALLINT        NOT NULL  DEFAULT 0,
  "SPISUNCM"     SMALLINT        NOT NULL  DEFAULT 0,
  "SPID"         VARCHAR(32)     NOT NULL  DEFAULT '''',
  "SVRTYPE"      VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"           VARCHAR(64)     NOT NULL  DEFAULT '''',
  "MOBILEAREA"	 INTEGER	     NOT NULL DEFAULT 0,
  "SENDTYPE"     INTEGER         NOT NULL DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL DEFAULT 0,
  "AREACODE"	  INTEGER 		 NOT NULL DEFAULT 0,
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0
 )
  DATA CAPTURE NONE
IN "TBSPHISTORY"
			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_DATAREPORT' AND INDNAME='IX_MTDATAREPORT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTDATAREPORT"
  ON "MT_DATAREPORT"
 ("TASKID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_DATAREPORT' AND INDNAME='IX_MT_DATAREPORT_UNION') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MT_DATAREPORT_UNION"
  ON "MT_DATAREPORT"
 ("USERID",
    "TASKID",
    "SPGATE",
    "IYMD",
    "IHOUR",
    "SPISUNCM",
    "SVRTYPE",
    "P1",
    "P2",
    "P3",
    "P4",
    "SPID",
    "MOBILEAREA",
    "SENDTYPE",
    "BATCHID",
    "AREACODE",
	"TMPLID",
	"CHGRADE",
	"MSGTYPE"
  )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_DATAREPORT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_DATAREPORT_SP') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_DATAREPORT_SP"
 ("IYMD"        INTEGER         NOT NULL,
  "USERID"      VARCHAR(11)     NOT NULL,
  "SPGATE"      VARCHAR(21)     NOT NULL,
  "SPISUNCM"    INTEGER         NOT NULL,
  "ICOUNT"      INTEGER         NOT NULL  DEFAULT 0,
  "ISUCC"       INTEGER         NOT NULL  DEFAULT 0,
  "IFAIL"       INTEGER         NOT NULL  DEFAULT 0,
  "UPDATETIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"

			';
      END;
    END IF;

IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='MT_DATAREPORT_SP' AND CONSTNAME='PK_MTDATAREPORT_SP') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "MT_DATAREPORT_SP"
  ADD CONSTRAINT "PK_MTDATAREPORT_SP" PRIMARY KEY
   ("IYMD",
    "USERID",
    "SPGATE",
    "SPISUNCM"
   )';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_DATAREPORT_SP' AND INDNAME='PK_MTDATAREPORT_SP') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MTDATAREPORT_SP"
  ON "MT_DATAREPORT_SP"
 ("IYMD"     ASC,
  "USERID"   ASC,
  "SPGATE"   ASC,
  "SPISUNCM" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "MT_DATAREPORT_SP"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL0_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL0_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL0_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 				NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_AGE"
  ON "MT_LEVEL0_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_DESTUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_DESTUID"
  ON "MT_LEVEL0_QUEUE"
 ("DESTUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_END"
  ON "MT_LEVEL0_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_LGNUID"
  ON "MT_LEVEL0_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_PRE"
  ON "MT_LEVEL0_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_ATTIME"
  ON "MT_LEVEL0_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL0_PTID"
  ON "MT_LEVEL0_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_UID"
  ON "MT_LEVEL0_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL0_QUEUE' AND INDNAME='IX_MTLVL0_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL0_USRID"
  ON "MT_LEVEL0_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&


ALTER TABLE "MT_LEVEL0_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL1_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL1_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL1_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_AGE"
  ON "MT_LEVEL1_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_DESTUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_DESTUID"
  ON "MT_LEVEL1_QUEUE"
 ("DESTUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_END"
  ON "MT_LEVEL1_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_LGNUID"
  ON "MT_LEVEL1_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_PRE"
  ON "MT_LEVEL1_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL1_PTID"
  ON "MT_LEVEL1_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_UID"
  ON "MT_LEVEL1_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_USRID"
  ON "MT_LEVEL1_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL1_QUEUE' AND INDNAME='IX_MTLVL1_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL1_ATTIME"
  ON "MT_LEVEL1_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL1_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL2_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL2_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL2_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_DESTUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_AGE"
  ON "MT_LEVEL2_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_END"
  ON "MT_LEVEL2_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_LGNUID"
  ON "MT_LEVEL2_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL2_PRE"
  ON "MT_LEVEL2_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_ATTIME"
  ON "MT_LEVEL2_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL2_PTID"
  ON "MT_LEVEL2_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_UID"
  ON "MT_LEVEL2_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL2_USRID"
  ON "MT_LEVEL2_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='IX_MTLVL2_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_ATTIME"
  ON "MT_LEVEL2_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL2_QUEUE' AND INDNAME='PK_MT_LVL2_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL2_QUE"
  ON "MT_LEVEL2_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL2_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL3_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL3_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL3_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='PK_MT_LVL3_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL3_QUE"
  ON "MT_LEVEL3_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_AGE"
  ON "MT_LEVEL3_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_END"
  ON "MT_LEVEL3_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_LGNUID"
  ON "MT_LEVEL3_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL3_PRE"
  ON "MT_LEVEL3_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_ATTIME"
  ON "MT_LEVEL3_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL3_PTID"
  ON "MT_LEVEL3_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_UID"
  ON "MT_LEVEL3_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_USRID"
  ON "MT_LEVEL3_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL3_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL3_ATTIME"
  ON "MT_LEVEL3_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL3_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL4_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL4_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL4_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='PK_MT_LVL4_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL4_QUE"
  ON "MT_LEVEL4_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_AGE"
  ON "MT_LEVEL4_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_END"
  ON "MT_LEVEL4_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_LGNUID"
  ON "MT_LEVEL4_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL4_PRE"
  ON "MT_LEVEL4_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_ATTIME"
  ON "MT_LEVEL4_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL3_QUEUE' AND INDNAME='IX_MTLVL4_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL4_PTID"
  ON "MT_LEVEL4_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_UID"
  ON "MT_LEVEL4_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_USRID"
  ON "MT_LEVEL4_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL4_QUEUE' AND INDNAME='IX_MTLVL4_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL4_ATTIME"
  ON "MT_LEVEL4_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL4_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL5_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL5_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL5_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='PK_MT_LVL5_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL5_QUE"
  ON "MT_LEVEL5_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_AGE"
  ON "MT_LEVEL5_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_END"
  ON "MT_LEVEL5_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_LGNUID"
  ON "MT_LEVEL5_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL5_PRE"
  ON "MT_LEVEL5_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_ATTIME"
  ON "MT_LEVEL5_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL5_PTID"
  ON "MT_LEVEL5_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_UID"
  ON "MT_LEVEL5_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_USRID"
  ON "MT_LEVEL5_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL5_QUEUE' AND INDNAME='IX_MTLVL5_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL5_ATTIME"
  ON "MT_LEVEL5_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL5_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL6_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL6_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL6_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='PK_MT_LVL6_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL6_QUE"
  ON "MT_LEVEL6_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_AGE"
  ON "MT_LEVEL6_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_END"
  ON "MT_LEVEL6_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_LGNUID"
  ON "MT_LEVEL6_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL6_PRE"
  ON "MT_LEVEL6_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_ATTIME"
  ON "MT_LEVEL6_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL6_PTID"
  ON "MT_LEVEL6_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_UID"
  ON "MT_LEVEL6_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_USRID"
  ON "MT_LEVEL6_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL6_QUEUE' AND INDNAME='IX_MTLVL6_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL6_ATTIME"
  ON "MT_LEVEL6_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL6_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL7_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL7_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL7_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_AGE"
  ON "MT_LEVEL7_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
				IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='PK_MT_LVL7_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL7_QUE"
  ON "MT_LEVEL7_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_END"
  ON "MT_LEVEL7_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_LGNUID"
  ON "MT_LEVEL7_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL7_PRE"
  ON "MT_LEVEL7_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_ATTIME"
  ON "MT_LEVEL7_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL7_PTID"
  ON "MT_LEVEL7_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_UID"
  ON "MT_LEVEL7_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_USRID"
  ON "MT_LEVEL7_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL7_QUEUE' AND INDNAME='IX_MTLVL7_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL7_ATTIME"
  ON "MT_LEVEL7_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&



ALTER TABLE "MT_LEVEL7_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL8_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL8_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL8_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
				IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='PK_MT_LVL8_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL8_QUE"
  ON "MT_LEVEL8_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_AGE"
  ON "MT_LEVEL8_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_END"
  ON "MT_LEVEL8_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_LGNUID"
  ON "MT_LEVEL8_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL8_PRE"
  ON "MT_LEVEL8_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_ATTIME"
  ON "MT_LEVEL8_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL8_PTID"
  ON "MT_LEVEL8_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_UID"
  ON "MT_LEVEL8_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_USRID"
  ON "MT_LEVEL8_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL8_QUEUE' AND INDNAME='IX_MTLVL8_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL8_ATTIME"
  ON "MT_LEVEL8_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&



ALTER TABLE "MT_LEVEL8_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_LEVEL9_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_LEVEL9_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_LVL9_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0,
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
				IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='PK_MT_LVL9_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_LVL9_QUE"
  ON "MT_LEVEL9_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_AGE"
  ON "MT_LEVEL9_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_END"
  ON "MT_LEVEL9_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_LGNUID"
  ON "MT_LEVEL9_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX "IX_MTLVL9_PRE"
  ON "MT_LEVEL9_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_ATTIME"
  ON "MT_LEVEL9_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTLVL9_PTID"
  ON "MT_LEVEL9_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_UID"
  ON "MT_LEVEL9_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_USRID"
  ON "MT_LEVEL9_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_LEVEL9_QUEUE' AND INDNAME='IX_MTLVL9_ATTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTLVL9_ATTIME"
  ON "MT_LEVEL9_QUEUE"
 ("ATTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_LEVEL9_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

 BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_ROUTETABLE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_ROUTETABLE"
 ("ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_MT_ROUTE primary key,
  "ROUTETYPE"  INTEGER         NOT NULL  DEFAULT 1,
  "EXNOHOLD"   INTEGER         NOT NULL  DEFAULT 1,
  "EXPIREDTM"  INTEGER         NOT NULL  DEFAULT 60,
  "SRCUSERID"  VARCHAR(11)     NOT NULL  DEFAULT '''',
  "DESTUSERID" VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SRCBINDID"  INTEGER         NOT NULL  DEFAULT 0,
  "DESTBINDID" INTEGER         NOT NULL  DEFAULT 0,
  "PARAMS"     VARCHAR(100)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"

			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_ROUTETABLE' AND INDNAME='PK_MT_ROUTE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_ROUTE"
  ON "MT_ROUTETABLE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_ROUTETABLE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_TASK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MTTASK primary key,
  "PTMSGID"       BIGINT          NOT NULL,
  "UID"           INTEGER         NOT NULL  DEFAULT 0,
  "ECID"          INTEGER         NOT NULL  DEFAULT 0,
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "RETFLAG"       SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"       SMALLINT        NOT NULL  DEFAULT 1,
  "PKNUMBER"      SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"       SMALLINT        NOT NULL  DEFAULT 1,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 2,
  "SENDFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "RECVFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "DONEDATE"      CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"     CHARACTER(7)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"     SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTYPE"      SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"        SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"       VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "RESENDCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "TASKID"        INTEGER         NOT NULL  DEFAULT 0,
  "SPID"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MOBILEAREA"    INTEGER         NOT NULL  DEFAULT 0,
  "RECVMTTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSMTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSRPTTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDRPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSGFMT"        SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"    SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"         SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"        SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"      INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"        BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"     BIGINT          NOT NULL  DEFAULT 0,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"	  INTEGER 	NOT NULL DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"
';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK' AND INDNAME='IX_MTTASK_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTTASK_PTID"
  ON "MT_TASK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK' AND INDNAME='IX_MTTASK_SDTM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTASK_SDTM"
  ON "MT_TASK"
 ("SENDTIME" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK' AND INDNAME='PK_MTTASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MTTASK"
  ON "MT_TASK"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&



ALTER TABLE "MT_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_TASK_C') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_TASK_C"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_TASK_C primary key,
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "LOGINID"     VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SHOUJI"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDSTATUS"  INTEGER         NOT NULL  DEFAULT 0,
  "SENDFLAG"    SMALLINT        NOT NULL  DEFAULT 0,
  "RECVFLAG"    SMALLINT        NOT NULL  DEFAULT 0,
  "DONEDATE"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTYPE"    SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"      SMALLINT        NOT NULL  DEFAULT 0,
  "FIXEDCH"     SMALLINT        NOT NULL  DEFAULT 0,
  "SENDCH"      SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(4000)   NOT NULL  DEFAULT '''',
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TRANSMTTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "MOBILEAREA"  INTEGER         NOT NULL  DEFAULT 0,
"NETERRORCNT"  INTEGER         NOT NULL  DEFAULT 0,
"SUBMITERRORCNT"  INTEGER         NOT NULL  DEFAULT 0,
   "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
   "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "MSGTYPE"	SMALLINT         NOT NULL  DEFAULT 0,
  "VALIDTM"	SMALLINT         NOT NULL  DEFAULT 0,
  "TMPLID"	BIGINT          NOT NULL  DEFAULT 0,
"PROTOCOLVER"	SMALLINT         NOT NULL  DEFAULT 0,
"TITLE"			VARCHAR(40)	 NOT NULL  DEFAULT '''',
"SHOWAY"		VARCHAR(16)	 NOT NULL  DEFAULT '''',
"DLDWAY"		INTEGER         NOT NULL  DEFAULT 0,
"DLDNEY"		INTEGER         NOT NULL  DEFAULT 0,
"ISFREE"		INTEGER         NOT NULL  DEFAULT 0,
"SHOWTIME"		BIGINT         NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK_C' AND INDNAME='PK_MT_TASK_C') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_TASK_C"
  ON "MT_TASK_C"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK_C' AND INDNAME='IX_MTTASKC_LGNID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTASKC_LGNID"
  ON "MT_TASK_C"
 ("LOGINID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TASK_C' AND INDNAME='IX_MTTASKC_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTTASKC_PTID"
  ON "MT_TASK_C"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "MT_TASK_C"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_TIMER_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
				CREATE TABLE "MT_TIMER_QUEUE"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_TMR_QUE primary key,
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 2,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_AGE"
  ON "MT_TIMER_QUEUE"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_DESTUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_DESTUID"
  ON "MT_TIMER_QUEUE"
 ("DESTUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_END"
  ON "MT_TIMER_QUEUE"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_LGNUID"
  ON "MT_TIMER_QUEUE"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_PRE"
  ON "MT_TIMER_QUEUE"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTTMR_PTID"
  ON "MT_TIMER_QUEUE"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_UID"
  ON "MT_TIMER_QUEUE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='IX_MTTMR_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTTMR_USRID"
  ON "MT_TIMER_QUEUE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_TIMER_QUEUE' AND INDNAME='PK_MT_TMR_QUE') THEN
	        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_TMR_QUE"
  ON "MT_TIMER_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&




ALTER TABLE "MT_TIMER_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_VERIFY_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_VERIFY_TASK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) constraint PK_MT_VFY_TASK primary key,
  "DEALSTATUS"    INTEGER         NOT NULL  DEFAULT 1,
  "VERIFYSTATUS"  INTEGER         NOT NULL  DEFAULT 0,
  "CMDTEXT"       VARCHAR(1000)   NOT NULL  DEFAULT '''',
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PARAMS"        VARCHAR(1000)   NOT NULL  DEFAULT '''',
  "MEMO"          VARCHAR(256)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_TASK' AND INDNAME='PK_MT_VFY_TASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_VFY_TASK"
  ON "MT_VERIFY_TASK"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&

ALTER TABLE "MT_VERIFY_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_VERIFY_WAIT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_VERIFY_WAIT"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) constraint PK_MT_VFY_WAIT primary key,
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "DESTUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "DEALSTATUS"  INTEGER         NOT NULL  DEFAULT 1,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 1,
  "SPLITFLAG"   SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"     SMALLINT        NOT NULL  DEFAULT 2,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 5,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"    INTEGER         NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
';
      END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_AGE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_AGE"
  ON "MT_VERIFY_WAIT"
 ("LOGINUID" ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_DESTUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_DESTUID"
  ON "MT_VERIFY_WAIT"
 ("DESTUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_END') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_END"
  ON "MT_VERIFY_WAIT"
 ("DESTUID"   ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_LGNUID"
  ON "MT_VERIFY_WAIT"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_PRE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_PRE"
  ON "MT_VERIFY_WAIT"
 ("UID"       ASC,
  "SENDLEVEL" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTVFY_PTID"
  ON "MT_VERIFY_WAIT"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_UID"
  ON "MT_VERIFY_WAIT"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='IX_MTVFY_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTVFY_USRID"
  ON "MT_VERIFY_WAIT"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_VERIFY_WAIT' AND INDNAME='PK_MT_VFY_WAIT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_VFY_WAIT"
  ON "MT_VERIFY_WAIT"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&

ALTER TABLE "MT_VERIFY_WAIT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MT_WAIT_A') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "MT_WAIT_A"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  constraint PK_MT_WAIT_A primary key,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "USERUID"     INTEGER         NOT NULL  DEFAULT 0,
  "TASKID"      INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"    CHARACTER(21)   NOT NULL  DEFAULT '''',
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 1,
  "SENDLEVEL"   SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "PHONECOUNT"  INTEGER         NOT NULL  DEFAULT 1,
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(3500)   NOT NULL  DEFAULT '''',
  "TPPID"       SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"      SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"    SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"     SMALLINT        NOT NULL  DEFAULT 1,
  "MSGFMT"      SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"     VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"          VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "RETFLAG"     SMALLINT        NOT NULL  DEFAULT 0,
  "ATTIME"      BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"   BIGINT          NOT NULL  DEFAULT 0,
  "SENDTYPE"      INTEGER       NOT NULL  DEFAULT 1,
  "BATCHID"      BIGINT         NOT NULL  DEFAULT 0,
  "TOTALCOUNT"  INTEGER         NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_WAIT_A' AND INDNAME='IX_MTWAITA_LGNUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTWAITA_LGNUID"
  ON "MT_WAIT_A"
 ("LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_WAIT_A' AND INDNAME='IX_MTWAITA_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_MTWAITA_PTID"
  ON "MT_WAIT_A"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_WAIT_A' AND INDNAME='IX_MTWAITA_UIDSTS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTWAITA_UIDSTS"
  ON "MT_WAIT_A"
 ("USERUID"    ASC,
  "SENDSTATUS" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MT_WAIT_A' AND INDNAME='PK_MT_WAIT_A') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MT_WAIT_A"
  ON "MT_WAIT_A"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&



ALTER TABLE "MT_WAIT_A"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_BUFINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_BUFINFO"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) ,
  "PTCODE"       VARCHAR(32)     NOT NULL  DEFAULT ''''  constraint PK_M_MON_BUFINFO primary key,
  "ENDCNT"       INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "MTTOTALSND"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMOBUF"      INTEGER         NOT NULL  DEFAULT 0,
  "UPDMOBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "UPDRPTBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "WRRPTBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "ENDRSPBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "SMTSNDBUF"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "NMTSNDBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "MTWAITBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "PRECNT"       INTEGER         NOT NULL  DEFAULT 0,
  "MTTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALSND"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMTTASKBUF"  INTEGER         NOT NULL  DEFAULT 0,
  "WRMTTMBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "WRMTVFYBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMTLVLBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "PRERSPBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "PRERSPTMPBUF" INTEGER         NOT NULL  DEFAULT 0,
  "MOSNDBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "RPTSNDBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "MORPTWAITBUF" INTEGER         NOT NULL  DEFAULT 0,
  "LOGFILENUM"   INTEGER         NOT NULL  DEFAULT 0,
  "LOGBUF"       INTEGER         NOT NULL  DEFAULT 0,
  "RECVBUF"      INTEGER         NOT NULL  DEFAULT 0,
  "RESNDBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "SUPPSNDBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "MONLOGBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "UPDATETIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';

			EXECUTE IMMEDIATE '
			COMMENT ON "M_MON_BUFINFO"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "ENDCNT" IS ''后端连接数'',
  "MOTOTALRECV" IS ''后端转发至网关的MO总数'',
  "MTTOTALSND" IS ''网关成功转发至后端的MT总数'',
  "WRMOBUF" IS ''写MO_TASK表缓冲大小'',
  "UPDMOBUF" IS ''更新MO_TASK表缓冲大小'',
  "UPDRPTBUF" IS ''更新MT_TASK表中SENDSTATUS字段'',
  "WRRPTBUF" IS ''写RPT_WAIT_B表缓冲大小'',
  "ENDRSPBUF" IS ''后端高级别回应缓冲'',
  "SMTSNDBUF" IS ''网关向后端转发MT的发送缓冲（0-9级）,中间以/分隔，如0/1/2/3/4/5/6/7/8/9,中间以/分隔，如0/1/2/3/4/5/6/7/8/9'',
  "MTWAITBUF" IS ''网关向后端转发MT的发送缓冲（0-9级）0-9级别的总和'',
  "PRECNT" IS ''前端连接数'',
  "MTTOTALRECV" IS ''接收到前端MT的总量'',
  "MOTOTALSND" IS ''接收到前端MO的总量'',
  "WRMTTASKBUF" IS ''写MT_TASK表缓冲大小'',
  "WRMTTMBUF" IS ''写MT_TIMER_QUE表缓冲大小'',
  "WRMTVFYBUF" IS ''写MT_VERIFY_WAIT表缓冲大小'',
  "WRMTLVLBUF" IS ''写MT_LEVEL_QUE表缓冲大小'',
  "PRERSPBUF" IS ''前端高级别回应缓冲'',
  "PRERSPTMPBUF" IS ''前端高级别回应临时缓冲'',
  "MOSNDBUF" IS ''MO发送缓冲'',
  "RPTSNDBUF" IS ''RPT发送缓冲'',
  "MORPTWAITBUF" IS ''MO/RPT发送等待缓冲'',
  "LOGFILENUM" IS ''日志文件数量'',
  "LOGBUF" IS ''日志缓冲'',
  "RECVBUF" IS ''接收缓冲'',
  "RESNDBUF" IS ''重发缓冲'',
  "SUPPSNDBUF" IS ''补发缓冲'',
  "MONLOGBUF" IS ''监控日志缓冲'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )
			';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_BUFINFO' AND INDNAME='PK_M_MON_BUFINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_M_MON_BUFINFO"
  ON "M_MON_BUFINFO"
 ("PTCODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_BUFINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_LOGINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_LOGINFO"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT ''''  constraint PK_M_MON_LOGINFO primary key,
  "LOGTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGS"        VARCHAR(4000)   NOT NULL  DEFAULT '''',
  "CREATETIME"  VARCHAR(35)     NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
			EXECUTE IMMEDIATE 'COMMENT ON "M_MON_LOGINFO"
 ("ID" IS ''自增ID，主键'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "LOGTYPE" IS ''0：来自于后台监控程序1：来自于前台监控页面'',
  "LOGS" IS ''流水日志''
 ) ';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_LOGINFO' AND INDNAME='PK_M_MON_LOGINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_M_MON_LOGINFO"
  ON "M_MON_LOGINFO"
 ("PTCODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_LOGINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_MONLOG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_MONLOG"
 ("ID"      BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_M_MON_MONLOG primary key,
  "PTCODE"  VARCHAR(32)     NOT NULL  DEFAULT '''',
  "LOGTYPE" INTEGER         NOT NULL  DEFAULT 0,
  "LOGS"    VARCHAR(4000)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_MONLOG' AND INDNAME='PK_M_MON_MONLOG') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_M_MON_MONLOG"
  ON "M_MON_MONLOG"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&

ALTER TABLE "M_MON_MONLOG"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_MONMSG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_MONMSG"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_M_MON_MONMSG primary key ,
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT '''',
  "MSGTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "MSGID"       INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MOBILE"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "MOBILETYPE"  INTEGER         NOT NULL  DEFAULT 0,
  "MOBILEAREA"  INTEGER         NOT NULL  DEFAULT 0,
  "SENDLEVEL"   INTEGER         NOT NULL  DEFAULT 0,
  "MSGFMT"      INTEGER         NOT NULL  DEFAULT 15,
  "SENDSTATUS"  INTEGER         NOT NULL  DEFAULT 1,
  "RESENDCNT"   INTEGER         NOT NULL  DEFAULT 0,
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "SENDTIME"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "RECVTIME"    VARCHAR(35)     NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
			 EXECUTE IMMEDIATE '
			 COMMENT ON "M_MON_MONMSG"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "MSGTYPE" IS ''100-199：检测短信(通道检测，新通道各区域发送情况检测等)200-299：报警短信(前面报警，后台报警)'',
  "MSGID" IS ''取发送后平台返回的流水号'',
  "MOBILE" IS ''最大支持10个手机号，中间英文逗号隔开'',
  "MOBILETYPE" IS ''0：移动1：联通2：小灵通21：电信手机255：未知'',
  "MOBILEAREA" IS ''手机号归属地'',
  "SENDLEVEL" IS ''0-255：值越小，级别越高'',
  "MSGFMT" IS ''默认取15'',
  "SENDSTATUS" IS ''1:新插入，待发送2:发送至下级网关3:接交下级网失败0:状态报告已返回'',
  "RESENDCNT" IS ''接交下级网关失败后，重发的次数'',
  "ERRORCODE" IS ''状态报告错误码'',
  "MESSAGE" IS ''短信内容'',
  "SENDTIME" IS ''短信发送至下级网关的时间'',
  "RECVTIME" IS ''状态报告返回时间''
 )
			 ';
      END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_MONMSG' AND INDNAME='PK_M_MON_MONMSG') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_M_MON_MONMSG"
  ON "M_MON_MONMSG"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_MONMSG"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_PTINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_PTINFO"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  constraint PK_M_MON_PTINFO primary key,
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT '''',
  "PTNAME"      VARCHAR(128)    NOT NULL  DEFAULT '''',
  "PTIP"        VARCHAR(4000)   NOT NULL  DEFAULT '''',
  "PTPORT"      INTEGER         NOT NULL  DEFAULT 9001,
  "PTTYPE"      INTEGER         NOT NULL  DEFAULT 100,
  "PTSTATUS"    INTEGER         NOT NULL  DEFAULT 0,
  "MONUSERID"   VARCHAR(11)     NOT NULL  DEFAULT '''',
  "MONUSERPWD"  VARCHAR(32)     NOT NULL  DEFAULT '''',
  "MONFREQ"     INTEGER         NOT NULL  DEFAULT 5,
  "MAXRPTDELAY" INTEGER         NOT NULL  DEFAULT 65,
  "WARNPHONE"   VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LINKMAN"     VARCHAR(256)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;
	  EXECUTE IMMEDIATE '
		COMMENT ON "M_MON_PTINFO"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "PTNAME" IS ''平台名称'',
  "PTIP" IS ''平台IP地址'',
  "PTPORT" IS ''平台监听端口'',
  "PTTYPE" IS ''平台类型'',
  "PTSTATUS" IS ''0：正常非0：各种各样的异常'',
  "MONUSERID" IS ''监控帐号'',
  "MONUSERPWD" IS ''监控帐号PWD'',
  "MONFREQ" IS ''通道监测频率'',
  "MAXRPTDELAY" IS ''通道状态报告返回最大延时时间'',
  "WARNPHONE" IS ''报警手机'',
  "LINKMAN" IS ''平台联系人''
 )
	  ';
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_PTINFO' AND INDNAME='PK_M_MON_PTINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_M_MON_PTINFO"
  ON "M_MON_PTINFO"
 ("PTCODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_PTINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_SPGATEINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
				CREATE TABLE "M_MON_SPGATEINFO"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"        VARCHAR(32)     NOT NULL  DEFAULT '''',
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERUID"       INTEGER         NOT NULL  DEFAULT 0,
  "USERNAME"      VARCHAR(128)    NOT NULL  DEFAULT '''',
  "JTYPE"         VARCHAR(64)     NOT NULL  DEFAULT ''直连用户(CMPP)'',
  "LINKNUM"       INTEGER         NOT NULL  DEFAULT 1,
  "LOGINIP"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "ONLINESTATUS"  INTEGER         NOT NULL  DEFAULT 0,
  "MTHAVESND"     INTEGER         NOT NULL  DEFAULT 0,
  "MTREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "MTRECVSPD"     INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"   INTEGER         NOT NULL  DEFAULT 0,
  "MOHAVESND"     INTEGER         NOT NULL  DEFAULT 0,
  "MOREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "MOSNDSPD"      INTEGER         NOT NULL  DEFAULT 0,
  "RPTTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "RPTHAVESND"    INTEGER         NOT NULL  DEFAULT 0,
  "RPTREMAINED"   INTEGER         NOT NULL  DEFAULT 0,
  "RPTSNDSPD"     INTEGER         NOT NULL  DEFAULT 0,
  "SNDERCNT"      INTEGER         NOT NULL  DEFAULT 0,
  "LASTSNDERTM"   VARCHAR(35)     NOT NULL  DEFAULT '''',
  "LOGININTM"     VARCHAR(35)     NOT NULL  DEFAULT '''',
  "LOGINOUTTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "UPDATETIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
 LONG IN "TBSPSVRINDEX"
			';
      END;

	  EXECUTE IMMEDIATE '
	   COMMENT ON "M_MON_SPGATEINFO"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "USERID" IS ''用户帐号，主键'',
  "USERUID" IS ''用户帐号UID，与帐号一一对应'',
  "USERNAME" IS ''帐号对应的客户名称'',
  "JTYPE" IS ''用户使用的接入方式及接入协议'',
  "LINKNUM" IS ''帐号连接数'',
  "LOGINIP" IS ''帐号登陆IP'',
  "ONLINESTATUS" IS ''0：在线1：离线'',
  "MTHAVESND" IS ''已成功转发的MT数量'',
  "MTREMAINED" IS ''当前滞留平台未转发的MT数量'',
  "MTRECVSPD" IS ''该通道接收网关转发MT的速度'',
  "MOTOTALRECV" IS ''客户当前收到的MO总量'',
  "MOHAVESND" IS ''已转发给用户的该通道的MO数量'',
  "MOREMAINED" IS ''客户当前滞留在平台的MO数量'',
  "MOSNDSPD" IS ''客户提交MT的速度'',
  "RPTTOTALRECV" IS ''客户当前收到的RPT总量'',
  "RPTHAVESND" IS ''已转发给用户的该通道的RPT数量'',
  "RPTREMAINED" IS ''客户当前滞留在平台的RPT数量'',
  "RPTSNDSPD" IS ''客户接收RPT时超过时的次数'',
  "LOGININTM" IS ''最后一次登陆的时间'',
  "LOGINOUTTM" IS ''最后一次离线的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )
	  ';
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_SPGATEINFO' AND INDNAME='PK_MON_SPGATEINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MON_SPGATEINFO"
  ON "M_MON_SPGATEINFO"
 ("PTCODE" ASC,
  "USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&



ALTER TABLE "M_MON_SPGATEINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_SYSINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_SYSINFO"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"         VARCHAR(32)     NOT NULL  DEFAULT '''',
  "CPUUSAGE"       INTEGER         NOT NULL  DEFAULT 0,
  "MEMUSAGE"       INTEGER         NOT NULL  DEFAULT 0,
  "VMEMUSAGE"      INTEGER         NOT NULL  DEFAULT 0,
  "DISKFREESPACE"  INTEGER         NOT NULL  DEFAULT 0,
  "UPDATETIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"

			';
      END;

	  EXECUTE IMMEDIATE '
	   COMMENT ON "M_MON_SYSINFO"
 ("ID" IS ''自增ID'',
  "CPUUSAGE" IS ''CPU使用量，有必要是格式成XX%的字符串后显示'',
  "MEMUSAGE" IS ''物理内存使用量，以M为单位'',
  "VMEMUSAGE" IS ''虚拟内存使用量，以M为单位'',
  "DISKFREESPACE" IS ''磁盘剩余量，以M为单位'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )
	  ';
    END IF;
END  &&

ALTER TABLE "M_MON_SYSINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_THREADINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_THREADINFO"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "THRID"        INTEGER         NOT NULL  DEFAULT 0  constraint PK_MON_THREADINFO primary key,
  "THRNAME"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "THRSTATUS"    INTEGER         NOT NULL  DEFAULT 0,
  "ERRORCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "LASTERRORTM"  VARCHAR(35)     NOT NULL  DEFAULT '''',
  "THRLOGS"      VARCHAR(2048)   NOT NULL  DEFAULT '''',
  "LASTRUNTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "THISRUNTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "UPDATETIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"
			';
      END;

	  EXECUTE IMMEDIATE 'COMMENT ON "M_MON_THREADINFO"
 ("ID" IS ''自增ID'',
  "THRID" IS ''主键，对网关来说，启动后进程 内的线程它的ID是唯一的'',
  "THRNAME" IS ''线程名称描述'',
  "THRSTATUS" IS ''00：线程正在启动中(初始状态)'',
  "ERRORCNT" IS ''线程异常次数'',
  "LASTERRORTM" IS ''最后一次出现异常的时间，仅当异常次数大于0时该值才有意义'',
  "THRLOGS" IS ''线程输出日志'',
  "LASTRUNTM" IS ''上一次线程执行时网关记下的时间'',
  "THISRUNTM" IS ''本次执行时网关记下的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间'')';
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_THREADINFO' AND INDNAME='PK_MON_THREADINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MON_THREADINFO"
  ON "M_MON_THREADINFO"
 ("THRID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_THREADINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_USERINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_USERINFO"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"         VARCHAR(32)     NOT NULL  DEFAULT '''',
  "USERID"         VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERUID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERNAME"       VARCHAR(128)    NOT NULL  DEFAULT '''',
  "USERPRIVILEGE"  INTEGER         NOT NULL  DEFAULT 0,
  "JTYPE"          VARCHAR(64)     NOT NULL  DEFAULT ''直连用户(CMPP)'',
  "LINKNUM"        INTEGER         NOT NULL  DEFAULT 1,
  "LOGINIP"        VARCHAR(64)     NOT NULL  DEFAULT '''',
  "ONLINESTATUS"   INTEGER         NOT NULL  DEFAULT 0,
  "USERFEE"        INTEGER         NOT NULL  DEFAULT 0,
  "FIXFAILURERATE" INTEGER         NOT NULL  DEFAULT 0,
  "FAILURENUM"     INTEGER         NOT NULL  DEFAULT 0,
  "FAILURERATE"    INTEGER         NOT NULL  DEFAULT 0,
  "BINDINFO"       VARCHAR(2000)   NOT NULL  DEFAULT '''',
  "MTTOTALSND"     INTEGER         NOT NULL  DEFAULT 0,
  "MTHAVESND"      INTEGER         NOT NULL  DEFAULT 0,
  "MTREMAINED"     INTEGER         NOT NULL  DEFAULT 0,
  "MTSNDINFO"      VARCHAR(2000)   NOT NULL  DEFAULT '''',
  "MTSNDSPD"       INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"    INTEGER         NOT NULL  DEFAULT 0,
  "MOREMAINED"     INTEGER         NOT NULL  DEFAULT 0,
  "MORPTRECVSPD"   INTEGER         NOT NULL  DEFAULT 0,
  "MOTMOUTCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "RPTTOTALRECV"   INTEGER         NOT NULL  DEFAULT 0,
  "RPTREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "RPTTMOUTCNT"    INTEGER         NOT NULL  DEFAULT 0,
  "LOGININTM"      VARCHAR(35)     NOT NULL  DEFAULT '''',
  "LOGINOUTTM"     VARCHAR(35)     NOT NULL  DEFAULT '''',
  "UPDATETIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
      END;

	  EXECUTE IMMEDIATE 'COMMENT ON "M_MON_USERINFO"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "USERID" IS ''用户帐号，主键'',
  "USERUID" IS ''用户帐号UID，与帐号一一对应'',
  "USERNAME" IS ''帐号对应的客户名称'',
  "USERPRIVILEGE" IS ''与USERDATA表中字段意义和取值均相同。需解析出来后在界面展现出具体的权限'',
  "JTYPE" IS ''用户使用的接入方式及接入协议'',
  "LINKNUM" IS ''帐号连接数'',
  "LOGINIP" IS ''帐号登陆IP'',
  "ONLINESTATUS" IS ''0：在线1：离线'',
  "USERFEE" IS ''帐号费用'',
  "FIXFAILURERATE" IS ''0：表示没有失败率真控制,大于0表示有失几率控制。失败率FIXFAILURERATE /10000来代表失败率的值'',
  "FAILURENUM" IS ''当FIXFAILURERATE>0时才有意义'',
  "FAILURERATE" IS ''当FIXFAILURERATE>0时才有意义'',
  "BINDINFO" IS ''以字符串的形式体现该帐号的绑定信息'',
  "MTTOTALSND" IS ''客户接交MT的总数量'',
  "MTHAVESND" IS ''已成功转发的MT数量'',
  "MTREMAINED" IS ''当前滞留平台未转发的MT数量'',
  "MTSNDINFO" IS ''以字符串的形式描述用户每个通道的发送量/滞留量'',
  "MTSNDSPD" IS ''客户提交MT的速度'',
  "MOTOTALRECV" IS ''客户当前收到的MO总量'',
  "MOREMAINED" IS ''客户当前滞留在平台的MO数量'',
  "MORPTRECVSPD" IS ''客户接收MO/RPT的速度'',
  "MOTMOUTCNT" IS ''客户接收MO时超过时的次数'',
  "RPTTOTALRECV" IS ''客户当前收到的RPT总量'',
  "RPTREMAINED" IS ''客户当前滞留在平台的RPT数量'',
  "RPTTMOUTCNT" IS ''客户接收RPT时超过时的次数'',
  "LOGININTM" IS ''最后一次登陆的时间'',
  "LOGINOUTTM" IS ''最后一次离线的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )';
    END IF;
	IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='M_MON_USERINFO' AND CONSTNAME='PK_MON_USERINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "M_MON_USERINFO"
  ADD CONSTRAINT "PK_MON_USERINFO" PRIMARY KEY
   ("PTCODE",
    "USERID"
   )';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='M_MON_USERINFO' AND INDNAME='PK_MON_USERINFO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_MON_USERINFO"
  ON "M_MON_USERINFO"
 ("PTCODE" ASC,
  "USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "M_MON_USERINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_BUF_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_BUF_HIS"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "ENDCNT"       INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "MTTOTALSND"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMOBUF"      INTEGER         NOT NULL  DEFAULT 0,
  "UPDMOBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "UPDRPTBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "WRRPTBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "ENDRSPBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "SMTSNDBUF"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "NMTSNDBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "MTWAITBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "PRECNT"       INTEGER         NOT NULL  DEFAULT 0,
  "MTTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALSND"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMTTASKBUF"  INTEGER         NOT NULL  DEFAULT 0,
  "WRMTTMBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "WRMTVFYBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "WRMTLVLBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "PRERSPBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "PRERSPTMPBUF" INTEGER         NOT NULL  DEFAULT 0,
  "MOSNDBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "RPTSNDBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "MORPTWAITBUF" INTEGER         NOT NULL  DEFAULT 0,
  "LOGFILENUM"   INTEGER         NOT NULL  DEFAULT 0,
  "LOGBUF"       INTEGER         NOT NULL  DEFAULT 0,
  "RECVBUF"      INTEGER         NOT NULL  DEFAULT 0,
  "RESNDBUF"     INTEGER         NOT NULL  DEFAULT 0,
  "SUPPSNDBUF"   INTEGER         NOT NULL  DEFAULT 0,
  "MONLOGBUF"    INTEGER         NOT NULL  DEFAULT 0,
  "UPDATETIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"
			';
      END;

	  EXECUTE IMMEDIATE 'COMMENT ON "M_MON_BUF_HIS"
 ("ID"     IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "ENDCNT" IS ''后端连接数'',
  "MOTOTALRECV" IS ''后端转发至网关的MO总数'',
  "MTTOTALSND" IS ''网关成功转发至后端的MT总数'',
  "WRMOBUF" IS ''写MO_TASK表缓冲大小'',
  "UPDMOBUF" IS ''更新MO_TASK表缓冲大小'',
  "UPDRPTBUF" IS ''更新MT_TASK表中SENDSTATUS字段'',
  "WRRPTBUF" IS ''写RPT_WAIT_B表缓冲大小'',
  "ENDRSPBUF" IS ''后端高级别回应缓冲'',
  "SMTSNDBUF" IS ''网关向后端转发MT的发送缓冲（0-9级）,中间以/分隔，如0/1/2/3/4/5/6/7/8/9,中间以/分隔，如0/1/2/3/4/5/6/7/8/9'',
  "MTWAITBUF" IS ''网关向后端转发MT的发送缓冲（0-9级）0-9级别的总和'',
  "PRECNT" IS ''前端连接数'',
  "MTTOTALRECV" IS ''接收到前端MT的总量'',
  "MOTOTALSND" IS ''接收到前端MO的总量'',
  "WRMTTASKBUF" IS ''写MT_TASK表缓冲大小'',
  "WRMTTMBUF" IS ''写MT_TIMER_QUE表缓冲大小'',
  "WRMTVFYBUF" IS ''写MT_VERIFY_WAIT表缓冲大小'',
  "WRMTLVLBUF" IS ''写MT_LEVEL_QUE表缓冲大小'',
  "PRERSPBUF" IS ''前端高级别回应缓冲'',
  "PRERSPTMPBUF" IS ''前端高级别回应临时缓冲'',
  "MOSNDBUF" IS ''MO发送缓冲'',
  "RPTSNDBUF" IS ''RPT发送缓冲'',
  "MORPTWAITBUF" IS ''MO/RPT发送等待缓冲'',
  "LOGFILENUM" IS ''日志文件数量'',
  "LOGBUF" IS ''日志缓冲'',
  "RECVBUF" IS ''接收缓冲'',
  "RESNDBUF" IS ''重发缓冲'',
  "SUPPSNDBUF" IS ''补发缓冲'',
  "MONLOGBUF" IS ''监控日志缓冲'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 ) ';
    END IF;
END  &&

ALTER TABLE "M_MON_BUF_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_LOG_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_LOG_HIS"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT '' '',
  "LOGTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGS"        VARCHAR(4000)   NOT NULL  DEFAULT '' '',
  "CREATETIME"  VARCHAR(35)     NOT NULL  DEFAULT '' ''
 )';
			EXECUTE IMMEDIATE 'COMMENT ON "M_MON_LOG_HIS"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "LOGTYPE" IS ''0：来自于后台监控程序1：来自于前台监控页面'',
  "LOGS" IS ''流水日志''
 )';
	  END;
END IF;
END  &&

ALTER TABLE "M_MON_LOG_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_MONLOG_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_MONLOG_HIS"
 ("ID"      BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"  VARCHAR(32)     NOT NULL  DEFAULT '''',
  "LOGTYPE" INTEGER         NOT NULL  DEFAULT 0,
  "LOGS"    VARCHAR(4000)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"';
	  END;
END IF;
END  &&


ALTER TABLE "M_MON_MONLOG_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_MONMSG_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_MONMSG_HIS"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT '''',
  "MSGTYPE"     INTEGER         NOT NULL  DEFAULT 0,
  "MSGID"       INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MOBILE"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "MOBILETYPE"  INTEGER         NOT NULL  DEFAULT 0,
  "MOBILEAREA"  INTEGER         NOT NULL  DEFAULT 0,
  "SENDLEVEL"   INTEGER         NOT NULL  DEFAULT 0,
  "MSGFMT"      INTEGER         NOT NULL  DEFAULT 15,
  "SENDSTATUS"  INTEGER         NOT NULL  DEFAULT 1,
  "RESENDCNT"   INTEGER         NOT NULL  DEFAULT 0,
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "MESSAGE"     VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "SENDTIME"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "RECVTIME"    VARCHAR(35)     NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
  IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"';
			EXECUTE IMMEDIATE 'COMMENT ON "M_MON_MONMSG_HIS"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "MSGTYPE" IS ''100-199：检测短信(通道检测，新通道各区域发送情况检测等)200-299：报警短信(前面报警，后台报警)'',
  "MSGID" IS ''取发送后平台返回的流水号'',
  "MOBILE" IS ''最大支持10个手机号，中间英文逗号隔开'',
  "MOBILETYPE" IS ''0：移动1：联通2：小灵通21：电信手机255：未知'',
  "MOBILEAREA" IS ''手机号归属地'',
  "SENDLEVEL" IS ''0-255：值越小，级别越高'',
  "MSGFMT" IS ''默认取15'',
  "SENDSTATUS" IS ''1:新插入，待发送2:发送至下级网关3:接交下级网失败0:状态报告已返回'',
  "RESENDCNT" IS ''接交下级网关失败后，重发的次数'',
  "ERRORCODE" IS ''状态报告错误码'',
  "MESSAGE" IS ''短信内容'',
  "SENDTIME" IS ''短信发送至下级网关的时间'',
  "RECVTIME" IS ''状态报告返回时间'')';
	  END;
END IF;
END  &&

ALTER TABLE "M_MON_MONMSG_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



BEGIN
    IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_PT_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '
			CREATE TABLE "M_MON_PT_HIS"
 ("ID"      BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"      VARCHAR(32)     NOT NULL  DEFAULT '''',
  "PTNAME"      VARCHAR(128)    NOT NULL  DEFAULT '''',
  "PTIP"        VARCHAR(4000)   NOT NULL  DEFAULT '''',
  "PTPORT"      INTEGER         NOT NULL  DEFAULT 9001,
  "PTTYPE"      INTEGER         NOT NULL  DEFAULT 100,
  "PTSTATUS"    INTEGER         NOT NULL  DEFAULT 0,
  "MONUSERID"   VARCHAR(11)     NOT NULL  DEFAULT '''',
  "MONUSERPWD"  VARCHAR(32)     NOT NULL  DEFAULT '''',
  "MONFREQ"     INTEGER         NOT NULL  DEFAULT 5,
  "MAXRPTDELAY" INTEGER         NOT NULL  DEFAULT 65,
  "WARNPHONE"   VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LINKMAN"     VARCHAR(256)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
  IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"
			';
      END;

	  EXECUTE IMMEDIATE ' COMMENT ON "M_MON_PT_HIS"
 ("ID"  IS  ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "PTNAME" IS ''平台名称'',
  "PTIP" IS ''平台IP地址'',
  "PTPORT" IS ''平台监听端口'',
  "PTTYPE" IS ''平台类型'',
  "PTSTATUS" IS ''0：正常非0：各种各样的异常'',
  "MONUSERID" IS ''监控帐号'',
  "MONUSERPWD" IS ''监控帐号PWD'',
  "MONFREQ" IS ''通道监测频率'',
  "MAXRPTDELAY" IS ''通道状态报告返回最大延时时间'',
  "WARNPHONE" IS ''报警手机'',
  "LINKMAN" IS ''平台联系人''
 )  ';
    END IF;
END  &&



ALTER TABLE "M_MON_PT_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_SPGATE_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_SPGATE_HIS"
 ("ID"      BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"        VARCHAR(32)     NOT NULL  DEFAULT '''',
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "USERUID"       INTEGER         NOT NULL  DEFAULT 0,
  "USERNAME"      VARCHAR(128)    NOT NULL  DEFAULT '''',
  "JTYPE"         VARCHAR(64)     NOT NULL  DEFAULT ''直连用户(CMPP)'',
  "LINKNUM"       INTEGER         NOT NULL  DEFAULT 1,
  "LOGINIP"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "ONLINESTATUS"  INTEGER         NOT NULL  DEFAULT 0,
  "MTHAVESND"     INTEGER         NOT NULL  DEFAULT 0,
  "MTREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "MTRECVSPD"     INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"   INTEGER         NOT NULL  DEFAULT 0,
  "MOHAVESND"     INTEGER         NOT NULL  DEFAULT 0,
  "MOREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "MOSNDSPD"      INTEGER         NOT NULL  DEFAULT 0,
  "RPTTOTALRECV"  INTEGER         NOT NULL  DEFAULT 0,
  "RPTHAVESND"    INTEGER         NOT NULL  DEFAULT 0,
  "RPTREMAINED"   INTEGER         NOT NULL  DEFAULT 0,
  "RPTSNDSPD"     INTEGER         NOT NULL  DEFAULT 0,
  "SNDERCNT"      INTEGER         NOT NULL  DEFAULT 0,
  "LASTSNDERTM"   VARCHAR(35)     NOT NULL  DEFAULT '''',
  "LOGININTM"     VARCHAR(35)     NOT NULL  DEFAULT '''',
  "LOGINOUTTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "UPDATETIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"
 LONG IN "TBSPHISINDEX"';

 EXECUTE IMMEDIATE 'COMMENT ON "M_MON_SPGATE_HIS"
 ("ID"  IS  ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "USERID" IS ''用户帐号，主键'',
  "USERUID" IS ''用户帐号UID，与帐号一一对应'',
  "USERNAME" IS ''帐号对应的客户名称'',
  "JTYPE" IS ''用户使用的接入方式及接入协议'',
  "LINKNUM" IS ''帐号连接数'',
  "LOGINIP" IS ''帐号登陆IP'',
  "ONLINESTATUS" IS ''0：在线1：离线'',
  "MTHAVESND" IS ''已成功转发的MT数量'',
  "MTREMAINED" IS ''当前滞留平台未转发的MT数量'',
  "MTRECVSPD" IS ''该通道接收网关转发MT的速度'',
  "MOTOTALRECV" IS ''客户当前收到的MO总量'',
  "MOHAVESND" IS ''已转发给用户的该通道的MO数量'',
  "MOREMAINED" IS ''客户当前滞留在平台的MO数量'',
  "MOSNDSPD" IS ''客户提交MT的速度'',
  "RPTTOTALRECV" IS ''客户当前收到的RPT总量'',
  "RPTHAVESND" IS ''已转发给用户的该通道的RPT数量'',
  "RPTREMAINED" IS ''客户当前滞留在平台的RPT数量'',
  "RPTSNDSPD" IS ''客户接收RPT时超过时的次数'',
  "LOGININTM" IS ''最后一次登陆的时间'',
  "LOGINOUTTM" IS ''最后一次离线的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )';
	  END;
END IF;
END  &&


ALTER TABLE "M_MON_SPGATE_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_SYS_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_SYS_HIS"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"         VARCHAR(32)     NOT NULL  DEFAULT '''',
  "CPUUSAGE"       INTEGER         NOT NULL  DEFAULT 0,
  "MEMUSAGE"       INTEGER         NOT NULL  DEFAULT 0,
  "VMEMUSAGE"      INTEGER         NOT NULL  DEFAULT 0,
  "DISKFREESPACE"  INTEGER         NOT NULL  DEFAULT 0,
  "UPDATETIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
  IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"';
           EXECUTE IMMEDIATE 'COMMENT ON "M_MON_SYS_HIS" ("ID" IS ''自增ID'',
  "CPUUSAGE" IS ''CPU使用量，有必要是格式成XX%的字符串后显示'',
  "MEMUSAGE" IS ''物理内存使用量，以M为单位'',
  "VMEMUSAGE" IS ''虚拟内存使用量，以M为单位'',
  "DISKFREESPACE" IS ''磁盘剩余量，以M为单位'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )';

	  END;
END IF;
END  &&



ALTER TABLE "M_MON_SYS_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_THREAD_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_THREAD_HIS"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "THRID"        INTEGER         NOT NULL  DEFAULT 0,
  "THRNAME"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "THRSTATUS"    INTEGER         NOT NULL  DEFAULT 0,
  "ERRORCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "LASTERRORTM"  VARCHAR(35)     NOT NULL  DEFAULT '''',
  "THRLOGS"      VARCHAR(2048)   NOT NULL  DEFAULT '''',
  "LASTRUNTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "THISRUNTM"    VARCHAR(35)     NOT NULL  DEFAULT '''',
  "UPDATETIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
  IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"';
			EXECUTE IMMEDIATE 'COMMENT ON "M_MON_THREAD_HIS"
 ("ID" IS ''自增ID'',
  "THRID" IS ''主键，对网关来说，启动后进程 内的线程它的ID是唯一的'',
  "THRNAME" IS ''线程名称描述'',
  "THRSTATUS" IS ''00：线程正在启动中(初始状态)'',
  "ERRORCNT" IS ''线程异常次数'',
  "LASTERRORTM" IS ''最后一次出现异常的时间，仅当异常次数大于0时该值才有意义'',
  "THRLOGS" IS ''线程输出日志'',
  "LASTRUNTM" IS ''上一次线程执行时网关记下的时间'',
  "THISRUNTM" IS ''本次执行时网关记下的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )';
	  END;
END IF;
END  &&


ALTER TABLE "M_MON_THREAD_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='M_MON_USER_HIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "M_MON_USER_HIS"
 ("ID"           BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTCODE"         VARCHAR(32)     NOT NULL  DEFAULT '' '',
  "USERID"         VARCHAR(11)     NOT NULL  DEFAULT '' '',
  "USERUID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERNAME"       VARCHAR(128)    NOT NULL  DEFAULT '' '',
  "USERPRIVILEGE"  INTEGER         NOT NULL  DEFAULT 0,
  "JTYPE"          VARCHAR(64)     NOT NULL  DEFAULT ''直连用户(CMPP)'',
  "LINKNUM"        INTEGER         NOT NULL  DEFAULT 1,
  "LOGINIP"        VARCHAR(64)     NOT NULL  DEFAULT '' '',
  "ONLINESTATUS"   INTEGER         NOT NULL  DEFAULT 0,
  "USERFEE"        INTEGER         NOT NULL  DEFAULT 0,
  "FIXFAILURERATE" INTEGER         NOT NULL  DEFAULT 0,
  "FAILURENUM"     INTEGER         NOT NULL  DEFAULT 0,
  "FAILURERATE"    INTEGER         NOT NULL  DEFAULT 0,
  "BINDINFO"       VARCHAR(2000)   NOT NULL  DEFAULT '' '',
  "MTTOTALSND"     INTEGER         NOT NULL  DEFAULT 0,
  "MTHAVESND"      INTEGER         NOT NULL  DEFAULT 0,
  "MTREMAINED"     INTEGER         NOT NULL  DEFAULT 0,
  "MTSNDINFO"      VARCHAR(2000)   NOT NULL  DEFAULT '' '',
  "MTSNDSPD"       INTEGER         NOT NULL  DEFAULT 0,
  "MOTOTALRECV"    INTEGER         NOT NULL  DEFAULT 0,
  "MOREMAINED"     INTEGER         NOT NULL  DEFAULT 0,
  "MORPTRECVSPD"   INTEGER         NOT NULL  DEFAULT 0,
  "MOTMOUTCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "RPTTOTALRECV"   INTEGER         NOT NULL  DEFAULT 0,
  "RPTREMAINED"    INTEGER         NOT NULL  DEFAULT 0,
  "RPTTMOUTCNT"    INTEGER         NOT NULL  DEFAULT 0,
  "LOGININTM"      VARCHAR(35)     NOT NULL  DEFAULT '' '',
  "LOGINOUTTM"     VARCHAR(35)     NOT NULL  DEFAULT '' '',
  "UPDATETIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
  IN "TBSPHISTORY"
  INDEX IN "TBSPHISINDEX"';
			EXECUTE IMMEDIATE 'COMMENT ON "M_MON_USER_HIS"
 ("ID" IS ''自增ID'',
  "PTCODE" IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台'',
  "USERID" IS ''用户帐号，主键'',
  "USERUID" IS ''用户帐号UID，与帐号一一对应'',
  "USERNAME" IS ''帐号对应的客户名称'',
  "USERPRIVILEGE" IS ''与USERDATA表中字段意义和取值均相同。需解析出来后在界面展现出具体的权限'',
  "JTYPE" IS ''用户使用的接入方式及接入协议'',
  "LINKNUM" IS ''帐号连接数'',
  "LOGINIP" IS ''帐号登陆IP'',
  "ONLINESTATUS" IS ''0：在线1：离线'',
  "USERFEE" IS ''帐号费用'',
  "FIXFAILURERATE" IS ''0：表示没有失败率真控制,大于0表示有失几率控制。失败率FIXFAILURERATE /10000来代表失败率的值'',
  "FAILURENUM" IS ''当FIXFAILURERATE>0时才有意义'',
  "FAILURERATE" IS ''当FIXFAILURERATE>0时才有意义'',
  "BINDINFO" IS ''以字符串的形式体现该帐号的绑定信息'',
  "MTTOTALSND" IS ''客户接交MT的总数量'',
  "MTHAVESND" IS ''已成功转发的MT数量'',
  "MTREMAINED" IS ''当前滞留平台未转发的MT数量'',
  "MTSNDINFO" IS ''以字符串的形式描述用户每个通道的发送量/滞留量'',
  "MTSNDSPD" IS ''客户提交MT的速度'',
  "MOTOTALRECV" IS ''客户当前收到的MO总量'',
  "MOREMAINED" IS ''客户当前滞留在平台的MO数量'',
  "MORPTRECVSPD" IS ''客户接收MO/RPT的速度'',
  "MOTMOUTCNT" IS ''客户接收MO时超过时的次数'',
  "RPTTOTALRECV" IS ''客户当前收到的RPT总量'',
  "RPTREMAINED" IS ''客户当前滞留在平台的RPT数量'',
  "RPTTMOUTCNT" IS ''客户接收RPT时超过时的次数'',
  "LOGININTM" IS ''最后一次登陆的时间'',
  "LOGINOUTTM" IS ''最后一次离线的时间'',
  "UPDATETIME" IS ''该条记录最后一次被更新的时间''
 )';
	  END;
END IF;
END  &&

ALTER TABLE "M_MON_USER_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='PB_LIST_BLACK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "PB_LIST_BLACK"
 ("ID"        INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 5, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint PK_PB_LIST_BLACK primary key,
  "USERID"    VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"  VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"     BIGINT          NOT NULL  DEFAULT 0,
  "SVRTYPE"	  VARCHAR(64)	    NOT NULL  DEFAULT '''',
  "SPISUNCM"	SMALLINT	        NOT NULL  DEFAULT 0,
  "CORPCODE"	VARCHAR(64)	    NOT NULL  DEFAULT '''',
  "OPTYPE"    SMALLINT        NOT NULL  DEFAULT 1,
  "OPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSG"       VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "BLTYPE"    SMALLINT        NOT NULL  DEFAULT 1
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_PB_USERID"
  ON "PB_LIST_BLACK"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_SVRTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX "IX_PB_SVRTYPE"
  ON "PB_LIST_BLACK"
 ("SVRTYPE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_SPGATE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX "IX_PB_SPGATE"
  ON "PB_LIST_BLACK"
 ("SPGATE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_SPNUMBER') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX "IX_PB_SPNUMBER"
  ON "PB_LIST_BLACK"
 ("SPNUMBER" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_PHONE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX "IX_PB_PHONE"
  ON "PB_LIST_BLACK"
 ("PHONE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;


	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='IX_PB_CORPCODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX "IX_PB_CORPCODE"
  ON "PB_LIST_BLACK"
 ("CORPCODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_LIST_BLACK' AND INDNAME='PK_PB_LIST_BLACK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE UNIQUE INDEX "PK_PB_LIST_BLACK"
  ON "PB_LIST_BLACK"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&

ALTER TABLE "PB_LIST_BLACK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='PB_SERVICETYPE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "PB_SERVICETYPE"
 ("SPISUNCM"     INTEGER         NOT NULL  DEFAULT 0 constraint PK_PBSVRTYPE primary key,
  "SERVICENO"    VARCHAR(256)    NOT NULL  DEFAULT '''',
  "SERVICEINFO"  VARCHAR(100)    NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
			EXECUTE IMMEDIATE 'COMMENT ON TABLE "PB_SERVICETYPE"
  IS ''运营商号段表''';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_SERVICETYPE' AND INDNAME='PK_PBSVRTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_PBSVRTYPE"
  ON "PB_SERVICETYPE"
 ("SPISUNCM" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE "PB_SERVICETYPE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='PB_WEBZZCMD_LOG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "PB_WEBZZCMD_LOG"
 ("STIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "SID"        VARCHAR(20)     NOT NULL,
  "CMDTYPE"    INTEGER         NOT NULL,
  "USERID"     VARCHAR(20),
  "CMDPARAM"   VARCHAR(20)               DEFAULT ''0'',
  "EXECTIME"   TIMESTAMP                 DEFAULT CURRENT TIMESTAMP,
  "USEIP"      VARCHAR(50)     NOT NULL,
  "EXECFLAG"   INTEGER         NOT NULL  DEFAULT -1,
  "MEMO"       VARCHAR(100)    NOT NULL  DEFAULT '''',
  "PRODID"     INTEGER         NOT NULL  DEFAULT 0,
  "OPID"       VARCHAR(20)     NOT NULL  DEFAULT '''',
  "FEETYPE"    INTEGER         NOT NULL  DEFAULT 0,
  "FEE"        DECIMAL(6, 3)   NOT NULL,
  "SENDNUM"    BIGINT          NOT NULL  DEFAULT 0,
  "USENUMBER"  INTEGER
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;

END  &&

ALTER TABLE "PB_WEBZZCMD_LOG"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='PB_WEBZZCMD_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "PB_WEBZZCMD_QUEUE"
 ("ID"       INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "STIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SID"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CMDTYPE"  INTEGER         NOT NULL,
  "USERID"   VARCHAR(21)     NOT NULL,
  "CMDPARAM" VARCHAR(21)     NOT NULL  DEFAULT ''0'',
  "EXECTIME" TIMESTAMP,
  "USEIP"    VARCHAR(50),
  "EXECFLAG" INTEGER         NOT NULL  DEFAULT 1,
  "MEMO"     VARCHAR(100)    NOT NULL  DEFAULT '''',
  "PRODID"   INTEGER         NOT NULL  DEFAULT 0,
  "OPID"     VARCHAR(21)     NOT NULL  DEFAULT '''',
  "FEETYPE"  INTEGER         NOT NULL  DEFAULT 0,
  "FEE"      DECIMAL(6, 3)   NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;


IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='PB_WEBZZCMD_QUEUE' AND CONSTNAME='PK_CZ_QUEUE_KEY') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "PB_WEBZZCMD_QUEUE"
  ADD CONSTRAINT "PK_CZ_QUEUE_KEY" PRIMARY KEY
   ("STIME",
    "SID",
    "CMDTYPE",
    "USERID"
   )';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PB_WEBZZCMD_QUEUE' AND INDNAME='PK_CZ_QUEUE_KEY') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_CZ_QUEUE_KEY"
  ON "PB_WEBZZCMD_QUEUE"
 ("STIME"   ASC,
  "SID"     ASC,
  "CMDTYPE" ASC,
  "USERID"  ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;


END  &&

ALTER TABLE "PB_WEBZZCMD_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='PROCESSINGSTATUS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "PROCESSINGSTATUS"
 ("USEID"           INTEGER  NOT NULL  DEFAULT 0 constraint PK_PROCESSSTS primary key,
  "CURRINDEX"       BIGINT   NOT NULL  DEFAULT 0,
  "MAXINDEX"        BIGINT   NOT NULL  DEFAULT 0,
  "COUNTSTATUS"     INTEGER  NOT NULL  DEFAULT 0,
  "DISTRACTSTATUS"  INTEGER  NOT NULL  DEFAULT 0,
  "DELETESTATUS"    INTEGER  NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
IN "TBSPHISTORY"';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='PROCESSINGSTATUS' AND INDNAME='PK_PROCESSSTS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_PROCESSSTS"
  ON "PROCESSINGSTATUS"
 ("USEID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&
ALTER TABLE "PROCESSINGSTATUS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='RPT_WAIT_A') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "RPT_WAIT_A"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) constraint PK_RPT_WAIT_A primary key,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERUID"     INTEGER         NOT NULL  DEFAULT 0,
  "LOGINUID"    INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SUBMITTIME"  CHARACTER(10)   NOT NULL  DEFAULT '''',
  "DONETIME"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "RECVTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';

	  END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_A' AND INDNAME='IX_RPTWAITA_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITA_PTID"
  ON "RPT_WAIT_A"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_A' AND INDNAME='IX_RPTWAITA_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITA_UID"
  ON "RPT_WAIT_A"
 ("USERUID" ASC,
  "LOGINUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_A' AND INDNAME='PK_RPT_WAIT_A') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_RPT_WAIT_A"
  ON "RPT_WAIT_A"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&

ALTER TABLE "RPT_WAIT_A"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='RPT_WAIT_B') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "RPT_WAIT_B"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) constraint PK_RPT_WAIT_B primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "ORGUID"      INTEGER         NOT NULL  DEFAULT 0,
  "ECID"        INTEGER         NOT NULL  DEFAULT 0,
  "USERID"      VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPNUMBER"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SUBMITTIME"  CHARACTER(10)   NOT NULL  DEFAULT '''',
  "DONETIME"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "RECVTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
  "SPMSGID"   BIGINT          NOT NULL  DEFAULT 0,
   PKTOTAL	INTEGER         NOT NULL  DEFAULT 0,
   CUSTID	VARCHAR(64)	 NOT NULL  DEFAULT '''',
   EXDATA	VARCHAR(64)	 NOT NULL  DEFAULT '''',
   RESENDCNT	SMALLINT        NOT NULL  DEFAULT 0,
   RPTTYPE 	SMALLINT        NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';

	  END;
END IF;

	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_B' AND INDNAME='IX_RPTWAITB_ORGUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITB_ORGUID"
  ON "RPT_WAIT_B"
 ("ORGUID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_B' AND INDNAME='IX_RPTWAITB_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITB_UID"
  ON "RPT_WAIT_B"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_B' AND INDNAME='IX_RPTWAITB_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITB_PTID"
  ON "RPT_WAIT_B"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

			IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_B' AND INDNAME='PK_RPT_WAIT_B') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_RPT_WAIT_B"
  ON "RPT_WAIT_B"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&


ALTER TABLE "RPT_WAIT_B"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='RPT_WAIT_C') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "RPT_WAIT_C"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) constraint PK_RPT_WAIT_C primary key,
  "PTMSGID"     BIGINT          NOT NULL,
  "UID"         INTEGER         NOT NULL  DEFAULT 0,
  "SPGATE"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SUBMITTIME"  CHARACTER(10)   NOT NULL  DEFAULT '''',
  "DONETIME"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "RECVFLAG"    INTEGER         NOT NULL  DEFAULT 1,
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "LOGINID"     VARCHAR(11)     NOT NULL  DEFAULT '''',
  "RECVTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "USERMSGID"   BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"    INTEGER         NOT NULL  DEFAULT 0,
   RETFLAG	INTEGER   NOT NULL  DEFAULT 1,
   SENDTIME	BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"   BIGINT          NOT NULL  DEFAULT 0,
   WTRPTFLAG	INTEGER   NOT NULL  DEFAULT 0,
   PKTOTAL	INTEGER         NOT NULL  DEFAULT 0,
   CUSTID	VARCHAR(64)	 NOT NULL  DEFAULT '''',
   EXDATA	VARCHAR(64)	 NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_C' AND INDNAME='IX_RPTWAITC_LGNID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITC_LGNID"
  ON "RPT_WAIT_C"
 ("LOGINID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_C' AND INDNAME='IX_RPTWAITC_PTID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_RPTWAITC_PTID"
  ON "RPT_WAIT_C"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='RPT_WAIT_C' AND INDNAME='PK_RPT_WAIT_C') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_RPT_WAIT_C"
  ON "RPT_WAIT_C"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&


ALTER TABLE "RPT_WAIT_C"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='USERDATA') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "USERDATA"
 ("UID"            INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 100000, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "ID"             INTEGER         NOT NULL  DEFAULT 0,
  "USERID"         VARCHAR(11)     NOT NULL  DEFAULT '''',
  "LOGINID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "STAFFNAME"      VARCHAR(64)     NOT NULL  DEFAULT '''',
  "CORPACCOUNT"    VARCHAR(32)     NOT NULL  DEFAULT ''200001'',
  "USERACCOUNT"    VARCHAR(20)     NOT NULL  DEFAULT '''',
  "MOBILE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ORDERTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "CANCELTIME"     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODITIME"       TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "USERTYPE"       INTEGER         NOT NULL  DEFAULT 0,
  "STATUS"         INTEGER         NOT NULL  DEFAULT 0,
  "USERPASSWORD"   VARCHAR(32)     NOT NULL  DEFAULT ''147258'',
  "SMSTYPE"        INTEGER         NOT NULL  DEFAULT 0,
  "SENDTYPE"       INTEGER         NOT NULL  DEFAULT 0,
  "FEEFLAG"        INTEGER         NOT NULL  DEFAULT 0,
  "RETFLAG"        INTEGER         NOT NULL  DEFAULT 0,
  "USERPRIVILEGE"  INTEGER         NOT NULL  DEFAULT 0,
  "SUBMITCNT"      INTEGER         NOT NULL  DEFAULT 0,
  "COMPANY"        VARCHAR(100)    NOT NULL  DEFAULT '''',
  "SALEMAN"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MEMO"           VARCHAR(200)    NOT NULL  DEFAULT '''',
  "SPEEDLIMIT"     INTEGER         NOT NULL  DEFAULT 0,
  "RISELEVEL"      INTEGER         NOT NULL  DEFAULT 0,
  "MTURL"          VARCHAR(256)    NOT NULL  DEFAULT '''',
  "MOURL"          VARCHAR(256)    NOT NULL  DEFAULT '''',
  "RPTURL"         VARCHAR(256)    NOT NULL  DEFAULT '''',
  "LOGINIP"        VARCHAR(256)    NOT NULL  DEFAULT '''',
  "MAXDAYNUM"      INTEGER         NOT NULL  DEFAULT 0,
  "SENDTMSPAN"     VARCHAR(512)    NOT NULL  DEFAULT ''00:00:00-23:59:59'',
  "FORBIDTMSPAN"   VARCHAR(512)    NOT NULL  DEFAULT ''00:00:00-00:00:00'',
  "ACCOUNTTYPE"    INTEGER         NOT NULL  DEFAULT 1,
  "SPBINDURL"      VARCHAR(256)    NOT NULL  DEFAULT '''',
  "SRCNODE"        INTEGER         NOT NULL  DEFAULT 0 ,
  "SPTYPE"         SMALLINT        NOT NULL  DEFAULT 1 ,
  "TRANSMOTYPE"    INTEGER         NOT NULL  DEFAULT 0 ,
  "TRANSRPTYPE"    INTEGER         NOT NULL  DEFAULT 0,
  "PUSHVERSION"    SMALLINT        NOT NULL  DEFAULT 16
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';

	  END;
END IF;
IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='USERDATA' AND CONSTNAME='PK_USERDATA') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "USERDATA"
  ADD CONSTRAINT "PK_USERDATA" PRIMARY KEY
   ("ACCOUNTTYPE",
	  "USERID"
   )';
        END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='USERDATA' AND INDNAME='IX_USERDATA_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_USERDATA_USERID"
  ON "USERDATA"
 (
	"USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

		IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='USERDATA' AND INDNAME='PK_USERDATA') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_USERDATA"
  ON "USERDATA"
 ("ACCOUNTTYPE" ASC,Z
	"USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
END  &&

ALTER TABLE "USERDATA"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='USERFEE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "USERFEE"
 ("UID"          INTEGER         NOT NULL constraint PK_USERFEE primary key,
  "ECID"         INTEGER         NOT NULL  DEFAULT 0,
  "USERID"       VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SENDNUM"      INTEGER          NOT NULL  DEFAULT 100,
  "SENDEDNUM"    BIGINT          NOT NULL  DEFAULT 0,
  "THRESHOLD"    INTEGER         NOT NULL  DEFAULT 100000,
  "POSTPAYUSED"  BIGINT          NOT NULL  DEFAULT 0
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='USERFEE' AND INDNAME='IX_USERFEE_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_USERFEE_USERID"
  ON "USERFEE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;
	IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='USERFEE' AND INDNAME='PK_USERFEE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "PK_USERFEE"
  ON "USERFEE"
 ("UID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
    END IF;

END  &&

ALTER TABLE "USERFEE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='VERSION_CMPP') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "VERSION_CMPP"
 ("VERSION"      CHARACTER(32)    NOT NULL,
  "VERSIONDATE"  VARCHAR(10)     NOT NULL,
  "UPGRADETIME"  VARCHAR(19)     NOT NULL
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
			EXECUTE IMMEDIATE 'COMMENT ON "VERSION_CMPP"
 ("VERSION" IS ''数据库版本号(高位1个字符表示主版本号,低位2个字符表示次版本号)如：1.01'',
  "VERSIONDATE" IS ''数据库脚本发布日期，如：2011-08-08'',
  "UPGRADETIME" IS ''数据库版本升级时间，如：2011-01-01 08:08:08''
 )';
	  END;
END IF;
END  &&

ALTER TABLE "VERSION_CMPP"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='XT_GATE_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "XT_GATE_QUEUE"
 ("ID"             INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint PK_XT_GATE_QUE primary key,
  "SPGATE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "STATUS"         INTEGER         NOT NULL  DEFAULT 0,
  "SPISUNCM"       INTEGER         NOT NULL  DEFAULT 0,
  "GATETYPE"       INTEGER         NOT NULL  DEFAULT 1,
  "GATENAME"       VARCHAR(56)     NOT NULL  DEFAULT '''',
  "PORTTYPE"       INTEGER         NOT NULL  DEFAULT 0,
  "SINGLELEN"      INTEGER         NOT NULL  DEFAULT 70,
  "SIGNSTR"        VARCHAR(20)     NOT NULL  DEFAULT '''',
  "RISELEVEL"      INTEGER         NOT NULL  DEFAULT 0,
  "SPEED"          INTEGER         NOT NULL  DEFAULT 100,
  "LONGSMS"        INTEGER         NOT NULL  DEFAULT 1,
  "MAXWORDS"       INTEGER         NOT NULL  DEFAULT 0,
  "SUBLEN"         INTEGER         NOT NULL  DEFAULT 0,
  "FEEFLAG"        INTEGER         NOT NULL  DEFAULT 2,
  "SIGNLEN"        INTEGER         NOT NULL  DEFAULT 8,
  "FEE"            DECIMAL(4, 2)   NOT NULL  DEFAULT 0.00,
  "GATEINFO"       VARCHAR(50)     NOT NULL  DEFAULT '''',
  "SPLITRULE"      INTEGER                   DEFAULT 1,
  "SHOWFLAG"       INTEGER         NOT NULL  DEFAULT 1,
  "SORTID"         INTEGER         NOT NULL  DEFAULT 1,
  "MULTILEN1"      INTEGER         NOT NULL  DEFAULT 67,
  "MULTILEN2"      INTEGER         NOT NULL  DEFAULT 67,
  "GATENO"         INTEGER         NOT NULL  DEFAULT 0,
  "SIGNTYPE"       INTEGER         NOT NULL  DEFAULT 0,
  "SIGNFIXLEN"     INTEGER         NOT NULL  DEFAULT 10,
  "PREFIXLEN"      SMALLINT        NOT NULL  DEFAULT 3,
  "MAXLONGMSGSEQ"  SMALLINT        NOT NULL  DEFAULT 255,
  "ENDSPLIT"       SMALLINT        NOT NULL  DEFAULT 0,
  "GATESEQ"        SMALLINT        NOT NULL  DEFAULT 0,
  "SIGNDROPTYPE"   SMALLINT        NOT NULL  DEFAULT 1,
  "AREATYPE"       SMALLINT        NOT NULL  DEFAULT 0,
  "GATEAREA"       VARCHAR(32)     NOT NULL  DEFAULT '''',
  "EACHSIGN"       SMALLINT        NOT NULL  DEFAULT 0,
  "GATEPRIVILEGE"  INTEGER         NOT NULL  DEFAULT 0,
  "ENSIGNSTR" VARCHAR(20) NOT NULL DEFAULT '''' ,
  "ENSIGNLEN" INTEGER NOT NULL DEFAULT 20 ,
  "ENPREFIXLEN" INTEGER NOT NULL DEFAULT 6 ,
  "ENMAXWORDS" INTEGER NOT NULL DEFAULT 720 ,
  "ENSINGLELEN" INTEGER NOT NULL DEFAULT 160,
  "ENMULTILEN1" INTEGER NOT NULL DEFAULT 153 ,
  "ENMULTILEN2" INTEGER NOT NULL DEFAULT 133,
"ESPLITMAXWD" INTEGER NOT NULL DEFAULT 360,
  "ESPLITENMAXWD" INTEGER NOT NULL DEFAULT 720
 )
  DATA CAPTURE NONE
 IN "TPACCMGR"';
			EXECUTE IMMEDIATE 'COMMENT ON "XT_GATE_QUEUE"
 ("GATENAME" IS ''能道名称'',
  "PORTTYPE" IS ''端口类型'',
  "SINGLELEN" IS ''单条长度'',
  "LONGSMS" IS ''是否长短信支持(1支持，0不支持)'',
  "SUBLEN" IS ''子号长度'',
  "SIGNLEN" IS ''签名长度''
 )';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='XT_GATE_QUEUE' AND INDNAME='PK_XT_GATE_QUE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE UNIQUE INDEX "PK_XT_GATE_QUE"
  ON "XT_GATE_QUEUE"
 ("ID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&




ALTER TABLE "XT_GATE_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_TEMPLATE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_TEMPLATE"(
"ID"	BIGINT NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_TEMPLATE_PK primary key,
"TMPLID"	BIGINT NOT NULL DEFAULT 0,
"EMP_TMPLID"	VARCHAR(32) NOT NULL DEFAULT '''',
"USERID"	VARCHAR(11) NOT NULL DEFAULT '''',
"AUDITSTATUS"	SMALLINT NOT NULL DEFAULT 0,
"TMPLSTATUS"	SMALLINT NOT NULL DEFAULT 0,
"PARAMCNT"	INTEGER NOT NULL DEFAULT 0,
"TMPLPATH"	VARCHAR(256) NOT NULL DEFAULT  '''',
"RECVTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"AUDITTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"AUDITOR"	VARCHAR(32) NOT NULL DEFAULT '''',
"REMARKS"	VARCHAR(256) NOT NULL DEFAULT '''',
"RESERVE1"	VARCHAR(256) NOT NULL DEFAULT '''',
"RESERVE2"	VARCHAR(256) NOT NULL DEFAULT '''',
"RESERVE3"	VARCHAR(256) NOT NULL DEFAULT '''',
"RESERVE4"	VARCHAR(256) NOT NULL DEFAULT '''',
"RESERVE5"	VARCHAR(256) NOT NULL DEFAULT '''',
"SUBMITSTATUS"	SMALLINT NOT NULL DEFAULT 0,
"ERRCODE" INTEGER NOT NULL DEFAULT 0
)
 DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TEMPLATE' AND INDNAME='IX_MTEMP_TMPLID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTEMP_TMPLID"
  ON "MMS_TEMPLATE"
 ("TMPLID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TEMPLATE' AND INDNAME='IX_MTEMP_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MTEMP_USERID"
  ON "MMS_TEMPLATE"
 ("USERID" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&

 ALTER TABLE "MMS_TEMPLATE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_BMTREQ') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_BMTREQ"(
"ID"	INTEGER	 NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_BMTREQ_PRIMARY primary key,
"MSGID"	BIGINT	NOT NULL DEFAULT 0,
"BMTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	 NOT NULL DEFAULT '''',
"LOGINID"	VARCHAR(11)	 NOT NULL DEFAULT '''',
"USERUID"	INTEGER	NOT NULL DEFAULT 0,
"SERVICETYPE"	VARCHAR(10) NOT NULL DEFAULT '''',
"MSGTYPE"	INTEGER	NOT NULL DEFAULT 0,
"TASKID"	INTEGER	NOT NULL DEFAULT 0,
"TITLE"	VARCHAR(100) NOT NULL DEFAULT '''',
"TMPLID"	BIGINT	NOT NULL DEFAULT 0,
"MSG"	VARCHAR(3000) NOT NULL DEFAULT '''',
"MSGFMT"	SMALLINT	NOT NULL DEFAULT 15,
"REMOTEURL"	VARCHAR(256) NOT NULL DEFAULT '''',
"LOCALPATH"	VARCHAR(256) NOT NULL DEFAULT '''',
"SENDLEVEL"	SMALLINT	NOT NULL DEFAULT 5,
"ATTIME"	VARCHAR(14)	NOT NULL DEFAULT '''',
"VALIDTIME"	VARCHAR(14) NOT NULL DEFAULT '''',
"SENDSTATUS"	SMALLINT	NOT NULL DEFAULT 1,
"ERRORCODE"	VARCHAR(7) NOT NULL DEFAULT '''',
"RECVTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDTYPE"	SMALLINT	NOT NULL DEFAULT 1,
"ATTIMEFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"SA"	VARCHAR(21)	NOT NULL DEFAULT '''',
"SVRTYPE"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P1"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P3"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P4"	VARCHAR(64)	NOT NULL DEFAULT '''',
"USERMSGID"	BIGINT	NOT NULL DEFAULT 0,
"MODULEID"	INTEGER	NOT NULL DEFAULT 0,
"RETFLAG"	SMALLINT	NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';

	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQ' AND INDNAME='IX_MBMT_MSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MBMT_MSGID" ON "MMS_BMTREQ"
(
	"MSGID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQ' AND INDNAME='IX_MBMT_BMTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE   INDEX "IX_MBMT_BMTMSGID" ON "MMS_BMTREQ"
(
	"BMTMSGID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQ' AND INDNAME='IX_MBMT_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE   INDEX "IX_MBMT_USERID" ON "MMS_BMTREQ"
(
	"USERID" ASC
)';
        END;
END IF;

END  &&

 ALTER TABLE "MMS_BMTREQ"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_BMTREQHIS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_BMTREQHIS"(
"ID"	INTEGER	NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_BMTREQHIS_PK primary key,
"MSGID"	BIGINT	NOT NULL DEFAULT 0,
"BMTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	 NOT NULL DEFAULT '''',
"LOGINID"	VARCHAR(11)	 NOT NULL DEFAULT '''',
"USERUID"	INTEGER	NOT NULL DEFAULT 0,
"SERVICETYPE"	VARCHAR(10) NOT NULL DEFAULT '''',
"MSGTYPE"	INTEGER	NOT NULL DEFAULT 0,
"TASKID"	INTEGER	NOT NULL DEFAULT 0,
"TITLE"	VARCHAR(100) NOT NULL DEFAULT '''',
"TMPLID"	BIGINT	NOT NULL DEFAULT 0,
"MSG"	VARCHAR(3000) NOT NULL DEFAULT '''',
"MSGFMT"	SMALLINT	NOT NULL DEFAULT 15,
"REMOTEURL"	VARCHAR(256) NOT NULL DEFAULT '''',
"LOCALPATH"	VARCHAR(256) NOT NULL DEFAULT '''',
"SENDLEVEL"	SMALLINT	NOT NULL DEFAULT 5,
"ATTIME"	VARCHAR(14)	NOT NULL DEFAULT '''',
"VALIDTIME"	VARCHAR(14) NOT NULL DEFAULT '''',
"SENDSTATUS"	SMALLINT	NOT NULL DEFAULT 1,
"ERRORCODE"	VARCHAR(7) NOT NULL DEFAULT '''',
"RECVTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDTYPE"	SMALLINT	NOT NULL DEFAULT 1,
"ATTIMEFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"SA"	VARCHAR(21)	NOT NULL DEFAULT '''',
"SVRTYPE"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P1"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P3"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P4"	VARCHAR(64)	NOT NULL DEFAULT '''',
"USERMSGID"	BIGINT	NOT NULL DEFAULT 0,
"MODULEID"	INTEGER	NOT NULL DEFAULT 0,
"RETFLAG"	SMALLINT	NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQHIS' AND INDNAME='IX_MBMTH_MSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_MBMTH_MSGID" ON "MMS_BMTREQHIS"
(
	"MSGID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQHIS' AND INDNAME='IX_MBMTH_BMTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MBMTH_BMTMSGID" ON "MMS_BMTREQHIS"
(
	"BMTMSGID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_BMTREQHIS' AND INDNAME='IX_MBMTH_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_MBMTH_USERID" ON "MMS_BMTREQHIS"
(
	"USERID" ASC
)';
        END;
END IF;

END  &&

ALTER TABLE "MMS_BMTREQHIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&



BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_LEVEL_QUEUE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_LEVEL_QUEUE"(
"ID"	INTEGER	NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_LEVEL_QUEUE_PK primary key,
"PTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"UID"	INTEGER	NOT NULL DEFAULT 0,
"DESTUID"	INTEGER	NOT NULL DEFAULT 0,
"LOGINUID"	INTEGER	NOT NULL DEFAULT 0,
"DEALSTATUS"	INTEGER	NOT NULL DEFAULT 1,
"USERID"	VARCHAR(11)	NOT NULL DEFAULT '''',
"SPGATE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"CPNO"	VARCHAR(21)	NOT NULL DEFAULT '''',
"RETFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"TPPID"	SMALLINT	NOT NULL DEFAULT 0,
"TPUDHI"	SMALLINT	NOT NULL DEFAULT 0,
"PKNUMBER"	SMALLINT	NOT NULL DEFAULT 1,
"PKTOTAL"	SMALLINT	NOT NULL DEFAULT 1,
"TOTALCOUNT"	INTEGER	NOT NULL DEFAULT 1,
"PHONECOUNT"	INTEGER	NOT NULL DEFAULT 1,
"UNICOM"	SMALLINT	NOT NULL DEFAULT 0,
"SENDSTATUS"	SMALLINT	NOT NULL DEFAULT 1,
"SPLITFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"FEEFLAG"	SMALLINT	NOT NULL DEFAULT 2,
"SENDLEVEL"	SMALLINT	NOT NULL DEFAULT 5,
"SENDTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"MSGFMT"	SMALLINT	NOT NULL DEFAULT 15,
"MSGTYPE"	SMALLINT	NOT NULL DEFAULT 10,
"LONGMSGSEQ"	SMALLINT	NOT NULL DEFAULT 0,
"TASKID"	INTEGER		NOT NULL DEFAULT 0,
"ECID"	INTEGER		NOT NULL DEFAULT 0,
"MSGTITLE"	VARCHAR(200)	NOT NULL DEFAULT '''',
"TMPLID"	BIGINT	NOT NULL DEFAULT 0,
"MESSAGE"	VARCHAR(3000)	NOT NULL DEFAULT '''',
"PHONE"	VARCHAR(1500)	NOT NULL DEFAULT '''',
"SVRTYPE"	VARCHAR(20)	NOT NULL DEFAULT '''',
"JTYPE"	SMALLINT	NOT NULL DEFAULT 0,
"ORDERCPNO"	VARCHAR(21)	NOT NULL DEFAULT '''',
"PASSTHROUGH"	SMALLINT	NOT NULL DEFAULT 0,
"SA"	VARCHAR(21)	NOT NULL DEFAULT '''',
"P1"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P3"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P4"	VARCHAR(64)	NOT NULL DEFAULT '''',
"USERMSGID"	BIGINT	NOT NULL DEFAULT 0,
"MODULEID"	INTEGER	NOT NULL DEFAULT 0,
"ATTIME"	BIGINT	NOT NULL DEFAULT 0,
"VALIDTIME"	BIGINT	NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';

	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_LEVEL_QUEUE' AND INDNAME='IX_MLEV_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MLEV_PTMSGID" ON "MMS_LEVEL_QUEUE"
(
	"PTMSGID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_LEVEL_QUEUE' AND INDNAME='IX_MLEV_SPGATE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MLEV_SPGATE" ON "MMS_LEVEL_QUEUE"
(
	"SPGATE" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_LEVEL_QUEUE' AND INDNAME='IX_MLEV_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MLEV_USERID" ON "MMS_LEVEL_QUEUE"
(
	"USERID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_LEVEL_QUEUE' AND INDNAME='IX_MLEV_SENDTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MLEV_SENDTIME" ON "MMS_LEVEL_QUEUE"
(
	"SENDTIME" ASC
)';
        END;
END IF;

END  &&

 ALTER TABLE "MMS_LEVEL_QUEUE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_TASK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_TASK"(
"ID"	INTEGER	NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_TASK_PRIMARY primary key,
"UID"	INTEGER	NOT NULL DEFAULT 0,
"PTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	NOT NULL DEFAULT '''',
"SPGATE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"CPNO"	VARCHAR(21)	NOT NULL DEFAULT '''',
"PHONE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"TASKID"	INTEGER	NOT NULL DEFAULT 0,
"SPMSGID"	BIGINT	NOT NULL DEFAULT 0,
"SPMSGID2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"RETFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"FEEFLAG"	SMALLINT	NOT NULL DEFAULT 2,
"PKNUMBER"	SMALLINT	NOT NULL DEFAULT 1,
"PKTOTAL"	SMALLINT	NOT NULL DEFAULT 1,
"UNICOM"	SMALLINT	NOT NULL DEFAULT 0,
"SENDSTATUS"	SMALLINT	NOT NULL DEFAULT 1,
"SENDFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"DONEDATE"	CHAR(10)	NOT NULL DEFAULT '''',
"ERRORCODE"	CHAR(7)	NOT NULL DEFAULT '''',
"ERRORMSG"	VARCHAR(256)	NOT NULL DEFAULT '''',
"SENDLEVEL"	SMALLINT	NOT NULL DEFAULT 5,
"SENDTYPE"	SMALLINT	NOT NULL DEFAULT 0,
"MOBILEAREA"	INTEGER	NOT NULL DEFAULT 0,
"RESENDCNT"	SMALLINT	NOT NULL DEFAULT 0,
"RECVMTTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"TRANSMTTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"RECVTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"TRANSRPTTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"SENDRPTTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"MSGFMT"	SMALLINT	NOT NULL DEFAULT 15,
"MSGTYPE"	SMALLINT	NOT NULL DEFAULT 0,
"LONGMSGSEQ"	SMALLINT	NOT NULL DEFAULT 0,
"TPPID"	SMALLINT	NOT NULL DEFAULT 0,
"TPUDHI"	SMALLINT	NOT NULL DEFAULT 0,
"RECVFLAG"	SMALLINT	NOT NULL DEFAULT 0,
"MSGTITLE"	VARCHAR(720)	NOT NULL DEFAULT '''',
"TMPLID"	BIGINT	NOT NULL DEFAULT 0,
"MESSAGE"	VARCHAR(3000)	NOT NULL DEFAULT '''',
"ECID"	INTEGER	NOT NULL DEFAULT 0,
"SVRTYPE"	VARCHAR(20)	NOT NULL DEFAULT '''',
"JTYPE"	SMALLINT	NOT NULL DEFAULT 0,
"ORDERCPNO"	VARCHAR(21)	NOT NULL DEFAULT '''',
"PASSTHROUGH"	SMALLINT	NOT NULL DEFAULT 0,
"SPID" VARCHAR(32) NOT NULL DEFAULT '''',
"P1"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P3"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P4"	VARCHAR(64)	NOT NULL DEFAULT '''',
"USERMSGID"	BIGINT	NOT NULL DEFAULT 0,
"MODULEID"	INTEGER	NOT NULL DEFAULT 0,
"ATTIME"	BIGINT	NOT NULL DEFAULT 0,
"VALIDTIME"	BIGINT	NOT NULL DEFAULT 0
)

DATA CAPTURE NONE
IN "TBSPMTTASKDATA"
INDEX IN "TBSPMTTASKINDEX"';

	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MT_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MT_PTMSGID" ON "MMS_TASK"
(
	"PTMSGID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MMSTASK_P1') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMSTASK_P1" ON "MMS_TASK"
(
	"P1"
) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MMSTASK_SDTM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMSTASK_SDTM" ON "MMS_TASK"
(
	"SENDTIME"
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MMSTASK_SVRTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMSTASK_SVRTYPE" ON "MMS_TASK"
(
	"SVRTYPE"
) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MMSTASK_TASKID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMSTASK_TASKID" ON "MMS_TASK"
(
	"TASKID"
) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_TASK' AND INDNAME='IX_MMSTASK_USRID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMSTASK_USRID" ON "MMS_TASK"
(
	"USERID"
)  ';
        END;
END IF;
END  &&

 ALTER TABLE "MMS_TASK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_RPT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_RPT"(
"ID"	INTEGER	NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_RPT_PRIMARY primary key,
"UID"	INTEGER	NOT NULL DEFAULT 0,
"ORGUID"	INTEGER	NOT NULL DEFAULT 0,
"PTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	NOT NULL DEFAULT '''',
"SPNUMBER"	VARCHAR(21)	NOT NULL DEFAULT '''',
"PHONE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"SPMSGID"	BIGINT	NOT NULL DEFAULT 0,
"SPMSGID2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"SUBMITTIME"	CHAR(10) NOT NULL DEFAULT '''',
"DONEDATE"	CHAR(10) NOT NULL DEFAULT '''',
"ERRORCODE"	CHAR(7)	 NOT NULL DEFAULT '''',
"SENDLEVEL"	SMALLINT	NOT NULL DEFAULT 5,
"RESENDCNT"	SMALLINT	NOT NULL DEFAULT 0,
"RECVTIME"	TIMESTAMP NOT NULL DEFAULT	CURRENT TIMESTAMP,
"ECID"	INTEGER	NOT NULL DEFAULT 0,
"USERMSGID"	BIGINT	NOT NULL DEFAULT 0,
"SENDSATATUS"	SMALLINT	NOT NULL DEFAULT 1,
"ERRORMSG" VARCHAR(256) NOT NULL DEFAULT ''''
)
DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_RPT' AND INDNAME='IX_MMS_RPT_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_RPT_UID" ON "MMS_RPT"
(
	"UID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_RPT' AND INDNAME='IX_MMS_RPT_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_RPT_PTMSGID" ON "MMS_RPT"
(
	"PTMSGID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_RPT' AND INDNAME='IX_MMS_RPT_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_RPT_USERID" ON "MMS_RPT"
(
	"USERID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_RPT' AND INDNAME='IX_MMS_RPT_SPMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_RPT_SPMSGID" ON "MMS_RPT"
(
	"SPMSGID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_RPT' AND INDNAME='IX_MRPT_SPMSGID2') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MRPT_SPMSGID2" ON "MMS_RPT"
(
	"SPMSGID2" ASC
)';
        END;
END IF;

END  &&

 ALTER TABLE "MMS_RPT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_MO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_MO"(
"ID" INTEGER NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) constraint MMS_MO_PRIMARY primary key,
"UID"	INTEGER	NOT NULL DEFAULT 0,
"ORGUID"	INTEGER	NOT NULL DEFAULT 0,
"PTMSGID"	BIGINT	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	NOT NULL DEFAULT '''',
"SPGATE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"SPNUMBER"	VARCHAR(21)	NOT NULL DEFAULT '''',
"PHONE"	VARCHAR(21)	NOT NULL DEFAULT '''',
"SERVICEID"	VARCHAR(10)	NOT NULL DEFAULT '''',
"SENDSTATUS"	SMALLINT	NOT NULL DEFAULT 1,
"MSGFMT"	SMALLINT	NOT NULL DEFAULT 15,
"MSGTYPE"	SMALLINT	NOT NULL DEFAULT 0,
"TP_PID"	SMALLINT	NOT NULL DEFAULT 0,
"TP_UDHI"	SMALLINT	NOT NULL DEFAULT 0,
"DELIVERTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"UNICOM"	SMALLINT	NOT NULL DEFAULT 0,
"LONGMSGSEQ"	SMALLINT	NOT NULL DEFAULT 0,
"PKNUMBER"	SMALLINT	NOT NULL DEFAULT 1,
"PKTOTAL"	SMALLINT	NOT NULL DEFAULT 1,
"PTNOTICE"	SMALLINT	NOT NULL DEFAULT 0,
"RESENDCNT"	SMALLINT	NOT NULL DEFAULT 0,
"ECID"	INTEGER	NOT NULL DEFAULT 0,
"MSGTITLE"	VARCHAR(200)	NOT NULL DEFAULT '''',
"MSGCONTENT"	VARCHAR(3000)	NOT NULL DEFAULT '''',
"PASSTHROUGH"	SMALLINT	NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_UID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_MMS_MO_UID" ON "MMS_MO"
(
	"UID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_MO_PTMSGID" ON "MMS_MO"
(
	"PTMSGID" ASC
)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_MO_USERID" ON "MMS_MO"
(
	"USERID" ASC
)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_ORGUID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_MO_ORGUID" ON "MMS_MO"
(
	"ORGUID"
) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_SENDSTATUS') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_MO_SENDSTATUS" ON "MMS_MO"
(
	"SENDSTATUS"
) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='MMS_MO' AND INDNAME='IX_MMS_MO_US') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_MMS_MO_US" ON "MMS_MO"
(
	"UID",
	"SENDSTATUS"
)  ';
        END;
END IF;
END  &&

 ALTER TABLE "MMS_MO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_DATAREPORT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_DATAREPORT"(
"USERID"	VARCHAR(11)	NOT NULL ,
"TASKID"	INTEGER	NOT NULL DEFAULT 0,
"SPGATE"	VARCHAR(21)	NOT NULL ,
"IYMD"	INTEGER	NOT NULL ,
"IHOUR"	INTEGER	NOT NULL ,
"PTCODE"	VARCHAR(10)	NOT NULL DEFAULT '''',
"IMONTH"	INTEGER	NOT NULL ,
"ICOUNT"	INTEGER	NOT NULL DEFAULT 0,
"SUCC"	INTEGER	NOT NULL DEFAULT 0,
"FAIL1"	INTEGER	NOT NULL DEFAULT 0,
"FAIL2"	INTEGER	NOT NULL DEFAULT 0,
"FAIL3"	INTEGER	NOT NULL DEFAULT 0,
"NRET"	INTEGER	NOT NULL DEFAULT 0,
"RSUCC"	INTEGER	NOT NULL DEFAULT 0,
"RFAIL1"	INTEGER	NOT NULL DEFAULT 0,
"RFAIL2"	INTEGER	NOT NULL DEFAULT 0,
"RNRET"	INTEGER	NOT NULL DEFAULT 0,
"RELEASEFLAG"	INTEGER NOT NULL DEFAULT 1,
"STARTTIME"	TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
"ENDTIME"	TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
"ID"	BIGINT	NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
"Y"	INTEGER	NOT NULL DEFAULT 0,
"SPISUNCM"	INTEGER	NOT NULL DEFAULT 0,
"SPID"	VARCHAR(64)	NOT NULL DEFAULT '''',
"SVRTYPE"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P1"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P2"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P3"	VARCHAR(64)	NOT NULL DEFAULT '''',
"P4"	VARCHAR(64)	NOT NULL DEFAULT '''',
"MOBILEAREA"	 INTEGER	       NOT NULL DEFAULT 0,
"SENDTYPE"     INTEGER         NOT NULL DEFAULT 1
)
DATA CAPTURE NONE
 IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='MMS_DATAREPORT' AND CONSTNAME='MMS_DATAREPORT_PK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "MMS_DATAREPORT" ADD CONSTRAINT "MMS_DATAREPORT_PK" PRIMARY KEY
(
	"USERID",
    "TASKID",
    "SPGATE",
    "IYMD",
    "IHOUR",
    "PTCODE",
	"SPISUNCM",
	"SPID",
	"SVRTYPE",
	"P1",
    "P2",
    "P3",
    "P4",
    "MOBILEAREA",
    "SENDTYPE"
)';
        END;
END IF;

END  &&


 ALTER TABLE "MMS_DATAREPORT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='MMS_MODATAREPORT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "MMS_MODATAREPORT"(
"IYMD"	INTEGER	NOT NULL DEFAULT 0,
"USERID"	VARCHAR(11)	NOT NULL DEFAULT '''',
"SPGATE"	VARCHAR(21)NOT NULL DEFAULT '''',
"IHOUR"	INTEGER	NOT NULL DEFAULT 0,
"ICOUNT"	INTEGER NOT NULL DEFAULT 0,
"IMONTH"	INTEGER	NOT NULL DEFAULT 0,
"IYEAR"	INTEGER	NOT NULL DEFAULT 0,
"ID"	BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
"RECVDATE"	INTEGER	NOT NULL DEFAULT 0,
"SPISUNCM"	BIGINT	NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TBSPHISTORY"
 INDEX IN "TBSPHISINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='MMS_MODATAREPORT' AND CONSTNAME='MMS_MODT_PK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'ALTER TABLE "MMS_MODATAREPORT" ADD  CONSTRAINT "MMS_MODT_PK" PRIMARY KEY
(
	"USERID",
	"SPGATE",
	"SPISUNCM",
	"IYMD",
	"IYEAR",
	"IMONTH",
	"IHOUR"
)';
        END;
END IF;

END  &&


 ALTER TABLE "MMS_MODATAREPORT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&





--############################20200106 end  ##################

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_CMD_ROUTE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_CMD_ROUTE"(
	"ID" BIGINT NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT PK_A_CMD_ROUTE PRIMARY KEY,
	"NAME" VARCHAR(50) NOT NULL  DEFAULT '''',
	"STRUCTCODE" VARCHAR(20)NOT NULL  DEFAULT '''',
  "TRUCTTYPE"	CHAR(2)NOT NULL   DEFAULT ''01'',
  "BUSSYSNAME" VARCHAR(256)NOT NULL   DEFAULT '''',
  "SP_ID"	INTEGER NOT NULL   DEFAULT 0,
  "STATUS" CHAR(2)	NOT NULL   DEFAULT ''01'',
  "MATCHMODE"	INTEGER	NOT NULL   DEFAULT 0,

  "CMDTYPE"	INTEGER	NOT NULL DEFAULT 0,
  "CMDPARAM" INTEGER NOT NULL DEFAULT 0,
  "CMDATTRI" VARCHAR(64) DEFAULT '''',
  "PUSHURL"	VARCHAR(256) DEFAULT '''',
  "PUSHPROTOCOL" VARCHAR(256) DEFAULT '''',

  "CREATER"	VARCHAR(20)	NOT NULL   DEFAULT '''',
  "CREATTIME"	TIMESTAMP  NOT NULL  DEFAULT CURRENT TIMESTAMP,

  "RESERVE1" VARCHAR(64) DEFAULT '''',
  "RESERVE2" VARCHAR(64) DEFAULT ''''
)
DATA CAPTURE NONE
 IN "TPACCMGR" ';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_CMD_ROUTE' AND INDNAME='IX_STRUCTCODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_STRUCTCODE" ON "A_CMD_ROUTE"
(
	"STRUCTCODE" ASC
)';
        END;
END IF;

END  &&

 ALTER TABLE "A_CMD_ROUTE"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_CMD_PORT') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_CMD_PORT"(
"ID" BIGINT NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER)  CONSTRAINT PK_A_CMD_PORT PRIMARY KEY,
"GATEID"	BIGINT	NOT NULL DEFAULT 0,
"CMDID"	BIGINT	NOT NULL DEFAULT 0,
"STATUS"	INTEGER	NOT NULL DEFAULT 0,
"CPNO"	VARCHAR(21)	DEFAULT '''',
"FAILOPT"	INTEGER	NOT NULL DEFAULT 0,
"DEFCMDID"	BIGINT DEFAULT 0,
"RESERVE1"	VARCHAR(64)	DEFAULT '''',
"RESERVE2"	VARCHAR(64)	DEFAULT ''''
)
 DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_CMD_PORT' AND INDNAME='IX_A_CMD_PORT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX "IX_A_CMD_PORT" ON "A_CMD_PORT"
(
	"GATEID" ASC,
	"CMDID" ASC,
	"CPNO" ASC
)';
        END;
END IF;

END  &&

 ALTER TABLE "A_CMD_PORT"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SMSFWDCONF') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_SMSFWDCONF" (
	"PROTOCOLCODE" VARCHAR(64) NOT NULL DEFAULT '''' CONSTRAINT "A_SMSFWDCONF_PK" PRIMARY KEY,
	"PROTOCOLNAME" VARCHAR(128) NOT NULL DEFAULT '''',
	"FWDSNDURL" VARCHAR(256) NOT NULL DEFAULT '''',
	"FWDRECVURL" VARCHAR(256) NOT NULL DEFAULT '''',
	"FWDACCOUNT" VARCHAR(32) NOT NULL DEFAULT '''',
	"FWDPASSWD" VARCHAR(32) NOT NULL DEFAULT ''''
)
DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;
END  &&

 ALTER TABLE "A_SMSFWDCONF"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_MT_TASK_BAK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_MT_TASK_BAK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_MTTASKBAK_PK PRIMARY KEY,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "UID"           INTEGER         NOT NULL  DEFAULT 0,
  "ECID"          INTEGER         NOT NULL  DEFAULT 0,
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "RETFLAG"       SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"       SMALLINT        NOT NULL  DEFAULT 1,
  "PKNUMBER"      SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"       SMALLINT        NOT NULL  DEFAULT 1,
  "SENDSTATUS"    INTEGER         NOT NULL  DEFAULT 2,
  "SENDFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "RECVFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "DONEDATE"      CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"     CHARACTER(7)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"     SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTYPE"      SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"        SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"       VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "RESENDCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "TASKID"        INTEGER         NOT NULL  DEFAULT 0,
  "SPID"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MOBILEAREA"    INTEGER         NOT NULL  DEFAULT 0,
  "RECVMTTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSMTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSRPTTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDRPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSGFMT"        SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"    SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"         SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"        SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"      INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"        BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"     BIGINT          NOT NULL  DEFAULT 0,
  "BATCHID"       BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"      INTEGER         NOT NULL  DEFAULT 0,
  "FLAGMTSDOK"    SMALLINT        NOT NULL  DEFAULT 0,
  "FLAGRPTRVOK"   SMALLINT        NOT NULL  DEFAULT 0,
  "FLAGRPTSDOK"   SMALLINT        NOT NULL  DEFAULT 0,
  "MTSUBMITTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRRESENDCNT"  INTEGER         NOT NULL  DEFAULT 0,
  "NETERRCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "SENDRESULT"    SMALLINT        NOT NULL  DEFAULT 1,
  "SPGATESEND"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SENDERRCODE"   VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SUBMITDATE"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "CUSTID"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "EXDATA"	VARCHAR(64)	 NOT NULL  DEFAULT '''',
  "LONGMSG"	 VARCHAR(4000) NOT NULL DEFAULT '''',
  "TMPLID" 	   BIGINT NOT NULL DEFAULT 0,
  "CHGRADE"    SMALLINT NOT NULL DEFAULT 0,
  "MSGTYPE"    SMALLINT NOT NULL DEFAULT 0,
  "RMSVALIDTM" SMALLINT NOT NULL DEFAULT 0,
  "ERRORCODE2" CHARACTER(7) NOT NULL DEFAULT '''',
  "DOWNTM" TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
  "RMSRPTFLAG" SMALLINT NOT NULL DEFAULT 1,
  "PROTOCOLVER" SMALLINT NOT NULL DEFAULT 0,
  "TMPLTYPE" SMALLINT NOT NULL DEFAULT 0,
  "TITLE"	 VARCHAR(40) NOT NULL DEFAULT '''',
  "SHOWAY"	 VARCHAR(16) NOT NULL DEFAULT '''',
  "DLDWAY"     INTEGER         NOT NULL  DEFAULT 0,
  "DLDNEY"     INTEGER         NOT NULL  DEFAULT 0,
  "ISFREE"     INTEGER         NOT NULL  DEFAULT 0,
  "SHOWTIME"   BIGINT NOT NULL DEFAULT 0,
  "SUID1"	VARCHAR(64) NOT NULL DEFAULT '''',
  "LUID1"	VARCHAR(64) NOT NULL DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_PTMSGID_TASK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX  "IX_PTMSGID_TASK"
  ON  "GW_MT_TASK_BAK"
 ("PTMSGID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_P1') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GW_MT_TASK_P1"
  ON  "GW_MT_TASK_BAK"
 ("P1" ASC
 )
   PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_SENDTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IX_GW_MT_TASK_SENDTIME"
  ON  "GW_MT_TASK_BAK"
 ("SENDTIME" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_SVRTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX  "IX_GW_MT_TASK_SVRTYPE"
  ON  "GW_MT_TASK_BAK"
 ("SVRTYPE" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_TASKID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX  "IX_GW_MT_TASK_TASKID"
  ON  "GW_MT_TASK_BAK"
 ("TASKID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_USERID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '       CREATE INDEX  "IX_GW_MT_TASK_USERID"
  ON  "GW_MT_TASK_BAK"
 ("USERID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_BATCHID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_GW_MT_TASK_BATCHID"
  ON  "GW_MT_TASK_BAK"
 ("BATCHID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_PHONE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_GW_MT_TASK_PHONE"
  ON  "GW_MT_TASK_BAK"
 ("PHONE" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_GW_MT_TASK_AREACODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_GW_MT_TASK_AREACODE"
  ON  "GW_MT_TASK_BAK"
 ("AREACODE" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_FLAGMTSDOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_FLAGMTSDOK"
  ON  "GW_MT_TASK_BAK"
 ("FLAGMTSDOK" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_FLAGRPTRVOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_FLAGRPTRVOK"
  ON  "GW_MT_TASK_BAK"
 ("FLAGRPTRVOK" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_BAK' AND INDNAME='IX_FLAGRPTSDOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
CREATE INDEX  "IX_FLAGRPTSDOK"
  ON  "GW_MT_TASK_BAK"
 ("FLAGRPTSDOK" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
END  &&



ALTER TABLE  "GW_MT_TASK_BAK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_MT_TASK_ERR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_MT_TASK_ERR"
 ("ID"            BIGINT          NOT NULL  DEFAULT 0,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "UID"           INTEGER         NOT NULL  DEFAULT 0,
  "ECID"          INTEGER         NOT NULL  DEFAULT 0,
  "USERID"        VARCHAR(11)     NOT NULL  DEFAULT '''',
  "SPGATE"        VARCHAR(21)     NOT NULL  DEFAULT '''',
  "CPNO"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "RETFLAG"       SMALLINT        NOT NULL  DEFAULT 0,
  "FEEFLAG"       SMALLINT        NOT NULL  DEFAULT 1,
  "PKNUMBER"      SMALLINT        NOT NULL  DEFAULT 1,
  "PKTOTAL"       SMALLINT        NOT NULL  DEFAULT 1,
  "SENDSTATUS"    INTEGER         NOT NULL  DEFAULT 2,
  "SENDFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "RECVFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "DONEDATE"      CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"     CHARACTER(7)    NOT NULL  DEFAULT '''',
  "SENDLEVEL"     SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTYPE"      SMALLINT        NOT NULL  DEFAULT 0,
  "UNICOM"        SMALLINT        NOT NULL  DEFAULT 0,
  "SENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MESSAGE"       VARCHAR(3000)   NOT NULL  DEFAULT '''',
  "RESENDCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "TASKID"        INTEGER         NOT NULL  DEFAULT 0,
  "SPID"          VARCHAR(21)     NOT NULL  DEFAULT '''',
  "MOBILEAREA"    INTEGER         NOT NULL  DEFAULT 0,
  "RECVMTTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSMTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSRPTTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDRPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MSGFMT"        SMALLINT        NOT NULL  DEFAULT 15,
  "LONGMSGSEQ"    SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"         SMALLINT        NOT NULL  DEFAULT 0,
  "TPUDHI"        SMALLINT        NOT NULL  DEFAULT 0,
  "SVRTYPE"       VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P1"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P2"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P3"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "P4"            VARCHAR(64)     NOT NULL  DEFAULT '''',
  "USERMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "MODULEID"      INTEGER         NOT NULL  DEFAULT 0,
  "ATTIME"        BIGINT          NOT NULL  DEFAULT 0,
  "VALIDTIME"     BIGINT          NOT NULL  DEFAULT 0,
  "BATCHID"       BIGINT          NOT NULL  DEFAULT 0,
  "AREACODE"      INTEGER         NOT NULL  DEFAULT 0,
  "FLAGMTSDOK"    SMALLINT        NOT NULL  DEFAULT 0,
  "FLAGRPTRVOK"   SMALLINT        NOT NULL  DEFAULT 0,
  "FLAGRPTSDOK"   SMALLINT        NOT NULL  DEFAULT 0,
  "MTSUBMITTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRRESENDCNT"  INTEGER         NOT NULL  DEFAULT 0,
  "NETERRCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "SENDRESULT"    SMALLINT        NOT NULL  DEFAULT 1,
  "SPGATESEND"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SENDERRCODE"   VARCHAR(10)     NOT NULL  DEFAULT '''',
  "SUBMITDATE"    CHARACTER(10)   NOT NULL  DEFAULT ''''
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_ERR' AND INDNAME='IX_PTMSGID_TASKERR') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX  "IX_PTMSGID_TASKERR"
  ON  "GW_MT_TASK_ERR"
 ("PTMSGID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MT_TASK_ERR' AND INDNAME='IX_TASKERR_SENDTIM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IX_TASKERR_SENDTIM"
  ON  "GW_MT_TASK_ERR"
 ("SENDTIME" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

END  &&

  &&

ALTER TABLE  "GW_MT_TASK_ERR"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


 -------------------------------------GW_MTSDOK--------------------------------------------------


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_MTSDOK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_MTSDOK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_MTSDOK_PK PRIMARY KEY ,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 3,
  "SPID"          VARCHAR(32)     NOT NULL  DEFAULT '''',
  "TRANSMTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MTSUBMITTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRRESENDCNT"  INTEGER         NOT NULL  DEFAULT 0,
  "NETERRCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "SENDRESULT"    SMALLINT        NOT NULL  DEFAULT 1,
  "SPGATESEND"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SENDERRCODE"   VARCHAR(10)     NOT NULL  DEFAULT '''',
  "TPUDHI"        SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"         SMALLINT        NOT NULL  DEFAULT 0,
  "PKTOTAL"       SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"      SMALLINT        NOT NULL  DEFAULT 0,
  "LONGMSGSEQ"    SMALLINT        NOT NULL  DEFAULT 0,
  "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK' AND INDNAME='IX_GWMTSDOK_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWMTSDOK_PTMSGID"
  ON  "GW_MTSDOK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK' AND INDNAME='IDX_GWMTSDOK_SPGATESE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IDX_GWMTSDOK_SPGATESE"
  ON  "GW_MTSDOK"
 ("SPGATESEND" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK' AND INDNAME='IDX_GWMTSDOK_SENDRES') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX  "IDX_GWMTSDOK_SENDRES"
  ON  "GW_MTSDOK"
 ("SENDRESULT" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK' AND INDNAME='IDX_GWMTSDOK_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX  "IDX_GWMTSDOK_INTIME"
  ON  "GW_MTSDOK"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
END  &&

 ALTER TABLE  "GW_MTSDOK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



  ---------------------------------GW_MTSDOK_ERR-----------------------------------------
  BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_MTSDOK_ERR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_MTSDOK_ERR"
 ("ID"            BIGINT          NOT NULL CONSTRAINT GW_MTSDOKERR_PK PRIMARY KEY,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 3,
  "SPID"          VARCHAR(32)     NOT NULL  DEFAULT '''',
  "TRANSMTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MTSUBMITTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "SENDTIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRRESENDCNT"  INTEGER         NOT NULL  DEFAULT 0,
  "NETERRCNT"     INTEGER         NOT NULL  DEFAULT 0,
  "SENDRESULT"    SMALLINT        NOT NULL  DEFAULT 1,
  "SPGATESEND"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SENDERRCODE"   VARCHAR(10)     NOT NULL  DEFAULT '''',
  "TPUDHI"        SMALLINT        NOT NULL  DEFAULT 0,
  "TPPID"         SMALLINT        NOT NULL  DEFAULT 0,
  "PKTOTAL"       SMALLINT        NOT NULL  DEFAULT 0,
  "PKNUMBER"      SMALLINT        NOT NULL  DEFAULT 0,
  "LONGMSGSEQ"    SMALLINT        NOT NULL  DEFAULT 0,
  "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK_ERR' AND INDNAME='IX_PTMSGID_MTSDOKERR') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_PTMSGID_MTSDOKERR"
  ON  "GW_MTSDOK_ERR"
 ("PTMSGID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MTSDOK_ERR' AND INDNAME='IDX_GWMTSDOKERR_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IDX_GWMTSDOKERR_INTIME"
  ON  "GW_MTSDOK_ERR"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;


END  &&

ALTER TABLE  "GW_MTSDOK_ERR"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



---------------------------------------GW_RPTRVOK--------------------------------------
  BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RPTRVOK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_RPTRVOK"
 ("ID"          BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_RPTRVOK_PK PRIMARY KEY ,
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 5,
  "RECVTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "DONEDATE"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "SUBMITDATE"  CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"    VARCHAR(21)     NOT NULL  DEFAULT '''',
   "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTRVOK' AND INDNAME='IX_PTMSGID_GWRPTRVOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX  "IX_PTMSGID_GWRPTRVOK"
  ON  "GW_RPTRVOK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTRVOK' AND INDNAME='IDX_GWRPTRVOK_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
   CREATE INDEX  "IDX_GWRPTRVOK_INTIME"
  ON  "GW_RPTRVOK"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;


END  &&


ALTER TABLE  "GW_RPTRVOK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


----------------------------------GW_RPTRVOK_ERR------------------------------------
 BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RPTRVOK_ERR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE TABLE  "GW_RPTRVOK_ERR"
 ("ID"          BIGINT          NOT NULL  CONSTRAINT GW_RPTRVOKERR_PK PRIMARY KEY,
  "PTMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"     BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"  SMALLINT        NOT NULL  DEFAULT 5,
  "RECVTIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "DONEDATE"    CHARACTER(10)   NOT NULL  DEFAULT '''',
  "SUBMITDATE"  CHARACTER(10)   NOT NULL  DEFAULT '''',
  "ERRORCODE"   CHARACTER(7)    NOT NULL  DEFAULT '''',
  "PHONE"       VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"    VARCHAR(21)     NOT NULL  DEFAULT '''',
  "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTRVOK_ERR' AND INDNAME='IX_PTMSGID_RPTRVOKERR') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE INDEX  "IX_PTMSGID_RPTRVOKERR"
  ON  "GW_RPTRVOK_ERR"
 ("PTMSGID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTRVOK_ERR' AND INDNAME='IDX_GWRPTRVOKERR_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
  CREATE INDEX  "IDX_GWRPTRVOKERR_INTIME"
  ON  "GW_RPTRVOK_ERR"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;


END  &&

ALTER TABLE  "GW_RPTRVOK_ERR"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

--------------------------------------GW_RPTSDOK--------------------------
 BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RPTSDOK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE TABLE  "GW_RPTSDOK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_RPTSDOK_PK PRIMARY KEY,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 5,
  "SENDFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "SENDRPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSRPTTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRORCODE"     CHARACTER(7)    NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTSDOK' AND INDNAME='IX_PTMSGID_GWRPTSDOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX  "IX_PTMSGID_GWRPTSDOK"
  ON  "GW_RPTSDOK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTSDOK' AND INDNAME='IDX_INTIME_GWRPTSDOK') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
   CREATE INDEX  "IDX_INTIME_GWRPTSDOK"
  ON  "GW_RPTSDOK"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

END  &&


ALTER TABLE  "GW_RPTSDOK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


   ---------------------------------------GW_RPTSDOK_ERR-----------------------------------------
 BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RPTSDOK_ERR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE TABLE  "GW_RPTSDOK_ERR"
 ("ID"            BIGINT          NOT NULL CONSTRAINT GW_RPTSDOKERR_PK PRIMARY KEY,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 5,
  "SENDFLAG"      SMALLINT        NOT NULL  DEFAULT 0,
  "SENDRPTTIME"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "TRANSRPTTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ERRORCODE"     CHARACTER(7)    NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "IN_TIME"    TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTSDOK_ERR' AND INDNAME='IX_PTMSGID_RPTSDOKERR') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE INDEX  "IX_PTMSGID_RPTSDOKERR"
  ON  "GW_RPTSDOK_ERR"
 ("PTMSGID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RPTSDOK_ERR' AND INDNAME='IDX_INTIME_GWRPTSDOKERR') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
      CREATE INDEX  "IDX_INTIME_GWRPTSDOKERR"
  ON  "GW_RPTSDOK_ERR"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

END  &&

ALTER TABLE  "GW_RPTSDOK_ERR"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



  -------------------------------GW_TRAN_DEL_LOG--------------------------------------
 BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_TRAN_DEL_LOG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_TRAN_DEL_LOG"
 ("ID"       BIGINT     NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER),
  "OPRTYPE"  SMALLINT   NOT NULL,
  "STARTID"  BIGINT     NOT NULL,
  "ENDID"    BIGINT     NOT NULL,
  "ISSUCCES" SMALLINT   NOT NULL,
  "IN_TIME"  TIMESTAMP  NOT NULL,
  "END_TIME" TIMESTAMP  NOT NULL
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_TRAN_DEL_LOG' AND INDNAME='IX_ID_TRAN') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '   CREATE UNIQUE INDEX  "IX_ID_TRAN"
  ON  "GW_TRAN_DEL_LOG"
 ("ID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;


END  &&

ALTER TABLE  "GW_TRAN_DEL_LOG"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


 -------------------------------GW_UPD_DEL_LOG--------------------------------------
BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_UPD_DEL_LOG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE  "GW_UPD_DEL_LOG"
 ("ID"       BIGINT     NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER),
  "OPRTYPE"  SMALLINT   NOT NULL,
  "UPTYPE"   SMALLINT   NOT NULL,
  "COUNTID"  BIGINT     NOT NULL,
  "ISSUCCES" SMALLINT   NOT NULL,
  "IN_TIME"  TIMESTAMP  NOT NULL,
  "END_TIME" TIMESTAMP  NOT NULL
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_UPD_DEL_LOG' AND INDNAME='IX_ID_UPD') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE UNIQUE INDEX  "IX_ID_UPD"
  ON  "GW_UPD_DEL_LOG"
 ("ID" ASC
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;

END  &&


ALTER TABLE  "GW_UPD_DEL_LOG"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&






BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_MOBILEAREA') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_MOBILEAREA"
(
"ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT A_MOBILEAREA_PK PRIMARY KEY,
"MOBILE"	INTEGER NOT NULL DEFAULT 0,
"AREACODE"	INTEGER NOT NULL DEFAULT 0,
"CREATETIME"	TIMESTAMP 	NOT NULL DEFAULT CURRENT TIMESTAMP
)
DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_MOBILEAREA' AND INDNAME='IX_A_MOBILEAREA') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE UNIQUE INDEX "IX_A_MOBILEAREA" ON "A_MOBILEAREA"
 ("MOBILE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&

ALTER TABLE "A_MOBILEAREA"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_IPCOMINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_IPCOMINFO(
ID	      INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
GATENAME	VARCHAR(32)	NOT NULL ,
PTIP	      VARCHAR(32)	NOT NULL DEFAULT '''',
PTPORT	    INTEGER         NOT NULL DEFAULT 0,
IP	      VARCHAR(32)	NOT NULL DEFAULT '''',
PORT	    INTEGER         NOT NULL DEFAULT 0,
GATEID	  INTEGER         NOT NULL DEFAULT 0 CONSTRAINT PK_IPCOM PRIMARY KEY ,
CORPSIGN	VARCHAR(20)	DEFAULT '''',
COMMON	  VARCHAR(256) DEFAULT '''',
CREATETIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP
)
 DATA CAPTURE NONE
IN "TPACCMGR" ';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_IPCOMINFO' AND INDNAME='IX_IPCOM_ID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IX_IPCOM_ID ON A_IPCOMINFO (ID)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_IPCOMINFO' AND INDNAME='IX_IPCOM_IP') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_IPCOM_IP ON A_IPCOMINFO (IP)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_IPCOMINFO' AND INDNAME='IX_IPCOM_PORT') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_IPCOM_PORT ON A_IPCOMINFO (PORT)';
        END;
END IF;
END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SIMINFO') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_SIMINFO(
ID	        INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT PK_ASIM PRIMARY KEY ,
GATEID	    INTEGER NOT NULL DEFAULT  0 ,
UNICOM	    INTEGER NOT NULL DEFAULT	0 ,
PHONENO	    VARCHAR(21)	NOT NULL DEFAULT '''' ,
MOBILEAREA	INTEGER NOT NULL DEFAULT 0 ,
DESCRIPTION	VARCHAR(256) DEFAULT '''',
SIMNO	      INTEGER NOT NULL DEFAULT  0,
HOURLIMIT	  INTEGER	NOT NULL DEFAULT	0,
DAYLIMIT	  INTEGER	NOT NULL DEFAULT	0,
MONTHLIMIT	INTEGER	NOT NULL DEFAULT	0,
CREATETIME	TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)
 DATA CAPTURE NONE
IN "TPACCMGR"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SIMINFO' AND INDNAME='IX_ASIM_GATEID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_ASIM_GATEID ON A_SIMINFO(GATEID) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SIMINFO' AND INDNAME='IX_ASIM_UNICOM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_ASIM_UNICOM ON A_SIMINFO(UNICOM)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SIMINFO' AND INDNAME='IX_ASIM_EAREA') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_ASIM_EAREA  ON A_SIMINFO(MOBILEAREA)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SIMINFO' AND INDNAME='IX_ASIM_SIMNO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_ASIM_SIMNO  ON A_SIMINFO(SIMNO)';
        END;
END IF;
END  &&




BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_MNP') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_MNP(
ID INTEGER NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT PK_AMNP PRIMARY KEY,
PHONE	VARCHAR(21)	NOT NULL DEFAULT '''' ,
UNICOM INTEGER NOT NULL DEFAULT 0,
PHONETYPE	INTEGER NOT NULL DEFAULT 0,
ADDTYPE	INTEGER	NOT NULL DEFAULT 0,
OPTTYPE	INTEGER	NOT NULL DEFAULT 0,
CREATETIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP
)
  DATA CAPTURE NONE
IN "TBSPSVRDATA"
INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_MNP' AND INDNAME='IX_MNP_PHOTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_MNP_PHOTYPE ON A_MNP (PHONETYPE)';
        END;
END IF;

END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_MNPERRCODE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_MNPERRCODE(
ID	INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
TYPE INTEGER NOT NULL DEFAULT 0,
MNPTYPE INTEGER NOT NULL DEFAULT 0,
ERRORCODE	VARCHAR(7) NOT NULL DEFAULT '''' CONSTRAINT PK_MNPERRCODE PRIMARY KEY,
STATUS	INTEGER NOT NULL DEFAULT 0,
CREATETIME	TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)
  DATA CAPTURE NONE
IN "TBSPSVRDATA"
INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_MNPERRCODE' AND INDNAME='IX_MNPERR_ID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IX_MNPERR_ID ON A_MNPERRCODE (ID)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_MNPERRCODE' AND INDNAME='IX_MNPERR_TYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_MNPERR_TYPE ON A_MNPERRCODE (TYPE)';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_MNPERRCODE' AND INDNAME='IX_MNPERR_MNPTYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_MNPERR_MNPTYPE ON A_MNPERRCODE (MNPTYPE)';
        END;
END IF;
END  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SPE_PHONE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_SPE_PHONE(
ID	INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT PK_SPE_PHONE PRIMARY KEY,
PHONE	VARCHAR(21)	NOT NULL DEFAULT '''' ,
CUSTID	INTEGER NOT NULL DEFAULT 0,
USERID	VARCHAR(11)	NOT NULL DEFAULT '''',
SPECTYPE INTEGER NOT NULL DEFAULT 0,
OPTTYPE	INTEGER  NOT NULL DEFAULT 0,
UNICOM	INTEGER  NOT NULL DEFAULT 0,
CREATETIME TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)
  DATA CAPTURE NONE
IN "TBSPSVRDATA"
INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SPE_PHONE' AND INDNAME='IX_SPEPHO_SPETYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_SPEPHO_SPETYPE ON A_SPE_PHONE (SPECTYPE) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SPE_PHONE' AND INDNAME='IX_SPEPHO_UNICOM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_SPEPHO_UNICOM ON A_SPE_PHONE (UNICOM)';
        END;
END IF;

END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_AREACODE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_AREACODE(
ID	INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT PK_AREACODE PRIMARY KEY,
AREACODE	VARCHAR(21)	NOT NULL DEFAULT '''',
AREANAME	VARCHAR(256) NOT NULL DEFAULT '''',
CREATETIME TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
CODE	INTEGER    NOT NULL  DEFAULT 0
)
 DATA CAPTURE NONE
IN "TPACCMGR"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_AREACODE' AND INDNAME='IX_AREACODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IX_AREACODE ON A_AREACODE (AREACODE)';
        END;
END IF;


END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_GWROUTE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE A_GWROUTE(
ID	INTEGER  NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
TYPE	  INTEGER NOT NULL DEFAULT 0,
GATEID	INTEGER NOT NULL DEFAULT 0,
STATUS	INTEGER NOT NULL DEFAULT 0,
UNICOM	INTEGER NOT NULL DEFAULT 0,
AREA	  INTEGER NOT NULL DEFAULT 0,
SIMID	  INTEGER NOT NULL DEFAULT 0,
GATESEQ	INTEGER NOT NULL DEFAULT 0,
SENDTIMEBEGIN	CHAR(8)	NOT NULL DEFAULT ''00:00:00'',
SENDTIMEEND	CHAR(8)	NOT NULL DEFAULT ''23:59:59'',
P1	VARCHAR(256)	NOT NULL DEFAULT '''',
P2	VARCHAR(256)	NOT NULL DEFAULT '''',
CREATETIME TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)
 DATA CAPTURE NONE
IN "TPACCMGR" ';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWROUTE' AND INDNAME='IX_GWRUT_TYPE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_GWRUT_TYPE ON A_GWROUTE(TYPE)';
        END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_GWROUTE' AND INDNAME='IX_GWRUT_GATEID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX IX_GWRUT_GATEID ON A_GWROUTE(GATEID) ';
        END;
END IF;
END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_CLUSPBIND') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE TABLE  "GW_CLUSPBIND"
 ("ID"       INTEGER     NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, NO CYCLE, NO ORDER) CONSTRAINT GW_CLUSPBIND_PK PRIMARY KEY,
  "PTACCUID"  INTEGER   NOT NULL DEFAULT 0,
  "GWNO"  INTEGER     NOT NULL DEFAULT 0,
  "GWEIGHT"    INTEGER     NOT NULL DEFAULT 0,
  "UPDTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX" ';
	  END;
END IF;

END  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_CLUSTATUS') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE '  CREATE TABLE  "GW_CLUSTATUS"
 ("ID"       INTEGER     NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1,  NO CYCLE, NO ORDER) CONSTRAINT GW_CLUSTATUS_PK PRIMARY KEY,
  "GWTYPE"  INTEGER   NOT NULL DEFAULT 0,
  "GWNO"  INTEGER     NOT NULL DEFAULT 0,
  "PRIGWNO"    INTEGER     NOT NULL DEFAULT 0,
  "RUNSTATUS"    INTEGER     NOT NULL DEFAULT 0,
  "GWEIGHT"    INTEGER     NOT NULL DEFAULT 0,
  "RUNWEIGHT"    INTEGER     NOT NULL DEFAULT 0,
  "UPDTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_CLUSTATUS' AND INDNAME='IX_GWCLUS_TYPENO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_GWCLUS_TYPENO" ON "GW_CLUSTATUS"
 (GWTYPE ASC,GWNO ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_CLUDECISION') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE TABLE  "GW_CLUDECISION"
 ("ID"       INTEGER     NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1,  NO CYCLE, NO ORDER) CONSTRAINT GW_CLUDECISION_PK PRIMARY KEY,
  "GWTYPE"  INTEGER   NOT NULL DEFAULT 0,
  "GWNO"  INTEGER     NOT NULL DEFAULT 0,
  "RUNGWNO"    INTEGER     NOT NULL DEFAULT 0,
  "RUNUPDTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
   "APPLYGWNO"    INTEGER     NOT NULL DEFAULT 0,
   "APPLYSTATUS"    INTEGER     NOT NULL DEFAULT 0

 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX" ';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_CLUDECISION' AND INDNAME='IX_GWDECI_TYPENO') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE  INDEX "IX_GWDECI_TYPENO" ON "GW_CLUDECISION"
 (GWTYPE ASC,GWNO ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;

END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_DBMONITOR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE TABLE  "GW_DBMONITOR"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_DBMONITOR_PK PRIMARY KEY,
  "GWNO"  INTEGER   NOT NULL DEFAULT 0,
  "TESTSTRING" VARCHAR(256) NOT NULL DEFAULT '''',
  "UPDTIME" TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX" ';
	  END;
END IF;

END  &&



CREATE OR REPLACE  PROCEDURE "DELPROC"
 (IN "PROCNAME1" VARCHAR(30)
 )
BEGIN
DECLARE STR VARCHAR (256);
DECLARE STR1 VARCHAR (256);
SELECT PROCNAME INTO STR1 FROM SYSCAT.PROCEDURES WHERE  PROCNAME=PROCNAME1;
IF  STR1 IS NOT NULL THEN
  SET STR ='DROP PROCEDURE '||PROCNAME1;
  EXECUTE IMMEDIATE STR ;
END IF;
END  &&


CALL DELPROC('GW_CBASEPARA')   &&
CREATE OR REPLACE  PROCEDURE GW_CBASEPARA()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_BASEPARA') THEN
SET PISQL ='CREATE TABLE  "GW_BASEPARA" (
  "ID" INTEGER NOT NULL DEFAULT ''0'',
  "FUNNAME" VARCHAR(20)  NOT NULL  DEFAULT '''',
  "CMDTYPE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "ARGNAME" VARCHAR(50) NOT NULL DEFAULT '''',
  "ARGVALUELEN" INTEGER NOT NULL DEFAULT ''0'',
  "ARGDES" VARCHAR(50) NOT NULL DEFAULT '''',
  "ARGTYPE" SMALLINT NOT NULL DEFAULT ''1'',
  "CREATETIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODIFTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RESERVE" VARCHAR(64) NOT NULL DEFAULT ''''
)  DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_BASEPARA"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_BASEPARA"
ADD CONSTRAINT "GW_BASEPARA_PK" PRIMARY KEY("FUNNAME","CMDTYPE","ARGNAME")';
EXECUTE IMMEDIATE PISQL_1;
END IF;
END  &&

CALL GW_CBASEPARA()   &&
CALL DELPROC('GW_CBASEPARA')   &&

CALL DELPROC('GW_CPROTOMTCH')   &&
CREATE OR REPLACE  PROCEDURE GW_CPROTOMTCH()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_PROTOMTCH') THEN
SET PISQL ='CREATE TABLE "GW_PROTOMTCH" (
  "ID"  INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "ECID" INTEGER  NOT NULL  DEFAULT ''0'',
  "FUNTYPE" VARCHAR(30) NOT NULL DEFAULT '''',
  "FUNNAME" VARCHAR(20) NOT NULL DEFAULT '''',
  "CMDTYPE" SMALLINT NOT NULL DEFAULT ''1'',
  "CARGNAME" VARCHAR(50) NOT NULL DEFAULT '''',
  "MARGNAME"	VARCHAR(50) NOT NULL DEFAULT '''',
  "CARGTYPE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CARGVALUE" VARCHAR(64) NOT NULL DEFAULT '''',
  "BELONGTYPE" SMALLINT NOT NULL DEFAULT ''0'' ,
  "BELONG" VARCHAR(50) NOT NULL DEFAULT '''',
  "CREATETIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODIFTIME"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RESERVE" VARCHAR(64) NOT NULL DEFAULT ''''
) DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_PROTOMTCH"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_PROTOMTCH"
ADD CONSTRAINT "GW_PROTOMTCH_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE UNIQUE INDEX  "IX_PROTOMTCH_FFCCB"
  ON  "GW_PROTOMTCH"
 ("FUNTYPE","FUNNAME","CMDTYPE","CARGNAME","BELONG"
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&

CALL GW_CPROTOMTCH()  &&
CALL DELPROC('GW_CPROTOMTCH')  &&


CALL DELPROC('GW_CUSERPROPERTY')  &&
CREATE OR REPLACE  PROCEDURE GW_CUSERPROPERTY()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_USERPROPERTY') THEN
SET PISQL ='CREATE TABLE  "GW_USERPROPERTY" (
  "ID" INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
 "ECID" INTEGER  NOT NULL  DEFAULT ''0'',
  "USERID" VARCHAR(11) NOT NULL DEFAULT '''',
  "PWDENCODE" SMALLINT NOT NULL DEFAULT ''0'' ,
  "PWDENCODESTR"  VARCHAR(256) NOT NULL DEFAULT ''00000000'',
  "MSGCODE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "MSGENCODE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "PUSHMOFMT" SMALLINT NOT NULL DEFAULT ''2'' ,
  "PUSHRPTFMT" SMALLINT NOT NULL DEFAULT ''2'' ,
  "PUSHPWDENCODE" SMALLINT NOT NULL DEFAULT ''0'' ,
  "PUSHPWDENCODESTR" VARCHAR(256) NOT NULL DEFAULT ''00000000'',
  "PUSHMSGCODE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "PUSHMSGENCODE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "PUSHFAILCNT" SMALLINT NOT NULL DEFAULT ''3'' ,
  "PUSHSLIDEWND" SMALLINT NOT NULL DEFAULT ''5'' ,
  "PUSHMOMAXCNT" INTEGER NOT NULL DEFAULT ''100'',
  "PUSHRPTMAXCNT" INTEGER NOT NULL DEFAULT ''100'',
  "GETMOMAXCNT" INTEGER NOT NULL DEFAULT ''100'',
  "GETRPTMAXCNT" INTEGER NOT NULL DEFAULT ''100'',
  "RESERVE" VARCHAR(64) NOT NULL DEFAULT '''',
"CACERTNAME" VARCHAR(256) NOT NULL DEFAULT '''',
"VERIFYPEER" SMALLINT NOT NULL DEFAULT ''1'' ,
"VERIFYHOST" SMALLINT NOT NULL DEFAULT ''1''
)DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_USERPROPERTY"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_USERPROPERTY"
ADD CONSTRAINT "GW_USERPROPERTY_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&

CALL GW_CUSERPROPERTY()   &&
CALL DELPROC('GW_CUSERPROPERTY')   &&



CALL DELPROC('GW_CPUSHPROTOMTCH')   &&
CREATE OR REPLACE  PROCEDURE GW_CPUSHPROTOMTCH()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_PUSHPROTOMTCH') THEN
SET PISQL ='CREATE TABLE  "GW_PUSHPROTOMTCH" (
  "ID" INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "ECID" INTEGER  NOT NULL  DEFAULT ''0'',
  "USERID" VARCHAR(11) NOT NULL DEFAULT '''',
  "PUSHFLAG" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CMDTYPE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CARGNAME" VARCHAR(30) NOT NULL DEFAULT '''',
  "CARGTYPE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "MARGNAME" VARCHAR(30) NOT NULL DEFAULT '''',
  "CARGVALUE" VARCHAR(30) NOT NULL DEFAULT '''',
  "BELONGTYPE" SMALLINT NOT NULL DEFAULT ''0'' ,
  "BELONG" VARCHAR(30) NOT NULL DEFAULT ''mos'',
  "RESERVE" VARCHAR(64) NOT NULL DEFAULT ''''
) DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_PUSHPROTOMTCH"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_PUSHPROTOMTCH"
ADD CONSTRAINT "GW_PUSHPROTOMTCH_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&

CALL GW_CPUSHPROTOMTCH()   &&
CALL DELPROC('GW_CPUSHPROTOMTCH')   &&


CALL DELPROC('GW_CMULTI_ENTERP')   &&
CREATE OR REPLACE  PROCEDURE GW_CMULTI_ENTERP()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_MULTI_ENTERP') THEN
SET PISQL ='CREATE TABLE  "GW_MULTI_ENTERP" (
  "ECID" INTEGER  NOT NULL  ,
  "FUNTYPE" VARCHAR(30) NOT NULL DEFAULT '''',
  "RESPFMT" INTEGER  NOT NULL DEFAULT ''2'' ,
  "STATUS" SMALLINT NOT NULL DEFAULT ''1'' ,
  "BOOKCNT" SMALLINT NOT NULL DEFAULT ''0'' ,
  "MATCHCNT" SMALLINT NOT NULL DEFAULT ''0'' ,
  "CREATETM"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODIYTM"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "REQFMT" INTEGER  NOT NULL DEFAULT ''2''
) DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_MULTI_ENTERP"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_MULTI_ENTERP"
ADD CONSTRAINT "GW_MULTIENTERP_PK" PRIMARY KEY("ECID")';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&
CALL GW_CMULTI_ENTERP()   &&
CALL DELPROC('GW_CMULTI_ENTERP')   &&


CALL DELPROC('GW_CBASEPROTOCOL')   &&
CREATE OR REPLACE  PROCEDURE GW_CBASEPROTOCOL()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_BASEPROTOCOL') THEN
SET PISQL ='CREATE TABLE  "GW_BASEPROTOCOL" (
 "ID"  INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "ECID" INTEGER  NOT NULL  DEFAULT ''0'',
  "FUNTYPE" VARCHAR(30) NOT NULL DEFAULT '''',
  "FUNNAME" VARCHAR(20) NOT NULL DEFAULT '''',
  "CFUNNAME" VARCHAR(50) NOT NULL DEFAULT '''',
  "CMDTYPE" SMALLINT NOT NULL DEFAULT ''1'' ,
  "RETTYPE" SMALLINT NOT NULL DEFAULT ''2'' ,
  "STATUS" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CUST_INTFNAME" VARCHAR(64)  NOT NULL   DEFAULT '''',
  "FMTMSG" VARCHAR(3000)  NOT NULL   DEFAULT '''',
  "CREATETM"  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MODIYTM"   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_BASEPROTOCOL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_BASEPROTOCOL"
ADD CONSTRAINT "GW_BASEPROTOCOL_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE UNIQUE INDEX  "IDX_CFFC"
  ON  "GW_BASEPROTOCOL"
 ("ECID","FUNTYPE","FUNNAME","CMDTYPE"
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&
CALL GW_CBASEPROTOCOL()   &&
CALL DELPROC('GW_CBASEPROTOCOL')   &&


CALL DELPROC('GW_CPUSHRSPROTOCOL')   &&
CREATE OR REPLACE  PROCEDURE GW_CPUSHRSPROTOCOL()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_PUSHRSPROTOCOL') THEN
SET PISQL ='CREATE TABLE  "GW_PUSHRSPROTOCOL" (
 "ID" INTEGER   NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "ECID" INTEGER  NOT NULL  DEFAULT ''0'',
  "USERID" VARCHAR(11) NOT NULL DEFAULT '''',
  "RSPCMD" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CARGNAME" VARCHAR(50) NOT NULL DEFAULT '''',
  "RSPSTATUS" SMALLINT NOT NULL DEFAULT ''1'' ,
  "CRSPFMT" SMALLINT NOT NULL DEFAULT ''2'' ,
  "CARGVALUE" VARCHAR(128) NOT NULL DEFAULT ''''
)DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = ' ALTER TABLE "GW_PUSHRSPROTOCOL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_PUSHRSPROTOCOL"
ADD CONSTRAINT "GW_PUSHRSPROTOCOL_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE UNIQUE INDEX  "IDX_ERCR"
  ON  "GW_PUSHRSPROTOCOL"
 ("ECID","RSPCMD","CARGNAME","RSPSTATUS")
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&

CALL GW_CPUSHRSPROTOCOL()   &&
CALL DELPROC('GW_CPUSHRSPROTOCOL')   &&


CALL DELPROC('GW_GATECONNINFO')   &&
CREATE OR REPLACE  PROCEDURE GW_GATECONNINFO()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_GATECONNINFO') THEN
SET PISQL ='CREATE TABLE  GW_GATECONNINFO  (
  ID   INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
   PTID  INTEGER  NOT NULL  DEFAULT ''0'' ,
   GATEID  INTEGER NOT NULL DEFAULT ''0'',
   CONNTYPE  SMALLINT NOT NULL DEFAULT ''0'' ,
   PTACCID  VARCHAR(11) NOT NULL DEFAULT '''',
   IP  VARCHAR(32) NOT NULL DEFAULT '''',
   PORT  INTEGER NOT NULL DEFAULT ''0'',
   LINKCNT  INTEGER NOT NULL DEFAULT ''1'',
   SPEEDLIMIT  INTEGER NOT NULL DEFAULT ''1000'',
 LINKLEVEL  SMALLINT NOT NULL DEFAULT ''0'' ,
 LINKSTATUS  SMALLINT NOT NULL DEFAULT ''0'' ,
 PING  SMALLINT NOT NULL DEFAULT ''0'' ,
 MINLINKS  SMALLINT NOT NULL DEFAULT ''1'' ,
 KEEPCONN  SMALLINT NOT NULL DEFAULT ''1'' ,
 RECONNCNT  SMALLINT NOT NULL DEFAULT ''5'' ,
 RELOGINCNT  SMALLINT NOT NULL DEFAULT ''5'' ,
 SWITCHMAINIP  SMALLINT NOT NULL DEFAULT ''1'' ,
 TESTMETHOD  SMALLINT NOT NULL DEFAULT ''1'' ,
 TESTTIMES  INTEGER NOT NULL DEFAULT ''60'',
 ABNORMALONG  INTEGER NOT NULL DEFAULT ''300'',
 ABNORMALTMS  INTEGER NOT NULL DEFAULT ''10'',
 CREATETM  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
 UPDATETM   TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_GATECONNINFO"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_GATECONNINFO"
ADD CONSTRAINT "GW_GATECONNINFO_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE UNIQUE INDEX  "IDX_PIPPGC"
  ON  "GW_GATECONNINFO"
 (PTACCID , IP , PORT , PTID , GATEID , CONNTYPE)
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&

CALL GW_GATECONNINFO()   &&
CALL DELPROC('GW_GATECONNINFO')   &&

CALL DELPROC('GW_CTDCMD')   &&
CREATE OR REPLACE  PROCEDURE GW_CTDCMD()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_TDCMD') THEN
SET PISQL ='CREATE TABLE  "GW_TDCMD" (
  ID INTEGER NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  TD_CMD VARCHAR(64)  NOT NULL  DEFAULT ''TD'',
  TD_USERID VARCHAR(11) NOT NULL DEFAULT ''000000'',
  TD_SPNUMBER VARCHAR(21) NOT NULL DEFAULT '' '' ,
  TD_ECID INTEGER NOT NULL DEFAULT 0,
  TD_TIMES INTEGER NOT NULL DEFAULT 1,
  MATCHTYPE SMALLINT  NOT NULL DEFAULT 0,
  OPTYPE SMALLINT  NOT NULL DEFAULT 0,
  PB_USERID VARCHAR(11) NOT NULL DEFAULT ''000000'',
  PB_SPNUMBER VARCHAR(11) NOT NULL DEFAULT '' '',
  PB_SVRTYPE VARCHAR(64)  NOT NULL  DEFAULT '' '',
  PB_CROPCODE VARCHAR(64)  NOT NULL  DEFAULT '' '',
  STATUS SMALLINT  NOT NULL DEFAULT 0
)  DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_TDCMD"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_TDCMD"
ADD CONSTRAINT "GW_TDCMD_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE  INDEX  "IDX_CUSE"
  ON  "GW_TDCMD"
 ("TD_CMD","TD_USERID","TD_SPNUMBER","TD_ECID"
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&
CALL GW_CTDCMD()   &&
CALL DELPROC('GW_CTDCMD')   &&


CALL DELPROC('GW_CTDCMD_HIS')   &&
CREATE OR REPLACE  PROCEDURE GW_CTDCMD_HIS()
BEGIN
DECLARE PISQL VARCHAR(6000);
DECLARE PISQL_1 VARCHAR(256);
IF NOT EXISTS (SELECT * FROM SYSIBM.SYSTABLES WHERE TID <> 0 AND NAME = 'GW_TDCMD_HIS') THEN
SET PISQL ='CREATE TABLE  "GW_TDCMD_HIS" (
   ID INTEGER NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  TD_PHONE  BIGINT NOT NULL DEFAULT 0,
  TD_CMD VARCHAR(64)  NOT NULL  DEFAULT ''TD'',
  TD_USERID VARCHAR(11) NOT NULL DEFAULT ''000000'',
  TD_SPNUMBER VARCHAR(21) NOT NULL DEFAULT '' '' ,
  TD_ECID INTEGER NOT NULL DEFAULT 0,
  OPTYPE SMALLINT NOT NULL DEFAULT 0,
  MO_MSGID BIGINT NOT NULL DEFAULT 0,
  TD_TIME  TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
)  DATA CAPTURE NONE
 IN "TPACCMGR"';
EXECUTE IMMEDIATE PISQL;

SET PISQL_1 = 'ALTER TABLE "GW_TDCMD_HIS"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'ALTER TABLE  "GW_TDCMD_HIS"
ADD CONSTRAINT "GW_TDCMD_HIS_PK" PRIMARY KEY("ID")';
EXECUTE IMMEDIATE PISQL_1;

SET PISQL_1 = 'CREATE  INDEX  "IDX_PCUSE"
  ON  "GW_TDCMD_HIS"
 (TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
EXECUTE IMMEDIATE PISQL_1;

END IF;
END  &&
CALL GW_CTDCMD_HIS()   &&
CALL DELPROC('GW_CTDCMD_HIS')   &&


CREATE OR REPLACE  PROCEDURE "A_LOADUSRBIND"
	(
	IN PIUSERID VARCHAR(11),
  IN  PISPTYPE INTEGER --=1
  )
  SPECIFIC "A_LOADUSRBIND"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN

 IF PISPTYPE IS NULL THEN
 SET PISPTYPE=1;
 END IF;

 P1:BEGIN
 DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT /*CORP.ECID*/0 AS ECID,USR.UID/*TB1.UID*/ AS UID,USR.UID AS UIDEX,USR.RISELEVEL AS RISELEVEL,TB2.DESTUID AS DESTUID,
  USR.USERID AS USERID,USR.USERID/*USR.LOGINID*/ AS LOGINID,GT.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,GT.SPGATE AS SPGATE,GT.ID AS CHANNELNO,
  GT.CPNO AS CPNO,GT.SPISUNCM AS SPISUNCM,GT.FEEFLAG AS FEEFLAG,GT.ROUTEFLAG AS ROUTEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,
  GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,GT.MULTILEN2 AS MULTILEN2,GT.SENDTIMEBEGIN AS TIMESTART,
  GT.SENDTIMEEND AS TIMEEND,GT.GATESEQ AS GATESEQ,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE,GATE.GATEPRIVILEGE AS GATEPRIVILEGE,
  GATE.ENPREFIXLEN AS ENPREFIXLEN,
  GT.ENSIGNSTR AS ENSIGNSTR,GT.ENSIGNLEN AS ENSIGNLEN,GT.ENMAXWORDS AS ENMAXWORDS,GT.ENSINGLELEN AS ENSINGLELEN,GT.ENMULTILEN1 AS ENMULTILEN1,GT.ENMULTILEN2 AS ENMULTILEN2
  FROM GT_PORT_USED GT
 INNER JOIN USERDATA USR ON USR.USERID=UCASE(GT.USERID) AND LENGTH(RTRIM(USR.USERID)) <= 6
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE AND GATE.SPISUNCM=GT.SPISUNCM
  INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.SPGATE AS SPGATE,GATE2.SPISUNCM AS SPISUNCM FROM A_GWACCOUNT GWACC
         INNER JOIN A_GWSPBIND BIND ON BIND.PTACCUID=GWACC.PTACCUID
         INNER JOIN XT_GATE_QUEUE GATE2 ON GATE2.ID=BIND.GATEID WHERE GATE2.GATETYPE=PISPTYPE) TB2
         ON GT.SPGATE=TB2.SPGATE AND GT.SPISUNCM=TB2.SPISUNCM
  WHERE UCASE(GT.USERID)=UCASE(PIUSERID) AND USR.USERTYPE=0  AND USR.STATUS=0 AND GATE.STATUS=0 AND GT.STATUS=0
        AND USR.ACCOUNTTYPE=PISPTYPE
        AND GATE.GATETYPE=PISPTYPE
        AND GT.GATETYPE=PISPTYPE
        ORDER BY UID;
OPEN C_2;
END P1;
END  &&



CREATE OR REPLACE  PROCEDURE "A_LOADALLBIND" (
IN PISPTYPE INT--=1
)
  SPECIFIC "A_LOADALLBIND"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  P1:BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT /*CORP.ECID*/ 0 AS ECID,USR.UID,USR.UID AS UIDEX,USR.RISELEVEL AS RISELEVEL,TB2.DESTUID AS DESTUID,USR.USERID AS USERID,GT.ID AS CHANNELNO,
  USR.LOGINID AS LOGINID,GT.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,GT.SPGATE AS SPGATE,GT.CPNO AS CPNO,GT.SPISUNCM AS SPISUNCM,GT.FEEFLAG AS FEEFLAG,
  GT.ROUTEFLAG AS ROUTEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,
  GT.MULTILEN2 AS MULTILEN2,GT.SENDTIMEBEGIN AS TIMESTART,GT.SENDTIMEEND AS TIMEEND,GT.GATESEQ AS GATESEQ,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE,
  GATE.GATEPRIVILEGE AS GATEPRIVILEGE,GATE.ENPREFIXLEN AS ENPREFIXLEN,
  GT.ENSIGNSTR AS ENSIGNSTR,GT.ENSIGNLEN AS ENSIGNLEN,GT.ENMAXWORDS AS ENMAXWORDS,GT.ENSINGLELEN AS ENSINGLELEN,GT.ENMULTILEN1 AS ENMULTILEN1,GT.ENMULTILEN2 AS ENMULTILEN2
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON USR.USERID=UCASE(GT.USERID) AND LENGTH(RTRIM(USR.USERID)) <= 6
  --INNER JOIN KF_CORPBASE CORP ON UCASE(USR.CORPACCOUNT)=UCASE(CORP.CORPACCOUNT)
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE AND GATE.SPISUNCM=GT.SPISUNCM
 INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.SPGATE AS SPGATE,GATE2.SPISUNCM AS SPISUNCM FROM A_GWACCOUNT GWACC
         INNER JOIN A_GWSPBIND BIND ON BIND.PTACCUID=GWACC.PTACCUID
         INNER JOIN XT_GATE_QUEUE GATE2 ON GATE2.ID=BIND.GATEID WHERE GATE2.GATETYPE=PISPTYPE) TB2
         ON GT.SPGATE=TB2.SPGATE AND GT.SPISUNCM=TB2.SPISUNCM
  WHERE USR.USERTYPE=0 AND USR.STATUS=0 AND USR.ACCOUNTTYPE=PISPTYPE AND GATE.STATUS=0  AND GATE.GATETYPE=PISPTYPE AND GT.STATUS=0 AND GT.GATETYPE=PISPTYPE ORDER BY UID;
	OPEN C_2;
	END P1;
END  &&



CREATE OR REPLACE  PROCEDURE "A_GETSPRULE"
 (IN "PIPTACCID" VARCHAR(11),
  IN "PISPTYPE"  INTEGER --=1
 )
  SPECIFIC "A_GETSPRULE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS

  BEGIN
	DECLARE PIPTACCUID INTEGER DEFAULT 0;

	IF PISPTYPE IS NULL THEN
    SET PISPTYPE=1 ;
    END IF;

	SELECT  UID INTO PIPTACCUID FROM USERDATA
	WHERE USERID=UCASE(PIPTACCID) AND USERTYPE=1 AND STATUS=0 AND ACCOUNTTYPE = PISPTYPE;

	P1: BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT ID,SPGATE,STATUS,SPISUNCM,GATETYPE,PORTTYPE,GATENAME,SINGLELEN,SIGNTYPE,SIGNFIXLEN,PREFIXLEN,ENDSPLIT,SIGNDROPTYPE,
  SIGNSTR,RISELEVEL,SPEED,LONGSMS,MAXWORDS,SUBLEN,FEEFLAG,SIGNLEN,SPLITRULE,MULTILEN1,MULTILEN2,MAXLONGMSGSEQ,GATESEQ,EACHSIGN,GATEPRIVILEGE,
  ENSIGNSTR, ENSIGNLEN,ENPREFIXLEN, ENMAXWORDS,ENSINGLELEN, ENMULTILEN1,ENMULTILEN2,ESPLITMAXWD,ESPLITENMAXWD
  FROM XT_GATE_QUEUE WHERE ID IN(SELECT GATEID FROM A_GWSPBIND WHERE PTACCUID=PIPTACCUID) AND STATUS=0 AND GATETYPE=PISPTYPE ORDER BY GATESEQ ASC;
	OPEN RS1;
	END P1;
END  &&

--加载网优路由绑定表

CREATE OR REPLACE  PROCEDURE A_LOADGWROUTE(IN PISPTYPE INT)
SPECIFIC A_LOADGWROUTE
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
    SELECT 0 AS ECID,
TB2.DESTUID AS DESTUID,TB2.RISELEVEL AS RISELEVEL,TB2.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,TB2.SPGATE AS SPGATE,
TB2.FEEFLAG AS FEEFLAG,TB2.SIGNSTR AS SIGNSTR,TB2.SIGNLEN AS SIGNLEN,TB2.MAXWORDS AS MAXWORDS,70 AS SINGLELEN,
TB2.MULTILEN1 AS MULTILEN1,TB2.MULTILEN2 AS MULTILEN2,TB2.AREATYPE AS AREATYPE,
RT.ID AS CHANNELNO, RT.TYPE AS ROUTEFLAG,RT.UNICOM AS SPISUNCM,RT.AREA AS GATEAREA,RT.GATESEQ AS GATESEQ,
RT.SENDTIMEBEGIN AS TIMESTART,RT.SENDTIMEEND AS TIMEEND,GATE.GATEPRIVILEGE AS GATEPRIVILEGE,
GATE.ENSIGNSTR AS ENSIGNSTR,GATE.ENSIGNLEN AS ENSIGNLEN,GATE.ENPREFIXLEN AS ENPREFIXLEN,GATE.ENMAXWORDS AS ENMAXWORDS,GATE.ENSINGLELEN AS ENSINGLELEN,GATE.ENMULTILEN1 AS ENMULTILEN1,GATE.ENMULTILEN2 AS ENMULTILEN2
FROM A_GWROUTE RT
INNER JOIN XT_GATE_QUEUE GATE
           ON GATE.ID=RT.GATEID AND GATE.SPISUNCM=RT.UNICOM
INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.ID AS GATEID,GATE2.SPISUNCM AS SPISUNCM,GATE2.RISELEVEL,GATE2.PORTTYPE,
            GATE2.SPGATE,GATE2.FEEFLAG,GATE2.SIGNSTR,GATE2.SIGNLEN,GATE2.MAXWORDS,GATE2.MULTILEN1,GATE2.MULTILEN2,GATE2.AREATYPE
            FROM A_GWACCOUNT GWACC
            INNER JOIN A_GWSPBIND BIND
                       ON GWACC.PTACCUID=BIND.PTACCUID
            INNER JOIN XT_GATE_QUEUE GATE2
                       ON GATE2.ID=BIND.GATEID
            WHERE GATE2.GATETYPE=PISPTYPE)TB2
           ON TB2.GATEID=RT.GATEID AND TB2.SPISUNCM=RT.UNICOM
WHERE GATE.STATUS=0 AND RT.STATUS=0 AND GATE.GATETYPE=PISPTYPE;
OPEN RS1;
END  &&



CREATE OR REPLACE  PROCEDURE "S_RD_RPTWAITA"
 (IN "PIUSERUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "S_RD_RPTWAITA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,ECID,PTMSGID,USERID,SPNUMBER,SUBMITTIME,DONETIME,PHONE,ERRORCODE,USERMSGID,MODULEID,RECVTIME FROM RPT_WAIT_A '||
		'WHERE USERUID='||CAST(PIUSERUID AS CHAR(12))||' AND LOGINUID='||CAST(PILOGINUID AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&



CREATE OR REPLACE  PROCEDURE "S_RD_RPTWAITB"
 (IN "PIUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "S_RD_RPTWAITB"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,"UID",ORGUID,ECID,USERID,SUBMITTIME,DONETIME,PHONE,SPNUMBER,PTMSGID,ERRORCODE,USERMSGID,MODULEID,RECVTIME,SPMSGID FROM RPT_WAIT_B '||
		'WHERE UID='||CAST(PIUID AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&



CREATE OR REPLACE  PROCEDURE "S_WR_RPTWAITA"
 (IN "PIECID" INTEGER,
  IN "PIUSERUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP
 )
  SPECIFIC "S_WR_RPTWAITA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF PIUSERID='' THEN
		SELECT USERID,RTRIM(SPGATE)||RTRIM(CPNO) INTO PIUSERID,PISPNUMBER FROM MT_TASK WHERE PTMSGID=PIPTMSGID;
	END IF;

	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_A WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO RPT_WAIT_A(ECID,USERUID,LOGINUID,PTMSGID,USERID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERMSGID,MODULEID,RECVTIME)
		VALUES(PIECID,PIUSERUID,PILOGINUID,PIPTMSGID,PIUSERID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERMSGID,PIMODULEID,PIRECVTIME);
	END IF;
END  &&



CREATE OR REPLACE  PROCEDURE "S_WR_RPTWAITB"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIECID" INTEGER,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERID" VARCHAR(11),
  IN "PIORGUID" INTEGER,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP
 )
  SPECIFIC "S_WR_RPTWAITB"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_B(UID, PTMSGID, SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, USERID, ECID, ORGUID,USERMSGID,MODULEID,RECVTIME)
	   VALUES(PIUID, PIPTMSGID, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PIUSERID, PIECID, PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME);
	END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "A_LOADFORWARDBIND" ()
  SPECIFIC "A_LOADFORWARDBIND"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
    SELECT * FROM A_SMSFWDCONF;
	OPEN C_2;
END  &&

------------------------FUNCTION "REBIND_PACKAGE"
CREATE OR REPLACE  FUNCTION "REBIND_PACKAGE" ()
  RETURNS VARCHAR(6000)
  SPECIFIC "REBIND_PACKAGE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRSQL VARCHAR(6000);
	SET STRSQL = ' ';
    FOR REBIND_LOOP AS
	    SELECT 'REBIND PACKAGE '|| RTRIM(R.ROUTINESCHEMA) || '.' || 'P'||SUBSTR(CHAR(R.LIB_ID+10000000),2)
        ||'RESOLVE ANY; ' AS REBINDOPT FROM SYSCAT.ROUTINES R WHERE R.ROUTINETYPE = 'P' AND
        ((R.ORIGIN = 'Q' AND R.VALID != 'Y') OR
        EXISTS
        (SELECT 1 FROM SYSCAT.PACKAGES WHERE PKGSCHEMA = R.ROUTINESCHEMA AND PKGNAME = 'P'||
        SUBSTR(CHAR(R.LIB_ID+10000000),2) AND VALID !='Y') )
	DO
	    SET STRSQL = STRSQL || REBIND_LOOP.REBINDOPT;
	END FOR;
	RETURN STRSQL;
END  &&
-- END OF GENERATED SCRIPT FOR WINDYNIGHT-DB2-EMPSVR (DB2JHB)

-- START OF GENERATED SCRIPT FOR WINDYNIGHT-DB2-EMPSVR (DB2JHB)
--  JUN-24-2012 AT 17:28:51

--SET SCHEMA DB2JHB;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  FUNCTION "BUILDINSERTSQL"
 ("STRTABLE" VARCHAR(128),
  "FEILDS" VARCHAR(2048),
  "STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "BUILDINSERTSQL"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES;
    SET STRSQL = 'INSERT INTO '||STRTABLE ||'(';
    SET STRSQL = STRSQL || REPLACE(FEILDS,'#',',');
    SET STRSQL = STRSQL || ') VALUES(';
    WHILE LOCATE('#', STRVAL) <> 0 DO
      SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      SET STRSQL = STRSQL || '''' ||STRVALUE || ''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
      IF(LOCATE('#',STRVAL))=0 THEN
        SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '')||'#';
      END IF;
    END WHILE;
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)-1) ||',CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&

--SET SCHEMA DB2JHB;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";



CREATE OR REPLACE  FUNCTION "BUILDUPDATESQL"
 ("STRTABLE" VARCHAR(128),
  "FEILDS" VARCHAR(2048),
  "STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "BUILDUPDATESQL"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE FIELD VARCHAR(2048);
    DECLARE FIELDS1 VARCHAR(2048);
    DECLARE STRSQL VARCHAR(6000);
    DECLARE INDEXNO1 INTEGER;
    DECLARE INDEXNO2 INTEGER;
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    --STRVALUES1 := SUBSTR(STRVALUES1,2,LENGTH(STRVALUES1)-1);
    SET FIELDS1 = "FEILDS";
    SET FIELDS1 = FIELDS1 || '#';
    SET STRSQL = 'UPDATE '||STRTABLE|| ' SET ';
    SET INDEXNO1=LOCATE('#',FIELDS1);
    WHILE INDEXNO1 <> 0 DO
      SET INDEXNO2 = LOCATE('#',STRVAL);
      IF INDEXNO2 > 0 THEN
        SET STRVALUE = SUBSTR(STRVAL, 1, INDEXNO2 - 1);
        SET STRVAL = SUBSTR(STRVAL, INDEXNO2+1, LENGTH(STRVAL));
      ELSE
        SET STRVALUE = '';
      END IF;
      SET FIELD = SUBSTR(FIELDS1, 1, INDEXNO1-1);
      SET FIELDS1 = SUBSTR(FIELDS1, INDEXNO1+1, LENGTH(FIELDS1));
      SET INDEXNO1=LOCATE(FIELDS1,'#');
      IF INDEXNO2 IS NULL THEN
        SET STRSQL = STRSQL || FIELD || '=CURRENT TIMESTAMP,';
      ELSE
        IF STRVALUE IS NULL THEN
          --STRSQL := STRSQL ||FIELD || '=''' ||STRVALUE ||''',';
           SET STRSQL = STRSQL ||FIELD || '=' || 'VALUE(''' ||STRVALUE ||
            ''','' ''),';
        ELSE
          SET STRSQL = STRSQL ||FIELD || '=' || '''' ||STRVALUE || ''',';
        END IF;
      END IF;
    END WHILE;
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)-1) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&

--SET SCHEMA DB2JHB;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  FUNCTION "GETARRAYLENGTH"
 ("STR" VARCHAR(8000),
  "SPLIT" VARCHAR(10)
 )
  RETURNS BIGINT
  SPECIFIC "GETARRAYLENGTH"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE NLOCATION INTEGER;
    DECLARE NSTART INTEGER;
    DECLARE NLENGTH INTEGER;
    DECLARE STR1 VARCHAR(8000);
    SET STR1=LTRIM(RTRIM(STR));
    SET NLOCATION=LOCATE(SPLIT,STR);
    SET NLENGTH=1;
    WHILE NLOCATION<>0 DO
      SET NSTART=NLOCATION+1;
      SET NLOCATION=LOCATE(SPLIT,STR,NSTART);
      SET NLENGTH=NLOCATION+1;
    END WHILE;
    RETURN NLENGTH;
  END  &&

--SET SCHEMA DB2JHB;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";


CREATE OR REPLACE  FUNCTION "GETARRAYSTROFINDEX"
 ("STR" VARCHAR(8000),
  "STRSPLIT" VARCHAR(10),
  "INDEXNO" INTEGER
 )
  RETURNS VARCHAR(1024)
  SPECIFIC "GETARRAYSTROFINDEX"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE NLOCATION INTEGER;
    DECLARE NSTART INTEGER;
    DECLARE NNEXT INTEGER;
    DECLARE NSEED INTEGER;
    DECLARE STR1 VARCHAR(8000);
    DECLARE STRSPLIT1 VARCHAR(10);
    SET STR1=STR;
    SET STRSPLIT1=STRSPLIT;
    SET STR1=LTRIM(RTRIM(STR1));
    SET NSTART=1;
    SET NNEXT=1;
    SET NSEED=LENGTH(STRSPLIT1);
    SET NLOCATION=LOCATE(STRSPLIT1,STR1);
      --CHARINDEX(@SPLIT,@STR)
    WHILE NLOCATION<>0
      AND INDEXNO>NNEXT DO
      SET NSTART=NLOCATION+NSEED;
      -- SET STR1=SUBSTR(STR1,NSTART+1,LENGTH(STR1)-NSTART);
      SET NLOCATION=LOCATE(STRSPLIT,STR1,NSTART);
      --CHARINDEX(@SPLIT,@STR,@START)
      SET NNEXT=NNEXT+1;
    END WHILE;
    IF NLOCATION =0 THEN
      SET NLOCATION=LENGTH(STR1)+1;
    END IF;

      --这儿存在两种情况：1、字符串不存在分隔符号 2、字符串中存在分隔符号，跳出WHILE循环后，@LOCATION为0，那默认为字符串后边有一个分隔符号。
    RETURN SUBSTR(STR,NSTART,NLOCATION-NSTART);
  END  &&

--SET SCHEMA DB2JHB;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

   CREATE OR REPLACE  FUNCTION "SUBSTRINGPRIKEY"
 ("INPSTR" VARCHAR(2048),
  "INDEXNO" INTEGER
 )
  RETURNS VARCHAR(2048)
  SPECIFIC "SUBSTRINGPRIKEY"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    --DECLARE STR VARCHAR(2048);
    DECLARE STRS VARCHAR(2048);
	DECLARE STRVAL VARCHAR(2048);
    DECLARE FLAGINDEX INTEGER;
    DECLARE FLAGINDEX1 INTEGER;
    SET FLAGINDEX1=INDEXNO;
    SET STRVAL=INPSTR;
    WHILE(FLAGINDEX1>0) DO
      SET FLAGINDEX=LOCATE('#',STRVAL);
      SET STRS=SUBSTR(STRVAL,1,LOCATE('#',STRVAL)-1) ;
	  SET STRVAL=INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
      --SET STRS=SUBSTR(STRS,FLAGINDEX+1,LENGTH(STRS));
      SET FLAGINDEX1=FLAGINDEX1-1;
    END WHILE;
    RETURN STRS;
  END  &&


---取十进制转换二进制后右边第二位的值
CREATE OR REPLACE  FUNCTION "NUMBER_TO_BIT"("V_NUM" INTEGER)
RETURNS VARCHAR(16)
SPECIFIC "NUMBER_TO_BIT"
BEGIN ATOMIC
DECLARE V_RTN VARCHAR(16);--注意返回列长度
DECLARE V_N1  INTEGER;
DECLARE V_N2  INTEGER;
SET V_N1 = V_NUM;
IF (V_N1=0 OR V_N1=1)THEN
RETURN '0';
END IF;
WHILE(V_N1<>0) DO
SET V_N2 = MOD(V_N1, 2);
SET V_N1  = ABS(V_N1 / 2);
SET V_RTN = RTRIM(CHAR(V_N2 ))|| COALESCE(V_RTN,'');
END WHILE;
SET V_RTN = COALESCE(SUBSTR(V_RTN,LENGTH(V_RTN)-1,1),'0');
RETURN V_RTN;
END  &&

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETALLUSRINFO" (
IN PISPTYPE INTEGER --=1
)
  SPECIFIC "A_GETALLUSRINFO"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;
  P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
	SELECT COALESCE(B.UID,A.UID) AS  SVRID,A.UID,A.USERID,A.USERTYPE,A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,
	A.STAFFNAME AS CORPNAME,A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,
	A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE
	FROM USERDATA A LEFT JOIN (SELECT UID,USERID FROM USERDATA WHERE NUMBER_TO_BIT(USERPRIVILEGE) = '1' AND ACCOUNTTYPE=PISPTYPE) B
	ON (UCASE(A.LOGINID) = UCASE(B.USERID)) OR B.USERID IS NULL
	WHERE A.STATUS=0 AND A.USERTYPE=0 AND A.ACCOUNTTYPE=PISPTYPE;

	OPEN RS1;
	END P1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETCHANNELMAP" ( )
  SPECIFIC "A_GETCHANNELMAP"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT SPNUMBER,CPNO FROM A_CHANNELMAP;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETCMDQUE"
 (IN "PIGWNO" INTEGER
 )
  SPECIFIC "A_GETCMDQUE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
	SELECT ID,GWNO,GWTYPE,CMDTYPE,DEALSTATUS,CMDPARAM,RESULTCODE
	FROM A_CMDQUE WHERE GWNO=PIGWNO AND DEALSTATUS=1;

	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETENDCHBINDB"
 (IN "PIUSERID" VARCHAR(11),
  IN PISPTYPE INTEGER --=1
 )
  SPECIFIC "A_GETENDCHBINDB"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE IPTACCUID INTEGER DEFAULT 0;

	IF PISPTYPE IS NULL THEN
    SET PISPTYPE=1;
    END IF;

	SELECT  UID INTO IPTACCUID FROM USERDATA WHERE USERID=UCASE(PIUSERID) AND USERTYPE=1 AND STATUS=0 AND ACCOUNTTYPE=PISPTYPE ;
	P1: BEGIN
		DECLARE RS1 CURSOR WITH RETURN FOR
		SELECT 0 AS ECID,PIUSERID AS USERID, 0 AS PORTTYPE,XTGATE.GATETYPE AS GATETYPE,XTGATE.SPGATE AS SPGATE,XTGATE.SPISUNCM AS SPISUNCM,
		XTGATE.FEEFLAG AS FEEFLAG,XTGATE.GATEAREA AS GATEAREA,XTGATE.AREATYPE AS AREATYPE,XTGATE.GATESEQ AS GATESEQ,
		XTGATE.ENSIGNSTR AS ENSIGNSTR,XTGATE.ENSIGNLEN AS ENSIGNLEN,XTGATE.ENPREFIXLEN AS ENPREFIXLEN,XTGATE.ENMAXWORDS AS ENMAXWORDS,XTGATE.ENSINGLELEN AS ENSINGLELEN,XTGATE.ENMULTILEN1 AS ENMULTILEN1,XTGATE.ENMULTILEN2 AS ENMULTILEN2
		FROM XT_GATE_QUEUE XTGATE
		INNER JOIN A_GWSPBIND GWBIND ON XTGATE.ID=GWBIND.GATEID AND GWBIND.PTACCUID=IPTACCUID
		WHERE XTGATE.STATUS=0 AND XTGATE.GATETYPE=PISPTYPE;
		OPEN RS1;
	END P1;

END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETGWACC"
 (IN "PIGWNO" INTEGER,
  IN "PISPTYPE"  INTEGER --=1
 )
  SPECIFIC "A_GETGWACC"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;
  P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT GWACC.GWNO AS GWNO,GWACC.PTACCUID AS PTACCUID,USR.USERID AS PTACCID,USR.USERPASSWORD AS PTACCPWD,
  	GWACC.SPACCID AS SPACCID,GWACC.SPACCPWD AS SPACCPWD,GWACC.SPID AS SPID,GWACC.SERVICETYPE AS SERVICETYPE,
    GWACC.FEEUSERTYPE AS FEEUSERTYPE,GWACC.SPIP AS SPIP,GWACC.SPPORT AS SPPORT,GWACC.SPEEDLIMIT AS SPEEDLIMIT,
    GWACC.PROTOCOLCODE AS PROTOCOLCODE,GWACC.PROTOCOLPARAM AS PROTOCOLPARAM,GWACC.PTACCNAME AS PTACCNAME,
    GWACC.PTIP AS PTIP,GWACC.PTPORT AS PTPORT FROM A_GWACCOUNT GWACC
    INNER JOIN USERDATA USR ON PTACCUID=USR.UID WHERE GWACC.GWNO=PIGWNO AND USR.ACCOUNTTYPE=PISPTYPE;
	OPEN RS1;
	END P1;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_A_GETGWACCV1"
 (IN "PIGWNO" INTEGER,
  IN "PISPTYPE"  INTEGER --=1
 )
  SPECIFIC "GW_A_GETGWACCV1"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;
  P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT GWACC.GWNO AS GWNO,GWACC.PTACCUID AS PTACCUID,USR.USERID AS PTACCID,USR.USERPASSWORD AS PTACCPWD,
  	GWACC.SPACCID AS SPACCID,GWACC.SPACCPWD AS SPACCPWD,GWACC.SPID AS SPID,GWACC.SERVICETYPE AS SERVICETYPE,
    GWACC.FEEUSERTYPE AS FEEUSERTYPE,GWACC.SPIP AS SPIP,GWACC.SPPORT AS SPPORT,GWACC.SPEEDLIMIT AS SPEEDLIMIT,
    GWACC.PROTOCOLCODE AS PROTOCOLCODE,GWACC.PROTOCOLPARAM AS PROTOCOLPARAM,GWACC.PTACCNAME AS PTACCNAME,
    GWACC.PTIP AS PTIP,GWACC.PTPORT AS PTPORT,GWACC.PTNODE FROM A_GWACCOUNT GWACC
    INNER JOIN USERDATA USR ON PTACCUID=USR.UID WHERE GWACC.GWNO=(SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWNO=PIGWNO) AND USR.ACCOUNTTYPE=PISPTYPE;
	OPEN RS1;
	END P1;
END  &&
--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETGWCFG"
 (IN "PIGWNO" INTEGER
 )
  SPECIFIC "A_GETGWCFG"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT * FROM A_GWPARAMVALUE WHERE GWNO=PIGWNO;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETKFPARAMS" ( )
  SPECIFIC "A_GETKFPARAMS"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT PARACODE,PARAVAL1,PARAVAL2 FROM KF_PARAMS;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETPBSVRTYPE" ( )
  SPECIFIC "A_GETPBSVRTYPE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT SPISUNCM,SERVICENO,SERVICEINFO FROM PB_SERVICETYPE;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETPRECHBINDA"
 (IN "PIUSERID" VARCHAR(11),
  IN PISPTYPE INTEGER --=1
 )
  SPECIFIC "A_GETPRECHBINDA"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PISPTYPE IS NULL THEN
  SET PISPTYPE =1;
  END IF;
  P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT GT.PORTTYPE AS PORTTYPE,GT.SPGATE AS SPGATE,GT.CPNO AS CPNO,
  GT.FEEFLAG AS FEEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,GT.ROUTEFLAG AS ROUTEFLAG,
  GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,
  GT.MULTILEN2 AS MULTILEN2,GT.SPISUNCM AS SPISUNCM,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE
  ,GATE.ENPREFIXLEN AS ENPREFIXLEN,
  GT.ENSIGNSTR AS ENSIGNSTR,GT.ENSIGNLEN AS ENSIGNLEN,GT.ENMAXWORDS AS ENMAXWORDS,GT.ENSINGLELEN AS ENSINGLELEN,GT.ENMULTILEN1 AS ENMULTILEN1,GT.ENMULTILEN2 AS ENMULTILEN2
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON USR.USERID=UCASE(GT.USERID)
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE
  WHERE UCASE(GT.USERID)=UCASE(PIUSERID) AND USR.USERTYPE=0 AND GATE.STATUS=0 AND GT.STATUS=0
  AND GT.GATETYPE=PISPTYPE
  AND USR.ACCOUNTTYPE=PISPTYPE
  AND GATE.GATETYPE=PISPTYPE;
	OPEN RS1;
 END P1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETURLBIND"
(
	IN PIUID INTEGER,--=0,
    IN PISPTYPE INTEGER--=1
	)
SPECIFIC "A_GETURLBIND"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
 IF PISPTYPE IS NULL THEN
 SET PISPTYPE=1;
 END IF;

 IF PIUID IS NULL THEN
 SET PIUID=0;
 END IF;

	IF PIUID=0 THEN
	P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
		SELECT UID,USERID,USERPASSWORD AS PWD,MTURL,
		CASE WHEN(VALUE(MOURL,'')<>'' AND TRANSMOTYPE=2) THEN MOURL ELSE '' END AS MOURL,
		CASE WHEN(VALUE(RPTURL,'')<>'' AND TRANSRPTYPE=2) THEN RPTURL ELSE '' END AS RPTURL
		FROM USERDATA
		WHERE USERTYPE=0 AND STATUS=0
		AND ((VALUE(MOURL,'')<>'' AND TRANSMOTYPE=2) OR (VALUE(RPTURL,'')<>'' AND TRANSRPTYPE=2))
		AND ACCOUNTTYPE=PISPTYPE ORDER BY UID;
		OPEN RS1;
	END P1;
	ELSE
	P2:BEGIN
	DECLARE RS2 CURSOR WITH RETURN FOR
		SELECT UID,USERID,USERPASSWORD AS PWD,MTURL,
		CASE WHEN(VALUE(MOURL,'')<>'' AND TRANSMOTYPE=2) THEN MOURL ELSE '' END AS MOURL,
		CASE WHEN(VALUE(RPTURL,'')<>'' AND TRANSRPTYPE=2) THEN RPTURL ELSE '' END AS RPTURL
		FROM USERDATA
		WHERE UID=PIUID AND USERTYPE=0 AND STATUS=0
		AND ((VALUE(MOURL,'')<>'' AND TRANSMOTYPE=2) OR (VALUE(RPTURL,'')<>'' AND TRANSRPTYPE=2))
		AND ACCOUNTTYPE=PISPTYPE ORDER BY UID;
	OPEN RS2;
	END P2;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETUSRFEE"
 (IN "PUSERID" VARCHAR(11),
  IN "PUID" INTEGER
 )
  SPECIFIC "A_GETUSRFEE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT UID,SENDNUM,USERID FROM USERFEE WHERE USERID=UCASE(PUSERID) OR UID=PUID;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETUSRINFO"
( IN PIUSERID VARCHAR(11),
  IN PISPTYPE INTEGER--=1
)
SPECIFIC "A_GETUSRINFO"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
IF PISPTYPE IS NULL THEN
SET PISPTYPE = 1;
END IF;
P1:BEGIN
 DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT COALESCE(B.UID,A.UID) AS  SVRID, A.UID,A.USERID,A.USERTYPE,A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,A.STAFFNAME AS CORPNAME,
	A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.ACCOUNTTYPE,
	A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE
	FROM USERDATA A LEFT JOIN (SELECT UID,USERID FROM USERDATA WHERE NUMBER_TO_BIT(USERPRIVILEGE) = '1'
	AND ACCOUNTTYPE=PISPTYPE AND UCASE(USERID)=UCASE(PIUSERID)) B
	ON (UCASE(A.LOGINID) = UCASE(B.USERID)) OR B.USERID IS NULL
	WHERE UCASE(A.USERID)=UCASE(PIUSERID) AND A.STATUS=0 AND A.ACCOUNTTYPE=PISPTYPE FETCH FIRST 1 ROW ONLY;
 OPEN C_2;
END P1;
END  &&



--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_GETUSRUID"
 (IN "PIUSERID" VARCHAR(11)
 )
  SPECIFIC "A_GETUSRUID"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
		SELECT UID FROM USERDATA WHERE USERID=UCASE(PIUSERID)  ;
	OPEN C_2;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_LOADFEEINFOA" ( )
  SPECIFIC "A_LOADFEEINFOA"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT UID,USERID,SENDNUM FROM USERFEE ORDER BY UID;
	OPEN C_2;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";


CREATE OR REPLACE  PROCEDURE  A_LOADKEYWORDS
 (IN PIID INTEGER
 )
  SPECIFIC  A_LOADKEYWORDS
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  DECLARE RS1 CURSOR WITH RETURN FOR
  SELECT ID,OPTTYPE,KEYWORD,0 AS KEYTYPE,0 AS KEYLEVEL FROM KEYWORD_BLACK WHERE ID>PIID AND KEYWORD<>'';
  OPEN RS1;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "A_LOADMTROUTE" (
IN PISPTYPE INTEGER --=1
 )
  SPECIFIC "A_LOADMTROUTE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;

  P1:BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT USRSRC.UID AS SRCUID,USRDEST.UID AS DESTUID,COALESCE(GTDEST.FEEFLAG,1) AS FEEFLAG,
	ROUTE.EXNOHOLD AS EXNOHOLD,ROUTE.EXPIREDTM AS EXPIREDTM,/*USR3.ENDUID AS ENDUID,*/ ROUTE.SRCUSERID AS SRCUSERID,
	ROUTE.DESTUSERID AS DESTUSERID,ROUTE.ROUTETYPE AS ROUTETYPE,GTSRC.SPISUNCM AS GATETYPE,
	GTSRC.SPGATE AS SRCSPGATE,COALESCE(GTDEST.SPGATE,'') AS DESTSPGATE,
	COALESCE(LTRIM(RTRIM(GTSRC.SPGATE))||LTRIM(RTRIM(GTSRC.CPNO)),'') AS SRCSPNUMBER,
	COALESCE(LTRIM(RTRIM(GTDEST.SPGATE))||LTRIM(RTRIM(GTDEST.CPNO)),'') AS DESTSPNUMBER,
	COALESCE(LTRIM(RTRIM(ROUTE.PARAMS)),'') AS PARAMS,GTSRC.ID AS SRCCHANNELNO,GTDEST.ID AS DESTCHANNELNO
	,GTSRC.ENSIGNSTR AS ENSIGNSTR,GTSRC.ENSIGNLEN AS ENSIGNLEN,GTSRC.ENMAXWORDS AS ENMAXWORDS,GTSRC.ENSINGLELEN AS ENSINGLELEN,GTSRC.ENMULTILEN1 AS ENMULTILEN1,GTSRC.ENMULTILEN2 AS ENMULTILEN2,GATEQUESRC.ENPREFIXLEN AS ENPREFIXLEN
	FROM MT_ROUTETABLE ROUTE
	INNER JOIN USERDATA USRSRC ON USRSRC.USERID=UCASE(ROUTE.SRCUSERID)
	INNER JOIN USERDATA USRDEST ON USRDEST.USERID=UCASE(ROUTE.DESTUSERID)
	INNER JOIN GT_PORT_USED GTSRC ON ROUTE.SRCBINDID=GTSRC.ID AND GTSRC.STATUS=0
	INNER JOIN GT_PORT_USED GTDEST ON ROUTE.DESTBINDID=GTDEST.ID AND GTDEST.STATUS=0
	INNER JOIN XT_GATE_QUEUE GATEQUESRC ON GTSRC.SPGATE=GATEQUESRC.SPGATE AND GTSRC.SPISUNCM=GATEQUESRC.SPISUNCM
	INNER JOIN XT_GATE_QUEUE GATEQUEDEST ON GTDEST.SPGATE=GATEQUEDEST.SPGATE AND GTDEST.SPISUNCM=GATEQUEDEST.SPISUNCM
	WHERE GATEQUESRC.STATUS=0 AND GATEQUEDEST.STATUS=0
		AND  USRSRC.ACCOUNTTYPE=PISPTYPE
		AND  USRDEST.ACCOUNTTYPE=PISPTYPE
		AND  GTSRC.GATETYPE=PISPTYPE
		AND  GTDEST.GATETYPE=PISPTYPE
		AND  GATEQUESRC.GATETYPE=PISPTYPE
		AND  GATEQUEDEST.GATETYPE=PISPTYPE
		 ORDER BY ROUTETYPE;
	OPEN C_2;
	END P1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_RD_PROINFO" ( )
  SPECIFIC "A_RD_PROINFO"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE C_2 CURSOR WITH RETURN FOR
	SELECT  * FROM A_PROINFO FETCH FIRST 1 ROW ONLY;
	OPEN C_2;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_SYNCUSRFEEA"
 (IN "PIUID" INTEGER
 )
  SPECIFIC "A_SYNCUSRFEEA"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF PIUID > 0 THEN
	P1: BEGIN
		DECLARE C_2 CURSOR WITH RETURN FOR
		SELECT SENDNUM FROM USERFEE WHERE UID = PIUID;
		OPEN C_2;
	END P1;
	ELSE
	P2: BEGIN
		DECLARE C_2 CURSOR WITH RETURN FOR
		SELECT 0 AS SENDNUM FROM SYSIBM.SYSDUMMY1;
		OPEN C_2;
	END P2;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_SYNCUSRFEEB"
 (IN "PIUID" INTEGER,
  IN "PILASTDBREMAINED" INTEGER,
  IN "PIREMAINED" INTEGER,
  IN "PIPREPAYUSED" INTEGER,
  IN "PIPOSTPAYUSED" INTEGER
 )
  SPECIFIC "A_SYNCUSRFEEB"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF PIUID>0 THEN
		IF PIPREPAYUSED <>0 OR PIPOSTPAYUSED <>0 THEN
			UPDATE USERFEE SET SENDNUM=SENDNUM-PIPREPAYUSED,SENDEDNUM=SENDEDNUM+PIPREPAYUSED,POSTPAYUSED=POSTPAYUSED+PIPOSTPAYUSED WHERE UID = PIUID;
		END IF;
		P2:BEGIN
			DECLARE C_2 CURSOR WITH RETURN FOR
				SELECT SENDNUM AS SENDNUM  FROM USERFEE WHERE UID=PIUID;
			OPEN C_2;
		END P2;
	ELSE
		P3:BEGIN
			DECLARE C_2 CURSOR WITH RETURN FOR
				SELECT 0 AS SENDNUM  FROM SYSIBM.SYSDUMMY1;
			OPEN C_2;
		END P3;
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_SYNCUSRFEEBV1"
 (IN "PIUID" INTEGER,
  IN "PILASTDBREMAINED" INTEGER,
  IN "PIREMAINED" INTEGER,
  IN "PIPREPAYUSED" INTEGER,
  IN "PIPOSTPAYUSED" BIGINT
 )
  SPECIFIC "GW_SYNCUSRFEEBV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF PIUID>0 THEN
		IF PIPREPAYUSED <>0 OR PIPOSTPAYUSED <>0 THEN
			UPDATE USERFEE SET SENDNUM=SENDNUM-PIPREPAYUSED,SENDEDNUM=SENDEDNUM+PIPREPAYUSED,POSTPAYUSED=POSTPAYUSED+PIPOSTPAYUSED WHERE UID = PIUID;
		END IF;
		P2:BEGIN
			DECLARE C_2 CURSOR WITH RETURN FOR
				SELECT SENDNUM AS SENDNUM  FROM USERFEE WHERE UID=PIUID;
			OPEN C_2;
		END P2;
	ELSE
		P3:BEGIN
			DECLARE C_2 CURSOR WITH RETURN FOR
				SELECT 0 AS SENDNUM  FROM SYSIBM.SYSDUMMY1;
			OPEN C_2;
		END P3;
	END IF;
END  &&
--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_UPDCMDQUE"
 (IN "PIID" INTEGER,
  IN "PIDEALSTATUS" INTEGER,
  IN "PIRESULTCODE" VARCHAR(32)
 )
  SPECIFIC "A_UPDCMDQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PIDEALSTATUS=2 THEN
    UPDATE A_CMDQUE SET DEALSTATUS=2 WHERE ID=PIID AND DEALSTATUS=1;
  ELSEIF PIDEALSTATUS=1 THEN
    UPDATE A_CMDQUE SET DEALSTATUS=1 WHERE ID=PIID AND DEALSTATUS=2;
  ELSEIF PIDEALSTATUS=0 THEN
		INSERT INTO A_CMDQUE_HIS (ID,GWNO,GWTYPE,CMDTYPE,CMDINFO,CMDPARAM,DEALSTATUS,RESULTCODE,REQTIME)
		SELECT ID,GWNO,GWTYPE,CMDTYPE,CMDINFO,CMDPARAM,0 AS DEALSTATUS,PIRESULTCODE AS RESULTCODE,REQTIME
		FROM A_CMDQUE WHERE ID=PIID;
		DELETE FROM A_CMDQUE WHERE ID=PIID;
		DELETE FROM A_CMDQUE_HIS WHERE DONETIME <(CURRENT TIMESTAMP - 60 DAYS);
	END IF;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "A_UPDNUMSECTION"
 (IN "PINUMSECTION_IN" VARCHAR(2048)
 )
  SPECIFIC "A_UPDNUMSECTION"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
    DECLARE PINUM0  VARCHAR(2048);
	DECLARE PINUM1  VARCHAR(2048); --
	DECLARE PINUM21 VARCHAR(2048); --
	DECLARE PITMP1  VARCHAR(2048); --
	DECLARE PITMP2  VARCHAR(2048); --
	DECLARE PINUMSECTION VARCHAR(2048);
	DECLARE PISPLITSTR VARCHAR(8) DEFAULT ';'; --
	DECLARE PILOCATION INT DEFAULT 0; --
	DECLARE PISTART    INT DEFAULT 0; --
	DECLARE PITMPPOS   INT; --
	DECLARE PICOUNT    INT; --
	DECLARE PILEN      INT; --
	DECLARE PITMPLEN   INT; --

	SET PINUMSECTION = PISPLITSTR||PINUMSECTION_IN||PISPLITSTR;
	SET PILEN      = LENGTH(PINUMSECTION);
    SET PILOCATION = LOCATE(PISPLITSTR,PINUMSECTION);

	WHILE PILOCATION <> 0 DO
		SET PISTART = PILOCATION;
		SET PILOCATION = LOCATE(PISPLITSTR,PINUMSECTION,PISTART+1);
		IF PILOCATION > 0 THEN
			SET PITMP1 = SUBSTR(PINUMSECTION,PISTART+1,PILOCATION-PISTART-1);
			IF PITMP1 <> '' THEN
				SET PITMPLEN = LENGTH(PITMP1);
				SET PITMPPOS = LOCATE(',',PITMP1);
				IF PITMPPOS > 0 THEN
					SET PITMP2 = SUBSTR(PITMP1,1,PITMPPOS-1);
					IF PITMP2 = '0' THEN
						SET PINUM0 = SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
					ELSEIF PITMP2 = '1' THEN
						SET PINUM1 = SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
					ELSEIF PITMP2 = '21' THEN
						SET PINUM21 = SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
					END IF;
				END IF;
			END IF;
		END IF;
	END WHILE;

	--
	IF PINUM0 IS NOT NULL THEN
		IF EXISTS(SELECT *  FROM PB_SERVICETYPE WHERE SPISUNCM=0) THEN
			UPDATE PB_SERVICETYPE SET SERVICENO = PINUM0 WHERE SPISUNCM=0;
		ELSE
			INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (0,PINUM0,'移动号段');
		END IF;
	END IF;

	--
	IF PINUM1 IS NOT NULL THEN
		IF EXISTS(SELECT *  FROM PB_SERVICETYPE WHERE SPISUNCM=1) THEN
			UPDATE PB_SERVICETYPE SET SERVICENO = PINUM1 WHERE SPISUNCM=1;
		ELSE
			INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (1,PINUM1,'联通号段');
		END IF;
	END IF;

	--
	IF PINUM21 IS NOT NULL THEN
		IF EXISTS(SELECT *  FROM PB_SERVICETYPE WHERE SPISUNCM=21) THEN
			UPDATE PB_SERVICETYPE SET SERVICENO = PINUM21 WHERE SPISUNCM=21;
		ELSE
			INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (21,PINUM21,'电信C网号段');
		END IF;
	END IF;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE PROCEDURE H_PROCESSINGSTATUS
 (IN "CUSEID" INTEGER,
  IN "CUR" BIGINT,
  IN "MAXI" BIGINT,
  IN "COUNTS" INTEGER,
  IN "DISTRACTS" INTEGER,
  IN "DELETES" INTEGER
 )
  SPECIFIC H_PROCESSINGSTATUS
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	--SET NOCOUNT ON

	IF NOT EXISTS (SELECT USEID FROM PROCESSINGSTATUS WHERE USEID=CUSEID) THEN
		INSERT INTO PROCESSINGSTATUS(USEID,CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS ,DELETESTATUS)
                VALUES(CUSEID,CUR,MAXI,COUNTS,DISTRACTS,DELETES);
    ELSE
		UPDATE PROCESSINGSTATUS SET CURRINDEX=CUR, MAXINDEX=MAXI,COUNTSTATUS=COUNTS,DISTRACTSTATUS=DISTRACTS ,DELETESTATUS=DELETES
                WHERE USEID=CUSEID ;
	END IF;
END  &&
--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "INSERTMTREPORT_SP"
 (IN "PIUSERID" CHARACTER(11),
  IN "PIRPTSTR" VARCHAR(64)
 )
  SPECIFIC "INSERTMTREPORT_SP"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PIIYMD INT;
	DECLARE PISPGATE VARCHAR(21);
	DECLARE PISPISUNCM INT;
	DECLARE PIICOUNT INT;
	DECLARE PIISUCC INT;
	DECLARE PIIFAIL INT;
	DECLARE I INT ;
	DECLARE J INT DEFAULT 1;

	IF COALESCE(PIUSERID,'') = '' OR COALESCE(PIRPTSTR,'') = '' THEN
	   RETURN;
	END IF;

	SET I = LOCATE(',',PIRPTSTR);

	WHILE I > 0 DO
		IF J = 1 THEN
			SET PIIYMD = CAST(SUBSTR(PIRPTSTR,1,I-1) AS INT);
		ELSEIF J = 2 THEN
			SET PISPGATE = SUBSTR(PIRPTSTR,1,I-1);
		ELSEIF J = 3  THEN
			SET PISPISUNCM = CAST(SUBSTR(PIRPTSTR,1,I-1) AS INT);
		ELSEIF J = 4 THEN
			SET PIICOUNT = CAST(SUBSTR(PIRPTSTR,1,I-1) AS INT);
		ELSEIF J = 5 THEN
			SET PIISUCC = CAST(SUBSTR(PIRPTSTR,1,I-1) AS INT);
		ELSEIF J = 6 THEN
			SET PIIFAIL = CAST(SUBSTR(PIRPTSTR,1,I-1) AS INT);
		END IF;

		SET J = J+1;
		SET PIRPTSTR = SUBSTR(PIRPTSTR,I+1);
		SET I = LOCATE(',',PIRPTSTR);
	END WHILE;

	IF VALUE(PIRPTSTR,'') <> '' THEN
		SET PIIFAIL = CAST(PIRPTSTR AS INT);
	END IF;

	IF NOT EXISTS(SELECT IYMD FROM MT_DATAREPORT_SP WHERE IYMD = PIIYMD AND USERID = PIUSERID AND SPGATE = PISPGATE) THEN
		INSERT INTO MT_DATAREPORT_SP(IYMD,USERID,SPGATE,SPISUNCM,ICOUNT,ISUCC,IFAIL)
		VALUES (PIIYMD,PIUSERID,PISPGATE,PISPISUNCM,PIICOUNT,PIISUCC,PIIFAIL);
	ELSE
		UPDATE MT_DATAREPORT_SP	SET ICOUNT = PIICOUNT,ISUCC = PIISUCC,IFAIL = PIIFAIL,UPDATETIME = CURRENT TIMESTAMP
		WHERE IYMD = PIIYMD AND UCASE(USERID) = UCASE(PIUSERID) AND SPGATE = PISPGATE;
	END	IF;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "MMS_ADD_MT_HISTORY"
 (IN "@PTMSGID" VARCHAR(20),
  IN "@USERID" VARCHAR(11),
  IN "@SPGATE" VARCHAR(21),
  IN "@CPNO" VARCHAR(21),
  IN "@PHONE" VARCHAR(21),
  IN "@MESSAGE" VARCHAR(1000),
  IN "@TASKID" INTEGER,
  IN "@TMS_PATH" VARCHAR(512),
  IN "@SENDLEVEL" SMALLINT,
  IN "@SENDTYPE" SMALLINT,
  IN "@UNICOM" SMALLINT,
  IN "@SUBMITTIME" TIMESTAMP,
  IN "@SENDTIME" TIMESTAMP,
  IN "@SPMSGID" VARCHAR(64),
  IN "@RPTTIME" TIMESTAMP,
  IN "@SENDFLAG" INTEGER,
  IN "@STATUS" VARCHAR(20),
  IN "@ERRORCODE" INTEGER
 )
  SPECIFIC "MMS_ADD_MT_HISTORY"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	DECLARE @PTMSGID VARCHAR(20) DEFAULT 'AAADAD';
	DECLARE @SPGATE VARCHAR(21) DEFAULT '10657';
	DECLARE @SENDTYPE SMALLINT DEFAULT 0;

	INSERT INTO MMS_SEND_HISTORY(PTMSGID, USERID,  SPGATE,  CPNO,  PHONE,  MESSAGE,  TASKID,  TMS_PATH,  SENDLEVEL,  SENDTYPE,  UNICOM,  SUBMITTIME,  SENDTIME,  SPMSGID,  RPTTIME,  SENDFLAG,  STATUS, ERRORCODE)
		   			   VALUES(@PTMSGID, @USERID,  @SPGATE,  @CPNO,  @PHONE,  @MESSAGE,  @TASKID,  @TMS_PATH,  @SENDLEVEL,  @SENDTYPE,  @UNICOM,  @SUBMITTIME,  @SENDTIME,  @SPMSGID,  @RPTTIME,  @SENDFLAG,  @STATUS, @ERRORCODE);



END &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_ATTMRTASK"
 (IN "PILOGINID" VARCHAR(11),
  IN "PIATTIME" BIGINT
 )
  SPECIFIC "S_RD_ATTMRTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT A.ID,A.LOGINID,A.TASKID,A.BMTMSGID,A.ATTIME,A.VALIDTIME
	FROM ATTIME_TASK A
	INNER JOIN BATCH_MT_REQ B ON A.BMTMSGID=B.BMTMSGID
	WHERE UCASE(A.LOGINID)=UCASE(PILOGINID) AND A.ATTIME<=PIATTIME  AND B.ERRORCODE='ACCEPTD';
	OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE S_RD_MTTASKRPT
 (IN "PIPTMSGID" BIGINT,
  IN "PIUID" INTEGER
 )
  SPECIFIC S_RD_MTTASKRPT
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PICOUNT INTEGER;
DECLARE PICNTTB INTEGER;
DECLARE PISQLSTR1 VARCHAR(1024);
DECLARE PISQLSTR2 VARCHAR(1024);
DECLARE PISQLSTR3 VARCHAR(1024);
DECLARE PISQLSTRING VARCHAR(256);
DECLARE PIDBNAME VARCHAR(32);
DECLARE PIMONTH  INTEGER;
DECLARE PICURYM  INTEGER;
DECLARE PISQL VARCHAR(1024);
DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP (COUNT INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP1 (SPNUMBER VARCHAR(21),PHONE VARCHAR(21),DONEDATE CHAR(10),
ERRORCODE CHAR(7),RECVRPTTIME VARCHAR(22)) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

 SET PICOUNT = 0;
 SET PIDBNAME = 'MTTASK';

  SELECT COUNT(*) INTO PICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
  IF PICOUNT > 0 THEN
	C1:BEGIN
	DECLARE C_1 CURSOR WITH RETURN FOR
    SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME  FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
	OPEN C_1;
	END C1;
  ELSE
    --取当前月份,在当月历史中查询
	SET PICURYM = CAST((SUBSTR(CHAR(CURRENT TIMESTAMP),1,4)||SUBSTR(CHAR(CURRENT TIMESTAMP),6,2))AS INT);--获取当前时间的年月
    SET  PIDBNAME = 'MTTASK'||CHAR(PICURYM);--当前月份的历史表名
    SET PICOUNT = 0;
	SET PISQLSTR1 = 'SELECT COUNT(*) FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID);
	SET PISQL='INSERT INTO SESSION.TEMP(COUNT) SELECT COUNT(*)  FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID) ;
	EXECUTE IMMEDIATE PISQL;
	SELECT COUNT INTO PICOUNT FROM SESSION.TEMP;
	COMMIT;
     IF PICOUNT > 0 THEN
	    SET PISQLSTR2 = 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
	    C2:BEGIN
	    DECLARE C_1 CURSOR WITH RETURN FOR S1;
	    PREPARE S1 FROM PISQLSTR2;
	    OPEN C_1;
	    END C2;
        RETURN;
     ELSE
       --若当月历史表中没有,则遍历近三个月的历史表
	   SET PIMONTH = 1;
       WHILE PIMONTH <3 DO
       --格式化数据库名称
	   SET   PICURYM=CAST((SUBSTR(CHAR(CURRENT TIMESTAMP - PIMONTH MONTHS),1,4)||SUBSTR(CHAR(CURRENT TIMESTAMP - PIMONTH MONTHS),6,2))AS INT);
       SET   PIDBNAME = 'MTTASK'||CHAR(PICURYM);
	   --判断表名是否存在
	   SELECT COUNT(TABNAME) INTO PICNTTB FROM SYSCAT.TABLES WHERE TABNAME=PIDBNAME;
	   IF PICNTTB>0 THEN
	      SET  PICOUNT = 0;
	      SET PISQLSTR3 = 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
	      SET PISQL='INSERT INTO SESSION.TEMP(COUNT) SELECT COUNT(*)  FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID) ;
	      EXECUTE IMMEDIATE PISQL;
	      SELECT COUNT INTO PICOUNT FROM SESSION.TEMP;
	      COMMIT;
          IF PICOUNT > 0 THEN
             SET  PISQLSTRING = 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
			 C3:BEGIN
			 DECLARE C_1 CURSOR WITH RETURN FOR S2;
			 PREPARE S2 FROM PISQLSTRING;
			 OPEN C_1;
			 END C3;
			 RETURN;----查询到需要的数据后，跳出循环
          END IF;
	   END IF;--END OF IF PICNTTB>0 THEN
       SET PIMONTH = PIMONTH+1;
       END WHILE;
     END IF;--end of 查询当月历史表
	 C4:BEGIN
	    DECLARE C_1 CURSOR WITH RETURN FOR
		SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,RECVRPTTIME FROM SESSION.TEMP1;
	 END C4;
  END IF;--end of 查询实时表
END  &&

CREATE OR REPLACE  PROCEDURE "S_RD_MOWAITA"
 (IN "PIUSERUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "S_RD_MOWAITA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(4000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,ECID,PTMSGID,USERID,SPNUMBER,MESSAGE,PHONE,DELIVERTIME,SPGATE,CPNO,UNICOM,CMDID FROM MO_WAIT_A WHERE USERUID='||CAST(PIUSERUID AS CHAR(12))||' AND LOGINUID<='||CAST(PILOGINUID AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_MTLVLQUE"
 (IN "PIDESTUID" INTEGER,
  IN "PISENDLEVEL" INTEGER,
  IN "PIMAXREADCNT" INTEGER,
  IN "PISTRUID" VARCHAR(4000),
  IN "PICURTIME" BIGINT
 )
  SPECIFIC "S_RD_MTLVLQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,UID,DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,SENDTIME AS RECVMTTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA FROM MT_LEVEL0_QUEUE WHERE DESTUID='||
		CAST(PIDESTUID AS CHAR(12))||' AND UID NOT IN ('||PISTRUID||')AND SENDLEVEL='||CAST(PISENDLEVEL AS CHAR(12))||' AND (ATTIME<='||CAST(PICURTIME AS CHAR(20))||' OR ATTIME<0) FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_MTTASKRESD"
 (IN "PIMAXRESNDCNT" INTEGER,
  IN "PISTRMSGID" VARCHAR(4000)
 )
  SPECIFIC "S_RD_MTTASKRESD"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,UID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,
	PKNUMBER,PKTOTAL,SENDSTATUS,SENDLEVEL,TPUDHI,LONGMSGSEQ,MSGFMT,MESSAGE,RECVMTTIME,SVRTYPE,
	P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE
	FROM MT_TASK WHERE PTMSGID IN('||PISTRMSGID||') AND RESENDCNT<'||CAST(PIMAXRESNDCNT AS CHAR(12));
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_MTTMRQUE"
 (IN "PIUID" INTEGER,
  IN "PIDESTUID" INTEGER,
  IN "PISENDLEVEL" INTEGER,
  IN "PIMAXREADCNT" INTEGER,
  IN "PICURTIME" BIGINT
 )
  SPECIFIC "S_RD_MTTMRQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,UID,DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,'||
		'TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,'||
		'SENDTIME AS RECVMTTIME,LONGMSGSEQ,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID FROM MT_TIMER_QUEUE '||
		'WHERE UID='||CAST(PIUID AS CHAR(12))||' AND DESTUID= '||CAST(PIDESTUID AS CHAR(12))||' AND SENDLEVEL='||CAST(PISENDLEVEL AS CHAR(12))||' AND (ATTIME<='||CAST(PICURTIME AS CHAR(20))||' OR ATTIME<0) FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_MTVFYTASK" ( )
  SPECIFIC "S_RD_MTVFYTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT ID,VERIFYSTATUS,CMDTEXT,PARAMS FROM MT_VERIFY_TASK
	WHERE DEALSTATUS=1 ORDER BY ID ASC;
	OPEN RS1;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_RD_MTWAITA"
 (IN "PILOGINUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "S_RD_MTWAITA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,USERUID,USERID,PTMSGID,SPNUMBER,PHONECOUNT,MESSAGE,PHONE,MSGFMT,SENDTIME AS RECVMTTIME,'||
		'TASKID,SENDLEVEL,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,ATTIME,VALIDTIME,SENDTYPE,BATCHID,TOTALCOUNT FROM MT_WAIT_A '||
		'WHERE SENDSTATUS IN (1,255,8) AND  LOGINUID='||CAST(PILOGINUID AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "S_STATREMAIN"
 (IN "PIPICMD" INTEGER
 )
  SPECIFIC "S_STATREMAIN"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;

	IF PIPICMD=100 THEN
  --汇总MT_LEVEL0_QUEUE中各帐号数据
    --前端滞留
  SET PISQLSTR = 'SELECT UID, SENDLEVEL AS LEVEL, SUM(TOTALCOUNT) AS REMAINEDNUM FROM (SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL0_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL1_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL2_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL3_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL4_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL5_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL6_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL7_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL8_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL9_QUEUE WHERE UID>0) GROUP BY UID,SENDLEVEL';
    --后端滞留
  ELSEIF PIPICMD=110 THEN
    SET PISQLSTR = 'SELECT DESTUID AS UID,SENDLEVEL AS LEVEL,SUM(TOTALCOUNT) AS REMAINEDNUM  FROM (SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL0_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL1_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL2_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL3_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL4_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL5_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL6_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL7_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL8_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL9_QUEUE WHERE DESTUID>0) GROUP BY DESTUID,SENDLEVEL';

  --汇总MT_TIMER_QUEUE中各帐号数据
    --前端滞留
  ELSEIF PIPICMD=200 THEN
    SET PISQLSTR = 'SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, UID FROM MT_TIMER_QUEUE WHERE UID>0 GROUP BY UID,SENDLEVEL';
  --后端滞留
  ELSEIF PIPICMD=210 THEN
    SET PISQLSTR = 'SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, DESTUID AS UID FROM MT_TIMER_QUEUE WHERE DESTUID>0 GROUP BY DESTUID,SENDLEVEL';

  --汇总MO_TASK中各帐号数据
    --前端滞留
  ELSEIF PIPICMD=300 THEN
   SET PISQLSTR = 'SELECT COUNT(UID) AS REMAINEDNUM, 0 AS LEVEL, UID FROM MO_TASK WHERE SENDSTATUS=1 AND UID>0 AND ORGUID>0 GROUP BY UID';
    --后端滞留
  ELSEIF PIPICMD=310 THEN
   SET PISQLSTR = 'SELECT COUNT(UID) AS REMAINEDNUM, 0 AS LEVEL, ORGUID AS UID FROM MO_TASK WHERE SENDSTATUS=1 AND ORGUID>0 GROUP BY ORGUID';

  --汇总RPT_WAIT_B中各帐号数据
    --前端滞留
  ELSEIF PIPICMD=401 THEN
   SET PISQLSTR = 'SELECT COUNT(UID) AS REMAINEDNUM, 1 AS LEVEL, UID FROM RPT_WAIT_B WHERE UID>0 AND ORGUID>0 GROUP BY UID';
    --后端滞留
  ELSEIF PIPICMD=411 THEN
   SET PISQLSTR = 'SELECT COUNT(UID) AS REMAINEDNUM, 1 AS LEVEL, ORGUID AS UID FROM RPT_WAIT_B WHERE ORGUID>0 GROUP BY ORGUID';

   --CMD 501统计MT_WAIT_A
  ELSEIF PIPICMD=501 THEN
    SET PISQLSTR = 'SELECT SUM(TOTALCOUNT) AS REMAINEDNUM,0 AS LEVEL,  USERUID AS UID FROM MT_WAIT_A WHERE USERUID>0 GROUP BY USERUID';

   --502统计BATCH_MT_REQ(统计滞留为TOTALNUM-SENDNUM)
  ELSEIF PIPICMD=502 THEN
    SET PISQLSTR = 'SELECT SUM(TOTALNUM-SENDNUM) AS REMAINEDNUM,0 AS LEVEL,  USERUID AS UID FROM BATCH_MT_REQ WHERE USERUID>0 GROUP BY USERUID';
 ELSE
		   SET PISQLSTR = 'SELECT 0 AS REMAINEDNUM, 0 AS LEVEL, 0 AS UID ';
 END IF;

	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_ATTMRFLAG"
 (IN "PITASKID" INTEGER,
  IN "PIID" INTEGER,
  IN "PILOGINID" VARCHAR(11),
  IN "PIBMTMSGID" BIGINT
 )
  SPECIFIC "S_UPD_ATTMRFLAG"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC

	DECLARE RCOUNT INT;
	UPDATE BATCH_MT_REQ SET ATTIMEFLAG=0 WHERE BMTMSGID=PIBMTMSGID AND UCASE(LOGINID)=UCASE(PILOGINID)  ;
	GET DIAGNOSTICS RCOUNT=ROW_COUNT;
	IF RCOUNT>0 THEN
		DELETE FROM ATTIME_TASK WHERE ID=PIID;
	END IF;

END  &&


CREATE OR REPLACE  PROCEDURE S_RD_BATMTREQ
 (IN "PILOGINID" VARCHAR(11),
  IN "PIDOWNLOADFLAG" SMALLINT
 )
  SPECIFIC S_RD_BATMTREQ
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF  PIDOWNLOADFLAG =0 THEN
    P1:BEGIN
	  DECLARE C1 CURSOR WITH RETURN FOR
	  SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,
  		  TASKID,TITLE,MSG,MSGFMT,REMOTEURL,TRIM(LOCALPATH) AS LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TOTALNUM,SENDNUM,TASKTYPE,BATCHID FROM BATCH_MT_REQ
	  WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND SENDSTATUS=3 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH)='' ORDER BY SENDLEVEL FETCH FIRST 1000 ROWS ONLY;
	  OPEN C1;
    END P1;
  ELSE
    P2:BEGIN
	  DECLARE C2 CURSOR WITH RETURN FOR
	  SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,
  		  TASKID,TITLE,MSG,MSGFMT,REMOTEURL,TRIM(LOCALPATH) AS LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TOTALNUM,SENDNUM,TASKTYPE,BATCHID FROM BATCH_MT_REQ
	  WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND (SENDSTATUS=4 OR SENDSTATUS=5) AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD'AND TRIM(LOCALPATH)<>''ORDER BY SENDLEVEL FETCH FIRST 1000 ROWS ONLY;
	  OPEN C2;
	END P2;
  END IF;
END  &&


CREATE OR REPLACE  PROCEDURE S_UPD_BATMTREQ
 (IN "PIUSERID" VARCHAR(6),
  IN "PIUSERUID" INTEGER,
  IN "PILOGINID" VARCHAR(11),
  IN "PISENDSTATUS" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIMSGID" BIGINT,
  IN "PILOCALPATH" VARCHAR(256),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIBMTMSGID" BIGINT,
  IN "PITOTALNUM" INTEGER,
  IN "PISENDNUM" INTEGER
 )
  SPECIFIC S_UPD_BATMTREQ
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIROWCOUNT INTEGER;

  IF PISENDSTATUS=0 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
       WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID)  ;
       DELETE FROM BATCH_MT_REQ WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       DELETE FROM ATTIME_TASK WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   IF SQLCODE<>0 AND SQLCODE<>100 THEN
	     ROLLBACK TO SAVEPOINT A;
	   ELSE
	     COMMIT;
	   END IF;
  ELSEIF PISENDSTATUS=2 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
       WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=3 THEN
       UPDATE BATCH_MT_REQ SET USERUID=PIUSERUID,SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,MSGID=PIMSGID,SENDTIME=CURRENT TIMESTAMP
       WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=4 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,LOCALPATH=PILOCALPATH,SENDNUM=PISENDNUM,SENDTIME=CURRENT TIMESTAMP,TOTALNUM=PITOTALNUM
       WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID AND SENDSTATUS=3;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
	   IF PIROWCOUNT<> 1 THEN
		   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
		   UPDATE BATCH_MT_REQ SET SENDSTATUS=0,ERRORCODE='UPDFAIL',SENDTIME=CURRENT TIMESTAMP WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID)  ;
	       DELETE FROM BATCH_MT_REQ WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	       DELETE FROM ATTIME_TASK WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
		   IF SQLCODE<>0 AND SQLCODE<>100 THEN
		     ROLLBACK TO SAVEPOINT A;
		   ELSE
		     COMMIT;
		   END IF;
	   END IF;
  ELSEIF PISENDSTATUS=5 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,
       SENDTIME=CURRENT TIMESTAMP WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=6 THEN
       UPDATE BATCH_MT_REQ SET ERRORCODE=PIERRORCODE,SENDNUM=PISENDNUM,
       SENDTIME=CURRENT TIMESTAMP WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSE
       SET PIROWCOUNT = 0;
  END IF;

  P1:BEGIN
  DECLARE C1 CURSOR  WITH RETURN FOR
             SELECT PIROWCOUNT AS UPDROWCOUNT FROM SYSIBM.SYSDUMMY1;
  OPEN C1;
  END P1;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_MONINFO"
 (IN "PIGATEID" INTEGER,
  IN "PISPGATE" VARCHAR(21),
  IN "PIUSRID" VARCHAR(11),
  IN "PIONLINESTATUS" INTEGER,
  IN "PITOTALRPTSEND" INTEGER,
  IN "PITOTALMOSEND" INTEGER,
  IN "PIHAVESENDMO" INTEGER,
  IN "PIHAVESENDRPT" INTEGER,
  IN "PIRECVMT" INTEGER,
  IN "PIREMAINEDMT" INTEGER,
  IN "PITIMERSENDMT" INTEGER,
  IN "PIREMAINEDRPT" INTEGER,
  IN "PIREMAINEDMO" INTEGER,
  IN "PIRECVSPEED" INTEGER
 )
  SPECIFIC "S_UPD_MONINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT GATEID FROM MR_SPGATE_WATCH WHERE UCASE(USRID)=UCASE(PIUSRID) AND SPGATE=PISPGATE) THEN
		INSERT INTO MR_SPGATE_WATCH(GATEID,SPGATE,USRID,ONLINESTATUS,TOTALRPTSEND,NUMRPT,
		TOTALMOSEND,NUMMO,HAVESENDMO,HAVESENDRPT,RECVMT,NUMMT,REMAINEDMT,TIMERSENDMT,REMAINEDRPT,REMAINEDMO,RECVSPEED)
		VALUES(PIGATEID,PISPGATE,PIUSRID,PIONLINESTATUS,PITOTALRPTSEND,PITOTALRPTSEND,PITOTALMOSEND,
		PITOTALMOSEND,PIHAVESENDMO,PIHAVESENDRPT,PIRECVMT,PIRECVMT,PIREMAINEDMT,PITIMERSENDMT,PIREMAINEDRPT,PIREMAINEDMO,PIRECVSPEED)  ;
	ELSE
		UPDATE MR_SPGATE_WATCH SET SPGATE=PISPGATE,USRID=PIUSRID,ONLINESTATUS=PIONLINESTATUS,TOTALRPTSEND=PITOTALRPTSEND,NUMRPT=PITOTALRPTSEND,
		TOTALMOSEND=PITOTALMOSEND,NUMMO=PITOTALMOSEND,HAVESENDMO=PIHAVESENDMO,HAVESENDRPT=PIHAVESENDRPT,RECVMT=PIRECVMT,NUMMT=PIRECVMT,
		REMAINEDMT=PIREMAINEDMT,TIMERSENDMT=PITIMERSENDMT,REMAINEDRPT=PIREMAINEDRPT,REMAINEDMO=PIREMAINEDMO,RECVSPEED=PIRECVSPEED
		WHERE UCASE(USRID)=UCASE(PIUSRID) AND SPGATE=PISPGATE;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_MOTASK"
 (IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIUID" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11)
 )
  SPECIFIC "S_UPD_MOTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PIRESENDCNT INT;

	IF PISENDSTATUS=1 THEN
		SET PIRESENDCNT=0;
	ELSE
		SET PIRESENDCNT=0;
	END IF;

	IF PIUID=0 AND PIECID=0 AND PIUSERID='' THEN
		UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,RESENDCNT=RESENDCNT+PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
	ELSE
		UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,UID=PIUID,ECID=PIECID,USERID=PIUSERID,RESENDCNT=RESENDCNT+PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
	END IF;

END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_MTRPT"
 (IN "PISENDSTATUS" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PIRECVFLAG" INTEGER,
  IN "PIERRORCODE" CHARACTER(7),
  IN "PISUBMITDATE" CHARACTER(10),
  IN "PIDONEDATE" CHARACTER(10),
  IN "PIRECVTIME" TIMESTAMP,
  IN "PISPID" VARCHAR(32)
 )
  SPECIFIC "S_UPD_MTRPT"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	SET PIRECVTIME=CURRENT TIMESTAMP;
	IF PISENDSTATUS=3 THEN
		UPDATE MT_TASK SET SENDSTATUS = PISENDSTATUS, RECVFLAG = PIRECVFLAG, ERRORCODE = PIERRORCODE, DONEDATE = PIDONEDATE, RECVTIME = PIRECVTIME,SPID=PISPID
		WHERE PTMSGID = PIPTMSGID AND SENDSTATUS=2;
	ELSEIF PISENDSTATUS=5 THEN
		UPDATE MT_TASK SET SENDSTATUS = PISENDSTATUS, RECVFLAG = PIRECVFLAG, ERRORCODE = PIERRORCODE, DONEDATE = PIDONEDATE, RECVTIME = PIRECVTIME,SPID=PISPID
		WHERE PTMSGID = PIPTMSGID AND SENDSTATUS<>0;
	ELSE
		UPDATE MT_TASK SET SENDSTATUS = PISENDSTATUS, RECVFLAG = PIRECVFLAG, ERRORCODE = PIERRORCODE, DONEDATE = PIDONEDATE, RECVTIME = PIRECVTIME,SPID=PISPID
		WHERE PTMSGID = PIPTMSGID AND SENDSTATUS<>0;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_MTTASK"
 (IN "PIPTMSGID" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PISENDFLAG" INTEGER,
  IN "PISENDRPTTM" VARCHAR(35)
 )
  SPECIFIC "S_UPD_MTTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  DECLARE SENDRPTTIME TIMESTAMP;
  IF(RTRIM(PISENDRPTTM))IS NULL THEN
  SET SENDRPTTIME = CURRENT TIMESTAMP;
  ELSE
  SET SENDRPTTIME = PISENDRPTTM;
  END IF;
	IF PISENDSTATUS=8  THEN
		UPDATE MT_TASK SET SENDFLAG = 10,SENDRPTTIME=SENDRPTTIME WHERE PTMSGID = PIPTMSGID;
 ELSEIF PISENDSTATUS=9 THEN
		UPDATE MT_TASK SET SENDFLAG = 11,SENDRPTTIME=SENDRPTTIME  WHERE PTMSGID = PIPTMSGID;
	ELSEIF PISENDSTATUS = 3 THEN
		UPDATE MT_TASK SET SENDSTATUS=PISENDSTATUS,SENDTIME=SENDRPTTIME  WHERE PTMSGID = PIPTMSGID;
	ELSE
		UPDATE MT_TASK SET SENDSTATUS = PISENDSTATUS,SENDRPTTIME=SENDRPTTIME  WHERE PTMSGID = PIPTMSGID;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_UPD_MTVFYTASK"
 (IN "PIUID" BIGINT
 )
  SPECIFIC "S_UPD_MTVFYTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	UPDATE MT_VERIFY_TASK SET DEALSTATUS=0 WHERE ID=PIUID;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_BATMTREQ"
 (IN "PIUSERID" VARCHAR(11),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERUID" INTEGER,
  IN "PISERVICETYPE" VARCHAR(10),
  IN "PISENDTYPE" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIREMOTEURL" VARCHAR(256),
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIMSG" VARCHAR(3000),
  IN "PITASKID" INTEGER,
  IN "PITITLE" VARCHAR(500),
  IN "PISENDLEVEL" SMALLINT,
  IN "PIATTIME" CHARACTER(14),
  IN "PIVALIDTIME" CHARACTER(14),
  IN "PIMSGID" BIGINT,
  IN "PILOCALPATH" VARCHAR(256),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PII64CURTIME" BIGINT,
  IN "PII64ATTIME" BIGINT,
  IN "PIBMTMSGID" BIGINT,
  IN "PISA" VARCHAR(21),
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PITASKTYPE" INTEGER,
  IN "PIBATCHID"  BIGINT
 )
  SPECIFIC "S_WR_BATMTREQ"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PIATTIMEFLAG INT DEFAULT 0;
	SET PIRECVTIME=CURRENT TIMESTAMP;
  	IF PII64CURTIME < PII64ATTIME THEN
		SET PIATTIMEFLAG=1;
	END IF;

	IF NOT EXISTS(SELECT ID FROM BATCH_MT_REQ WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID) THEN
		INSERT INTO BATCH_MT_REQ(BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,MSGFMT,REMOTEURL,SENDSTATUS,MSGID,TASKID,TITLE,
		MSG,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,ERRORCODE,RECVTIME,ATTIMEFLAG,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TASKTYPE,BATCHID )
		VALUES(PIBMTMSGID,PIUSERID,PILOGINID,PIUSERUID,PISERVICETYPE,PISA,PISENDTYPE,PIMSGFMT,PIREMOTEURL,PISENDSTATUS,
		PIMSGID,PITASKID,PITITLE,PIMSG,PILOCALPATH,PISENDLEVEL,PIATTIME,PIVALIDTIME,PIERRORCODE,PIRECVTIME,PIATTIMEFLAG,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIRETFLAG,PITASKTYPE,PIBATCHID )  ;
	END IF;

	IF PIATTIMEFLAG=1 THEN
		IF NOT EXISTS(SELECT TASKID FROM ATTIME_TASK WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID) THEN
			INSERT INTO ATTIME_TASK(LOGINID,BMTMSGID,TASKID,ATTIME,VALIDTIME) VALUES(PILOGINID,PIBMTMSGID,PITASKID,PII64ATTIME,PII64CURTIME)  ;
		ELSE
			UPDATE ATTIME_TASK SET ATTIME=PII64ATTIME,VALIDTIME=PII64CURTIME WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
		END IF;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MOTASK"
 (IN "PIPIUID" INTEGER,
  IN "PIPIPTMSGID" BIGINT,
  IN "PIPISENDSTATUS" INTEGER,
  IN "PIPIMSGFMT" SMALLINT,
  IN "PIPIECID" INTEGER,
  IN "PIPIUSERID" VARCHAR(11),
  IN "PIPISPNUMBER" VARCHAR(21),
  IN "PIPISERVICEID" VARCHAR(10),
  IN "PIPIDELIVERTIME" TIMESTAMP,
  IN "PIPIPHONE" VARCHAR(21),
  IN "PIPIMSGCONTENT" VARCHAR(3000),
  IN "PIPIORGUID" INTEGER,
  IN "PIPISPGATE" VARCHAR(21),
  IN "PIPITPUDHI" SMALLINT,
  IN "PIPITPPID" SMALLINT,
  IN "PIPIPKNUMBER" SMALLINT,
  IN "PIPIPKTOTAL" SMALLINT,
  IN "PIPILONGMSGSEQ" SMALLINT,
  IN "PIPIPTNOTICE" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PICMDID"  BIGINT
 )
  SPECIFIC "S_WR_MOTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	--SET PIPIDELIVERTIME=CURRENT TIMESTAMP;
	IF NOT EXISTS (SELECT PTMSGID FROM MO_TASK WHERE PTMSGID = PIPIPTMSGID) THEN
	   INSERT INTO MO_TASK(UID,PTMSGID,SPNUMBER,SERVICEID,SENDSTATUS,MSGFMT,DELIVERTIME,PHONE,
	   		  MSGCONTENT,ECID,USERID,ORGUID,SPGATE,TP_UDHI,TP_PID,PKNUMBER,PKTOTAL,LONGMSGSEQ,PTNOTICE,UNICOM,CMDID)
	   VALUES(PIPIUID,PIPIPTMSGID,PIPISPNUMBER,PIPISERVICEID,PIPISENDSTATUS,PIPIMSGFMT,PIPIDELIVERTIME,PIPIPHONE,PIPIMSGCONTENT,
	   		  PIPIECID,PIPIUSERID,PIPIORGUID,PIPISPGATE,PIPITPUDHI,PIPITPPID,PIPIPKNUMBER,PIPIPKTOTAL,PIPILONGMSGSEQ,PIPIPTNOTICE,PIUNICOM,PICMDID)  ;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";



CREATE OR REPLACE  PROCEDURE "S_WR_MOWAITA"
 (IN "PIECID" INTEGER,
  IN "PIUSERUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIUSERID" VARCHAR(11),
  IN "PIPHONE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIDELIVERTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIUNICOM" SMALLINT,
  IN "PICMDID"  BIGINT
 )
  SPECIFIC S_WR_MOWAITA
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	--SET PIDELIVERTIME=CURRENT TIMESTAMP;
	IF PIUSERID='' THEN
		SELECT USERID,SPNUMBER INTO PIUSERID,PISPNUMBER FROM MO_TASK WHERE PTMSGID=PIPTMSGID;
	END IF;

	IF NOT EXISTS(SELECT PTMSGID FROM MO_WAIT_A WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO MO_WAIT_A(ECID,USERUID,LOGINUID,PTMSGID,USERID,SPNUMBER,PHONE,DELIVERTIME,MESSAGE,SPGATE,CPNO,UNICOM,CMDID)
		VALUES(PIECID,PIUSERUID,PILOGINUID,PIPTMSGID,PIUSERID,PISPNUMBER,PIPHONE,PIDELIVERTIME,PIMESSAGE,PISPGATE,PICPNO,PIUNICOM,PICMDID)  ;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MOWAITC"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIMSGFMT" SMALLINT,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PISERVICEID" VARCHAR(10),
  IN "PIDELIVERTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(21),
  IN "PIMSGCONTENT" VARCHAR(3000),
  IN "PILOGINID" VARCHAR(11),
  IN "PITPPID" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPTNOTICE" SMALLINT
 )
  SPECIFIC "S_WR_MOWAITC"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	--SET PIDELIVERTIME=CURRENT TIMESTAMP;
	IF NOT EXISTS(SELECT PTMSGID FROM MO_WAIT_C WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO MO_WAIT_C(UID, PTMSGID, SPNUMBER, SERVICEID, SENDSTATUS, MSGFMT, DELIVERTIME, PHONE, MSGCONTENT,LOGINID,TP_UDHI,TP_PID,PKNUMBER,PKTOTAL,PTNOTICE)
		VALUES(PIUID, PIPTMSGID, PISPNUMBER, PISERVICEID, PISENDSTATUS, PIMSGFMT,PIDELIVERTIME, PIPHONE, PIMSGCONTENT,PILOGINID,PITPUDHI,PITPPID,PIPKNUMBER,PIPKTOTAL,PIPTNOTICE)  ;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "S_WR_MTLVLQUE"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER
 )
  SPECIFIC "S_WR_MTLVLQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   		  PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
			  TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
	   VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
			  PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
			  PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE)  ;
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WR_MTLVLQUEV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTLVLQUEV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   		  PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
			  TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
			  PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
			  PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA)  ;
	END IF;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MTTASKC"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PITPUDHI" SMALLINT,
  IN "PILOGINID" VARCHAR(11),
  IN "PIMSGFMT" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PISENDLEVEL" SMALLINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PIUNICOM"     SMALLINT,
  IN "PITASKID"     INTEGER,
  IN "PIMOBILEAREA" INTEGER

 )
  SPECIFIC "S_WR_MTTASKC"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO MT_TASK_C(UID, LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
	   SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME,TPUDHI,LONGMSGSEQ,MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA )
	   VALUES(PIUID, PILOGINID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
	   PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVTIME,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA )  ;
	END IF;
END  &&



--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MTTMRQUE"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT
 )
  SPECIFIC "S_WR_MTTMRQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	 IF NOT EXISTS (SELECT PTMSGID FROM MT_TIMER_QUEUE WHERE PTMSGID = PIPTMSGID) THEN
	 	INSERT INTO MT_TIMER_QUEUE(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,RETFLAG,PKTOTAL,TOTALCOUNT,PHONECOUNT,
		SENDTIME,SENDSTATUS,SPLITFLAG,ECID,FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID)
		VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIPHONE,PIPTMSGID,PIMESSAGE,PIRETFLAG,PIPKTOTAL,PITOTALCOUNT,
		PIPHONECOUNT,PIRECVMTTIME,PISENDSTATUS,PISPLITFLAG,PIECID,PIFEEFLAG,PIDESTUID,PILOGINUID,PIPKNUMBER,
		PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME, PISENDTYPE,PIBATCHID)  ;
	END IF;
END  &&

--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MTVRFYWAIT"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT
 )
  SPECIFIC "S_WR_MTVRFYWAIT"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	 DECLARE PIDEALSTATUS INT;

	IF PISENDSTATUS>=10 THEN
	  SET PIDEALSTATUS=0;
	ELSE
	  SET PIDEALSTATUS=1;
	END IF;

	IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO MT_VERIFY_WAIT(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,RETFLAG,PKTOTAL,TOTALCOUNT,PHONECOUNT,
		SENDTIME,SENDSTATUS,DEALSTATUS,SPLITFLAG,ECID,FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,
		LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME, SENDTYPE,BATCHID)
		VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIPHONE,PIPTMSGID,PIMESSAGE,PIRETFLAG,PIPKTOTAL,PITOTALCOUNT,PIPHONECOUNT,
	    PIRECVMTTIME,PISENDSTATUS,PIDEALSTATUS,PISPLITFLAG,PIECID,PIFEEFLAG,PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,
		PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID)  ;
	END IF;
END  &&



--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_MTWAITA"
 (IN "PILOGINUID" INTEGER,
  IN "PIUSERUID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PIPTMSGID" BIGINT,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PISENDSTATUS" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIPHONE" VARCHAR(3500),
  IN "PITASKID" INTEGER,
  IN "PISENDLEVEL" INTEGER,
  IN "PIPIMSGFMT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PITOTALCOUNT" INTEGER
 )
  SPECIFIC "S_WR_MTWAITA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_WAIT_A WHERE PTMSGID=PIPTMSGID) THEN
	   INSERT INTO MT_WAIT_A (PTMSGID,ECID,LOGINUID,USERUID,USERID,SPNUMBER,SENDSTATUS,SENDLEVEL,SENDTIME,PHONECOUNT,MESSAGE,PHONE,TASKID,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,ATTIME,VALIDTIME,SENDTYPE,BATCHID,TOTALCOUNT)
	   VALUES(PIPTMSGID,0,PILOGINUID,PIUSERUID,PIUSERID,PISPNUMBER,PISENDSTATUS,PISENDLEVEL,PIRECVMTTIME,PIPHONECOUNT,PIMESSAGE,PIPHONE,PITASKID,PIPIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIRETFLAG,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PITOTALCOUNT)  ;
	END IF;
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE "S_WR_RPTWAITC"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPGATE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER
 )
  SPECIFIC "S_WR_RPTWAITC"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	   INSERT INTO RPT_WAIT_C(UID, PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, LOGINID,USERMSGID,MODULEID)
	   VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PILOGINID,PIUSERMSGID,PIMODULEID)  ;
END  &&

--SET SCHEMA DB2JHB  ;
--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "S_WR_MTTASK"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PISIGNLEN" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER
 )
  SPECIFIC "S_WR_MTTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PITMPMSGID BIGINT;
DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
DECLARE PILEN INT;
DECLARE PIRESULTMSG VARCHAR(3000);
DECLARE PIPKNUM INT;
DECLARE PITMPNUM INT;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPMTTASK(UID INT,
USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
PHONE VARCHAR(21),PTMSGID BIGINT ,MESSAGE VARCHAR(3000),
SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,
FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER,AREACODE INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PILEN = LENGTH(PIMESSAGE, CODEUNITS32)-PISIGNLEN;
SET PITMPNUM = 0;
SET PIPKNUM = 1;
SET PISTRSPLIT = ',';

IF PIPHONECOUNT < 1 THEN
	RETURN;
END IF;

IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
	SET PISPLITLEN=140;
	SET PIMULTILEN1=134;
	SET PIMULTILEN2=134;
	SET PISIGNLEN=0;
END IF;

IF PIMSGFMT=25  THEN
		IF NOT EXISTS (SELECT PTMSGID FROM MT_TASK WHERE PTMSGID=PIPTMSGID) THEN
		   INSERT INTO MT_TASK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,
		   TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		   VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI,PIPTMSGID,PIMESSAGE,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,
		   PIRECVMTTIME,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		   PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
		END IF;
		RETURN;
END IF;

IF PIPHONECOUNT = 1
THEN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
	THEN
		IF PIPKTOTAL = 1
		THEN
			INSERT INTO MT_TASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,
			SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,
			TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
			SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
			VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE,
			PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,
			PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
			PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
		ELSE
			SET PIPKNUM = 1;
			SET PITMPMSGID = PIPTMSGID;
			IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
			THEN
				SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1,PISPLITLEN, CODEUNITS32);
				SET PITMPMSGID = PITMPMSGID;
				IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,
					PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				IF  PILEN-PISPLITLEN+PISIGNLEN>=0
				  THEN
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
				  ELSE
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
				END IF;
				SET PITMPMSGID = PITMPMSGID+17179869184;
				SET PIPKNUM = PIPKNUM+1;
				IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
					PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
			ELSE
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					IF PIPKNUM = PIPKTOTAL
					THEN
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSEIF PIPKNUM = PIPKTOTAL-1
					THEN
						IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
						THEN
						    IF  PILEN-(PIPKNUM-1)*PIMULTILEN1-1 >=0 THEN
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
							ELSE
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, 0, CODEUNITS32);
							END IF;
							SET PITMPNUM = PILEN-1;
						ELSE
							SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
							SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
						END IF;--END IF OF IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1;
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSE
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					END IF;--END IF OF IF PIPKNUM = PIPKTOTAL
					IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					THEN
						INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
						RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
						MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
						VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
						PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
						PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
					END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
			END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;

			INSERT INTO MT_TASK (UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
			RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,
			LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME, A.ECID, A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
			A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.TMPMTTASK A;
		END IF;--END IF OF IF PIPKTOTAL = 1
	END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);

	IF PIPKTOTAL < 1 --
	THEN
		RETURN;
	END IF;

	IF PIPKTOTAL >= 1 --
	THEN
		WHILE PILOCATION <> 0 --
		DO
			SET PISTART = PILOCATION;
			SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
			IF PILOCATION > 0
			THEN
				SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);--
				IF PIRESULTPHONE <> ''
				THEN
					SET PITMPMSGID = PIPTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					THEN
						IF PIPKTOTAL = 1
						THEN
							INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
							RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
							MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
							VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIMESSAGE, PISENDSTATUS,
							PIRETFLAG, PIPKTOTAL, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
							PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
						ELSE
							SET PIPKNUM = 1;
							IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
							THEN
								SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1, PISPLITLEN, CODEUNITS32);--
								SET PITMPMSGID = PITMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
									PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
								IF PILEN-PISPLITLEN+PISIGNLEN>=0 THEN
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
								ELSE
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
								END IF;
								SET PITMPMSGID = PITMPMSGID+17179869184;
								SET PIPKNUM = PIPKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
									PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
									PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
							ELSE
								WHILE PIPKNUM <= PIPKTOTAL
								DO
									IF PIPKNUM = PIPKTOTAL
									THEN
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSEIF PIPKNUM = PIPKTOTAL-1
									THEN
										IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										THEN
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
											SET PITMPNUM = PILEN-1;
										ELSE
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
											SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
										END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSE
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
									IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									THEN
										INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
										PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
										UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
										VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
										PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
										PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
									END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									SET PIPKNUM = PIPKNUM+1;
								END WHILE;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
							END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
						END	IF;--END IF OF IF PIPKTOTAL = 1
					END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
				END IF; --END IF OF IF PIRESULTPHONE <> ''
				SET PIPTMSGID = PIPTMSGID+1;
			END	IF; --END IF OF IF PILOCATION > 0
		END WHILE; --END WHILE OF WHILE PILOCATION <> 0

		INSERT INTO MT_TASK (UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
		PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
		UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
		A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
		A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.TMPMTTASK A;
	END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --
END  &&


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";
CREATE OR REPLACE  PROCEDURE "S_WR_MTTASKSR"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER
 )
  SPECIFIC "S_WR_MTTASKSR"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
SET PISTRSPLIT = ',';
--SET PIRECVMTTIME =CURRENT TIMESTAMP;
DECLARE GLOBAL TEMPORARY TABLE SESSION.PITMP(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),PHONE VARCHAR(21),
PTMSGID BIGINT ,MESSAGE VARCHAR(3000),SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

IF PIPHONECOUNT < 1 THEN--
	RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO MT_TASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
		PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
		PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
	END IF;
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);
	WHILE PILOCATION <> 0 --
	DO
	  SET PISTART = PILOCATION;
	  SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
	  IF PILOCATION > 0
	  THEN
		  IF PILOCATION-PISTART-1 >=0 THEN
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);
		  ELSE
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,0, CODEUNITS32);
		  END IF;
		  IF PIRESULTPHONE <> ''
		  THEN
			  IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID) THEN
				  INSERT INTO SESSION.PITMP(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
				  PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
				  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
				  VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
				  PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
				  PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
			  END IF;
			  SET PIPTMSGID = PIPTMSGID+1;
		  END IF;
	    END IF;
	 END WHILE;

	 INSERT INTO MT_TASK (UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
	 PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
	 SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
	 SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
	 A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
	 A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.PITMP A;
END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PISIGNLEN" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PITMPMSGID BIGINT;
DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
DECLARE PILEN INT;
DECLARE PIRESULTMSG VARCHAR(3000);
DECLARE PIPKNUM INT;
DECLARE PITMPNUM INT;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPMTTASK(UID INT,
USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
PHONE VARCHAR(21),PTMSGID BIGINT ,MESSAGE VARCHAR(3000),
SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,
FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER,AREACODE INTEGER,CUSTID VARCHAR(64),EXDATA VARCHAR(64)) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PILEN = LENGTH(PIMESSAGE, CODEUNITS32)-PISIGNLEN;
SET PITMPNUM = 0;
SET PIPKNUM = 1;
SET PISTRSPLIT = ',';

IF PIPHONECOUNT < 1 THEN
	RETURN;
END IF;

IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
	SET PISPLITLEN=140;
	SET PIMULTILEN1=134;
	SET PIMULTILEN2=134;
	SET PISIGNLEN=0;
END IF;

IF PIMSGFMT=25  THEN
		IF NOT EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID) THEN
		   INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,
		   TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
		   VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI,PIPTMSGID,PIMESSAGE,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,
		   PIRECVMTTIME,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		   PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
		END IF;
		RETURN;
END IF;

IF PIPHONECOUNT = 1
THEN
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
	THEN
		IF PIPKTOTAL = 1
		THEN
			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,
			SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,
			TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
			SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
			VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE,
			PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,
			PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
			PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
		ELSE
			SET PIPKNUM = 1;
			SET PITMPMSGID = PIPTMSGID;
			IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
			THEN
				SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1,PISPLITLEN, CODEUNITS32);
				SET PITMPMSGID = PITMPMSGID;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,
					PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				IF  PILEN-PISPLITLEN+PISIGNLEN>=0
				  THEN
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
				  ELSE
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
				END IF;
				SET PITMPMSGID = PITMPMSGID+17179869184;
				SET PIPKNUM = PIPKNUM+1;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
					PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
			ELSE
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					IF PIPKNUM = PIPKTOTAL
					THEN
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSEIF PIPKNUM = PIPKTOTAL-1
					THEN
						IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
						THEN
						    IF  PILEN-(PIPKNUM-1)*PIMULTILEN1-1 >=0 THEN
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
							ELSE
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, 0, CODEUNITS32);
							END IF;
							SET PITMPNUM = PILEN-1;
						ELSE
							SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
							SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
						END IF;--END IF OF IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1;
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSE
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					END IF;--END IF OF IF PIPKNUM = PIPKTOTAL
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
						RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
						MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
						VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
						PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
						PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
					END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
			END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;

			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
			RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,
			LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME, A.ECID, A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
			A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM SESSION.TMPMTTASK A;
		END IF;--END IF OF IF PIPKTOTAL = 1
	END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);

	IF PIPKTOTAL < 1 --
	THEN
		RETURN;
	END IF;

	IF PIPKTOTAL >= 1 --
	THEN
		WHILE PILOCATION <> 0 --
		DO
			SET PISTART = PILOCATION;
			SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
			IF PILOCATION > 0
			THEN
				SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);--
				IF PIRESULTPHONE <> ''
				THEN
					SET PITMPMSGID = PIPTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						IF PIPKTOTAL = 1
						THEN
							INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
							RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
							MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
							VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIMESSAGE, PISENDSTATUS,
							PIRETFLAG, PIPKTOTAL, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
							PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
						ELSE
							SET PIPKNUM = 1;
							IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
							THEN
								SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1, PISPLITLEN, CODEUNITS32);--
								SET PITMPMSGID = PITMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
									PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								IF PILEN-PISPLITLEN+PISIGNLEN>=0 THEN
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
								ELSE
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
								END IF;
								SET PITMPMSGID = PITMPMSGID+17179869184;
								SET PIPKNUM = PIPKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
									PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
									PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
							ELSE
								WHILE PIPKNUM <= PIPKTOTAL
								DO
									IF PIPKNUM = PIPKTOTAL
									THEN
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSEIF PIPKNUM = PIPKTOTAL-1
									THEN
										IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										THEN
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
											SET PITMPNUM = PILEN-1;
										ELSE
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
											SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
										END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSE
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
									IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
									THEN
										INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
										PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
										UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
										VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
										PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
										PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA);
									END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									SET PIPKNUM = PIPKNUM+1;
								END WHILE;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
							END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
						END	IF;--END IF OF IF PIPKTOTAL = 1
					END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
				END IF; --END IF OF IF PIRESULTPHONE <> ''
				SET PIPTMSGID = PIPTMSGID+1;
			END	IF; --END IF OF IF PILOCATION > 0
		END WHILE; --END WHILE OF WHILE PILOCATION <> 0

		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
		PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
		UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
		A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
		A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM SESSION.TMPMTTASK A;
	END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --
END  &&

CREATE OR REPLACE  PROCEDURE  S_RD_MTTASKSUPP
 (IN "PIOLDMSGID" BIGINT,
  IN "PINEWMSGID" BIGINT,
  IN "PISRCUID" INTEGER,
  IN "PISRCUSRID" VARCHAR(11),
  IN "PISRCSPGATE" VARCHAR(21),
  IN "PISRCSPNUMBER" VARCHAR(21),
  IN "PIDESTUID" INTEGER,
  IN "PIDESTUSRID" VARCHAR(11),
  IN "PIDESTSPGATE" VARCHAR(21),
  IN "PIDESTSPNUMBER" VARCHAR(21),
  IN "PIDESTFEEFLAG" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PINEWSIGNLEN" SMALLINT,
  IN "PIOLDSIGNLEN" SMALLINT,
  IN "PISIGNATURE" VARCHAR(20),
  IN "PINEWSIGNPOS" INTEGER,
  IN "PIOLDSIGNPOS" INTEGER,
  IN "PIENSPLITLEN" INTEGER, --英文短信单条长度，小于等于0标识不支持英文短信
  IN "PIENMULTILEN1" INTEGER, --英文长短信拆分长度
  IN "PIENMULTILEN2" INTEGER, --英文长短信最后一条长度
  IN "PINEWENSIGNLEN" INTEGER, --补发英文签名长度
  IN "PIOLDENSIGNLEN" INTEGER, --原英文签名长度
  IN "PIENSIGNATURE" VARCHAR(20) --英文签名
 )
  SPECIFIC  S_RD_MTTASKSUPP
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISENDNUM INTEGER;
	DECLARE PIPKTOTAL INTEGER;
	DECLARE PIPKNUM	 INTEGER;
	DECLARE PIINITMSGID BIGINT;
	DECLARE PISINGLEMSG VARCHAR(720);
	DECLARE PILONGMSG VARCHAR(3000);
	DECLARE PITOTALCNT INTEGER;
	DECLARE PILONGMSGLEN INTEGER;
	DECLARE PIECID INTEGER;
	DECLARE PIPHONE VARCHAR(21);
	DECLARE PISENDLEVEL SMALLINT;
	DECLARE PITASKID INTEGER;
	DECLARE PIRECVMTTIME TIMESTAMP;
	DECLARE PISRCCPNO  VARCHAR(21);
	DECLARE PIDESTCPNO VARCHAR(21);
	DECLARE PITPUDHI SMALLINT;
	DECLARE PITPPID SMALLINT;
	DECLARE PILONGMSGSEQ SMALLINT;
	DECLARE PIMSGFMT SMALLINT;
	DECLARE PIUNICOM SMALLINT;
	DECLARE PIMOBILEAREA INTEGER;
	DECLARE PISVRTYPE VARCHAR(64);
	DECLARE PIUSERMSGID BIGINT;
	DECLARE PISENDTYPE SMALLINT;
	DECLARE PIP1 VARCHAR(64);
	DECLARE PIP2 VARCHAR(64);
	DECLARE PIP3 VARCHAR(64);
	DECLARE PIP4 VARCHAR(64);
	DECLARE PIMODULEID INTEGER;
	DECLARE PIATTIME BIGINT;
	DECLARE PIVALIDTIME BIGINT;
	DECLARE PIRCOUNT1 INTEGER;
        DECLARE PIRCOUNT2 INTEGER;
  DECLARE PIBATCHID BIGINT;
  DECLARE PIAREACODE INTEGER;
  DECLARE PICUSTID VARCHAR(64);
  DECLARE PIEXDATA VARCHAR(64);

  DECLARE PISPLITLEN_V  INTEGER;
  DECLARE PIMULTILEN1_V  INTEGER;
  DECLARE PIMULTILEN2_V  INTEGER;
  DECLARE PINEWSIGNLEN_V  INTEGER;
  DECLARE PIOLDSIGNLEN_V  INTEGER;
  DECLARE PISIGNATURE_V  VARCHAR(22);

	SET PILONGMSG='';
	SET PIRECVMTTIME = CURRENT TIMESTAMP;
	SET PISRCCPNO  = SUBSTRING(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE),CODEUNITS32);
	SET PIDESTCPNO = SUBSTRING(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE),CODEUNITS32);
	DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPTB_RDMTTASK (
	UID INTEGER,
	PTMSGID BIGINT,
	ECID INTEGER,
	TASKID INTEGER,
	USERID VARCHAR(11),
	SPGATE VARCHAR(21),
	CPNO VARCHAR(21),
	PHONE VARCHAR(21),
	SPMSGID BIGINT,
	RETFLAG SMALLINT,
	FEEFLAG SMALLINT,
	PKNUMBER SMALLINT,
	PKTOTAL SMALLINT,
	SENDSTATUS SMALLINT,
	SENDFLAG SMALLINT,
	RECVFLAG SMALLINT,
	PASSTHROUGH SMALLINT,
	DONEDATE CHAR(10),
	ERRORCODE CHAR(7),
	SENDLEVEL SMALLINT,
	SENDTYPE SMALLINT,
	UNICOM SMALLINT,
	RESENDCNT SMALLINT,
	RECVMTTIME TIMESTAMP,
	RECVTIME TIMESTAMP,
	USERMSGID BIGINT,
	MESSAGE VARCHAR(3000),
	TPUDHI SMALLINT,
	LONGMSGSEQ SMALLINT,
	MSGFMT SMALLINT,
	MOBILEAREA INTEGER,
	SVRTYPE VARCHAR(64),
	TPPID SMALLINT,
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
	MODULEID INTEGER,
	ATTIME BIGINT,
	VALIDTIME BIGINT,
	BATCHID BIGINT,
	AREACODE INTEGER,
	CUSTID VARCHAR(64),
	EXDATA VARCHAR(64))ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	--取补发帐号的费用
	SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=UCASE(PIDESTUSRID);
	--该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;
    DELETE FROM SESSION.TMPTB_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
    GET DIAGNOSTICS PIRCOUNT2 = ROW_COUNT;
  IF PIRCOUNT1-PIRCOUNT2  <>0 THEN
	--BEGIN
		SELECT PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
		       INTO PIPKTOTAL ,PIPKNUM ,PIECID ,PIPHONE ,PISENDLEVEL ,PITASKID ,PITPUDHI ,PILONGMSGSEQ ,PIMSGFMT ,PIUNICOM ,PIMOBILEAREA  ,PISVRTYPE ,PITPPID ,PIUSERMSGID ,PISENDTYPE ,PIP1 ,PIP2 ,PIP3 ,PIP4 ,PIMODULEID ,PIATTIME ,PIVALIDTIME,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA
		       FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;

    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       SET PIOLDSIGNLEN_V=PIOLDENSIGNLEN;
     ELSE
       SET PIOLDSIGNLEN_V=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       SET PISPLITLEN_V  =PIENSPLITLEN;
       SET PIMULTILEN1_V =PIENMULTILEN1;
       SET PIMULTILEN2_V =PIENMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWENSIGNLEN;
       SET PISIGNATURE_V =PIENSIGNATURE;
     ELSE
       SET PISPLITLEN_V  =PISPLITLEN;
       SET PIMULTILEN1_V =PIMULTILEN1;
       SET PIMULTILEN2_V =PIMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWSIGNLEN;
       SET PISIGNATURE_V =PISIGNATURE;
     END IF;

		 IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN --对于非长短信补发的处理
			--BEGIN PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME
				SET PILONGMSG='';
				--取短信内容
				SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
				--更新替换MSGID
				UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF; --END OF LONGMSGLEN<=SPLITLEN

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = PILONGMSG||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||PILONGMSG;
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV2(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
				--END;--END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF; --END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1;
			--END ; --END OF PKTOTAL = 1
        /*
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN --对标准协议长短信的补发
		--BEGIN
			SET PILONGMSG='';
			--取短信内容
			SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
			--更新替换MSGID
			UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
			IF (PIPKTOTAL=PIPKNUM) THEN--如果是最后一条，去掉旧签名，加上新签名
			--BEGIN
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN; --减去签名的净长度
				SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				SET PILONGMSG =PILONGMSG||PISIGNATURE;
			END IF;
			SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
			IF PILONGMSGLEN > 0 THEN
			--BEGIN
				--调用插入存储过程
				CALL S_WR_MTTASKSR (PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
								PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
								PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,'',PITPUDHI,
								PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
								PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);

			--END --END OF IF LONGMSGLEN > 0
			ELSE
				SET PILONGMSG='';
			END IF; --IF LONGMSGLEN > 0
		*/
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0) THEN--对非标准长短信协议的处理
		--BEGIN
			SET PILONGMSG='';
			--没有补发过且通道号跟源通道号相等
			IF EXISTS(SELECT * FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID) THEN
			--BEGIN
				--循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
				--计算起始MSGID
				SET PIINITMSGID = PIOLDMSGID-(PIPKNUM-1)*17179869184;
				SET PIPKNUM = 1;
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					--取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
					SELECT MESSAGE INTO PISINGLEMSG FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					IF PISINGLEMSG = '' THEN
					--BEGIN
						SET PILONGMSG='';
						SET PIPKNUM=PIPKTOTAL;
					END IF; --IF SINGLEMSG = ''
					--更新替换MSGID
					UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					--拼接短信内容
					SET PILONGMSG = PILONGMSG||PISINGLEMSG;
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END OF WHILE PKNUM <= PKTOTAL

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
                SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF;

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = PILONGMSG||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||PILONGMSG;
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV2 (PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME ,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
				--END --END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF;--END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1 ;
			END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM TMP WHERE PTMSGID=OLDMSGID AND RESENDCNT<1 AND (RTRIM(SPGATE)+RTRIM(CPNO))=SRCSPNUMBER)
		END IF;--END OF IF PKTOTAL > 1
	END IF;--END OF IF ROWCOUNT<>0
	PRET: BEGIN

	DECLARE C_3 CURSOR WITH RETURN FOR
	SELECT PIDESTUID AS UID,PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
	PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,PIPKNUM AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
	SENDSTATUS,1 AS SENDLEVEL,PIRECVMTTIME AS RECVMTTIME,PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
	MOBILEAREA,SVRTYPE,TPPID,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA FROM SESSION.TMPTB_RDMTTASK WHERE PILONGMSG<>'' ;
	OPEN C_3;
	END PRET;
END  &&

--------------------监控函数
CREATE OR REPLACE  FUNCTION "INSERT_BUFINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "INSERT_BUFINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    SET STRSQL =
      'INSERT INTO M_MON_BUFINFO(PTCODE,ENDCNT,MOTOTALRECV,MTTOTALSND,WRMOBUF,UPDMOBUF,UPDRPTBUF,WRRPTBUF,ENDRSPBUF,SMTSNDBUF,NMTSNDBUF,MTWAITBUF,PRECNT,MTTOTALRECV,MOTOTALSND,
	  WRMTTASKBUF,WRMTTMBUF,WRMTVFYBUF,WRMTLVLBUF,PRERSPBUF,PRERSPTMPBUF,MOSNDBUF,RPTSNDBUF,MORPTWAITBUF,LOGFILENUM,LOGBUF,RECVBUF,RESNDBUF,SUPPSNDBUF,MONLOGBUF,UPDATETIME) VALUES('
      ;
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ENDCNT,INTEGER 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV,NUMBER(11) 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALSND,NUMBER(11)4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMOBUF,NUMBER(11)5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --UPDMOBUF,NUMBER(11)6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --UPDRPTBUF,NUMBER(11)7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRRPTBUF,NUMBER(11)8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ENDRSPBUF,NUMBER(11)9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SMTSNDBUF,VARCHAR2(256)10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --NMTSNDBUF,NUMBER(11)11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTWAITBUF,NUMBER(11)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRECNT,NUMBER(11)13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALRECV,NUMBER(11)14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALSND,NUMBER(11)15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      -- WRMTTASKBUF,NUMBER(11)16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTTMBUF,NUMBER(11)17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTVFYBUF,NUMBER(11)18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTLVLBUF,NUMBER(11)19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRERSPBUF,NUMBER(11)20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRERSPTMPBUF,NUMBER(11)21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOSNDBUF,NUMBER(11)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTSNDBUF,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MORPTWAITBUF,NUMBER(11)24
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGFILENUM,NUMBER(11)25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGBUF,NUMBER(11)26
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RECVBUF,NUMBER(11)27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RESNDBUF,NUMBER(11)28
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SUPPSNDBUF,NUMBER(11)29
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MONLOGBUF,NUMBER(11)30
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME,TIMESTAMP(6)31
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)) ||'CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&




CREATE OR REPLACE  FUNCTION "INSERT_LOGINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "INSERT_LOGINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    --M_MON_LOGINFO','PTCODE#LOGTYPE#LOGS'
    SET STRSQL =
      'INSERT INTO M_MON_LOGINFO(PTCODE,LOGTYPE,LOGS,CREATETIME) VALUES(';
      --PTCODE,VARCHAR(32)
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGTYPE,INTEGER
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGS,VARCHAR(4000)
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --CREATETIME,VARCHAR(35)
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''')';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRVAL = SUBSTR(STRVAL, 1, LENGTH(STRVAL)-1)||')';
    RETURN STRSQL;
  END  &&



CREATE OR REPLACE  FUNCTION "INSERT_SPGATEINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "INSERT_SPGATEINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    SET STRSQL =
      'INSERT INTO M_MON_SPGATEINFO(PTCODE,USERID,USERUID,USERNAME,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,MTHAVESND,MTREMAINED,MTRECVSPD,MOTOTALRECV,MOHAVESND,
	  MOREMAINED,MOSNDSPD,RPTTOTALRECV,RPTHAVESND,RPTREMAINED,RPTSNDSPD,SNDERCNT,LASTSNDERTM,LOGININTM,LOGINOUTTM,UPDATETIME) VALUES('
      ;
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERID,VARCHAR(11) 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERUID,INTEGER 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERNAME,VARCHAR(128) 4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --JTYPE,VARCHAR2(64) 5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LINKNUM,NUMBER(11) 6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINIP,VARCHAR2(64) 7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ONLINESTATUS,NUMBER(11) 8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTHAVESND,NUMBER(11)9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTREMAINED,NUMBER(11)10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTRECVSPD,NUMBER(11) 11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV,NUMBER(11)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOHAVESND,NUMBER(11) 13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOREMAINED,NUMBER(11) 14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOSNDSPD,VARCHAR(2000) 15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTOTALRECV,NUMBER(11)16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTHAVESND,NUMBER(11)17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTREMAINED,UMBER(11)18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTSNDSPD,NUMBER(11)19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SNDERCNT,NUMBER(11)20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTSNDERTM,VARCHAR(35)21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGININTM,VARCHAR(35)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINOUTTM,VARCHAR(35)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME,TIMESTAMP 24
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)) ||'CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&



CREATE OR REPLACE  FUNCTION "INSERT_SYSINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "INSERT_SYSINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    SET STRSQL =
      'INSERT INTO M_MON_SYSINFO(PTCODE,CPUUSAGE,MEMUSAGE,VMEMUSAGE,DISKFREESPACE,UPDATETIME) VALUES('
      ;
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --CPUUSAGE, INTEGER 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MEMUSAGE,NUMBER(11) 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --VMEMUSAGE,NUMBER(11) 4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --DISKFREESPACE,NUMBER(11) 5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME TIMESTAMP 6
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)) ||'CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&


CREATE OR REPLACE  FUNCTION  "INSERT_THREADINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC "INSERT_THREADINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    -- ,
    SET STRSQL =
      'INSERT INTO M_MON_THREADINFO(PTCODE,THRID,THRNAME,THRSTATUS,ERRORCNT,LASTERRORTM,THRLOGS,LASTRUNTM,THISRUNTM,UPDATETIME) VALUES('
      ;
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRID, INTEGER 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRNAME,VARCHAR(256) 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRSTATUS,NUMBER(11) 4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ERRORCNT,NUMBER(11) 5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTERRORTM,VARCHAR2(35) 6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRLOGS,VARCHAR(2048) 7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTRUNTM,VARCHAR(35) 8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THISRUNTM,VARCHAR(35) 9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME TIMESTAMP 10
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)) ||'CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&


CREATE OR REPLACE  FUNCTION  "INSERT_USERINFO"
 ("STRVALUES" VARCHAR(4096)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "INSERT_USERINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE CURPOS INTEGER;
    DECLARE STRSQL VARCHAR(6000);
    DECLARE STRVAL VARCHAR(4096);
    SET CURPOS = 1;
    SET STRVAL = STRVALUES||'#';
    SET STRSQL =
      'INSERT INTO M_MON_USERINFO(PTCODE,USERID,USERUID,USERNAME,USERPRIVILEGE,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,USERFEE,FIXFAILURERATE,FAILURENUM,FAILURERATE,BINDINFO,
	MTTOTALSND,MTHAVESND,MTREMAINED,MTSNDINFO,MTSNDSPD,MOTOTALRECV,MOREMAINED,MORPTRECVSPD,MOTMOUTCNT,RPTTOTALRECV,RPTREMAINED,RPTTMOUTCNT,LOGININTM,LOGINOUTTM ,UPDATETIME) VALUES('
      ;
      --PTCODE,VARCHAR(32) 29
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERID,VARCHAR(11) 28
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERUID,INTEGER 27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERNAME,VARCHAR(128)26
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERPRIVILEGE,NUMBER(11)25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --JTYPE,VARCHAR2(64)24
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LINKNUM,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINIP,VARCHAR2(64)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ONLINESTATUS,NUMBER(11)21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERFEE,NUMBER(11)20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FIXFAILURERATE,NUMBER(11)19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FAILURENUM,NUMBER(11)18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FAILURERATE,NUMBER(11)17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --BINDINFO,VARCHAR(2000)16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALSND,NUMBER(11)15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTHAVESND,NUMBER(11)14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTREMAINED,NUMBER(11)13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTSNDINFO,VARCHAR(2000)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTSNDSPD,NUMBER(11)11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV,NUMBER(11)10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOREMAINED,UMBER(11)9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MORPTRECVSPD,NUMBER(11)8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTMOUTCNT,NUMBER(11)7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTOTALRECV,NUMBER(11)6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTREMAINED,NUMBER(11)5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTMOUTCNT,NUMBER(11)4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGININTM,VARCHAR(35)3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINOUTTM,VARCHAR(35)2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRSQL= LEFT(STRSQL,LENGTH(STRSQL)) ||'CURRENT TIMESTAMP)';
    RETURN STRSQL;
  END  &&

CREATE OR REPLACE  FUNCTION  "UPDATE_BUFINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_BUFINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_BUFINFO SET ';
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ENDCNT,INTEGER 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'ENDCNT=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV, 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MOTOTALRECV=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALSND, 4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MTTOTALSND=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMOBUF, 5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRMOBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --UPDMOBUF, 6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'UPDMOBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --UPDRPTBUF, 7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'UPDRPTBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRRPTBUF, 8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRRPTBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ENDRSPBUF, 9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'ENDRSPBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SMTSNDBUF, 10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'SMTSNDBUF='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --NMTSNDBUF, 11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'NMTSNDBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTWAITBUF, 12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MTWAITBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRECNT, 13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'PRECNT=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALRECV, 14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MTTOTALRECV=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALSND, 15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MOTOTALSND=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTTASKBUF, 16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRMTTASKBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTTMBUF, 17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRMTTMBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTVFYBUF, 18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRMTVFYBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --WRMTLVLBUF, 19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'WRMTLVLBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRERSPBUF, 20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'PRERSPBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --PRERSPTMPBUF, 21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'PRERSPTMPBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOSNDBUF, 22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MOSNDBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTSNDBUF, 23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'RPTSNDBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MORPTWAITBUF, 24
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MORPTWAITBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGFILENUM, 25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'LOGFILENUM=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGBUF, 26
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'LOGBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RECVBUF, 27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'RECVBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RESNDBUF, 28
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'RESNDBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SUPPSNDBUF, 29
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'SUPPSNDBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MONLOGBUF, 30
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'MONLOGBUF=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME 31
    SET STRSQL = STRSQL||'UPDATETIME=' ||'CURRENT TIMESTAMP';
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&

CREATE OR REPLACE  FUNCTION  "UPDATE_LOGINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_LOGINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_LOGINFO SET ';
      --PTCODE,VARCHAR(32)
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERUID,INTEGER
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'LOGTYPE=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGS,VARCHAR(4000)
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGS=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)-1) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&


CREATE OR REPLACE  FUNCTION  "UPDATE_SPGATEINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_SPGATEINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_SPGATEINFO SET ';
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERID,VARCHAR(11) 2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERID='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERUID,INTEGER 3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'USERUID=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERNAME,VARCHAR(128)4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERNAME=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --JTYPE,VARCHAR2(64) 5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'JTYPE =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LINKNUM,NUMBER(11)6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LINKNUM =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINIP,VARCHAR2(64)7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGINIP =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ONLINESTATUS,NUMBER(11)8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'ONLINESTATUS =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTHAVESND,NUMBER(11)9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTHAVESND =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTREMAINED,NUMBER(11)10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTREMAINED=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTRECVSPD,NUMBER(11)11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTRECVSPD =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV,NUMBER(11)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOTOTALRECV =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOHAVESND,NUMBER(11)13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOHAVESND =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOREMAINED,,NUMBER(11)14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOREMAINED=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOSNDSPD,NUMBER(11)15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOSNDSPD =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTOTALRECV,NUMBER(11)16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTTOTALRECV=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTHAVESND,NUMBER(11)17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTHAVESND=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTREMAINED,NUMBER(11)18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTREMAINED=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTSNDSPD,NUMBER(11)19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTSNDSPD=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --SNDERCNT,NUMBER(11)20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'SNDERCNT=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTSNDERTM,VARCHAR(35)21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LASTSNDERTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGININTM,VARCHAR(35)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGININTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINOUTTM,VARCHAR(35)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGINOUTTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    --UPDATETIME,TIMESTAMP  24
    SET STRSQL = STRSQL||'UPDATETIME=' ||'CURRENT TIMESTAMP';
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&


CREATE OR REPLACE  FUNCTION  "UPDATE_SYSINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_SYSINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_SYSINFO SET ';
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --CPUUSAGE,INTEGER 27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'CPUUSAGE=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MEMUSAGE,NUMBER(11)25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MEMUSAGE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --VMEMUSAGE,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'VMEMUSAGE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --DISKFREESPACE,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'DISKFREESPACE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRSQL = STRSQL||'UPDATETIME=' ||'CURRENT TIMESTAMP';
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&

CREATE OR REPLACE  FUNCTION  "UPDATE_THREADINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_THREADINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_THREADINFO SET ';
      --PTCODE,VARCHAR(32) 1
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRID,INTEGER 27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'THRID=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRNAME,VARCHAR(256)26
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'THRNAME=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRSTATUS,NUMBER(11)25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'THRSTATUS =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ERRORCNT,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'ERRORCNT =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTERRORTM,VARCHAR2(35)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LASTERRORTM =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THRLOGS,VARCHAR(2048)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'THRLOGS =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LASTRUNTM,VARCHAR(35)3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LASTRUNTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --THISRUNTM,VARCHAR(35)2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'THISRUNTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRSQL = STRSQL||'UPDATETIME=' ||'CURRENT TIMESTAMP';
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&


CREATE OR REPLACE  FUNCTION  "UPDATE_USERINFO"
 ("STRVALUES" VARCHAR(4096),
  "STRWHERE" VARCHAR(1024)
 )
  RETURNS VARCHAR(6000)
  SPECIFIC  "UPDATE_USERINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  READS SQL DATA
  STATIC DISPATCH
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
    DECLARE STRVALUE VARCHAR(2048);
    DECLARE STRVAL VARCHAR(4096);
    DECLARE STRSQL VARCHAR(6000);
    SET STRVAL=STRVALUES;
    SET STRVAL = STRVAL || '#';
    SET STRSQL = 'UPDATE M_MON_USERINFO SET ';
      --PTCODE,VARCHAR(32) 29
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'PTCODE='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERID,VARCHAR(11) 28
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERID='||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERUID,INTEGER 27
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL|| 'USERUID=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERNAME,VARCHAR(128)26
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERNAME=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERPRIVILEGE,NUMBER(11)25
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERPRIVILEGE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --JTYPE,VARCHAR2(64)24
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'JTYPE =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LINKNUM,NUMBER(11)23
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LINKNUM =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINIP,VARCHAR2(64)22
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGINIP =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --ONLINESTATUS,NUMBER(11)21
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'ONLINESTATUS =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --USERFEE,NUMBER(11)20
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'USERFEE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FIXFAILURERATE,NUMBER(11)19
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'FIXFAILURERATE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FAILURENUM,NUMBER(11)18
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'FAILURENUM =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --FAILURERATE,NUMBER(11)17
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'FAILURERATE =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --BINDINFO,VARCHAR(2000)16
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'BINDINFO =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTTOTALSND,NUMBER(11)15
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTTOTALSND =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTHAVESND,NUMBER(11)14
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTHAVESND =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTREMAINED,NUMBER(11)13
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTREMAINED =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTSNDINFO,VARCHAR(2000)12
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTSNDINFO =' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MTSNDSPD,NUMBER(11)11
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MTSNDSPD =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTOTALRECV,NUMBER(11)10
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOTOTALRECV =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOREMAINED,UMBER(11)9
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOREMAINED =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MORPTRECVSPD,NUMBER(11)8
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MORPTRECVSPD =' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --MOTMOUTCNT,NUMBER(11)7
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'MOTMOUTCNT=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTOTALRECV,NUMBER(11)6
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTTOTALRECV=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTREMAINED,NUMBER(11)5
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTREMAINED=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --RPTTMOUTCNT,NUMBER(11)4
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '0';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'RPTTMOUTCNT=' ||STRVALUE||',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGININTM,VARCHAR(35)3
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGININTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
      --LOGINOUTTM,VARCHAR(35)2
    IF LOCATE('#', STRVAL) <> 0 THEN
      IF LOCATE('#', STRVAL)=1 THEN
        SET STRVALUE = '';
      ELSE
        SET STRVALUE = SUBSTR(STRVAL, 1,LOCATE('#', STRVAL) - 1);
      END IF;
      SET STRSQL = STRSQL||'LOGINOUTTM=' ||''''||STRVALUE||''',';
      SET STRVAL = INSERT(STRVAL, 1, LOCATE('#', STRVAL), '');
    END IF;
    SET STRSQL = STRSQL||'UPDATETIME=' ||'CURRENT TIMESTAMP';
    SET STRSQL = SUBSTR(STRSQL,1,LENGTH(STRSQL)) ||' '||STRWHERE;
    RETURN STRSQL;
  END  &&


-- END OF GENERATED SCRIPT FOR WINDYNIGHT-DB2-EMPSVR (DB2JHB)


--SET SCHEMA DB2JHB  ;

--SET CURRENT PATH = "SYSIBM","SYSFUN","SYSPROC","SYSIBMADM","DB2JHB";

CREATE OR REPLACE  PROCEDURE  "M_WR_MONINFO"
 (IN "INFOTYPE" INTEGER,
  IN "MONINFO" VARCHAR(5120)
 )
  SPECIFIC  "M_WR_MONINFO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  DECLARE PISTRSQL  VARCHAR(8000);         --返回的SQL语句
  DECLARE PIMONSTR   VARCHAR(5120); --传人的字符串
  DECLARE PISUBSTR    VARCHAR(5120); --截取的字符串
  DECLARE PIWHERESTR    VARCHAR(1024); --截取的字符串
  DECLARE NCOUNT1    INTEGER;
  DECLARE NCOUNT2    INTEGER;
  DECLARE SS VARCHAR(1024);
  --RETURN;
 -----------------------------------维护表M_MON_USERINFO,帐号为主键,存在更新/不存在插入--------------------------------------
  --SET FEEDBACK OFF;           --SET NOCOUNT ON
  IF INFOTYPE=130 THEN
    SET PIMONSTR=MONINFO ;
    SET PISUBSTR=SUBSTRINGPRIKEY(PIMONSTR,2);
	SET PIWHERESTR='WHERE USERID='||''''||PISUBSTR||'''';
    SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_USERINFO WHERE UCASE(USERID)=UCASE(PISUBSTR);
     IF NCOUNT1>0  THEN   --判断主键是否存在
	  SET PISTRSQL=UPDATE_USERINFO(PIMONSTR,PIWHERESTR);
      ELSE
    SET PISTRSQL=INSERT_USERINFO(PIMONSTR);
      END IF;
   EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
----------------------------------维护表M_MON_SPGATEINFO,帐号为主键,存在更新/不存在插入 -----------------------------
 ELSEIF INFOTYPE=131 THEN

    SET PIMONSTR=MONINFO;
    SET PISUBSTR=SUBSTRINGPRIKEY(PIMONSTR,2);
	SET PIWHERESTR='WHERE USERID='||''''||PISUBSTR||'''';
     SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_SPGATEINFO WHERE UCASE(USERID)=UCASE(PISUBSTR);

     IF NCOUNT1 >0  THEN  --判断主键是否存在
      SET PISTRSQL=UPDATE_SPGATEINFO(PIMONSTR,PIWHERESTR);

    ELSE

         SET PISTRSQL=INSERT_SPGATEINFO(PIMONSTR);
     END IF;
	-- INSERT INTO ABC(XX) VALUES(PISTRSQL);
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
-- ----------------------------------维护表DBO.M_MON_THREADINFO,THRID为主键,存在更新/不存在插入 -----------------------------
 ELSEIF INFOTYPE=132 THEN

     SET PIMONSTR=MONINFO;
     SET PISUBSTR=SUBSTRINGPRIKEY(PIMONSTR,2);
	 SET PIWHERESTR='WHERE THRID='||PISUBSTR;
     SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_THREADINFO WHERE THRID=INT(PISUBSTR);

     IF NCOUNT1 >0  THEN  --判断主键是否存在
      SET PISTRSQL=UPDATE_THREADINFO(PIMONSTR,PIWHERESTR);
      ELSE
         SET PISTRSQL=INSERT_THREADINFO(PIMONSTR);
      END IF;

  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
-- ------------------------------------维护表M_MON_BUFINFO,原则上只有一条记录，存在更新，不存在插入 -----------------------------
 ELSEIF INFOTYPE=133 THEN

     SET PIMONSTR=MONINFO;
     SELECT COUNT(*) INTO NCOUNT2 FROM M_MON_BUFINFO;

     IF NCOUNT2>0 THEN   --有记录更新,无记录插入
      SET PISTRSQL=UPDATE_BUFINFO(PIMONSTR,'WHERE 1=1');
      ELSE
         SET PISTRSQL=INSERT_BUFINFO(PIMONSTR);
     END IF;
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
-- ------------------------------------维护表M_MON_SYSINFO,原则上只有一条记录，存在更新，不存在插入 -----------------------------
 ELSEIF INFOTYPE=134 THEN

    SET PIMONSTR=MONINFO;
    SELECT COUNT(*) INTO NCOUNT2 FROM M_MON_SYSINFO;

     IF NCOUNT2>0 THEN    --有记录更新,无记录插入
      SET PISTRSQL=UPDATE_SYSINFO(PIMONSTR,'WHERE 1=1');

     ELSE
         SET PISTRSQL=INSERT_SYSINFO(PIMONSTR);
     END IF;
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);

-- --------------------------------------维护表M_MON_LOGINFO,持续插入,一小时清空一次(清空动作由上层页面完成) -----------------------------
  ELSEIF INFOTYPE=135 THEN

     SET PIMONSTR=MONINFO;--UPDATE_LOGINFO
         SET PISTRSQL=INSERT_LOGINFO(PIMONSTR);
		 --INSERT INTO ABC(XX) VALUES(PISTRSQL);
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);

-- ----------------------------------------INFOTYPE=254转数据---------------------------------
ELSEIF INFOTYPE=254 THEN
   INSERT INTO  M_MON_USER_HIS( PTCODE,USERID,USERUID,USERNAME,USERPRIVILEGE,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,USERFEE,FIXFAILURERATE,
	                             FAILURENUM,FAILURERATE,BINDINFO,MTTOTALSND,MTHAVESND,MTREMAINED,MTSNDINFO,MTSNDSPD,MOTOTALRECV,MOREMAINED,
								 MORPTRECVSPD,MOTMOUTCNT,RPTTOTALRECV,RPTREMAINED,RPTTMOUTCNT,LOGININTM ,LOGINOUTTM,UPDATETIME)
								 SELECT PTCODE,USERID,USERUID,USERNAME,USERPRIVILEGE,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,USERFEE,
								 FIXFAILURERATE,FAILURENUM,FAILURERATE,BINDINFO,MTTOTALSND,MTHAVESND,MTREMAINED,MTSNDINFO,MTSNDSPD,
								 MOTOTALRECV,MOREMAINED,MORPTRECVSPD,MOTMOUTCNT,RPTTOTALRECV,RPTREMAINED,RPTTMOUTCNT,LOGININTM ,LOGINOUTTM,UPDATETIME
								 FROM  M_MON_USERINFO;

	INSERT INTO  M_MON_SPGATE_HIS(PTCODE,USERID,USERUID,USERNAME,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,MTHAVESND,MTREMAINED,MTRECVSPD,MOTOTALRECV,
	                              MOHAVESND,MOREMAINED,MOSNDSPD,RPTTOTALRECV,RPTHAVESND,RPTREMAINED,RPTSNDSPD,SNDERCNT,LASTSNDERTM,LOGININTM,LOGINOUTTM,UPDATETIME)
								  SELECT PTCODE,USERID,USERUID,USERNAME,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,MTHAVESND,MTREMAINED,MTRECVSPD,MOTOTALRECV,MOHAVESND,
								  MOREMAINED,MOSNDSPD,RPTTOTALRECV,RPTHAVESND,RPTREMAINED,RPTSNDSPD,SNDERCNT,LASTSNDERTM,LOGININTM,LOGINOUTTM,UPDATETIME
								  FROM  M_MON_SPGATEINFO;


	INSERT INTO M_MON_SYS_HIS(PTCODE,CPUUSAGE,MEMUSAGE,VMEMUSAGE,DISKFREESPACE,UPDATETIME) SELECT PTCODE,CPUUSAGE,MEMUSAGE,VMEMUSAGE,DISKFREESPACE,UPDATETIME FROM M_MON_SYSINFO;


	INSERT INTO M_MON_BUF_HIS(PTCODE,ENDCNT,MOTOTALRECV,MTTOTALSND,WRMOBUF,UPDMOBUF,UPDRPTBUF,WRRPTBUF,ENDRSPBUF,SMTSNDBUF,NMTSNDBUF,MTWAITBUF,PRECNT,
	                          MTTOTALRECV,MOTOTALSND,WRMTTASKBUF,WRMTTMBUF,WRMTVFYBUF,WRMTLVLBUF,PRERSPBUF,PRERSPTMPBUF,MOSNDBUF,RPTSNDBUF,
							  MORPTWAITBUF,LOGFILENUM,LOGBUF,RECVBUF,RESNDBUF,SUPPSNDBUF,MONLOGBUF,UPDATETIME)
							  SELECT PTCODE,ENDCNT,MOTOTALRECV,MTTOTALSND,WRMOBUF,UPDMOBUF,UPDRPTBUF,WRRPTBUF,ENDRSPBUF,SMTSNDBUF,NMTSNDBUF,MTWAITBUF,
							  PRECNT,MTTOTALRECV,MOTOTALSND,WRMTTASKBUF,WRMTTMBUF,WRMTVFYBUF,WRMTLVLBUF,PRERSPBUF,PRERSPTMPBUF,MOSNDBUF,RPTSNDBUF,
							  MORPTWAITBUF,LOGFILENUM,LOGBUF,RECVBUF,RESNDBUF,SUPPSNDBUF,MONLOGBUF,UPDATETIME FROM M_MON_BUFINFO;

	INSERT INTO M_MON_THREAD_HIS(PTCODE,THRID,THRNAME,THRSTATUS,ERRORCNT,LASTERRORTM,THRLOGS,LASTRUNTM,THISRUNTM,UPDATETIME)
	                             SELECT PTCODE,THRID,THRNAME,THRSTATUS,ERRORCNT,LASTERRORTM,THRLOGS,LASTRUNTM,THISRUNTM,UPDATETIME FROM M_MON_THREADINFO;


	INSERT INTO M_MON_LOG_HIS(PTCODE,LOGTYPE,LOGS,CREATETIME) SELECT PTCODE,LOGTYPE,LOGS,CREATETIME FROM M_MON_LOGINFO;

-- --------------------------------------清空所有表 -----------------------------
  ELSE                --INFOTYPE=255   THEN

    SET SS='DELETE FROM M_MON_USERINFO';
    EXECUTE IMMEDIATE SS;

    SET SS='DELETE FROM M_MON_SPGATEINFO';
	  EXECUTE IMMEDIATE SS;

	  SET SS='DELETE FROM M_MON_SYSINFO';
	  EXECUTE IMMEDIATE SS;

	  SET SS='DELETE FROM M_MON_BUFINFO';
	  EXECUTE IMMEDIATE SS;

	  SET SS='DELETE FROM M_MON_THREADINFO';
	  EXECUTE IMMEDIATE SS;

	  SET SS='DELETE FROM M_MON_LOGINFO';
	  EXECUTE IMMEDIATE SS;
  END IF;
END  &&


--DROP SPECIFIC PROCEDURE A_WR_PROINFO;
CREATE OR REPLACE  PROCEDURE A_WR_PROINFO
 (IN "PISERIALNUM" VARCHAR(32),
  IN "PIPROTYPE" INTEGER,
  IN "PIPROSTATUS" INTEGER,
  IN "PIVALIDDAYS" INTEGER,
  IN "PICORPNAME" VARCHAR(128),
  IN "PISTATUSINFO" VARCHAR(1024),
  IN "PISENDSPEED" INTEGER
 )
  SPECIFIC A_WR_PROINFO
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
    IF PISERIALNUM='' THEN
		RETURN;
	END IF;

	DELETE FROM A_PROINFO WHERE SERIALNUM<>PISERIALNUM;
	IF NOT EXISTS(SELECT SERIALNUM FROM A_PROINFO WHERE SERIALNUM=PISERIALNUM) THEN
		INSERT INTO A_PROINFO(SERIALNUM,PROTYPE,PROSTATUS,VALIDDAYS,STATUSINFO,CORPNAME,SENDSPEED)
		VALUES(PISERIALNUM,PIPROTYPE,PIPROSTATUS,PIVALIDDAYS,PISTATUSINFO,PICORPNAME,PISENDSPEED)  ;
	ELSE
		UPDATE A_PROINFO SET PROTYPE=PIPROTYPE,PROSTATUS=PIPROSTATUS,VALIDDAYS=PIVALIDDAYS,
		STATUSINFO=PISTATUSINFO,CORPNAME=PICORPNAME,SENDSPEED=PISENDSPEED;
	END IF;
END  &&


--DROP TABLE "A_SMSMSGIDMAP";

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SMSMSGIDMAP') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_SMSMSGIDMAP"
 ("ID"        BIGINT   NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
  "PTMSGID"    BIGINT    NOT NULL  DEFAULT 0,
  "USERMSGID"   VARCHAR(64)   NOT NULL  DEFAULT '''',
  "PITIME"      TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TPACCMGR" ';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SMSMSGIDMAP' AND INDNAME='IX_A_SMSMSGIDMAP') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE UNIQUE INDEX "IX_A_SMSMSGIDMAP"
  ON "A_SMSMSGIDMAP"
 (ID ASC,
 PTMSGID ASC,
 USERMSGID ASC,
 PITIME ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS ';
        END;
END IF;

END  &&


--DROP TABLE "A_SMSPUSHBIND";
BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SMSPUSHBIND') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_SMSPUSHBIND"(
	"PROTOCOLCODE" VARCHAR(64) NOT NULL DEFAULT '''',
	"USERUID" INTEGER NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;

END  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_SMSPUSHCONF') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_SMSPUSHCONF"(
  "ID" BIGINT   NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
	"PROTOCOLCODE" VARCHAR(64) NOT NULL DEFAULT '''',
	"PROTOCOLNAME" VARCHAR(128) NOT NULL DEFAULT '''',
	"PUSHURL" VARCHAR(256) NOT NULL DEFAULT '''',
	"PUSHACCOUNT" VARCHAR(32) NOT NULL DEFAULT '''',
	"PUSHPASSWD" VARCHAR(32) NOT NULL DEFAULT '''',
	"PUSHKEY" VARCHAR(256) NOT NULL DEFAULT '''',
	"PUSHFLAG" INT NOT NULL DEFAULT 0 ,
  "MAXBATCHNUM" INT NOT NULL DEFAULT 1
)
DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;
IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='A_SMSPUSHCONF' AND CONSTNAME='PK_A_SMSPUSHCONF') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE '
ALTER TABLE "A_SMSPUSHCONF"
ADD CONSTRAINT "PK_A_SMSPUSHCONF" PRIMARY KEY
("ID",
 "PROTOCOLCODE"
)';
        END;
END IF;
END  &&


-- DROP PROCEDURE A_GETMSGIDMAP;
CREATE OR REPLACE  PROCEDURE "A_GETMSGIDMAP"
 (IN PIMSGID VARCHAR(3000)
 )
  SPECIFIC A_GETMSGIDMAP
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
  DECLARE PISQLSTR VARCHAR(3000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,PTMSGID,USERMSGID FROM A_SMSMSGIDMAP WHERE PTMSGID '||' IN('|| PIMSGID ||')';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

--DROP PROCEDURE "A_LOADPUSHBIND";
CREATE OR REPLACE  PROCEDURE "A_LOADPUSHBIND"(
IN PISPTYPE INTEGER --=1
)
  SPECIFIC "A_LOADPUSHBIND"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;
  P1:BEGIN
  DECLARE RS1 CURSOR WITH RETURN FOR
	SELECT PROBIND.USERUID AS USERUID, USERDATA.USERID AS USERID, PROCONF.PROTOCOLCODE AS PROTOCOLCODE,
	PROCONF.PROTOCOLNAME AS PROTOCOLNAME, PROCONF.PUSHURL AS PUSHURL, PROCONF.PUSHACCOUNT AS PUSHACCOUNT,
	PROCONF.PUSHPASSWD AS PUSHPASSWD, PROCONF.PUSHKEY AS PUSHKEY, PROCONF.PUSHFLAG AS PUSHFLAG
	FROM  A_SMSPUSHBIND PROBIND
	INNER JOIN A_SMSPUSHCONF PROCONF  ON UPPER(PROBIND.PROTOCOLCODE)=UPPER(PROCONF.PROTOCOLCODE)
	INNER JOIN USERDATA ON USERDATA.UID = PROBIND.USERUID AND USERDATA.ACCOUNTTYPE=PISPTYPE;
	OPEN RS1;
	END P1;
END  &&

CREATE OR REPLACE  PROCEDURE S_RD_MOWAITA_PUSH
 (IN "PIUSERUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER,
  IN PISPTYPE INTEGER --=1
 )
  SPECIFIC S_RD_MOWAITA_PUSH
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
  DECLARE PISQLSTR VARCHAR(4000)  ;

  IF PISPTYPE IS NULL THEN
  SET PISPTYPE =1;
  END IF;

  P1:BEGIN
  DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT MO.ID AS ID,MO.ECID AS ECID,MO.PTMSGID AS PTMSGID,MO.USERID AS USERID,'||
  '(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO)) AS SPNUMBER,SUBSTR(MO.SPNUMBER,LENGTH(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO))+1,LENGTH(MO.SPNUMBER)-LENGTH(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO))) AS CPNO,MO.MESSAGE AS MESSAGE,'||
  'MO.PHONE AS PHONE,CHAR(MO.DELIVERTIME) AS DELIVERTIME,MO.SPGATE AS SPGATE,MO.SPNUMBER AS SPNUMBER1,MO.UNICOM AS UNICOM  FROM MO_WAIT_A MO '||
  'INNER JOIN GT_PORT_USED TB ON UCASE(TB.USERID)=UCASE(MO.USERID) AND LOCATE(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO),RTRIM(MO.SPNUMBER),1)=1 AND (TB.ROUTEFLAG=2 OR TB.ROUTEFLAG=0) '||
	'WHERE MO.USERUID='||CAST(PIUSERUID AS CHAR(12))||' AND TB.GATETYPE='||CAST(PISPTYPE AS CHAR(12))||' FETCH FIRST ' ||CAST(PIMAXREADCNT AS CHAR(12))||' ROWS ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
	END P1;
END  &&

CREATE OR REPLACE  PROCEDURE "S_RD_MOTASK"
 (IN "PIUID" INTEGER,
  IN "PIMAXRESNDCNT" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "S_RD_MOTASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(4000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT  ID,UID,ORGUID,ECID,PTMSGID,SPNUMBER,USERID,SERVICEID,MSGFMT,TP_PID,
	TP_UDHI,PHONE,MSGCONTENT,TP_PID,TP_UDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PTNOTICE,RESENDCNT,CMDID,DELIVERTIME FROM MO_TASK WHERE UID='||CAST(PIUID AS CHAR(12))||' AND SENDSTATUS=1 AND RESENDCNT<='||CAST(PIMAXRESNDCNT AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&



CREATE OR REPLACE  PROCEDURE S_RD_RPTWAITA_PUSH
 (IN "PIUSERUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC S_RD_RPTWAITA_PUSH
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
  DECLARE PISQLSTR VARCHAR(4000)  ;
  DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,ECID,PTMSGID,USERID,SPNUMBER,SUBMITTIME,DONETIME,PHONE,ERRORCODE,USERMSGID,MODULEID,RECVTIME
	FROM RPT_WAIT_A WHERE USERUID='||CAST(PIUSERUID AS CHAR(12))||' FETCH FIRST ' ||CAST(PIMAXREADCNT AS CHAR(12))||' ROWS ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&



--DROP PROCEDURE "A_WR_MSGIDMAP";
CREATE OR REPLACE  PROCEDURE "A_WR_MSGIDMAP"(
IN PIPTMSGID  BIGINT,
IN PIUSERMSGID VARCHAR(64))
  SPECIFIC A_WR_MSGIDMAP
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC
  DECLARE PICNT INT;
  SELECT COUNT(PTMSGID)INTO PICNT FROM A_SMSMSGIDMAP WHERE PTMSGID=PIPTMSGID;
  IF (PICNT=0) THEN
	INSERT INTO A_SMSMSGIDMAP(PTMSGID, USERMSGID) VALUES(PIPTMSGID,PIUSERMSGID)  ;
  END IF;
END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='HTTPERRCODE') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "HTTPERRCODE"
 ("ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE) CONSTRAINT PK_HTTPERRCODE PRIMARY KEY,
  "ERRSTATUS"        VARCHAR(16)     NOT NULL  DEFAULT '''',
  "PROTOCOLTYPE"     VARCHAR(32)     NOT NULL  DEFAULT '''',
  "ERRCODE"          VARCHAR(8)      NOT NULL  DEFAULT '''',
  "DESCRPTINFO"      VARCHAR(128)    NOT NULL  DEFAULT ''''
 )
 DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_SMSMSGIDMAP' AND INDNAME='IX_A_SMSMSGIDMAP') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE UNIQUE INDEX "IX_A_SMSMSGIDMAP"
  ON "A_SMSMSGIDMAP"
 (ID ASC,
 PTMSGID ASC,
 USERMSGID ASC,
 PITIME ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS ';
        END;
END IF;
IF NOT EXISTS (SELECT CONSTNAME  FROM syscat.tabconst    WHERE TABNAME='HTTPERRCODE' AND CONSTNAME='IX_HTTPERRCODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' ALTER TABLE "HTTPERRCODE"
 ADD CONSTRAINT "IX_HTTPERRCODE" UNIQUE
   ("ERRSTATUS",
   "PROTOCOLTYPE",
   "ERRCODE",
   "DESCRPTINFO"
   )';
        END;
END IF;
END  &&




BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='A_PROVINCECITY') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "A_PROVINCECITY"
(
"ID"         INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER) CONSTRAINT A_PROVINCECITY_PK PRIMARY KEY,
"PROVINCE"	VARCHAR(256)	NOT NULL DEFAULT '''',
"CITY"	VARCHAR(256) NOT NULL DEFAULT '''',
"AREACODE"	INTEGER NOT NULL DEFAULT 0,
"PROVINCECODE"	INTEGER NOT NULL DEFAULT 0
)
DATA CAPTURE NONE
 IN "TPACCMGR"';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_PROVINCECITY' AND INDNAME='IX_A_PRCECITY_PRVC') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_A_PRCECITY_PRVC" ON "A_PROVINCECITY"
("PROVINCE"   ASC
)
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_PROVINCECITY' AND INDNAME='IX_A_PRCECITY_CITY') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_A_PRCECITY_CITY" ON "A_PROVINCECITY"
("CITY"   ASC
)
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='A_PROVINCECITY' AND INDNAME='IX_A_PRCE_AREACODE') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX "IX_A_PRCE_AREACODE" ON "A_PROVINCECITY"
 ("AREACODE" ASC
 )
  PCTFREE 10
  ALLOW REVERSE SCANS';
        END;
END IF;
END  &&

ALTER TABLE "A_PROVINCECITY"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&




CREATE OR REPLACE  PROCEDURE A_LOADPBLIST(
PIMAXID BIGINT, -- 最大ID
PIMAXCOLNUM INTEGER,-- 一次读取行数
PITYPE SMALLINT
)
SPECIFIC "A_LOADPBLIST"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
  DECLARE PISQLSTR VARCHAR(3000)  ;
  DECLARE RS1 CURSOR WITH RETURN FOR S1;
  SET PISQLSTR='SELECT  PB.ID,PB.USERID,PB.SPGATE,PB.SPNUMBER,PB.PHONE,PB.OPTYPE,PB.SVRTYPE,PB.SPISUNCM,PB.CORPCODE
  FROM PB_LIST_BLACK PB WHERE PB.BLTYPE='||CAST(PITYPE AS CHAR(4))||' AND PB.ID>'||CAST(PIMAXID AS CHAR(12))||' ORDER BY PB.ID ASC FETCH FIRST '||CAST(PIMAXCOLNUM AS CHAR(12))||' ROWS ONLY';
  PREPARE S1 FROM PISQLSTR;
  OPEN RS1;
END  &&


--写携号转网表
CREATE OR REPLACE  PROCEDURE A_WR_MNP(
IN PIPHONE	  VARCHAR(21),
IN PIUNICOM	  INTEGER	 ,
IN PIPHONETYPE	INTEGER	 ,
IN PIADDTYPE	  INTEGER	 ,
IN PIOPTTYPE	  INTEGER
)
  SPECIFIC A_WR_MNP
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
IF NOT EXISTS(SELECT ID FROM A_MNP WHERE PHONE=PIPHONE AND OPTTYPE=0) THEN
    INSERT INTO A_MNP(PHONE,UNICOM,PHONETYPE,ADDTYPE,OPTTYPE )VALUES(PIPHONE,PIUNICOM,PIPHONETYPE,PIADDTYPE,PIOPTTYPE)  ;
END IF;
END  &&


--携号转网表增量加载
CREATE OR REPLACE  PROCEDURE A_LOADMNP
 (IN "PIID" INTEGER,
  IN "PIMAXCNTID" INTEGER
 )
  SPECIFIC A_LOADMNP
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE PISQLSTR VARCHAR(3000)  ;
DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,PHONE,UNICOM,PHONETYPE,ADDTYPE,OPTTYPE FROM A_MNP
	WHERE ID>'||CAST(PIID AS CHAR(12))||' AND PHONE<>'''' ORDER BY ID FETCH FIRST '||CAST(PIMAXCNTID AS CHAR(12))||' ROWS ONLY';
PREPARE S1 FROM PISQLSTR;
OPEN RS1;
END  &&


--错误码表一次性全部加载
CREATE OR REPLACE  PROCEDURE A_LOADMNPERRCODE
  SPECIFIC A_LOADMNPERRCODE
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
    SELECT TYPE,MNPTYPE,ERRORCODE,STATUS FROM A_MNPERRCODE;
OPEN RS1;
END  &&


--特殊号码表增量加载
CREATE OR REPLACE  PROCEDURE A_LOADSPEPHNO(
IN PIID INTEGER,
IN PIMAXCNTID INTEGER
)
  SPECIFIC A_LOADSPEPHNO
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE PISQLSTR VARCHAR(3000)  ;
DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,PHONE,CUSTID,USERID,SPECTYPE,OPTTYPE,UNICOM FROM A_SPE_PHONE
	WHERE ID>'||CAST(PIID AS CHAR(12))||' AND PHONE<>'''' ORDER BY ID FETCH FIRST '||CAST(PIMAXCNTID AS CHAR(12))||' ROWS ONLY';
PREPARE S1 FROM PISQLSTR;
OPEN RS1;
END  &&


--加载国际区号表
CREATE OR REPLACE  PROCEDURE A_LOADAREACODE
  SPECIFIC A_LOADAREACODE
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
    SELECT ID,AREACODE,AREANAME FROM A_AREACODE;
OPEN RS1;
END  &&


CREATE OR REPLACE  PROCEDURE "A_LOADMOBILEAREA" (
IN PIID BIGINT ,
IN PIMAXCOL INTEGER
)
  SPECIFIC "A_LOADMOBILEAREA"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(3000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT M.ID,M.MOBILE,M.AREACODE,P.PROVINCE,P.PROVINCECODE FROM A_MOBILEAREA M
    INNER JOIN A_PROVINCECITY P ON P.AREACODE=M.AREACODE WHERE M.ID>'||CAST(PIID AS CHAR(12))||'ORDER BY M.ID ASC  FETCH FIRST '||CAST(PIMAXCOL AS CHAR(12))||' ROWS ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


CREATE OR REPLACE  PROCEDURE LOADPROCERRCODE
(
IN PIPROTOCOLTYPE VARCHAR(32)
)
BEGIN
DECLARE PICNT INTEGER;
SET PICNT=0;
SELECT COUNT(*) INTO PICNT FROM HTTPERRCODE WHERE PROTOCOLTYPE = PIPROTOCOLTYPE ;
  IF(PICNT=0)THEN
    P1: BEGIN
    DECLARE C_2 CURSOR WITH RETURN FOR SELECT ERRSTATUS,PROTOCOLTYPE,ERRCODE,DESCRPTINFO FROM HTTPERRCODE ;
    OPEN C_2;
    END P1;
  ELSE
    P2: BEGIN
    DECLARE C_2 CURSOR WITH RETURN FOR SELECT ERRSTATUS,PROTOCOLTYPE,ERRCODE,DESCRPTINFO FROM HTTPERRCODE WHERE PROTOCOLTYPE = PIPROTOCOLTYPE ;
    OPEN C_2;
    END P2;
  END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "MMS_RD_BMTREQ"
	(IN "PI_MAXREADCNT" INTEGER)
SPECIFIC MMS_RD_BMTREQ
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN ATOMIC

  DECLARE PISQLSTR VARCHAR(4000)  ;
  DECLARE RS1 CURSOR WITH RETURN FOR S1;

	SET PISQLSTR = 'SELECT  ID,MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,TASKID,TITLE,TMPLID,MSG,
    MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SENDSTATUS,ERRORCODE,RECVTIME,
    SENDTIME,SENDTYPE,ATTIMEFLAG,SA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG
	FROM MMS_BMTREQ WHERE SENDSTATUS=1 ORDER BY SENDLEVEL FETCH FIRST '||CAST(PI_MAXREADCNT AS CHAR(12))|| ' ROWS ONLY ';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&



--DROP SPECIFIC PROCEDURE "MMS_UPD_BMTREQ";
CREATE OR REPLACE  PROCEDURE "MMS_UPD_BMTREQ"
(
  IN "PIID" INTEGER,
	IN "PISENDSTATUS" SMALLINT,
	IN "PITASKID" INTEGER,
	IN "PIMSGID" BIGINT,
	IN "PIERRORCODE" CHAR(7),
	IN "PIBMTMSGID" BIGINT,--=0,
    IN "PIPTMSGIDSTR" VARCHAR(8000),--='',
	IN "PIPTMSGID" BIGINT --=0
	)
SPECIFIC "MMS_UPD_BMTREQ"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN

    IF PIPTMSGIDSTR IS NULL THEN
    SET PIPTMSGIDSTR='';
    END IF;

    IF PIBMTMSGID IS NULL THEN
    SET PIBMTMSGID=0;
    END IF;

    IF PIPTMSGID IS NULL THEN
    SET PIPTMSGID=0;
    END IF;

	IF PISENDSTATUS=1 THEN
		UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,MSGID=0,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;

	ELSEIF PISENDSTATUS=2 THEN
		UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,MSGID=PIMSGID,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;

	ELSEIF PISENDSTATUS=3 THEN
		UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;

	ELSEIF PISENDSTATUS=4 THEN
		UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;

	ELSEIF PISENDSTATUS=5 THEN
		UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;

	ELSEIF PISENDSTATUS=6 THEN
	BEGIN
		UPDATE MMS_BMTREQ SET MSGID=PIPTMSGID,SENDSTATUS=PISENDSTATUS,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
        UPDATE MMS_LEVEL_QUEUE SET SENDSTATUS=1
               WHERE SENDSTATUS=10 AND LOCATE(RTRIM(CAST(PTMSGID AS CHAR(30))),PIPTMSGIDSTR)>0;
	END;
	ELSEIF PISENDSTATUS=0 THEN
	BEGIN
		UPDATE MMS_BMTREQ SET MSGID=PIPTMSGID,SENDSTATUS=PISENDSTATUS,SENDTIME=CURRENT TIMESTAMP
		WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
        UPDATE MMS_LEVEL_QUEUE SET SENDSTATUS=1
               WHERE SENDSTATUS=10 AND LOCATE(RTRIM(CAST(PTMSGID AS CHAR(30))),PIPTMSGIDSTR)>0;
		INSERT INTO MMS_BMTREQHIS(MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,
                    TASKID,TITLE,TMPLID,MSG,MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,
                    SENDSTATUS,ERRORCODE,RECVTIME,SENDTIME,SENDTYPE,ATTIMEFLAG,SA,
                    SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG)
        SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,TASKID,TITLE,TMPLID,MSG,
               MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SENDSTATUS,ERRORCODE,RECVTIME,
               SENDTIME,SENDTYPE,ATTIMEFLAG,SA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG
        FROM MMS_BMTREQ WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
		DELETE FROM MMS_BMTREQ WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
	END;
	END IF;
END  &&



--DROP PROCEDURE "MMS_WR_LVLQUE";
CREATE OR REPLACE  PROCEDURE "MMS_WR_LVLQUE"
(
	IN PIPTMSGID         BIGINT,
	IN PIUID             INTEGER,
	IN PILOGINID        VARCHAR(11),
	IN PIDEALSTATUS      INTEGER,
	IN PIUSERID          VARCHAR(11),
	IN PISA              VARCHAR(21),
	IN PIRETFLAG         INTEGER,
	IN PIPHONECOUNT      INTEGER,
	IN PIUNICOM          INTEGER,
	IN PISENDSTATUS      INTEGER,
	IN PISENDLEVEL       INTEGER,
	IN PISENDTIME        TIMESTAMP,
  IN PIMSGFMT          INTEGER,
	IN PIMSGTYPE         INTEGER,
	IN PITASKID          INTEGER,
	IN PIMSGTITLE        VARCHAR(200),
	IN PITMPLID          BIGINT,
	IN PIMESSAGE         VARCHAR(3000),
	IN PIPHONE           VARCHAR(1500),
	IN PISVRTYPE         VARCHAR(64),--='',
	IN PIP1              VARCHAR(64),--='',
	IN PIP2              VARCHAR(64),--='',
	IN PIP3              VARCHAR(64),--='',
	IN PIP4              VARCHAR(64),--='',
	IN PIUSERMSGID       BIGINT,--=0,
	IN PIMODULEID        INTEGER,--=0,
	IN PIATTIME          BIGINT,--=0,
	IN PIVALIDTIME       BIGINT--=0
)
SPECIFIC "MMS_WR_LVLQUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN

	DECLARE PILOGINUID INTEGER;

	IF PISVRTYPE IS NULL THEN
    SET PISVRTYPE='';
    END IF;

    IF PIP1 IS NULL THEN
    SET PIP1='';
    END IF;

    IF PIP2 IS NULL THEN
    SET PIP2='';
    END IF;

	IF PIP3 IS NULL THEN
    SET PIP3='';
    END IF;

    IF PIP4 IS NULL THEN
    SET PIP4='';
    END IF;

    IF PIUSERMSGID IS NULL THEN
    SET PIUSERMSGID=0;
    END IF;

	IF PIMODULEID IS NULL THEN
    SET PIMODULEID=0;
    END IF;

	IF PIATTIME IS NULL THEN
    SET PIATTIME=0;
    END IF;

    IF PIVALIDTIME IS NULL THEN
    SET PIVALIDTIME=0;
    END IF;


	IF EXISTS (SELECT SPGATE FROM  GT_PORT_USED WHERE UCASE(USERID)=UCASE(PIUSERID) AND SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2) THEN
	BEGIN
		IF NOT EXISTS (SELECT PTMSGID FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
		INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,UID,DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
		UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
		SELECT  PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,CPNO,PISA,PIRETFLAG,
		PIPHONECOUNT,PIUNICOM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
		PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
		PIMODULEID,PIATTIME,PIVALIDTIME
		FROM GT_PORT_USED WHERE UCASE(USERID)=UCASE(PIUSERID) AND SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2 ORDER BY ID DESC FETCH FIRST 1 ROW ONLY;
		END IF;
	END ;

    ELSEIF EXISTS (SELECT SPGATE FROM XT_GATE_QUEUE WHERE SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2) THEN
    BEGIN
        IF NOT EXISTS (SELECT PTMSGID FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
		INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,UID,DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
		UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
		SELECT  PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,'',PISA,PIRETFLAG,
		PIPHONECOUNT,PIUNICOM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
		PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
		PIMODULEID,PIATTIME,PIVALIDTIME
		FROM XT_GATE_QUEUE WHERE SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2 ORDER BY ID DESC FETCH FIRST 1 ROW ONLY;
		END IF;
    END ;

	ELSEIF EXISTS (SELECT SPGATE FROM  GT_PORT_USED WHERE UCASE(USERID)=UCASE(PIUSERID) AND STATUS=0 AND GATETYPE=2) THEN
	BEGIN
		IF NOT EXISTS (SELECT PTMSGID FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
		INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,UID,DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
		UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
		SELECT  PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,CPNO,PISA,PIRETFLAG,
		PIPHONECOUNT,SPISUNCM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
		PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
		PIMODULEID,PIATTIME,PIVALIDTIME
		FROM GT_PORT_USED WHERE UCASE(USERID)=UCASE(PIUSERID) AND STATUS=0 AND GATETYPE=2 ORDER BY ID DESC FETCH FIRST 1 ROW ONLY;
		END IF;
	END ;

	ELSE
	BEGIN
		IF NOT EXISTS (SELECT PTMSGID FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
		INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,UID,DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
		UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
		VALUES(PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,'','',PISA,PIRETFLAG,
		PIPHONECOUNT,PIUNICOM,9,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
		PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
		PIMODULEID,PIATTIME,PIVALIDTIME) ;
		END IF;
  END ;
END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "S_RD_MMS_QUEUE"
(
IN PISPGATE VARCHAR(21),
IN PIUNICOM SMALLINT
)

SPECIFIC "S_RD_MMS_QUEUE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
    DECLARE PIATTIME BIGINT;
	SET PIATTIME=CAST(SUBSTR(CHAR(CURRENT TIMESTAMP),1,4)||SUBSTR(CHAR(CURRENT TIMESTAMP),6,2)||SUBSTR(CHAR(CURRENT TIMESTAMP),9,2)||SUBSTR(CHAR(CURRENT TIMESTAMP),12,2)||SUBSTR(CHAR(CURRENT TIMESTAMP),15,2)||SUBSTR(CHAR(CURRENT TIMESTAMP),18,2) AS BIGINT) ;
	P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN FOR
        SELECT ID,PTMSGID,USERMSGID,TMPLID,UID,DESTUID,LOGINUID,ECID,TASKID,PHONECOUNT,TOTALCOUNT,DEALSTATUS,
        JTYPE,FEEFLAG,RETFLAG,SPLITFLAG,SENDLEVEL,MSGFMT,MSGTYPE,TPPID,TPUDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,
        PASSTHROUGH,SENDSTATUS,USERID,SVRTYPE,SPGATE,CPNO,ORDERCPNO,PHONE,MSGTITLE,MESSAGE,SENDTIME,UNICOM,
        ATTIME,VALIDTIME,MODULEID,SA,P1,P2,P3,P4
        FROM MMS_LEVEL_QUEUE
        WHERE SPGATE=PISPGATE AND (SENDSTATUS=1 OR SENDSTATUS=2) AND UNICOM=PIUNICOM AND ATTIME<PIATTIME ORDER BY ID ASC,SENDLEVEL ASC  FETCH FIRST 1 ROW ONLY  ;
        OPEN RS1;
   END P1;
END  &&


CREATE OR REPLACE  PROCEDURE "S_WR_MMS_MO"
(
IN PIPTMSGID BIGINT,
IN PIUID INTEGER,
IN PIORGUID INTEGER,
IN PIECID INTEGER,

IN PIUNICOM SMALLINT,
IN PIPTNOTICE SMALLINT,
IN PIRESENDCNT SMALLINT,
IN PISENDSTATUS SMALLINT,

IN PIMSGFMT SMALLINT,
IN PIMSGTYPE SMALLINT,
IN PITP_PID SMALLINT,
IN PITP_UDHI SMALLINT,
IN PIPKNUMBER SMALLINT,
IN PIPKTOTAL SMALLINT,
IN PILONGMSGSEQ SMALLINT,
IN PIPASSTHROUGH SMALLINT,

IN PIUSERID VARCHAR(11),
IN PISERVICEID VARCHAR(50),
IN PISPGATE VARCHAR(21),
IN PISPNUMBER VARCHAR(21),
IN PIPHONE VARCHAR(21),
IN PIMSGTITLE VARCHAR(200),
IN PIMSGCONTENT VARCHAR(3000),
IN PIDELIVERTIME TIMESTAMP
)
SPECIFIC "S_WR_MMS_MO"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS

BEGIN
SELECT VALUE(USERID,'') INTO PIUSERID FROM GT_PORT_USED WHERE SPISUNCM=PIUNICOM AND LOCATE(RTRIM(SPGATE)||RTRIM(CPNO), PISPNUMBER, 1)>0 FETCH FIRST 1 ROW ONLY;
SELECT VALUE(UID,0) INTO PIUID FROM USERDATA WHERE USERID=UCASE(PIUSERID);
INSERT INTO MMS_MO(
PTMSGID,UID,ORGUID,ECID,UNICOM,PTNOTICE,RESENDCNT,SENDSTATUS,
MSGFMT,MSGTYPE,TP_PID,TP_UDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PASSTHROUGH,
USERID,SERVICEID,SPGATE,SPNUMBER,PHONE,MSGTITLE,MSGCONTENT,DELIVERTIME)
VALUES(
PIPTMSGID,PIUID,PIORGUID,PIECID,PIUNICOM,PIPTNOTICE,PIRESENDCNT,PISENDSTATUS,
PIMSGFMT,PIMSGTYPE,PITP_PID,PITP_UDHI,PIPKNUMBER,PIPKTOTAL,PILONGMSGSEQ,PIPASSTHROUGH,
PIUSERID,PISERVICEID,PISPGATE,PISPNUMBER,PIPHONE,PIMSGTITLE,PIMSGCONTENT,PIDELIVERTIME);

END  &&



CREATE OR REPLACE  PROCEDURE "S_WR_MMS_RPT"
(
IN PIPTMSGID BIGINT,
IN PISPMSGID BIGINT,
IN PIUSERMSGID BIGINT,

IN PIUID INTEGER,
IN PIORGUID INTEGER,
IN PIECID INTEGER,

IN PISENDLEVEL SMALLINT,
IN PIRESENDCNT SMALLINT,

IN PIUSERID VARCHAR(11),
IN PISPNUMBER VARCHAR(21),
IN PIPHONE VARCHAR(21),
IN PISPMSGID2 VARCHAR(64),
IN PIERRORCODE CHAR(7),
IN PIERRORMSG VARCHAR(256),
IN PISUBMITTIME CHAR(10),
IN PIDONEDATE CHAR(10),
IN PIRECVTIME TIMESTAMP
)

SPECIFIC "S_WR_MMS_RPT"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS

BEGIN
IF NOT EXISTS(SELECT PTMSGID FROM MMS_RPT WHERE PTMSGID=PIPTMSGID) THEN
BEGIN
IF PISPNUMBER='' THEN
SELECT (RTRIM(SPGATE)||RTRIM(CPNO)) INTO PISPNUMBER FROM MMS_TASK WHERE PTMSGID=PIPTMSGID;

INSERT INTO MMS_RPT(
PTMSGID,SPMSGID,USERMSGID,UID,ORGUID,ECID,SENDLEVEL,RESENDCNT,
USERID,SPNUMBER,PHONE,SPMSGID2,ERRORCODE,ERRORMSG,SUBMITTIME,DONEDATE,RECVTIME)
VALUES(
PIPTMSGID,PISPMSGID,PIUSERMSGID,PIUID,PIORGUID,PIECID,PISENDLEVEL,PIRESENDCNT,
PIUSERID,PISPNUMBER,PIPHONE,PISPMSGID2,PIERRORCODE,PIERRORMSG,PISUBMITTIME,PIDONEDATE,PIRECVTIME);
END IF;
END;
END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "S_WR_MMS_TASK"
(
IN PIPTMSGID BIGINT,
IN PISPMSGID BIGINT,
IN PIUSERMSGID BIGINT,
IN PITMPLID BIGINT,
IN PIATTIME BIGINT,
IN PIVALIDTIME BIGINT,

IN PIUID INTEGER,
IN PIECID INTEGER,
IN PITASKID INTEGER,
IN PIMOBILEAREA INTEGER,
IN PIMODULEID INTEGER,

IN PIJTYPE SMALLINT,
IN PIFEEFLAG SMALLINT,
IN PIUNICOM SMALLINT,
IN PIRETFLAG SMALLINT,
IN PISENDTYPE SMALLINT,
IN PISENDLEVEL SMALLINT,
IN PISENDFLAG SMALLINT,
IN PIRECVFLAG SMALLINT,
IN PIRESENDCNT SMALLINT,
IN PISENDSTATUS SMALLINT,

IN PIMSGFMT SMALLINT,
IN PIMSGTYPE SMALLINT,
IN PITPPID SMALLINT,
IN PITPUDHI SMALLINT,
IN PIPKNUMBER SMALLINT,
IN PIPKTOTAL SMALLINT,
IN PILONGMSGSEQ SMALLINT,
IN PIPASSTHROUGH SMALLINT,

IN PIUSERID VARCHAR(11),
IN PISVRTYPE VARCHAR(20),
IN PISPGATE VARCHAR(21),
IN PICPNO VARCHAR(21),
IN PIORDERCPNO VARCHAR(21),

IN PIPHONE VARCHAR(21),
IN PIMSGTITLE VARCHAR(720),
IN PIMESSAGE VARCHAR(3000),
IN PISPMSGID2 VARCHAR(64),
IN PIERRORCODE CHAR(7),
IN PIDONEDATE CHAR(10),

IN PIP1 VARCHAR(64),
IN PIP2 VARCHAR(64),
IN PIP3 VARCHAR(64),
IN PIP4 VARCHAR(64),

IN PIRECVMTTIME TIMESTAMP,
IN PITRANSMTTIME TIMESTAMP,
IN PISENDTIME TIMESTAMP,
IN PIRECVTIME TIMESTAMP,
IN PITRANSRPTTIME TIMESTAMP,
IN PISENDRPTTIME TIMESTAMP,
IN PISPID VARCHAR(32)--=''
)
SPECIFIC "S_WR_MMS_TASK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
	IF PISPID IS NULL THEN
	SET PISPID = '';
	END IF;
IF NOT EXISTS(SELECT PTMSGID FROM MMS_TASK WHERE PTMSGID=PIPTMSGID) THEN
INSERT INTO MMS_TASK(
PTMSGID,SPMSGID,USERMSGID,TMPLID,ATTIME,VALIDTIME,
UID,ECID,TASKID,MOBILEAREA,MODULEID,
JTYPE,FEEFLAG,UNICOM,RETFLAG,SENDTYPE,SENDLEVEL,SENDFLAG,RECVFLAG,RESENDCNT,SENDSTATUS,
MSGFMT,MSGTYPE,TPPID,TPUDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PASSTHROUGH,
USERID,SVRTYPE,SPGATE,CPNO,ORDERCPNO,
PHONE,MSGTITLE,MESSAGE,SPMSGID2,ERRORCODE,DONEDATE,
P1,P2,P3,P4,
RECVMTTIME,TRANSMTTIME,SENDTIME,RECVTIME,TRANSRPTTIME,SENDRPTTIME,SPID)
VALUES(
PIPTMSGID,PISPMSGID,PIUSERMSGID,PITMPLID,PIATTIME,PIVALIDTIME,
PIUID,PIECID,PITASKID,PIMOBILEAREA,PIMODULEID,
PIJTYPE,PIFEEFLAG,PIUNICOM,PIRETFLAG,PISENDTYPE,PISENDLEVEL,PISENDFLAG,PIRECVFLAG,PIRESENDCNT,PISENDSTATUS,
PIMSGFMT,PIMSGTYPE,PITPPID,PITPUDHI,PIPKNUMBER,PIPKTOTAL,PILONGMSGSEQ,PIPASSTHROUGH,
PIUSERID,PISVRTYPE,PISPGATE,PICPNO,PIORDERCPNO,
PIPHONE,PIMSGTITLE,PIMESSAGE,PISPMSGID2,PIERRORCODE,PIDONEDATE,
PIP1,PIP2,PIP3,PIP4,
PIRECVMTTIME,PITRANSMTTIME,PISENDTIME,PIRECVTIME,PITRANSRPTTIME,PISENDRPTTIME,PISPID)  ;
END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "S_UPD_MMS_MTRPT"
	-- ADD THE PARAMETERS FOR THE STORED PROCEDURE HERE --PIOPTYPE INT,
	--1-23
	(PISENDSTATUS INTEGER,
	PIPTMSGID BIGINT,
	PISPMSGID BIGINT,
	PIRECVFLAG INTEGER,
	PIERRORCODE CHAR(7),
	PISUBMITDATE CHAR(10),
	PIDONEDATE CHAR(10),
	PIRECVTIME TIMESTAMP--=''
	)
SPECIFIC "S_UPD_MMS_MTRPT"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
	SET PIRECVTIME=CURRENT TIMESTAMP;
	UPDATE MMS_TASK SET SENDSTATUS = PISENDSTATUS, RECVFLAG = PIRECVFLAG, ERRORCODE = PIERRORCODE, DONEDATE = PIDONEDATE, RECVTIME = PIRECVTIME
	WHERE PTMSGID = PIPTMSGID AND SENDSTATUS<>0;
END  &&

CREATE OR REPLACE  PROCEDURE H_RESTATISTICS
 (
 IN "PIYEAR" INTEGER,
 IN "PIMONTH" INTEGER,
 IN "PIDAY" INTEGER
 )
  SPECIFIC H_RESTATISTICS
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE USERID VARCHAR(11);
	DECLARE TASKID INTEGER;
	DECLARE IYMD INTEGER;
	DECLARE SPGATE VARCHAR(21);
	DECLARE SPISUNCM INTEGER;
	DECLARE SVRTYPE VARCHAR(64);
	DECLARE SPID VARCHAR(21);
	DECLARE P1 VARCHAR(64);
	DECLARE P2 VARCHAR(64);
	DECLARE P3 VARCHAR(64);
	DECLARE P4 VARCHAR(64);
	DECLARE IHOUR INTEGER;
	DECLARE IYEAR INTEGER ;
	DECLARE IMONTH INTEGER;
	DECLARE ICOUNT INTEGER;
	DECLARE SUCC INTEGER;
	DECLARE FAIL INTEGER;
	DECLARE NRET INTEGER;
	DECLARE AREACODE INTEGER;
	DECLARE TABLENAME VARCHAR(34);

	IF PIMONTH>9 THEN
       SET  TABLENAME = 'MTTASK' || TRIM(CHAR(PIYEAR))||TRIM(CHAR(PIMONTH));--CONCAT('MTTASK0',CAST(MONINDEX AS CHAR(1))) ;
    ELSE
       SET  TABLENAME = 'MTTASK' || TRIM(CHAR(PIYEAR))||'0'||TRIM(CHAR(PIMONTH));--CONCAT('MTTASK',CAST(MONINDEX AS CHAR(1))) ;
    END IF;

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS
	( USERID VARCHAR(11),TASKID INTEGER,SPGATE VARCHAR(21),SPISUNCM INTEGER,
	SPID VARCHAR(32),SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),P4 VARCHAR(64),
    IYMD INTEGER,IYEAR INTEGER,IMONTH INTEGER,IHOUR INTEGER,ICOUNT INTEGER,SUCC INTEGER,FAIL INTEGER,
    NRET INTEGER,MOBILEAREA INTEGER,SENDTYPE INTEGER,BATCHID BIGINT,AREACODE INTEGER)
    ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;
		SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
               INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			   VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			         MOBILEAREA,
			         SENDTYPE,BATCHID,AREACODE
               FROM '||TABLENAME||' WHERE INT(DAY(SENDTIME))='||CHAR(PIDAY)||' OR 0='||CHAR(PIDAY)||
               ' GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,MOBILEAREA,SENDTYPE,BATCHID,AREACODE,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';
       EXECUTE IMMEDIATE STR;
       --
      SET STR='MERGE INTO MT_DATAREPORT M
          USING  SESSION.TEMP_STATISTICS  T
          ON(M.USERID   = T.USERID AND
             M.TASKID   = T.TASKID AND
             M.IYMD     = T.IYMD AND
             M.SPGATE   = T.SPGATE AND
             M.SPISUNCM = T.SPISUNCM AND
             M.SPID     = T.SPID AND
             M.SVRTYPE  = T.SVRTYPE AND
             M.P1       = T.P1 AND
             M.P2       = T.P2 AND
             M.P3       = T.P3 AND
             M.P4       = T.P4 AND
             M.IHOUR    = T.IHOUR AND
             M.Y        = T.IYEAR AND
             M.IMONTH   = T.IMONTH AND
             M.MOBILEAREA = T.MOBILEAREA AND
             M.SENDTYPE = T.SENDTYPE AND
             M.BATCHID = T.BATCHID AND
             M.AREACODE = T.AREACODE)
          WHEN MATCHED THEN
               UPDATE SET M.ICOUNT=T.ICOUNT,M.RSUCC=T.SUCC,M.RFAIL1=T.FAIL,M.RFAIL2=(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),M.RNRET=T.NRET
          WHEN NOT MATCHED THEN
               INSERT (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE)
               VALUES(T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,
               T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.MOBILEAREA,T.SENDTYPE,T.BATCHID,T.AREACODE)';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
END  &&


CREATE OR REPLACE  PROCEDURE "A_LOADCMD_ROUTE"()
SPECIFIC "A_LOADCMD_ROUTE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE) AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,R.STATUS,R.MATCHMODE,R.CREATER,R.CREATTIME,U.UID,U.USERID  FROM  A_CMD_ROUTE R
INNER JOIN USERDATA U ON U.UID=R.SP_ID WHERE U.ACCOUNTTYPE=1;
OPEN RS1;
END  &&




CREATE OR REPLACE  PROCEDURE "A_LOADCMD_ROUTE_P"()
--通道指令
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE)AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,U.USERID,R.STATUS,R.MATCHMODE,R.CREATER,
R.CREATTIME,U.UID,R.CMDTYPE,R.CMDPARAM,R.CMDATTRI,R.PUSHURL,R.PUSHPROTOCOL,P.GATEID,P.CMDID,P.STATUS,P.CPNO,P.FAILOPT,
P.DEFCMDID,P.SPNUMBER ,P.ENSIGNSTR, P.ENSIGNLEN,P.ENPREFIXLEN, P.ENMAXWORDS,P.ENSINGLELEN, P.ENMULTILEN1,P.ENMULTILEN2 FROM  A_CMD_ROUTE R
INNER JOIN USERDATA U ON U.UID=R.SP_ID
INNER JOIN (SELECT CP.GATEID AS GATEID,CP.CMDID AS CMDID,CP.STATUS AS STATUS,CP.CPNO AS CPNO ,CP.FAILOPT AS FAILOPT,CP.DEFCMDID AS DEFCMDID, (XT.SPGATE ||TRIM(CHAR(CP.CPNO))) AS SPNUMBER, XT.ENSIGNSTR AS ENSIGNSTR,XT.ENSIGNLEN AS ENSIGNLEN,XT.ENPREFIXLEN AS ENPREFIXLEN,XT.ENMAXWORDS AS ENMAXWORDS,XT.ENSINGLELEN AS ENSINGLELEN,XT.ENMULTILEN1 AS ENMULTILEN1,XT.ENMULTILEN2 AS ENMULTILEN2  FROM A_CMD_PORT CP
            INNER JOIN XT_GATE_QUEUE XT ON XT.ID=CP.GATEID) P ON (R.ID=P.CMDID)
WHERE U.ACCOUNTTYPE=1 AND U.USERTYPE=0 AND P.STATUS=0 AND R.CMDTYPE=1;
OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE "A_LOADCMD_ROUTE_G"()
--全局指令
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE)AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,U.USERID,R.STATUS,R.MATCHMODE,R.CREATER,
R.CREATTIME,U."UID",R.CMDTYPE,R.CMDPARAM,R.CMDATTRI,R.PUSHURL,R.PUSHPROTOCOL  FROM  A_CMD_ROUTE R
INNER JOIN USERDATA U ON U."UID"=R.SP_ID
WHERE U.ACCOUNTTYPE=1 AND U.USERTYPE=0 AND R.CMDTYPE=0;
OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE A_GETSGIPBIND
 (IN "PIUID" INTEGER,
  IN "PITYPE" INTEGER
 )
  SPECIFIC A_GETSGIPBIND
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF PIUID=0 THEN
	P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN FOR
		SELECT UID,USERID,USERPASSWORD AS PWD,SPBINDURL
		FROM USERDATA WHERE USERTYPE=0 AND STATUS=0 AND VALUE(LTRIM(SPBINDURL),'')<>''
		AND TRANSMOTYPE=1 AND TRANSRPTYPE=1 AND ACCOUNTTYPE=PITYPE ORDER BY UID;
		OPEN RS1;
	END P1;
	ELSE
	P2:BEGIN
	DECLARE RS2 CURSOR WITH RETURN FOR
		SELECT UID,USERID,USERPASSWORD AS PWD,SPBINDURL
		FROM USERDATA WHERE USERTYPE=0 AND STATUS=0 AND VALUE(LTRIM(SPBINDURL),'')<>''
		AND TRANSMOTYPE=1 AND TRANSRPTYPE=1 AND UID=PIUID AND ACCOUNTTYPE=PITYPE ORDER BY UID;
	OPEN RS2;
	END P2;
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE H_DELETETASK
 (IN "MININDEX" BIGINT,
  IN "MAXINDEX" BIGINT
 )
  SPECIFIC H_DELETETASK
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	 DELETE  FROM MT_TASK  WHERE (ID <= MAXINDEX)  ;
END  &&

CREATE OR REPLACE  PROCEDURE H_MMSDELTETASK
	(
	  IN PIMININDEX BIGINT,
    IN PIMAXINDEX BIGINT
   )

SPECIFIC H_MMSDELTETASK
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS

BEGIN
	 DELETE  FROM MMS_TASK  WHERE (ID <= PIMAXINDEX)  ;
END  &&


CREATE OR REPLACE  PROCEDURE H_STATISTICS
 (IN "PIPROCESSFLAG" INTEGER
 )
  SPECIFIC H_STATISTICS
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS (
	USERID VARCHAR(11),
	TASKID INTEGER,
	SPGATE VARCHAR(21),
	SPISUNCM INTEGER,
	SPID VARCHAR(32),
	SVRTYPE VARCHAR(64),
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
    IYMD INTEGER,
	IYEAR INTEGER,
	IMONTH INTEGER,
	IHOUR INTEGER,
	ICOUNT INTEGER,
	SUCC INTEGER,
	FAIL INTEGER,
	NRET INTEGER,
	MOBILEAREA INTEGER,
	SENDTYPE INTEGER,
	BATCHID BIGINT,AREACODE INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';

	SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
               INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			         VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			         MOBILEAREA,
			         SENDTYPE,
			         BATCHID,AREACODE
               FROM MT_TASK
               WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
               USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,MOBILEAREA,SENDTYPE,BATCHID,AREACODE,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';

       EXECUTE IMMEDIATE STR;
       --插入或更新统计表
      DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN INT(CURRENT DATE - PIPROCESSFLAG DAYS) AND INT(CURRENT DATE);

      INSERT INTO MT_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET, SENDTYPE, MOBILEAREA,BATCHID,AREACODE)
      SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET, T.SENDTYPE, T.MOBILEAREA,T.BATCHID ,T.AREACODE
      FROM SESSION.TEMP_STATISTICS  T;
   END  &&


CREATE OR REPLACE  PROCEDURE H_MMSSTATISTICS
 (IN "PIPROCESSFLAG" INTEGER
 )
  SPECIFIC H_MMSSTATISTICS
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS
	( USERID VARCHAR(11),TASKID INTEGER,SPGATE VARCHAR(21),SPISUNCM INTEGER,SPID VARCHAR(32),SVRTYPE VARCHAR(64),
	  P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),P4 VARCHAR(64),IYMD INTEGER,IYEAR INTEGER,IMONTH INTEGER,
	  IHOUR INTEGER,ICOUNT INTEGER,SUCC INTEGER,FAIL INTEGER,NRET INTEGER,SENDTYPE INTEGER,MOBILEAREA INTEGER
	  ) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	  SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	  SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';

		SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
               INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			   VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			   SENDTYPE,
			   MOBILEAREA
               FROM MMS_TASK
                WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
                USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,SENDTYPE,MOBILEAREA,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';
       EXECUTE IMMEDIATE STR;
      DELETE FROM MMS_DATAREPORT WHERE IYMD BETWEEN INT(CURRENT DATE - PIPROCESSFLAG DAYS) AND INT(CURRENT DATE);

   INSERT INTO MMS_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA)
   SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA
   FROM SESSION.TEMP_STATISTICS T;

END  &&


CREATE OR REPLACE  PROCEDURE CREATETABLE(PITYPE INTEGER,PIYM INTEGER)
BEGIN

	DECLARE PISTR VARCHAR(4000);
	DECLARE PISTR_1 VARCHAR(256);
	DECLARE PITABLENAME VARCHAR(20);

  IF PITYPE=1 THEN
    SET PITABLENAME='MTTASK'||CAST(PIYM AS CHAR(6));
    SET PISTR='CREATE TABLE '||PITABLENAME||
    '(
    ID         BIGINT NOT NULL,
    MDAY       INTEGER NOT NULL,
    USERID     VARCHAR(11) NOT NULL,
    SPID       VARCHAR(32) NOT NULL DEFAULT '''',
    SPGATE     VARCHAR(21) NOT NULL,
    CPNO       VARCHAR(21) NOT NULL,
    PHONE      VARCHAR(21) NOT NULL,
    SPMSGID    BIGINT NOT NULL,
    RETFLAG    INTEGER NOT NULL,
    FEEFLAG    INTEGER NOT NULL,
    PKNUMBER   INTEGER NOT NULL,
    PKTOTAL    INTEGER NOT NULL,
    SENDSTATUS INTEGER NOT NULL,
    SENDFLAG   INTEGER NOT NULL,
    RECVFLAG   INTEGER NOT NULL,
    DONEDATE   CHAR(10) NOT NULL,
    ERRORCODE  CHAR(7) NOT NULL,
    SENDLEVEL  INTEGER NOT NULL,
    SENDTYPE   INTEGER NOT NULL,
    UNICOM     INTEGER NOT NULL,
    MOBILEAREA INTEGER NOT NULL DEFAULT 0,
    SENDTIME   TIMESTAMP NOT NULL,
    RECVTIME   TIMESTAMP NOT NULL,
    MESSAGE    VARCHAR(3000) NOT NULL,
    TASKID     INTEGER NOT NULL,
    ECID       INTEGER NOT NULL,
    PTMSGID    BIGINT NOT NULL,
    USERMSGID  BIGINT NOT NULL DEFAULT 0,
    MODULEID   INTEGER NOT NULL DEFAULT 0,
    SVRTYPE    VARCHAR(64) NOT NULL DEFAULT '''' ,
    P1         VARCHAR(64) NOT NULL DEFAULT '''' ,
    P2         VARCHAR(64) NOT NULL DEFAULT '''' ,
    P3         VARCHAR(64) NOT NULL DEFAULT '''' ,
    P4         VARCHAR(64) NOT NULL DEFAULT '''' ,
    ATTIME     BIGINT NOT NULL DEFAULT 0,
    VALIDTIME  BIGINT NOT NULL DEFAULT 0,
    BATCHID    BIGINT NOT NULL DEFAULT 0,
    AREACODE  INTEGER NOT NULL DEFAULT 0,
    CUSTID VARCHAR(64) NOT NULL DEFAULT '''',
    EXDATA VARCHAR(64) NOT NULL DEFAULT '''',
    LONGMSG VARCHAR(4000) NOT NULL DEFAULT '''' ,
    TMPLID BIGINT NOT NULL DEFAULT 0,
    CHGRADE SMALLINT NOT NULL DEFAULT 0,
    MSGTYPE SMALLINT NOT NULL DEFAULT 0,
    RMSVALIDTM SMALLINT NOT NULL DEFAULT 0,
    ERRORCODE2 CHARACTER(7) NOT NULL DEFAULT '''' ,
    DOWNTM TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
	RMSRPTFLAG SMALLINT NOT NULL DEFAULT 1,
	PROTOCOLVER SMALLINT NOT NULL DEFAULT 0,
	TMPLTYPE SMALLINT NOT NULL DEFAULT 0,
	TITLE	 VARCHAR(40) NOT NULL DEFAULT '''' ,
	SHOWAY	 VARCHAR(16) NOT NULL DEFAULT '''' ,
	DLDWAY     INTEGER         NOT NULL  DEFAULT 0,
	DLDNEY     INTEGER         NOT NULL  DEFAULT 0,
	ISFREE     INTEGER         NOT NULL  DEFAULT 0,
	SHOWTIME   BIGINT NOT NULL DEFAULT 0,
	SUID1	 VARCHAR(64) NOT NULL DEFAULT '''' ,
	LUID1	 VARCHAR(64) NOT NULL DEFAULT ''''
    )
      DATA CAPTURE NONE
    IN TBSPHISTORY';

	EXECUTE IMMEDIATE PISTR;

   SET PISTR_1= 'ALTER TABLE '||PITABLENAME||
    ' LOCKSIZE ROW
    APPEND OFF
    NOT VOLATILE
    LOG INDEX BUILD NULL';

	 EXECUTE IMMEDIATE PISTR_1;


    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_P1 ON '||PITABLENAME||'(P1)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE UNIQUE INDEX IX_'||PITABLENAME||'_PTID ON '||PITABLENAME||'(PTMSGID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_SVRTYPE ON '||PITABLENAME||'(SVRTYPE)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||'(TASKID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_SENDTIME ON '||PITABLENAME||'(SENDTIME)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_UID ON '||PITABLENAME||'(USERID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_BATCHID ON '||PITABLENAME||'(BATCHID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'AREACODE ON '||PITABLENAME||'(AREACODE)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'PHONE ON '||PITABLENAME||'(PHONE)';
    EXECUTE IMMEDIATE PISTR_1;

  ELSEIF PITYPE=2 THEN
    SET PITABLENAME='MMSTASK'||CAST(PIYM AS CHAR(6));
    SET PISTR='CREATE TABLE '||PITABLENAME||
    '(
    ID          BIGINT NOT NULL,
    MDAY        INTEGER DEFAULT 0 NOT NULL,
    USERID      VARCHAR(11) NOT NULL DEFAULT '''',
    SPGATE      VARCHAR(21) NOT NULL DEFAULT '''',
    CPNO        VARCHAR(21) NOT NULL DEFAULT '''',
    PHONE       VARCHAR(21) NOT NULL DEFAULT '''',
    SPMSGID     BIGINT DEFAULT 0 NOT NULL,
    RETFLAG     INTEGER DEFAULT 0 NOT NULL,
    FEEFLAG     INTEGER DEFAULT 0 NOT NULL,
    PKNUMBER    INTEGER DEFAULT 0 NOT NULL,
    PKTOTAL     INTEGER DEFAULT 0 NOT NULL,
    SENDSTATUS  INTEGER DEFAULT 0 NOT NULL,
    SENDFLAG    INTEGER DEFAULT 0 NOT NULL,
    RECVFLAG    INTEGER DEFAULT 0 NOT NULL,
    DONEDATE    VARCHAR(10) NOT NULL DEFAULT '''',
    ERRORCODE   VARCHAR(7)  NOT NULL DEFAULT '''' ,
    SENDLEVEL   INTEGER NOT NULL DEFAULT 0,
    SENDTYPE    INTEGER NOT NULL DEFAULT 0,
    UNICOM      INTEGER NOT NULL DEFAULT 0,
    SENDTIME    TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
    RECVTIME    TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
    MESSAGE     VARCHAR(3000) NOT NULL DEFAULT '''',
    TASKID      INTEGER NOT NULL DEFAULT 0,
    ECID        INTEGER NOT NULL DEFAULT 0,
    PTMSGID     BIGINT  NOT NULL DEFAULT 0,
    SPID        VARCHAR(32) NOT NULL DEFAULT '''',
    MOBILEAREA  INTEGER NOT NULL DEFAULT 0,
    SVRTYPE     VARCHAR(64) NOT NULL DEFAULT '''',
    P1          VARCHAR(64) NOT NULL DEFAULT '''',
    P2          VARCHAR(64) NOT NULL DEFAULT '''',
    P3          VARCHAR(64) NOT NULL DEFAULT '''',
    P4          VARCHAR(64) NOT NULL DEFAULT '''',
    USERMSGID   BIGINT  NOT NULL DEFAULT 0,
    MODULEID    INTEGER NOT NULL DEFAULT 0,
    ATTIME      BIGINT  NOT NULL DEFAULT 0,
    VALIDTIME   BIGINT  NOT NULL DEFAULT 0,
    SPMSGID2    VARCHAR(64) NOT NULL DEFAULT '''',
    JTYPE       INTEGER NOT NULL DEFAULT 0,
    ORDERCPNO   VARCHAR(21) NOT NULL DEFAULT '''',
    PASSTHROUGH INTEGER NOT NULL DEFAULT 0,
    MSGTITLE    VARCHAR(720) NOT NULL DEFAULT '''',
    TMPLID      BIGINT NOT NULL DEFAULT 0,
    MSGTYPE     INTEGER NOT NULL DEFAULT 0,
    ERRORMSG    VARCHAR(256) NOT NULL DEFAULT ''''
    )
      DATA CAPTURE NONE
    IN TBSPHISTORY';
	EXECUTE IMMEDIATE PISTR;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||
    ' LOCKSIZE ROW
    APPEND OFF
    NOT VOLATILE
    LOG INDEX BUILD NULL';

    EXECUTE IMMEDIATE PISTR_1;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT PK_'||PITABLENAME||' PRIMARY KEY (ID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_P1 ON '||PITABLENAME||' (P1)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE UNIQUE INDEX IX_'||PITABLENAME||'_PTMSGID ON '||PITABLENAME||' (PTMSGID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_SENDTIME ON '||PITABLENAME||' (SENDTIME)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_SVRTYPE ON '||PITABLENAME||' (SVRTYPE)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||' (TASKID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_USERID ON '||PITABLENAME||' (USERID)';
    EXECUTE IMMEDIATE PISTR_1;

  ELSEIF PITYPE=3 THEN
    SET PITABLENAME='MOTASK'||CAST(PIYM AS CHAR(6));
    SET PISTR='CREATE TABLE '||PITABLENAME||
    '(
    ID          BIGINT NOT NULL,
    "UID"       INTEGER NOT NULL,
    USERID      VARCHAR(11) NOT NULL,
    SPNUMBER    VARCHAR(21) NOT NULL,
    SERVICEID   VARCHAR(10) NOT NULL,
    SENDSTATUS  INTEGER NOT NULL,
    DELIVERTIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
    PHONE       VARCHAR(21) NOT NULL,
    MSGCONTENT  VARCHAR(3000) NOT NULL,
    ECID        INTEGER NOT NULL,
    ORGUID      INTEGER NOT NULL,
    PTMSGID     BIGINT NOT NULL,
    TP_PID      INTEGER NOT NULL,
    TP_UDHI     INTEGER NOT NULL,
    MSGFMT      INTEGER NOT NULL,
    UNICOM      INTEGER NOT NULL DEFAULT 0
    )
      DATA CAPTURE NONE
    IN TBSPHISTORY';

	EXECUTE IMMEDIATE PISTR;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||
    ' LOCKSIZE ROW
    APPEND OFF
    NOT VOLATILE
    LOG INDEX BUILD NULL';

    EXECUTE IMMEDIATE PISTR_1;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT '||PITABLENAME||'_PRIMARY PRIMARY KEY (ID)';
    EXECUTE IMMEDIATE PISTR_1;
  ELSE
     SET PITABLENAME='MMSMOTASK'||CAST(PIYM AS CHAR(6));
     SET PISTR='CREATE TABLE '||PITABLENAME||
     '(
      ID          BIGINT NOT NULL,
      "UID"         INTEGER NOT NULL DEFAULT 0,
      USERID      VARCHAR(11) NOT NULL DEFAULT '''',
      SPNUMBER    VARCHAR(11) NOT NULL DEFAULT '''',
      SERVICEID   VARCHAR(10) NOT NULL DEFAULT '''',
      SENDSTATUS  INTEGER NOT NULL DEFAULT 0,
      DELIVERTIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
      PHONE       VARCHAR(21) NOT NULL DEFAULT '''',
      MSGCONTENT  VARCHAR(3000) NOT NULL DEFAULT '''',
      ECID        INTEGER NOT NULL DEFAULT 0,
      ORGUID      INTEGER NOT NULL DEFAULT 0,
      PTMSGID     BIGINT NOT NULL DEFAULT 0,
      TP_PID      INTEGER NOT NULL DEFAULT 0,
      TP_UDHI     INTEGER NOT NULL DEFAULT 0,
      MSGFMT      INTEGER NOT NULL DEFAULT 15,
      UNICOM      INTEGER NOT NULL DEFAULT 0 ,
      MSGTYPE     INTEGER NOT NULL DEFAULT 0 ,
      MSGTITLE    VARCHAR(200) NOT NULL DEFAULT '''',
      PASSTHROUGH INTEGER NOT NULL DEFAULT 0
    )
      DATA CAPTURE NONE
    IN TBSPHISTORY';

	EXECUTE IMMEDIATE PISTR;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||
    ' LOCKSIZE ROW
    APPEND OFF
    NOT VOLATILE
    LOG INDEX BUILD NULL';

    EXECUTE IMMEDIATE PISTR_1;

    SET PISTR_1='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT PK_'||PITABLENAME||' PRIMARY KEY (ID)';
    EXECUTE IMMEDIATE PISTR_1;
  END IF;
  END  &&


CREATE OR REPLACE  PROCEDURE H_TRANSFER
 (IN "PIMININDEX" BIGINT,
  IN "PIMAXINDEX" BIGINT
 )
  SPECIFIC H_TRANSFER
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN

	DECLARE	PISTR VARCHAR(4000);
	DECLARE	PITABLENAME VARCHAR(20);
	DECLARE	MINYM INTEGER;
	DECLARE	MAXYM INTEGER;
	DECLARE	CURYM INTEGER;
  DECLARE MAXTIME VARCHAR(32);
  DECLARE MINTIME VARCHAR(32);
	DECLARE BEGTIME VARCHAR(32);
  DECLARE ENDTIME VARCHAR(32);
  --------------------VER 3.1-------------------------------------
  SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MT_TASK WHERE ID BETWEEN PIMININDEX AND PIMAXINDEX;

  SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
  SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);

  --转移
  SET CURYM = MINYM;
  WHILE CURYM<=MAXYM DO

  IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<>12 THEN
	    SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	    IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<9 THEN
	      SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-0'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		ELSE
		  SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		END IF;
	  ELSE
	      SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	      SET ENDTIME = TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),1,4))+1))||'-'||'01'||'-'||'01 00:00:00.000000';
	  END IF;

      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));

      SET PISTR= 'INSERT INTO '||PITABLENAME||' (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
                SELECT ID,INT(DAY(M.SENDTIME)),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
                FROM MT_TASK M
                WHERE SENDTIME>='''||BEGTIME||''' AND SENDTIME<'''||ENDTIME||''' AND (M.ID <='||CHAR(PIMAXINDEX)||')  ';
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)=12 THEN
        SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
      ELSE
        SET CURYM = CURYM+1;
      END IF;
  END WHILE;
END  &&




CREATE OR REPLACE  PROCEDURE H_MMSTRANSFER
 (IN "PIMININDEX" BIGINT,
  IN "PIMAXINDEX" BIGINT
 )
  SPECIFIC H_MMSTRANSFER
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  DECLARE	PISTR VARCHAR(4000);
	DECLARE	PITABLENAME VARCHAR(20);
	DECLARE	MINYM INTEGER;
	DECLARE	MAXYM INTEGER;
	DECLARE	CURYM INTEGER;
	DECLARE MAXTIME VARCHAR(32);
  DECLARE MINTIME VARCHAR(32);
	DECLARE BEGTIME VARCHAR(32);
  DECLARE ENDTIME VARCHAR(32);
  --------------------VER 3.1-------------------------------------
  SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MMS_TASK WHERE ID BETWEEN PIMININDEX AND PIMAXINDEX;

  SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
  SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);

  --转移
  SET CURYM = MINYM;
  WHILE CURYM<=MAXYM DO

  IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<>12 THEN
	    SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	    IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<9 THEN
	      SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-0'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		ELSE
		  SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		END IF;
	  ELSE
	      SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	      SET ENDTIME = TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),1,4))+1))||'-'||'01'||'-'||'01 00:00:00.000000';
	  END IF;

      SET PITABLENAME = 'MMSTASK'||CAST(CURYM AS CHAR(6));

      SET PISTR='INSERT INTO '||PITABLENAME||' (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
                SELECT ID,INT(DAY(M.SENDTIME)),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME
                FROM MMS_TASK M
                WHERE SENDTIME>='''||BEGTIME||''' AND SENDTIME<'''||ENDTIME||''' AND (M.ID <='||CHAR(PIMAXINDEX)||')  ';
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)=12 THEN
        SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
      ELSE
        SET CURYM = CURYM+1;
      END IF;
  END WHILE;
END  &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='TRANS_LOG') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE TRANS_LOG (
ID BIGINT NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 20, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
USETYPE VARCHAR(8) NOT NULL DEFAULT ''短信'',
TRANSNAME VARCHAR(64) DEFAULT '''' NOT NULL,
TSTATUS VARCHAR(4000) DEFAULT '''' NOT NULL,
CREATETIME TIMESTAMP DEFAULT CURRENT TIMESTAMP NOT NULL,
RUNFLAG INTEGER DEFAULT 0 NOT NULL
)DATA CAPTURE NONE
 IN "TBSPHISTORY"';
	  END;
END IF;
END  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_MSGTAIL') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_MSGTAIL"(
TAIL_ID BIGINT NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER),
TAIL_NAME VARCHAR(64)	NOT NULL DEFAULT '''',
CONTENT VARCHAR (512)   NOT NULL DEFAULT '''',
CREATE_TIME TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
UPDATE_TIME TIMESTAMP	NOT NULL DEFAULT CURRENT TIMESTAMP,
CORP_CODE VARCHAR(64)  NOT NULL DEFAULT '''',
USER_ID	BIGINT	NOT NULL DEFAULT 0
)
 DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MSGTAIL' AND INDNAME='IX_MSGTAIL_TI') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_MSGTAIL_TI"
  ON  "GW_MSGTAIL"
 (
  "TAIL_ID"
 ) ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_MSGTAIL' AND INDNAME='IX_MSGTAIL_CC') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_MSGTAIL_CC"
  ON  "GW_MSGTAIL"
 (
  "CORP_CODE"
 )  ';
        END;
END IF;
END  &&

ALTER TABLE  "GW_MSGTAIL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_TAILBIND') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_TAILBIND"(
ID BIGINT NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER),
TAIL_ID	 BIGINT NOT NULL DEFAULT 0,
BUS_CODE VARCHAR(64) NOT NULL DEFAULT '''',
SPUSERID VARCHAR(11) NOT NULL DEFAULT '''',
TAIL_TYPE SMALLINT NOT NULL DEFAULT 0,
CORP_CODE VARCHAR(64) NOT NULL DEFAULT '''',
CREATE_TIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
UPDATE_TIME TIMESTAMP  NOT NULL DEFAULT CURRENT TIMESTAMP,
USER_ID	 BIGINT	NOT NULL DEFAULT 0
)
 DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX"';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_TAILBIND' AND INDNAME='IX_TAILBIND_CC') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_TAILBIND_CC"
  ON  "GW_TAILBIND"
 (
  "CORP_CODE"
 )  ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_TAILBIND' AND INDNAME='IX_TAILBIND_TI') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_TAILBIND_TI"
  ON  "GW_TAILBIND"
 ("TAIL_ID"
 ) ';
        END;
END IF;
END  &&


ALTER TABLE  "GW_TAILBIND"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_TAILCTRL') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_TAILCTRL"(
ID BIGINT NOT NULL GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER),
OVERTAILFLAG SMALLINT NOT NULL DEFAULT 0,
OTHERTAILFLAG SMALLINT NOT NULL DEFAULT 0,
CREATE_TIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
UPDATE_TIME TIMESTAMP NOT NULL DEFAULT CURRENT TIMESTAMP,
CORP_CODE VARCHAR(64) NOT NULL DEFAULT '''',
USER_ID	 BIGINT	NOT NULL DEFAULT 0
)
 DATA CAPTURE NONE
 IN "TBSPSVRDATA"
 INDEX IN "TBSPSVRINDEX" ';
	  END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_TAILCTRL' AND INDNAME='IX_TAILCTRL_CC') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_TAILCTRL_CC"
  ON  "GW_TAILCTRL"
 ("CORP_CODE"
 )
  CLUSTER
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
END  &&


ALTER TABLE  "GW_TAILCTRL"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


CREATE OR REPLACE  PROCEDURE "GW_RTAILCTRL" ( )
  SPECIFIC "GW_RTAILCTRL"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     DECLARE RS1 CURSOR WITH RETURN FOR
     SELECT OVERTAILFLAG,OTHERTAILFLAG,CORP_CODE FROM GW_TAILCTRL;
	 OPEN RS1;
  END  &&

CREATE OR REPLACE  PROCEDURE "GW_RBINDINFO" ( )
  SPECIFIC "GW_RBINDINFO"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
      DECLARE RS1 CURSOR WITH RETURN FOR
      SELECT A.TAIL_ID,B.CONTENT,A.CORP_CODE,A.BUS_CODE,A.SPUSERID,A.TAIL_TYPE
      FROM GW_TAILBIND A INNER JOIN GW_MSGTAIL B ON A.TAIL_ID=B.TAIL_ID;
	  OPEN RS1;
  END  &&

CREATE OR REPLACE  PROCEDURE "GW_LFSPECBIND" ( )
  SPECIFIC "GW_LFSPECBIND"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(1000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT SPUSER,CORP_CODE FROM LF_SP_DEP_BIND WHERE IS_VALIDATE=1';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;

  END  &&

CREATE OR REPLACE  PROCEDURE H_TRANSFERMO ( )
  SPECIFIC H_TRANSFERMO
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PICURRINDEX BIGINT;
  DECLARE PIMAXINDEX BIGINT;
  DECLARE PIPROCESSFLAG INTEGER;
  DECLARE STR VARCHAR(4000);
  DECLARE STR_1 VARCHAR(4000);
  DECLARE TABLENAME VARCHAR(20);
  DECLARE ISEXIST INTEGER;
  DECLARE PIMONINDEX INTEGER;

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

  --创建临时表
  DECLARE GLOBAL TEMPORARY TABLE SESSION.MO_TEMP_STATISTICS(
              USERID VARCHAR(11),
              SPGATE VARCHAR(21),
              SPISUNCM INTEGER,
              IYMD INTEGER,
              IYEAR INTEGER,
              IMONTH INTEGER,
              IHOUR INTEGER,
              ICOUNT INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;
  --------------------VER 3.2-------------------------------------
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PIPROCESSFLAG           = 3;
  SET PIMONINDEX              = 1;

  --SET SQLCODE               = 0;

  SELECT VALUE(MIN(ID),0),VALUE(MAX(ID), 0),MIN(DELIVERTIME),MAX(DELIVERTIME) INTO PICURRINDEX,PIMAXINDEX,MINTIME,MAXTIME  FROM MO_TASK
  WHERE  DELIVERTIME< TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG  DAYS) AS CHAR(32)))||' 00:00:00.000000');

  --判断是否有数据
  IF(PIMAXINDEX <> 0) THEN
  BEGIN
  SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
  SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
  --创建不存在的历史表
  SET CURYM=MINYM;
  WHILE CURYM<=MAXYM DO
      SET PITABLENAME = 'MOTASK'||CAST(CURYM AS CHAR(6));
      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

      IF ISEXIST<1 THEN
        SET STR='CALL CREATETABLE (3,'||CAST(CURYM AS CHAR(6))||')';
        EXECUTE IMMEDIATE STR;
		IF PIERROR <> '' THEN
		  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行历史表创建：CREATETABLE',PIERROR);
	    END IF;
      END IF;

	  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
          SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
      ELSE
          SET CURYM = CURYM+1;
      END IF;
  END WHILE;
      --统计

       SET  STR =' INSERT INTO SESSION.MO_TEMP_STATISTICS (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
	   		  SELECT USERID,SPNUMBER,UNICOM,
              INT(DATE(DELIVERTIME)) AS IYMD,
              INT(YEAR(DELIVERTIME)) AS IYEAR,
              INT(MONTH(DELIVERTIME)) AS MON,
              INT(HOUR(DELIVERTIME)) AS HOUR,
              COUNT(ID)
              FROM MO_TASK
              WHERE DELIVERTIME< TIMESTAMP(TRIM(CAST(DATE(CURRENT TIMESTAMP) AS VARCHAR(32)))||'' 00:00:00.000000'')
              GROUP BY  USERID,SPNUMBER,UNICOM,
               INT(DATE(DELIVERTIME)),
               INT(YEAR(DELIVERTIME)),
               INT(MONTH(DELIVERTIME)),
               INT(HOUR(DELIVERTIME))';

                EXECUTE IMMEDIATE STR;
         --插入或更新统计表
        SET STR = 'MERGE INTO MO_DATAREPORT M
                 USING  SESSION.MO_TEMP_STATISTICS T
                 ON(UCASE(M.USERID) = UCASE(T.USERID) AND
                    M.SPGATE = T.SPGATE AND
                    M.SPISUNCM = T.SPISUNCM AND
                    M.IYMD = T.IYMD AND
                    M.IYEAR = T.IYEAR AND
                    M.IMONTH = T.IMONTH AND
                    M.IHOUR = T.IHOUR)
                 WHEN MATCHED THEN
                      UPDATE SET M.ICOUNT = T.ICOUNT
                 WHEN NOT MATCHED THEN
                      INSERT (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
                      VALUES(T.USERID,T.SPGATE,T.SPISUNCM,T.IYMD,T.IYEAR,T.IMONTH,T.IHOUR,T.ICOUNT)';
		  EXECUTE IMMEDIATE STR;

		  IF PIERROR <> '' THEN
	        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行汇总',PIERROR);
	      END IF;


          --转移
   SET CURYM = MINYM;
   WHILE CURYM<=MAXYM DO
      SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
      SET PITABLENAME = 'MOTASK'||CAST(CURYM AS CHAR(6));

      SET STR = 'INSERT INTO '||PITABLENAME||' SELECT  M.ID,"UID",USERID,SPNUMBER,SERVICEID,SENDSTATUS,DELIVERTIME,PHONE,MSGCONTENT,ECID,ORGUID,PTMSGID,TP_PID,TP_UDHI,MSGFMT,UNICOM
                            FROM MO_TASK M
                            WHERE (CAST(SUBSTR(CHAR(M.DELIVERTIME),1,4)||SUBSTR(CHAR(M.DELIVERTIME),6,2)AS INT) ='||CHAR(CURYM)||') AND TRIM(CAST(M.DELIVERTIME AS VARCHAR(32))) < TRIM(CAST(DATE(CURRENT TIMESTAMP - '||CHAR(PIPROCESSFLAG)||'  DAYS) AS VARCHAR(32))) ';
      SET STR_1 ='DELETE FROM MO_TASK WHERE (CAST(SUBSTR(CHAR(DELIVERTIME),1,4)||SUBSTR(CHAR(DELIVERTIME),6,2)AS INT) ='||CHAR(CURYM)||') AND TRIM(CAST(DELIVERTIME AS VARCHAR(32))) < TRIM(CAST(DATE(CURRENT TIMESTAMP - '||CHAR(PIPROCESSFLAG)||'  DAYS) AS VARCHAR(32))) ';
	  EXECUTE IMMEDIATE STR;
      EXECUTE IMMEDIATE STR_1;

	  IF PIERROR <> '' THEN
	    ROLLBACK TO SAVEPOINT A;--事务回滚
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行数据转移',PIERROR);
	  END IF;
	  COMMIT;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)=12 THEN
        SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
      ELSE
        SET CURYM = CURYM+1;
      END IF;
   END WHILE;

    END ;
    END IF;
END NAP  &&

CREATE OR REPLACE  PROCEDURE H_DATATRANSFER ( )
  SPECIFIC H_DATATRANSFER
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  DECLARE PIUSEID                 INTEGER; --使用哪一个USEID作为当前状态处理
  DECLARE PICURRINDEX             BIGINT; --当前处理位置
  DECLARE PIMAXINDEX              BIGINT; --此次执行的最大位置
  DECLARE PICOUNTSTATUS           INTEGER; --统计状态0:正常,1:错误
  DECLARE PIDISTRACTSTATUS        INTEGER; --数据转移状态0:正常,1:错误
  DECLARE PIDELETESTATUS          INTEGER; --删除状态0:正常,1:错误
  DECLARE PIPROCESSFLAG           INTEGER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,

  --异常退出
  DECLARE PICOUNTEXCEPTION        INTEGER; --允许统计异常最大值
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --允许数据转移异常最大值
  DECLARE PIDELETEEXCEPTION       INTEGER; --允许删除数据异常最大值
  DECLARE PIALLEXCEPTION          INTEGER; --允许所有异常最大值

  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

--------------------VER 3.2------------------------------------
--初始化
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 1;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  SET PIPROCESSFLAG           = 3;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;

      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行开始');

      --先汇总
      SELECT VALUE(MIN(ID),0),VALUE(MAX(ID),0)INTO PICURRINDEX,PIMAXINDEX  FROM MT_TASK
      WHERE SENDTIME>= TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') AND SENDTIME < TIMESTAMP (TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000');

	  CALL H_STATISTICS(PIPROCESSFLAG);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总H_STATISTICS',PIERROR);
	  END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
       BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
	  END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     --转移符合当前时间的数据
     SELECT VALUE(MAX(ID),0) INTO PIMAXINDEX FROM MT_TASK  WHERE  SENDTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MT_TASK  WHERE ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		  --创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL   H_TRANSFER(PI_MININDEX,PI_CURINDEX);
       CALL   H_DELETETASK(PI_MININDEX,PI_CURINDEX);
       CALL   H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
	      SET  PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF; --END OF IF PIERROR <> '' THEN
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_TRANSFERMO();

	--删除短信文件请求历史表数据
	DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
    END IF;

	IF DAY(CURRENT DATE)=1 THEN
	  DELETE FROM MO_WAIT_A WHERE DELIVERTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
	  END IF;

      DELETE FROM RPT_WAIT_A WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
	  END IF;

      DELETE FROM RPT_WAIT_B WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
	  END IF;

	END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行结束');
END NAP   &&


CREATE OR REPLACE  PROCEDURE H_MMSTRANSFERMO ( )
  SPECIFIC H_MMSTRANSFERMO
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PICURRINDEX BIGINT;
  DECLARE PIMAXINDEX BIGINT;
  DECLARE STR VARCHAR(4000);
  DECLARE STR_1 VARCHAR(4000);
  DECLARE TABLENAME VARCHAR(20);
  DECLARE ISEXIST INTEGER;
  DECLARE PIMONINDEX INTEGER;


  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;

  --错误代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;


  DECLARE GLOBAL TEMPORARY TABLE SESSION.MO_TEMP_STATISTICS(
              USERID VARCHAR(11),
              SPGATE VARCHAR(21),
              SPISUNCM INTEGER,
              IYMD INTEGER,
              IYEAR INTEGER,
              IMONTH INTEGER,
              IHOUR INTEGER,
              ICOUNT INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;
  --------------------VER 3.2-------------------------------------
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  --SET PROCESSFLAG           = 0;
  SET PIMONINDEX              = 1;
  --SET SQLCODE               = 0;

  SELECT VALUE(MIN(ID),0),VALUE(MAX(ID), 0),MIN(DELIVERTIME),MAX(DELIVERTIME) INTO PICURRINDEX,PIMAXINDEX,MINTIME,MAXTIME  FROM MMS_MO
  WHERE  DELIVERTIME< TIMESTAMP(TRIM(CAST(DATE(CURRENT TIMESTAMP) AS VARCHAR(32)))||' 00:00:00.000000');

  IF(PIMAXINDEX <> 0) THEN
  BEGIN
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
	    SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		  --创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MMSMOTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		      IF ISEXIST<1 THEN
		        SET STR='CALL CREATETABLE (4,'||CAST(CURYM AS CHAR(6))||')';
		        EXECUTE IMMEDIATE STR;
				IF PIERROR <> '' THEN
		          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行历史表创建：CREATETABLE',PIERROR);
	            END IF;
		      END IF;

			  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		          SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		      ELSE
		          SET CURYM = CURYM+1;
		      END IF;
		 END WHILE;

         SET  STR =' INSERT INTO SESSION.MO_TEMP_STATISTICS (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
	   		  SELECT USERID,SPNUMBER,UNICOM,
              INT(DATE(DELIVERTIME)) AS IYMD,
              INT(YEAR(DELIVERTIME)) AS IYEAR,
              INT(MONTH(DELIVERTIME)) AS MON,
              INT(HOUR(DELIVERTIME)) AS HOUR,
              COUNT(ID)
              FROM MMS_MO
              WHERE DELIVERTIME< TIMESTAMP(TRIM(CAST(DATE(CURRENT TIMESTAMP) AS VARCHAR(32)))||'' 00:00:00.000000'')
              GROUP BY  USERID,SPNUMBER,UNICOM,
               INT(DATE(DELIVERTIME)),
               INT(YEAR(DELIVERTIME)),
               INT(MONTH(DELIVERTIME)),
               INT(HOUR(DELIVERTIME))';

                EXECUTE IMMEDIATE STR;

        SET STR = 'MERGE INTO MMS_MODATAREPORT M
                 USING  SESSION.MO_TEMP_STATISTICS T
                 ON(UCASE(M.USERID) = UCASE(T.USERID) AND
                    M.SPGATE = T.SPGATE AND
                    M.SPISUNCM = T.SPISUNCM AND
                    M.IYMD = T.IYMD AND
                    M.IYEAR = T.IYEAR AND
                    M.IMONTH = T.IMONTH AND
                    M.IHOUR = T.IHOUR)
                 WHEN MATCHED THEN
                      UPDATE SET M.ICOUNT = T.ICOUNT
                 WHEN NOT MATCHED THEN
                      INSERT (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
                      VALUES(T.USERID,T.SPGATE,T.SPISUNCM,T.IYMD,T.IYEAR,T.IMONTH,T.IHOUR,T.ICOUNT)';
       EXECUTE IMMEDIATE STR;

       IF PIERROR <> '' THEN
	        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行汇总',PIERROR);
	   END IF;


	   --转移
	   SET CURYM = MINYM;
	   WHILE CURYM<=MAXYM DO
	      SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
	      SET PITABLENAME = 'MMSMOTASK'||CAST(CURYM AS CHAR(6));

	      SET STR = 'INSERT INTO '||PITABLENAME||' SELECT   ID,"UID",USERID,SPNUMBER,SERVICEID,SENDSTATUS,DELIVERTIME,PHONE,MSGCONTENT,ECID,ORGUID,PTMSGID,TP_PID,TP_UDHI,MSGFMT,UNICOM,MSGTYPE,MSGTITLE,PASSTHROUGH
                            FROM MMS_MO M
	                            WHERE (CAST(SUBSTR(CHAR(M.DELIVERTIME),1,4)||SUBSTR(CHAR(M.DELIVERTIME),6,2)AS INT) ='||CHAR(CURYM)||') AND TRIM(CAST(M.DELIVERTIME AS VARCHAR(32))) < TRIM(CAST(DATE(CURRENT TIMESTAMP) AS VARCHAR(32))) ';

		  SET STR_1 ='DELETE FROM MMS_MO WHERE (CAST(SUBSTR(CHAR(DELIVERTIME),1,4)||SUBSTR(CHAR(DELIVERTIME),6,2)AS INT) ='||CHAR(CURYM)||') AND TRIM(CAST(DELIVERTIME AS VARCHAR(32))) < TRIM(CAST(DATE(CURRENT TIMESTAMP) AS VARCHAR(32))) ';
		  EXECUTE IMMEDIATE STR;
	      EXECUTE IMMEDIATE STR_1;

		  IF PIERROR <> '' THEN
		    ROLLBACK TO SAVEPOINT A;
	        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行数据转移',PIERROR);
	      END IF;
		  COMMIT;

	      IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)=12 THEN
	        SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
	      ELSE
	        SET CURYM = CURYM+1;
	      END IF;
	   END WHILE;

    END ;
    END IF;
END NAP  &&

CREATE OR REPLACE  PROCEDURE H_MMSDATATRANSF
 (IN "PIPROCESSFLAG" INTEGER
 )
  SPECIFIC H_MMSDATATRANSF
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS(USEID,1)
  DECLARE PIUSEID                 INTEGER; --USEID
  DECLARE PICURRINDEX             BIGINT; --
  DECLARE PIMAXINDEX              BIGINT; --
  DECLARE PICOUNTSTATUS           INTEGER; --0:,1:
  DECLARE PIDISTRACTSTATUS        INTEGER; --0:,1:
  DECLARE PIDELETESTATUS          INTEGER; --0:,1:
  --
  DECLARE PICOUNTEXCEPTION        INTEGER; --
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --
  DECLARE PIDELETEEXCEPTION       INTEGER; --
  DECLARE PIALLEXCEPTION          INTEGER; --
  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;
--------------------VER 3.2-------------------------------------
--
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 2;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  --SET PIPROCESSFLAG           = 2;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;
  --SET PITRANSFERFLAG          = 0;
  --SET SQLCODE               = 0;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','H_MMSDATATRANSF','彩信汇总调度存储过程执行开始');

      SELECT VALUE(MIN(ID),0),VALUE(MAX(ID),0)INTO PICURRINDEX,PIMAXINDEX  FROM MMS_TASK
      WHERE SENDTIME>= TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') AND SENDTIME < TIMESTAMP (TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000');
      CALL H_MMSSTATISTICS(PIPROCESSFLAG);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行汇总H_MMSSTATISTICS',PIERROR);
	  END IF;

      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
	   BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
		END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     SELECT VALUE(MAX(ID),0) INTO PIMAXINDEX FROM MMS_TASK  WHERE  SENDTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
     --判断是否存在未转移的数据
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MMS_TASK  WHERE  ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		--创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MMSTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (2,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL  H_MMSTRANSFER(PI_MININDEX,PI_CURINDEX);
       CALL  H_MMSDELTETASK(PI_MININDEX,PI_CURINDEX);
       CALL  H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行数据转移',PIERROR);
	      SET PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF;
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_MMSTRANSFERMO();

	--删除彩信文件请求历史表数据
	DELETE FROM MMS_BMTREQHIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_BMTREQHIS表记录',PIERROR);
  END IF;

  IF DAY(CURRENT DATE)=1 THEN
  DELETE FROM MMS_RPT WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
    IF PIERROR <> '' THEN
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_RPT表记录',PIERROR);
    END IF;
  END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','H_MMSDATATRANSF','彩信汇总调度存储过程执行结束');
END NAP  &&

CREATE OR REPLACE TRIGGER INSERT_QUEUE_TRIG
  AFTER
  INSERT
  ON USERDATA
  REFERENCING
    NEW AS O
  FOR EACH ROW
  MODE DB2SQL
  BEGIN ATOMIC
      --若该用户已存在则更新其UID 不存则插入一条用户费用记录
    IF EXISTS (
        SELECT USERID
          FROM USERFEE
          WHERE UCASE(USERID)=UCASE(O.USERID)) THEN
      UPDATE USERFEE SET "UID"=O.UID WHERE USERID=UCASE(O.USERID)  ;
    ELSE
      INSERT INTO USERFEE("UID",ECID, USERID, SENDNUM, SENDEDNUM, POSTPAYUSED,
        THRESHOLD)
        VALUES(O.UID,1,UCASE(O.USERID),0,0,0,1000)  ;
    END IF;
  END  &&

CREATE OR REPLACE TRIGGER "INSERT_USEFEE_TRIG"
  AFTER
  INSERT
  ON "PB_WEBZZCMD_QUEUE"
  REFERENCING
    NEW AS "O"
  FOR EACH ROW
  MODE DB2SQL
  BEGIN ATOMIC
    DECLARE PUID INT;
    DECLARE PSENDNUM BIGINT;

    SET PUID=(
      SELECT UID
        FROM USERDATA
        WHERE USERID=UCASE(O.USERID));
	IF CAST(O.CMDPARAM AS BIGINT)<=0 THEN
	  SIGNAL SQLSTATE '75002' ('要回收/充值的短信条数不能为0或者负数！') ;
	END IF;
    IF EXISTS(--如果要操作的用户存在于USERFEE表中
        SELECT UID
          FROM USERFEE
          WHERE USERID=UCASE(O.USERID)) THEN
      IF O.CMDTYPE=113 THEN
        UPDATE USERFEE SET SENDNUM = SENDNUM+CAST(O.CMDPARAM AS BIGINT)
          WHERE USERID=UCASE(O.USERID);
      ELSEIF O.CMDTYPE=213 THEN
	    SET PSENDNUM=(SELECT SENDNUM FROM USERFEE WHERE USERID=UCASE(O.USERID));
	    IF PSENDNUM < CAST(O.CMDPARAM AS BIGINT) THEN
		  SIGNAL SQLSTATE '75002' ('要回收的费用条数不能大于剩余条数！') ;
		END IF;
        UPDATE USERFEE SET SENDNUM = SENDNUM-CAST(O.CMDPARAM AS BIGINT)
          WHERE USERID=UCASE(O.USERID)
            AND SENDNUM>=CAST(O.CMDPARAM AS BIGINT);
	  ELSE--当命令不是213和113时候，抛出错误
	    SIGNAL SQLSTATE '75002' ('回收/充值操作命令无效！') ;
      END IF;
    ELSE --如果要操作的用户不存在于USERFEE表中
	  IF O.CMDTYPE=113 THEN
        INSERT INTO USERFEE (UID,USERID,SENDNUM)
          VALUES (PUID,UCASE(O.USERID),CAST(O.CMDPARAM AS BIGINT));
	  ELSEIF O.CMDTYPE=213 THEN
	    SIGNAL SQLSTATE '75002' ('要回收费用的用户不存在！') ;
	  ELSE--当命令不是213和113时候，抛出错误
	    SIGNAL SQLSTATE '75002' ('回收/充值操作命令无效！') ;
      END IF;
    END IF;
    INSERT INTO PB_WEBZZCMD_LOG (SID,CMDTYPE,USERID,CMDPARAM,USEIP,EXECFLAG,MEMO,FEE,OPID,USENUMBER)
      VALUES (O.SID,O.CMDTYPE,O.USERID,O.CMDPARAM,COALESCE(O.USEIP,'0'),0,O.MEMO,O.FEE,O.OPID,0);
    DELETE FROM PB_WEBZZCMD_QUEUE WHERE ID=O.ID;
  END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITCV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPGATE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" INTEGER,
  IN "PIRECVFLAG" INTEGER,
  IN "PISENDTIME" INTEGER
 )
  SPECIFIC "WG_WRRPTWAITCV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_C(UID, PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, RECVFLAG ,ERRORCODE, LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME)
	   VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG , PIERRORCODE, PILOGINID,PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME)  ;
	END IF;
END  &&




CREATE OR REPLACE  PROCEDURE GW_H_STATISTIV1
 (IN "PIPROCESSFLAG" INTEGER,IN "ISP1" INTEGER,IN "ISP2" INTEGER,IN "ISP3" INTEGER,IN "ISP4" INTEGER
 )
  SPECIFIC GW_H_STATISTIV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS (
	USERID VARCHAR(11),
	TASKID INTEGER,
	SPGATE VARCHAR(21),
	SPISUNCM INTEGER,
	SPID VARCHAR(32),
	SVRTYPE VARCHAR(64),
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
    IYMD INTEGER,
	IYEAR INTEGER,
	IMONTH INTEGER,
	IHOUR INTEGER,
	ICOUNT INTEGER,
	SUCC INTEGER,
	FAIL INTEGER,
	NRET INTEGER,
	MOBILEAREA INTEGER,
	SENDTYPE INTEGER,
	BATCHID BIGINT,AREACODE INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';

	SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
			   IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
			   ELSE
			    SET STR=STR||','' '' AS P1';
			   END IF;
			   IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
			   ELSE
			    SET STR=STR||','' '' AS P2';
			   END IF;
			   IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   ELSE
			    SET STR=STR||','' '' AS P3';
			   END IF;
			   IF ISP1 =4 THEN
			    SET STR=STR||' ,P4';
			   ELSE
			    SET STR=STR||','' '' AS P4';
			   END IF;

               SET STR=STR||', INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			         VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			         MOBILEAREA,
			         SENDTYPE,
			         BATCHID,AREACODE
               FROM MT_TASK
               WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
               USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
	         IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
             END IF;
			 IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
             END IF;
			 IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   END IF;
			 IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   END IF;
	 SET STR=STR||',MOBILEAREA,SENDTYPE,BATCHID,AREACODE,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';

       EXECUTE IMMEDIATE STR;
       --插入或更新统计表
      DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN INT(CURRENT DATE - PIPROCESSFLAG DAYS) AND INT(CURRENT DATE);

      INSERT INTO MT_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET, SENDTYPE, MOBILEAREA,BATCHID,AREACODE)
      SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET, T.SENDTYPE, T.MOBILEAREA,T.BATCHID ,T.AREACODE
      FROM SESSION.TEMP_STATISTICS  T;
   END  &&


CREATE OR REPLACE  PROCEDURE GW_H_MMSSTATIV1
 (IN "PIPROCESSFLAG" INTEGER,IN "ISP1" INTEGER,IN "ISP2" INTEGER,IN "ISP3" INTEGER,IN "ISP4" INTEGER
 )
  SPECIFIC GW_H_MMSSTATIV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS
	( USERID VARCHAR(11),TASKID INTEGER,SPGATE VARCHAR(21),SPISUNCM INTEGER,SPID VARCHAR(32),SVRTYPE VARCHAR(64),
	  P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),P4 VARCHAR(64),IYMD INTEGER,IYEAR INTEGER,IMONTH INTEGER,
	  IHOUR INTEGER,ICOUNT INTEGER,SUCC INTEGER,FAIL INTEGER,NRET INTEGER,SENDTYPE INTEGER,MOBILEAREA INTEGER
	  ) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	  SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	  SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';

		SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
	       IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
			   ELSE
			    SET STR=STR||','' '' AS P1';
			   END IF;
			   IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
			   ELSE
			    SET STR=STR||','' '' AS P2';
			   END IF;
			   IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   ELSE
			    SET STR=STR||','' '' AS P3';
			   END IF;
			   IF ISP1 =4 THEN
			    SET STR=STR||' ,P4';
			   ELSE
			    SET STR=STR||','' '' AS P4';
			   END IF;

               SET STR=STR||', INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			   VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			   VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			   SENDTYPE,
			   MOBILEAREA
               FROM MMS_TASK
                WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
                USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
	        IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
             END IF;
			 IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
             END IF;
			 IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   END IF;
			 IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   END IF;
	     SET STR=STR||',SENDTYPE,MOBILEAREA,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';
       EXECUTE IMMEDIATE STR;
      DELETE FROM MMS_DATAREPORT WHERE IYMD BETWEEN INT(CURRENT DATE - PIPROCESSFLAG DAYS) AND INT(CURRENT DATE);

   INSERT INTO MMS_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA)
   SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA
   FROM SESSION.TEMP_STATISTICS T;

END  &&




CREATE OR REPLACE  PROCEDURE GW_H_DATATRANV1 ( IN "ISP1" INTEGER,IN "ISP2" INTEGER,IN "ISP3" INTEGER,IN "ISP4" INTEGER)
  SPECIFIC GW_H_DATATRANV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  DECLARE PIUSEID                 INTEGER; --使用哪一个USEID作为当前状态处理
  DECLARE PICURRINDEX             BIGINT; --当前处理位置
  DECLARE PIMAXINDEX              BIGINT; --此次执行的最大位置
  DECLARE PICOUNTSTATUS           INTEGER; --统计状态0:正常,1:错误
  DECLARE PIDISTRACTSTATUS        INTEGER; --数据转移状态0:正常,1:错误
  DECLARE PIDELETESTATUS          INTEGER; --删除状态0:正常,1:错误
  DECLARE PIPROCESSFLAG           INTEGER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,

  --异常退出
  DECLARE PICOUNTEXCEPTION        INTEGER; --允许统计异常最大值
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --允许数据转移异常最大值
  DECLARE PIDELETEEXCEPTION       INTEGER; --允许删除数据异常最大值
  DECLARE PIALLEXCEPTION          INTEGER; --允许所有异常最大值

  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

--------------------VER 3.2------------------------------------
--初始化
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 1;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  SET PIPROCESSFLAG           = 3;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;

      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV1','短信汇总调度存储过程执行开始');

      --先汇总
      SELECT VALUE(MIN(ID),0),VALUE(MAX(ID),0)INTO PICURRINDEX,PIMAXINDEX  FROM MT_TASK
      WHERE SENDTIME>= TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') AND SENDTIME < TIMESTAMP (TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000');

	  CALL GW_H_STATISTIV1(PIPROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV1',PIERROR);
	  END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
       BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
	  END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     --转移符合当前时间的数据
     SELECT VALUE(MAX(ID),0) INTO PIMAXINDEX FROM MT_TASK  WHERE  SENDTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MT_TASK  WHERE ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		  --创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL   H_TRANSFER(PI_MININDEX,PI_CURINDEX);
       CALL   H_DELETETASK(PI_MININDEX,PI_CURINDEX);
       CALL   H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
	      SET  PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF; --END OF IF PIERROR <> '' THEN
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_TRANSFERMO();

	--删除短信文件请求历史表数据
	DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
    END IF;

	IF DAY(CURRENT DATE)=1 THEN
	  DELETE FROM MO_WAIT_A WHERE DELIVERTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
	  END IF;

      DELETE FROM RPT_WAIT_A WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
	  END IF;

      DELETE FROM RPT_WAIT_B WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
	  END IF;

	END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行结束');
END NAP  &&

CREATE OR REPLACE  PROCEDURE "GW_LOADDATA"
 (IN "FLAG" BIGINT,
  IN "INCRES" BIGINT,
  IN "PRETIME" INTEGER)
  SPECIFIC "GW_LOADDATA"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
DECLARE STR VARCHAR(3000);
DECLARE STR1 VARCHAR(3000);
DECLARE STR2 VARCHAR(3000);
DECLARE TBNAME VARCHAR(30);
DECLARE TBNAMEBAK VARCHAR(30);
DECLARE TBNAMEERR VARCHAR(30);

DECLARE A INTEGER;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE STARTID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE ENDID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE CURMINID1 BIGINT DEFAULT 0;
DECLARE REMAINDER BIGINT DEFAULT 0;
DECLARE ISSUCCES BIGINT DEFAULT 1;
DECLARE TRANLOGID BIGINT DEFAULT 0;
DECLARE P_COUNT BIGINT DEFAULT 0;
DECLARE I BIGINT DEFAULT 0;
DECLARE J BIGINT DEFAULT 0;
DECLARE NUM BIGINT DEFAULT 0;
DECLARE TNUM BIGINT DEFAULT 0;
DECLARE INTERROR1 BIGINT DEFAULT 0;
DECLARE INTERROR2 BIGINT DEFAULT 0;
 ---YICHANG
 DECLARE PIERROR VARCHAR(3000);
 DECLARE PIERROR1 VARCHAR(3000);

 DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

  DECLARE CONTINUE HANDLER FOR   SQLSTATE   '23505'
  BEGIN
	 SET INTERROR1=23505;
  END ;



SELECT  COALESCE(ENDID,0) INTO STARTID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG AND ISSUCCES = 1 ORDER BY ID DESC FETCH  FIRST 1 ROWS ONLY ;   ----根据 上次成功转移的记录查找本次转移的开始id

IF FLAG =1 THEN
 SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0)  INTO  MINID,ENDID  FROM  MT_TASK WHERE SENDTIME<=CURRENT TIMESTAMP-PRETIME minutes WITH UR;
 SET TBNAME ='MT_TASK';
 SET TBNAMEBAK ='GW_MT_TASK_BAK';
 SET TBNAMEERR ='GW_MT_TASK_ERR';

 SET STR1 = ' ID ,PTMSGID,UID, ECID,  USERID, SPGATE, CPNO, PHONE, SPMSGID, RETFLAG,FEEFLAG, PKNUMBER , PKTOTAL, SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE , ERRORCODE,SENDLEVEL ,SENDTYPE ,UNICOM , SENDTIME, RECVTIME, MESSAGE   , RESENDCNT , TASKID ,  SPID   ,  MOBILEAREA , RECVMTTIME , TRANSMTTIME  ,TRANSRPTTIME , SENDRPTTIME  ,  MSGFMT  , LONGMSGSEQ ,  TPPID   , TPUDHI  ,  SVRTYPE ,  P1 , P2 ,  P3 ,  P4 ,  USERMSGID , MODULEID  ,ATTIME , VALIDTIME , BATCHID   ,  AREACODE,0 AS FLAGMTSDOK,0 AS FLAGRPTRVOK, 0 AS FLAGRPTSDOK, CURRENT TIMESTAMP AS  MTSUBMITTIME,0 AS ERRRESENDCNT,0 AS NETERRCNT,1 AS SENDRESULT,'' '' AS SPGATESEND, '' '' AS SPNUMBER,'' '' AS SENDERRCODE,'' '' AS  SUBMITDATE ';
 SET STR2 ='(ID ,PTMSGID ,UID, ECID,  USERID, SPGATE, CPNO, PHONE, SPMSGID, RETFLAG,FEEFLAG, PKNUMBER , PKTOTAL, SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE , ERRORCODE,SENDLEVEL ,SENDTYPE ,UNICOM , SENDTIME, RECVTIME, MESSAGE   , RESENDCNT , TASKID ,  SPID   ,  MOBILEAREA , RECVMTTIME , TRANSMTTIME  ,TRANSRPTTIME , SENDRPTTIME  ,  MSGFMT  , LONGMSGSEQ ,  TPPID   , TPUDHI  ,  SVRTYPE ,  P1 , P2 ,  P3 ,  P4 ,  USERMSGID , MODULEID  , ATTIME , VALIDTIME , BATCHID   ,  AREACODE, FLAGMTSDOK,FLAGRPTRVOK, FLAGRPTSDOK,  MTSUBMITTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,SENDERRCODE,SUBMITDATE) ';

ELSE
 RETURN;
END IF;


----如果表中无数据 则退出
IF ( 0=ENDID and 0=MINID ) THEN
RETURN;
END IF;

-----针对 前几次 删除 不成功处理   循环读出 然后删除  更新控制表
IF MINID  < STARTID+1  THEN
for v_row as c1 cursor with hold for SELECT  ID,STARTID,ENDID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG+4 AND ISSUCCES = 0
do
SET PIERROR = NULL;
SET STR = 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(v_row.STARTID)||' AND '||CHAR(v_row.ENDID);
PREPARE ST FROM STR;
EXECUTE  ST;
IF PIERROR IS NULL THEN
 UPDATE GW_TRAN_DEL_LOG SET END_TIME=CURRENT TIMESTAMP ,ISSUCCES=1 WHERE ID=v_row.ID;
END IF;
 COMMIT;
end for;
----------把此次转移的起始id重置 根据控制表上次转移成功id 重置
SET MINID =  STARTID+1;
END IF;

----若此次转移的最大id 等于上次成功转移的最大id 则退出
IF  ENDID=MINID-1 THEN
RETURN;
END IF;

-------加分批循环   设定步长

SELECT (ENDID-MINID+1)/INCRES,MOD((ENDID-MINID+1),INCRES) INTO TNUM,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET TNUM=TNUM+1;END IF;

WHILE ( NUM < TNUM ) DO
SET CURMINID=MINID+INCRES*NUM;
SET CURMAXID=CURMINID+INCRES-1;
IF NUM=TNUM-1 THEN
  SET CURMAXID=ENDID;
END IF;
INSERT INTO GW_TRAN_DEL_LOG(OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(FLAG,CURMINID,CURMAXID,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO TRANLOGID FROM SYSIBM.SYSDUMMY1;    ------此次转移的 控制信息
--- 转移数据 循环执行3次

SET I=0;
WHILE (I<3) DO
  SET PIERROR1 = NULL; SET PIERROR = NULL;
  SET STR ='INSERT INTO '||TBNAMEBAK||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID)||' WITH UR';

  EXECUTE IMMEDIATE STR;
  SET PIERROR1=PIERROR ;
  SET INTERROR2=INTERROR1;
   COMMIT;
  IF PIERROR1 is null  AND INTERROR2<>23505 THEN
      UPDATE GW_TRAN_DEL_LOG SET END_TIME= CURRENT TIMESTAMP,ISSUCCES=1 WHERE ID=TRANLOGID;
      INSERT INTO GW_TRAN_DEL_LOG(OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(FLAG+4,CURMINID,CURMAXID,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
      SELECT IDENTITY_VAL_LOCAL() INTO TRANLOGID FROM SYSIBM.SYSDUMMY1;    ------此次删除 的 控制信息
	  SET J=0;
	  WHILE J<3 DO
       SET PIERROR = NULL;
       SET STR = 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID);
       PREPARE ST FROM STR;
       EXECUTE  ST;
        IF PIERROR IS NULL THEN
          UPDATE GW_TRAN_DEL_LOG SET END_TIME=CURRENT TIMESTAMP ,ISSUCCES=1 WHERE ID=TRANLOGID;
          SET J=3;

        ELSE

          SET J=J+1;
        END IF;
      END WHILE;   -----END  WHILE J<3 DO
	  SET I=3;
  ELSE
      IF INTERROR2=23505 THEN
	   SET CURMINID1=CURMINID;
	   WHILE CURMINID1<=CURMAXID DO
	     SET INTERROR1=0;
	     SET STR ='INSERT INTO '||TBNAMEBAK||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||CHAR(CURMINID1)||' WITH UR';
         EXECUTE IMMEDIATE STR;
		 IF INTERROR1=23505 THEN
		  SET STR ='INSERT INTO '||TBNAMEERR||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||CHAR(CURMINID1)||' WITH UR';
          EXECUTE IMMEDIATE STR;
		 END IF; ---IF INTERROR1=23505 THEN
		  SET STR = 'DELETE FROM '||TBNAME||'  WHERE ID = '||CHAR(CURMINID1);
	      PREPARE ST FROM STR;
		  EXECUTE  ST;
		 SET CURMINID1=CURMINID1+1;
		 COMMIT;
	   END WHILE;---WHILE CURMINID1<=CURMAXID DO
	  ELSE
      SET STR = 'DELETE FROM '||TBNAMEBAK||' WHERE ID BETWEEN  '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID);
	  PREPARE ST FROM STR;
      EXECUTE  ST;
	  SET I=I+1;
	  END IF; ---IF INTERROR2=23505 THEN
 END IF;
END WHILE;--WHILE (I<3) DO

SET NUM=NUM+1;
COMMIT;
END WHILE ;   ---- end  WHILE ( NUM < TNUM ) DO
END  &&


CREATE OR REPLACE  PROCEDURE "GW_UPPMTSDOK"
 (IN "PRETIME" INTEGER,IN "INCRES" BIGINT,IN "STARTTIME" VARCHAR(30)
 )
  SPECIFIC "GW_UPPMTSDOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  begin
DECLARE STR VARCHAR(256);
DECLARE A INTEGER;
DECLARE rows1 INTEGER ;
DECLARE LOGID INTEGER ;
DECLARE I INTEGER DEFAULT 0;
DECLARE J INTEGER DEFAULT 0;
DECLARE REMAINDER INTEGER DEFAULT 0;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE MAXID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE MINLONG BIGINT DEFAULT 0;
declare  locl result_set_locator varying;
DECLARE PIERROR VARCHAR(3000);
DECLARE CONTINUE HANDLER FOR SQLSTATE '21506'
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END  ;


------------------更新MT_SDOK表-------------------------------------------


SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_MTSDOK WITH UR;

IF ( 0=MAXID and 0=MINID ) THEN
RETURN;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;

WHILE (I < J) DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(1,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
set PIERROR=null;
MERGE INTO  GW_MT_TASK_BAK AS A using GW_MTSDOK AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGMTSDOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
WHEN MATCHED THEN
UPDATE SET  A.SPMSGID     =B.SPMSGID ,
			A.SENDSTATUS  =A.SENDSTATUS+10,
			A.SPID        =B.SPID,
			A.TRANSMTTIME =B.TRANSMTTIME,
			A.MTSUBMITTIME=B.MTSUBMITTIME,
			A.SENDTIME    =B.SENDTIME,
			A.ERRRESENDCNT=B.ERRRESENDCNT,
			A.NETERRCNT   =B.NETERRCNT,
			A.SENDRESULT  =B.SENDRESULT,
			A.SPGATESEND  =B.SPGATESEND,

			A.SENDERRCODE =B.SENDERRCODE,

            A.FLAGMTSDOK=1;   ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
GET DIAGNOSTICS rows1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  set PIERROR=null;
  set rows1=null;
--------------若有重复的 则去重 更新
   MERGE INTO  GW_MT_TASK_BAK A using (SELECT  PTMSGID , MIN(SPMSGID) AS SPMSGID,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SPID) AS SPID,MIN(TRANSMTTIME) AS TRANSMTTIME,MIN(MTSUBMITTIME) AS MTSUBMITTIME,MIN(SENDTIME) AS SENDTIME,MIN(ERRRESENDCNT) AS ERRRESENDCNT,MIN(NETERRCNT) AS NETERRCNT,MIN(SENDRESULT) AS SENDRESULT,MIN(SPGATESEND) AS SPGATESEND,MIN(SENDERRCODE) AS SENDERRCODE  FROM  GW_MTSDOK WHERE  ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS  B  on ( A.PTMSGID=B.PTMSGID AND A.FLAGMTSDOK=0  )
   WHEN MATCHED THEN
   UPDATE SET   A.SPMSGID     =B.SPMSGID ,
				A.SENDSTATUS  =A.SENDSTATUS+10,
				A.SPID        =B.SPID,
				A.TRANSMTTIME =B.TRANSMTTIME,
				A.MTSUBMITTIME=B.MTSUBMITTIME,
				A.SENDTIME    =B.SENDTIME,
				A.ERRRESENDCNT=B.ERRRESENDCNT,
				A.NETERRCNT   =B.NETERRCNT,
				A.SENDRESULT  =B.SENDRESULT,
				A.SPGATESEND  =B.SPGATESEND,

				A.SENDERRCODE =B.SENDERRCODE,

                A.FLAGMTSDOK=1;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=rows1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   set rows1=null;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  set PIERROR=null;
COMMIT;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(4,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_MTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGMTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
  SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
  IF MINLONG>=PRETIME THEN
      SET  I=J;
  ELSE
      SET I=I+1;
 END IF;
COMMIT;
END WHILE;

END  &&



CREATE OR REPLACE  PROCEDURE "GW_UPPRPTRVOK"
 (IN "PRETIME" INTEGER,IN "INCRES" BIGINT,IN "STARTTIME" VARCHAR(30)
 )
  SPECIFIC "GW_UPPRPTRVOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  begin
DECLARE STR VARCHAR(256);
DECLARE A INTEGER;
DECLARE rows1 INTEGER ;
DECLARE LOGID INTEGER ;
DECLARE I INTEGER DEFAULT 0;
DECLARE J INTEGER DEFAULT 0;
DECLARE REMAINDER INTEGER DEFAULT 0;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE MAXID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE MINLONG BIGINT DEFAULT 0;
declare  locl result_set_locator varying;
DECLARE PIERROR VARCHAR(3000);
DECLARE CONTINUE HANDLER FOR SQLSTATE '21506'
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;



------------------更新rpt_rvok表  ---------------------------------------------------
SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTRVOK WITH UR;

IF ( 0=MAXID and 0=MINID ) THEN
RETURN;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;


WHILE I < J DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(2,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
set PIERROR=null;
merge into  GW_MT_TASK_BAK AS A using GW_RPTRVOK AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTRVOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
when matched then
update set  A.SENDSTATUS=A.SENDSTATUS+100,
			A.RECVTIME  =B.RECVTIME  ,
			A.DONEDATE  =B.DONEDATE  ,
			A.SUBMITDATE=B.SUBMITDATE,
			A.ERRORCODE =B.ERRORCODE ,

			A.FLAGRPTRVOK=1;          ---批量 更新
GET DIAGNOSTICS rows1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  set PIERROR=null;
  set rows1=null;
--------------若有重复的 则去重 更新
MERGE into  GW_MT_TASK_BAK AS A using (SELECT  PTMSGID , MIN(SENDSTATUS) AS SENDSTATUS,MIN(RECVTIME) AS RECVTIME,MIN(DONEDATE) AS DONEDATE,MIN(SUBMITDATE) AS SUBMITDATE,MIN(ERRORCODE) AS ERRORCODE    FROM  GW_RPTRVOK WHERE ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS  B  on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTRVOK=0 )
when MATCHED then
update set  A.SENDSTATUS=A.SENDSTATUS+100,
			A.RECVTIME  =B.RECVTIME  ,
			A.DONEDATE  =B.DONEDATE  ,
			A.SUBMITDATE=B.SUBMITDATE,
			A.ERRORCODE =B.ERRORCODE ,

			A.FLAGRPTRVOK=1;            ---更新
   GET DIAGNOSTICS rows1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=rows1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   set rows1=null;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  set PIERROR=null;
COMMIT;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(5,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_RPTRVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MT_TASK_BAK.PTMSGID = GW_RPTRVOK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTRVOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
  SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
  IF MINLONG>=PRETIME THEN
      SET  I=J;
  ELSE
      SET I=I+1;
 END IF;
COMMIT;
END WHILE;

END  &&


CREATE OR REPLACE  PROCEDURE "GW_UPPRPTSDOK"
 (IN "PRETIME" INTEGER,IN "INCRES" BIGINT,IN "STARTTIME" VARCHAR(30)
 )
  SPECIFIC "GW_UPPRPTSDOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  begin
DECLARE STR VARCHAR(256);
DECLARE A INTEGER;
DECLARE rows1 INTEGER ;
DECLARE LOGID INTEGER ;
DECLARE I INTEGER DEFAULT 0;
DECLARE J INTEGER DEFAULT 0;
DECLARE REMAINDER INTEGER DEFAULT 0;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE MAXID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE MINLONG BIGINT DEFAULT 0;

declare  locl result_set_locator varying;
DECLARE PIERROR VARCHAR(3000);
DECLARE CONTINUE HANDLER FOR SQLSTATE '21506'
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;



------------------更新rpt_SDok表  --------------------------------------------------------------
SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTSDOK WITH UR;
IF ( 0=MAXID and 0=MINID ) THEN
RETURN;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;



WHILE I < J DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(3,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
set PIERROR=null;
merge into  GW_MT_TASK_BAK AS A using GW_RPTSDOK AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTSDOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
			A.SENDFLAG    =B.SENDFLAG    ,
			A.SENDRPTTIME =B.SENDRPTTIME ,
			A.TRANSRPTTIME=B.TRANSRPTTIME,
			A.ERRORCODE   =B.ERRORCODE   ,
            A.FLAGRPTSDOK=1;   ---批量 更新
GET DIAGNOSTICS rows1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  set PIERROR=null;
  set rows1=null;
--------------若有重复的 则去重 更新

MERGE into  GW_MT_TASK_BAK AS A using ( SELECT  PTMSGID ,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SENDFLAG) AS SENDFLAG,MIN(SENDRPTTIME) AS SENDRPTTIME ,MIN(TRANSRPTTIME) AS TRANSRPTTIME,MIN(ERRORCODE) AS ERRORCODE FROM  GW_RPTSDOK  WHERE ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTSDOK=0 )
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
			A.SENDFLAG    =B.SENDFLAG    ,
			A.SENDRPTTIME =B.SENDRPTTIME ,
			A.TRANSRPTTIME=B.TRANSRPTTIME,
			A.ERRORCODE   =B.ERRORCODE   ,
			A.FLAGRPTSDOK=1;   ---批量 更新
GET DIAGNOSTICS rows1 = ROW_COUNT;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=rows1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   set rows1=null;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  set PIERROR=null;
COMMIT;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(6,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_RPTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MT_TASK_BAK.PTMSGID = GW_RPTSDOK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
  SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
  IF MINLONG>=PRETIME THEN
      SET  I=J;
  ELSE
      SET I=I+1;
 END IF;
COMMIT;
END WHILE;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_UPPDATA_ALL"
 (IN "PRETIME" INTEGER,IN "INCRES_LOAD" BIGINT,IN "INCRES" BIGINT
 )
  SPECIFIC "GW_UPPDATA_ALL"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  begin
DECLARE STR VARCHAR(256);
DECLARE A INTEGER;
DECLARE ROW1 INTEGER ;
DECLARE LOGID INTEGER ;
DECLARE I INTEGER DEFAULT 0;
DECLARE J INTEGER DEFAULT 0;
DECLARE REMAINDER INTEGER DEFAULT 0;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE MAXID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
--DECLARE INCRES BIGINT DEFAULT 5;   ------一次更新多少
declare  locl result_set_locator varying;
DECLARE PIERROR VARCHAR(3000);
DECLARE CONTINUE HANDLER FOR SQLSTATE '21506'
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

-------转移数据

CALL GW_LOADDATA(1,INCRES_LOAD,PRETIME) ;



------------------更新MT_SDOK表-------------------------------------------



SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_MTSDOK WITH UR ;

SET I=0;
IF ( 0=MAXID and 0=MINID ) THEN
SET I=2;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;

--SET INCRES = COUNTID ;

WHILE (I < J) DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(1,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
SET PIERROR=NULL;
MERGE INTO  GW_MT_TASK_BAK AS A using GW_MTSDOK AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGMTSDOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
WHEN MATCHED THEN
UPDATE SET  A.SPMSGID     =B.SPMSGID ,
			A.SENDSTATUS  =A.SENDSTATUS+10,
			A.SPID        =B.SPID,
			A.TRANSMTTIME =B.TRANSMTTIME,
			A.MTSUBMITTIME=B.MTSUBMITTIME,
			A.SENDTIME    =B.SENDTIME,
			A.ERRRESENDCNT=B.ERRRESENDCNT,
			A.NETERRCNT   =B.NETERRCNT,
			A.SENDRESULT  =B.SENDRESULT,
			A.SPGATESEND  =B.SPGATESEND,

			A.SENDERRCODE =B.SENDERRCODE,

            A.FLAGMTSDOK=1;   ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
GET DIAGNOSTICS ROW1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  SET PIERROR=null;
  SET ROW1=0;
--------------若有重复的 则去重 更新
   MERGE INTO  GW_MT_TASK_BAK A using (SELECT  PTMSGID , MIN(SPMSGID) AS SPMSGID,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SPID) AS SPID,MIN(TRANSMTTIME) AS TRANSMTTIME,MIN(MTSUBMITTIME) AS MTSUBMITTIME,MIN(SENDTIME) AS SENDTIME,MIN(ERRRESENDCNT) AS ERRRESENDCNT,MIN(NETERRCNT) AS NETERRCNT,MIN(SENDRESULT) AS SENDRESULT,MIN(SPGATESEND) AS SPGATESEND,MIN(SENDERRCODE) AS SENDERRCODE  FROM  GW_MTSDOK WHERE  ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS  B  on ( A.PTMSGID=B.PTMSGID AND A.FLAGMTSDOK=0  )
   WHEN MATCHED THEN
   UPDATE SET   A.SPMSGID     =B.SPMSGID ,
				A.SENDSTATUS  =A.SENDSTATUS+10,
				A.SPID        =B.SPID,
				A.TRANSMTTIME =B.TRANSMTTIME,
				A.MTSUBMITTIME=B.MTSUBMITTIME,
				A.SENDTIME    =B.SENDTIME,
				A.ERRRESENDCNT=B.ERRRESENDCNT,
				A.NETERRCNT   =B.NETERRCNT,
				A.SENDRESULT  =B.SENDRESULT,
				A.SPGATESEND  =B.SPGATESEND,

				A.SENDERRCODE =B.SENDERRCODE,

                A.FLAGMTSDOK=1;
   GET DIAGNOSTICS ROW1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROW1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   SET ROW1=NULL;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  SET PIERROR=NULL;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(4,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_MTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGMTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS ROW1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
 SET I=I+1;
COMMIT;
END WHILE;

------------------更新rpt_rvok表  ---------------------------------------------------

SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTRVOK WITH UR ;

SET I=0;
IF ( 0=MAXID and 0=MINID ) THEN
SET I=2;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;

WHILE I < J DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(2,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
SET PIERROR=NULL;
MERGE INTO  GW_MT_TASK_BAK AS A USING GW_RPTRVOK AS B ON ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTRVOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
WHEN MATCHED THEN
UPDATE SET   A.SENDSTATUS=A.SENDSTATUS+100,
			A.RECVTIME  =B.RECVTIME  ,
			A.DONEDATE  =B.DONEDATE  ,
			A.SUBMITDATE=B.SUBMITDATE,
			A.ERRORCODE =B.ERRORCODE ,

			A.FLAGRPTRVOK=1;          ---批量 更新
GET DIAGNOSTICS ROW1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  SET PIERROR=NULL;
  SET ROW1=NULL;
--------------若有重复的 则去重 更新
MERGE INTO  GW_MT_TASK_BAK AS A USING (SELECT  PTMSGID , MIN(SENDSTATUS) AS SENDSTATUS,MIN(RECVTIME) AS RECVTIME,MIN(DONEDATE) AS DONEDATE,MIN(SUBMITDATE) AS SUBMITDATE,MIN(ERRORCODE) AS ERRORCODE    FROM  GW_RPTRVOK WHERE ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS  B  on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTRVOK=0 )
when MATCHED then
update set  A.SENDSTATUS=A.SENDSTATUS+100,
			A.RECVTIME  =B.RECVTIME  ,
			A.DONEDATE  =B.DONEDATE  ,
			A.SUBMITDATE=B.SUBMITDATE,
			A.ERRORCODE =B.ERRORCODE ,

			A.FLAGRPTRVOK=1;            ---更新
   GET DIAGNOSTICS ROW1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROW1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   SET ROW1=0;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  SET PIERROR=null;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(5,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_RPTRVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MT_TASK_BAK.PTMSGID = GW_RPTRVOK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTRVOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS ROW1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
   SET I=I+1;
COMMIT;
END WHILE;


------------------更新rpt_SDok表  --------------------------------------------------------------

SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTSDOK WITH UR ;

SET I=0;
IF ( 0=MAXID and 0=MINID ) THEN
SET I=2;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;


WHILE I < J DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(3,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
set PIERROR=null;
merge into  GW_MT_TASK_BAK AS A using GW_RPTSDOK AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTSDOK=0 AND B.ID >= CURMINID AND B.ID <= CURMAXID)
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
			A.SENDFLAG    =B.SENDFLAG    ,
			A.SENDRPTTIME =B.SENDRPTTIME ,
			A.TRANSRPTTIME=B.TRANSRPTTIME,
			A.ERRORCODE   =B.ERRORCODE   ,
            A.FLAGRPTSDOK=1;   ---批量 更新
GET DIAGNOSTICS ROW1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  set PIERROR=null;
  set ROW1=0;
--------------若有重复的 则去重 更新

MERGE into  GW_MT_TASK_BAK AS A using ( SELECT  PTMSGID ,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SENDFLAG) AS SENDFLAG,MIN(SENDRPTTIME) AS SENDRPTTIME ,MIN(TRANSRPTTIME) AS TRANSRPTTIME,MIN(ERRORCODE) AS ERRORCODE FROM  GW_RPTSDOK  WHERE ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID ) AS B on ( A.PTMSGID=B.PTMSGID AND A.FLAGRPTSDOK=0 )
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
			A.SENDFLAG    =B.SENDFLAG    ,
			A.SENDRPTTIME =B.SENDRPTTIME ,
			A.TRANSRPTTIME=B.TRANSRPTTIME,
			A.ERRORCODE   =B.ERRORCODE   ,
			A.FLAGRPTSDOK=1;   ---批量 更新
GET DIAGNOSTICS ROW1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROW1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   set ROW1=null;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
 END IF;
  set PIERROR=null;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(6,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_RPTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MT_TASK_BAK.PTMSGID = GW_RPTSDOK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS ROW1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROW1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
      SET I=I+1;
COMMIT;
 END WHILE;
END  &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RMSRPT_RVOK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_RMSRPT_RVOK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER) CONSTRAINT GW_RMSRPT_RVOK_PK PRIMARY KEY ,
  "USERID"		  VARCHAR(6)	  NOT NULL  DEFAULT '''',
  "USERUID"		  INTEGER		  NOT NULL  DEFAULT 0,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ERRORCODE"	  VARCHAR(7)	  NOT NULL  DEFAULT '''',
  "MOBILEAREA"	  INTEGER		  NOT NULL  DEFAULT 0,
  "MOBILETYPE"	  SMALLINT		  NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 5,
  "FIRSTDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ENDDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNRPTOKTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNTRANSRPTTM" TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVRDNRPTTM"  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MOBILECOUNTRY" VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "ECID"		  VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "MSGTYPE"		  SMALLINT		  NOT NULL  DEFAULT 0,
  "IN_TIME"		  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK' AND INDNAME='IX_GWRMSRPTRVOK_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOK_PTMSGID"
  ON  "GW_RMSRPT_RVOK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK' AND INDNAME='IX_GWRMSRPTRVOK_RECVRDNRPTTM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOK_RECVRDNRPTTM"
  ON  "GW_RMSRPT_RVOK"
 ("RECVRDNRPTTM" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK' AND INDNAME='IDX_GWRMSRPTRVOK_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IDX_GWRMSRPTRVOK_INTIME"
  ON  "GW_RMSRPT_RVOK"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
END  &&


 ALTER TABLE  "GW_RMSRPT_RVOK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&


BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RMSRPT_RVOK_ERR') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_RMSRPT_RVOK_ERR"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  CONSTRAINT GW_RMSRPT_RVOK_ERR_PK PRIMARY KEY,
  "USERID"		  VARCHAR(6)	  NOT NULL  DEFAULT '''',
  "USERUID"		  INTEGER		  NOT NULL  DEFAULT 0,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ERRORCODE"	  VARCHAR(7)	  NOT NULL  DEFAULT '''',
  "MOBILEAREA"	  INTEGER		  NOT NULL  DEFAULT 0,
  "MOBILETYPE"	  SMALLINT		  NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 5,
  "FIRSTDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ENDDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNRPTOKTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNTRANSRPTTM" TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVRDNRPTTM"  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MOBILECOUNTRY" VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "ECID"		  VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "MSGTYPE"		  SMALLINT		  NOT NULL  DEFAULT 0,
  "IN_TIME"		  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_ERR' AND INDNAME='IX_GWRMSRPTRVOKERR_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOKERR_PTMSGID"
  ON  "GW_RMSRPT_RVOK_ERR"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_ERR' AND INDNAME='IX_GWRMSRPTRVOKERR_RECVRDNRPTTM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOKERR_RECVRDNRPTTM"
  ON  "GW_RMSRPT_RVOK_ERR"
 ("RECVRDNRPTTM" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS ';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_ERR' AND INDNAME='IDX_GWRMSRPTRVOKERR_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IDX_GWRMSRPTRVOKERR_INTIME"
  ON  "GW_RMSRPT_RVOK_ERR"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
END  &&
  &&

 ALTER TABLE  "GW_RMSRPT_RVOK_ERR"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&

BEGIN
IF NOT EXISTS (SELECT TBSPACE FROM SYSCAT.TABLES WHERE TABNAME='GW_RMSRPT_RVOK_BAK') THEN
	  BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE TABLE "GW_RMSRPT_RVOK_BAK"
 ("ID"            BIGINT          NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, CACHE 100, MINVALUE 1, MAXVALUE 9223372036854775807, NO CYCLE, NO ORDER)  CONSTRAINT GW_RMSRPT_RVOK_BAK_PK PRIMARY KEY,
  "USERID"		  VARCHAR(6)	  NOT NULL  DEFAULT '''',
  "USERUID"		  INTEGER		  NOT NULL  DEFAULT 0,
  "PTMSGID"       BIGINT          NOT NULL  DEFAULT 0,
  "SPNUMBER"      VARCHAR(21)     NOT NULL  DEFAULT '''',
  "PHONE"         VARCHAR(21)     NOT NULL  DEFAULT '''',
  "ERRORCODE"	  VARCHAR(7)	  NOT NULL  DEFAULT '''',
  "MOBILEAREA"	  INTEGER		  NOT NULL  DEFAULT 0,
  "MOBILETYPE"	  SMALLINT		  NOT NULL  DEFAULT 0,
  "SENDSTATUS"    SMALLINT        NOT NULL  DEFAULT 5,
  "FIRSTDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "ENDDOWNTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNRPTOKTM"	  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RDNTRANSRPTTM" TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "RECVRDNRPTTM"  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP,
  "MOBILECOUNTRY" VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "ECID"		  VARCHAR(10)	  NOT NULL  DEFAULT '''',
  "MSGTYPE"		  SMALLINT		  NOT NULL  DEFAULT 0,
  "IN_TIME"		  TIMESTAMP		  NOT NULL  DEFAULT CURRENT TIMESTAMP
 )
  DATA CAPTURE NONE
 IN "TBSPMTTASKDATA"
 INDEX IN "TBSPMTTASKINDEX"';
	  END;
END IF;

IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_BAK' AND INDNAME='IX_GWRMSRPTRVOKBAK_PTMSGID') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOKBAK_PTMSGID"
  ON  "GW_RMSRPT_RVOK_BAK"
 ("PTMSGID" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_BAK' AND INDNAME='IX_GWRMSRPTRVOKBAK_RECVRDNRPTTM') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE 'CREATE INDEX  "IX_GWRMSRPTRVOKBAK_RECVRDNRPTTM"
  ON  "GW_RMSRPT_RVOK_BAK"
 ("RECVRDNRPTTM" ASC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
IF NOT EXISTS (SELECT TABNAME FROM SYSCAT.INDEXES  WHERE TABNAME='GW_RMSRPT_RVOK_BAK' AND INDNAME='IDX_GWRMSRPTRVOKBAK_INTIME') THEN
        BEGIN ATOMIC
            EXECUTE IMMEDIATE ' CREATE INDEX  "IDX_GWRMSRPTRVOKBAK_INTIME"
  ON  "GW_RMSRPT_RVOK_BAK"
 ("IN_TIME" DESC
 )
  PCTFREE 10
  DISALLOW REVERSE SCANS';
        END;
END IF;
END  &&

 ALTER TABLE  "GW_RMSRPT_RVOK_BAK"
  LOCKSIZE ROW
  APPEND OFF
  NOT VOLATILE
  LOG INDEX BUILD NULL   &&



CREATE OR REPLACE  PROCEDURE "GW_DEL_ERR" ( )
  SPECIFIC "GW_DEL_ERR"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
DECLARE STR VARCHAR(3000);
DECLARE STR1 VARCHAR(3000);
DECLARE STR2 VARCHAR(3000);
DECLARE PROCESSFLAG INTEGER;

DECLARE I BIGINT;
DECLARE PIERROR VARCHAR(3000);
 DECLARE PIERROR1 VARCHAR(3000);
 DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;
  SET PROCESSFLAG=3;
  SET I=0;
 WHILE ( I<3 ) DO
  SET PIERROR1=NULL; SET PIERROR=NULL;
  SET STR1=' ID,PTMSGID,SPMSGID,SENDSTATUS,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,PHONE,SENDERRCODE,TPUDHI,TPPID,PKTOTAL,PKNUMBER,LONGMSGSEQ,IN_TIME  ';
  SET STR2='(ID,PTMSGID,SPMSGID,SENDSTATUS,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,PHONE,SENDERRCODE,TPUDHI,TPPID,PKTOTAL,PKNUMBER,LONGMSGSEQ,IN_TIME ) ';
  SET STR ='INSERT INTO  GW_MTSDOK_ERR'||STR2||' SELECT '||STR1||' FROM GW_MTSDOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - '||CHAR(PROCESSFLAG)||' DAYS) AS CHAR(32)))||'' 00:00:00.000000'') WITH UR ';    ---不影响mt_task插入  查询  between endid ...maxid
  EXECUTE IMMEDIATE STR;
  SET PIERROR1=PIERROR;


  IF PIERROR1 is null THEN
     DELETE FROM GW_MTSDOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
	 SET I=3;
  ELSE
     INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_MTSDOK..TO..GW_MTSDOK_ERR',PIERROR1);
     DELETE FROM GW_MTSDOK_ERR  WHERE EXISTS (SELECT PTMSGID FROM  GW_MTSDOK  B WHERE GW_MTSDOK_ERR.ID=B.ID AND B.IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') ) ;
     SET I=I+1;
 END IF;
END WHILE;


 SET I=0;
 WHILE ( I<3 ) DO
  SET PIERROR1=NULL; SET PIERROR=NULL;
 SET STR1='ID,PTMSGID,SPMSGID,SENDSTATUS,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE ,PHONE,SPNUMBER,IN_TIME  ';
 SET STR2='(ID,PTMSGID,SPMSGID,SENDSTATUS,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE ,PHONE,SPNUMBER,IN_TIME ) ';
 SET STR ='INSERT INTO  GW_RPTRVOK_ERR'||STR2||' SELECT '||STR1||'FROM GW_RPTRVOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - '||CHAR(PROCESSFLAG)||' DAYS) AS CHAR(32)))||'' 00:00:00.000000'') WITH UR ';    ---不影响mt_task插入  查询  between endid ...maxid
 EXECUTE IMMEDIATE STR;
 SET PIERROR1=PIERROR;
 IF PIERROR1 is null THEN
  DELETE FROM GW_RPTRVOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
   SET I=3;
  ELSE
   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_RPTRVOK..TO..GW_RPTRVOK_ERR',PIERROR1);
    DELETE FROM GW_RPTRVOK_ERR  WHERE EXISTS (SELECT PTMSGID FROM  GW_RPTRVOK  B WHERE GW_RPTRVOK_ERR.ID=B.ID AND B.IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') ) ;
     SET I=I+1;
 END IF;
END WHILE;



  SET I=0;
 WHILE ( I<3 ) DO
   SET PIERROR1=NULL; SET PIERROR=NULL;
   SET STR1=' ID,PTMSGID,SPMSGID,SENDSTATUS,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE,PHONE,SPNUMBER,IN_TIME  ';
  SET STR2='(ID,PTMSGID,SPMSGID,SENDSTATUS,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE,PHONE,SPNUMBER,IN_TIME ) ';
  SET STR ='INSERT INTO  GW_RPTSDOK_ERR'||STR2||' SELECT '||STR1||'FROM GW_RPTSDOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - '||CHAR(PROCESSFLAG)||' DAYS) AS CHAR(32)))||'' 00:00:00.000000'') WITH UR ';    ---不影响mt_task插入  查询  between endid ...maxid
  EXECUTE IMMEDIATE STR;
  SET PIERROR1=PIERROR;
   IF PIERROR1 is null THEN
     DELETE FROM GW_RPTSDOK WHERE IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
    SET I=3;
  ELSE
    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_RPTSDOK..TO..GW_RPTSDOK_ERR',PIERROR1);
    DELETE FROM GW_RPTSDOK_ERR  WHERE EXISTS (SELECT PTMSGID FROM  GW_RPTSDOK  B WHERE GW_RPTSDOK_ERR.ID=B.ID AND B.IN_TIME < TIMESTAMP (TRIM(CAST((CURRENT DATE - PROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') ) ;
     SET I=I+1;
 END IF;
END WHILE;


DELETE FROM GW_TRAN_DEL_LOG WHERE END_TIME<CURRENT TIMESTAMP-90 days WITH UR;
DELETE FROM GW_UPD_DEL_LOG WHERE END_TIME<CURRENT TIMESTAMP-90 days WITH UR;

DELETE FROM GW_MT_TASK_ERR WHERE SENDTIME<CURRENT TIMESTAMP-90 days WITH UR;
DELETE FROM GW_MTSDOK_ERR WHERE IN_TIME<CURRENT TIMESTAMP-90 days WITH UR;
DELETE FROM GW_RPTRVOK_ERR WHERE IN_TIME<CURRENT TIMESTAMP-90 days WITH UR;
DELETE FROM GW_RPTSDOK_ERR WHERE IN_TIME<CURRENT TIMESTAMP-90 days WITH UR;

END  &&

CREATE OR REPLACE  PROCEDURE "GW_WR_MTSDOK"
 (IN "PIPTMSGID" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPID" VARCHAR(32),
  IN "PITRANSMTTIME" TIMESTAMP,
  IN "PIMTSUBMITTIME" TIMESTAMP,
  IN "PISENDTIME" TIMESTAMP,
  IN "PIERRRESENDCNT" INTEGER,
  IN "PINETERRCNT" INTEGER,
  IN "PISENDRESULT" SMALLINT,
  IN "PISPGATESEND" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISENDERRCODE" VARCHAR(10),
  IN "PITPUDHI" SMALLINT,
  IN "PITPPID" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT
 )
  SPECIFIC "GW_WR_MTSDOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF NOT EXISTS (SELECT PTMSGID FROM GW_MTSDOK WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO GW_MTSDOK(PTMSGID,SPMSGID,SENDSTATUS,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,PHONE,SENDERRCODE,TPUDHI,TPPID,PKTOTAL,PKNUMBER,LONGMSGSEQ)
	   VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PISPID,PITRANSMTTIME,PIMTSUBMITTIME,PISENDTIME,PIERRRESENDCNT,PINETERRCNT,PISENDRESULT,PISPGATESEND,PISPNUMBER,PIPHONE,PISENDERRCODE,PITPUDHI,PITPPID,PIPKTOTAL,PIPKNUMBER,PILONGMSGSEQ);
	END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_WR_RPTRVOK"
 (IN "PIPTMSGID" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIDONEDATE" CHARACTER(10),
  IN "PISUBMITDATE" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIPHONE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21)
 )
  SPECIFIC "GW_WR_RPTRVOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF NOT EXISTS (SELECT PTMSGID FROM GW_RPTRVOK WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO GW_RPTRVOK(PTMSGID,SPMSGID,SENDSTATUS,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE ,PHONE,SPNUMBER )
	   VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PIRECVTIME,PIDONEDATE,PISUBMITDATE,PIERRORCODE ,PIPHONE,PISPNUMBER);
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WR_RPTSDOK"
 (IN "PIPTMSGID" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISENDFLAG" SMALLINT,
  IN "PISENDRPTTIME" TIMESTAMP,
  IN "PITRANSRPTTIME" TIMESTAMP,
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIPHONE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21)
 )
  SPECIFIC "GW_WR_RPTSDOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF NOT EXISTS (SELECT PTMSGID FROM GW_RPTSDOK WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO GW_RPTSDOK(PTMSGID,SPMSGID,SENDSTATUS,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE,PHONE,SPNUMBER)
	   VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PISENDFLAG,PISENDRPTTIME,PITRANSRPTTIME,PIERRORCODE,PIPHONE,PISPNUMBER);
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_H_DELTASKV1"
 (IN "MININDEX" BIGINT,
  IN "MAXINDEX" BIGINT
 )
  SPECIFIC "GW_H_DELTASKV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	 DELETE  FROM GW_MT_TASK_BAK   WHERE (ID <= MAXINDEX)  ;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_H_TRANSFERV1"
 (IN "PIMININDEX" BIGINT,
  IN "PIMAXINDEX" BIGINT
 )
  SPECIFIC "GW_H_TRANSFERV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	DECLARE	PISTR VARCHAR(4000);
	DECLARE	PITABLENAME VARCHAR(20);
	DECLARE	MINYM INTEGER;
	DECLARE	MAXYM INTEGER;
	DECLARE	CURYM INTEGER;
  DECLARE MAXTIME VARCHAR(32);
  DECLARE MINTIME VARCHAR(32);
	DECLARE BEGTIME VARCHAR(32);
  DECLARE ENDTIME VARCHAR(32);
  --------------------VER 3.1-------------------------------------
  SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM GW_MT_TASK_BAK  WHERE ID BETWEEN PIMININDEX AND PIMAXINDEX;

  SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
  SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);

  --转移
  SET CURYM = MINYM;
  WHILE CURYM<=MAXYM DO

  IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<>12 THEN
	    SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	    IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)<9 THEN
	      SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-0'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		ELSE
		  SET ENDTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),5,2))+1))||'-'||'01 00:00:00.000000';
		END IF;
	  ELSE
	      SET BEGTIME = SUBSTR(CHAR(CURYM),1,4)||'-'||SUBSTR(CHAR(CURYM),5,2)||'-'||'01 00:00:00.000000';
	      SET ENDTIME = TRIM(CHAR(INT(SUBSTR(CHAR(CURYM),1,4))+1))||'-'||'01'||'-'||'01 00:00:00.000000';
	  END IF;

      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));

      SET PISTR= 'INSERT INTO '||PITABLENAME||' (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,DOWNTM,SUID1,LUID1)
                SELECT ID,INT(DAY(M.SENDTIME)),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,DOWNTM,SUID1,LUID1
                FROM GW_MT_TASK_BAK  M
                WHERE SENDTIME>='''||BEGTIME||''' AND SENDTIME<'''||ENDTIME||''' AND (M.ID <='||CHAR(PIMAXINDEX)||')  ';
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR(6)),5,2) AS INT)=12 THEN
        SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
      ELSE
        SET CURYM = CURYM+1;
      END IF;
  END WHILE;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_H_STATISTIV2"
 (IN "PIPROCESSFLAG" INTEGER,
  IN "ISP1" INTEGER,
  IN "ISP2" INTEGER,
  IN "ISP3" INTEGER,
  IN "ISP4" INTEGER
 )
  SPECIFIC "GW_H_STATISTIV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);
	DECLARE MAXIYMD INTEGER;
	DECLARE DIFFDATE INTEGER;
	DECLARE MINTMIYMD INTEGER;
	DECLARE MAXTMIYMD INTEGER;

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS (
	USERID VARCHAR(11),
	TASKID INTEGER,
	SPGATE VARCHAR(21),
	SPISUNCM INTEGER,
	SPID VARCHAR(32),
	SVRTYPE VARCHAR(64),
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
    IYMD INTEGER,
	IYEAR INTEGER,
	IMONTH INTEGER,
	IHOUR INTEGER,
	ICOUNT INTEGER,
	SUCC INTEGER,
	FAIL INTEGER,
	NRET INTEGER,
	MOBILEAREA INTEGER,
	SENDTYPE INTEGER,
	BATCHID BIGINT,AREACODE INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

     SELECT  COALESCE(MAX(IYMD),20000101)  INTO MAXIYMD FROM MT_DATAREPORT ;
	SET DIFFDATE=days(CURRENT DATE - 2 days) - days(date(SUBSTR(CHAR(MAXIYMD),1,4)||'-'||SUBSTR(CHAR(MAXIYMD),5,2)||'-'||SUBSTR(CHAR(MAXIYMD),7,2)));
	IF DIFFDATE>0 THEN
          SET PIPROCESSFLAG=PIPROCESSFLAG+DIFFDATE;
	END IF;

	SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';



	SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
			   IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
			   ELSE
			    SET STR=STR||','' '' AS P1';
			   END IF;
			   IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
			   ELSE
			    SET STR=STR||','' '' AS P2';
			   END IF;
			   IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   ELSE
			    SET STR=STR||','' '' AS P3';
			   END IF;
			   IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   ELSE
			    SET STR=STR||','' '' AS P4';
			   END IF;

               SET STR=STR||', INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			         VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			         MOBILEAREA,
			         SENDTYPE,
			         BATCHID,AREACODE
               FROM GW_MT_TASK_BAK
               WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
               USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
	         IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
             END IF;
			 IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
             END IF;
			 IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   END IF;
			 IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   END IF;
	 SET STR=STR||',MOBILEAREA,SENDTYPE,BATCHID,AREACODE,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';

       EXECUTE IMMEDIATE STR;
       --插入或更新统计表
	  SELECT MIN(IYMD) , MAX(IYMD) INTO MINTMIYMD,MAXTMIYMD FROM SESSION.TEMP_STATISTICS;
      DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN MINTMIYMD AND MAXTMIYMD;

      INSERT INTO MT_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET, SENDTYPE, MOBILEAREA,BATCHID,AREACODE)
      SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET, T.SENDTYPE, T.MOBILEAREA,T.BATCHID ,T.AREACODE
      FROM SESSION.TEMP_STATISTICS  T;
      COMMIT;
   END  &&

CREATE OR REPLACE  PROCEDURE "GW_RDMTTASKRSV1"
 (IN "PIMAXRESNDCNT" INTEGER,
  IN "PISTRMSGID" VARCHAR(4000)
 )
  SPECIFIC "GW_RDMTTASKRSV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,UID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,
	PKNUMBER,PKTOTAL,SENDSTATUS,SENDLEVEL,TPUDHI,LONGMSGSEQ,MSGFMT,MESSAGE,RECVMTTIME,SVRTYPE,
	P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA
	FROM GW_MT_TASK_BAK WHERE PTMSGID IN('||PISTRMSGID||') AND RESENDCNT<'||CAST(PIMAXRESNDCNT AS CHAR(12));
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_RDMTTASKRPV1"
 (IN "PIPTMSGID" BIGINT,
  IN "PIUID" INTEGER
 )
  SPECIFIC "GW_RDMTTASKRPV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PICOUNT INTEGER;
DECLARE PICNTTB INTEGER;
DECLARE PISQLSTR1 VARCHAR(1024);
DECLARE PISQLSTR2 VARCHAR(1024);
DECLARE PISQLSTR3 VARCHAR(1024);
DECLARE PISQLSTRING VARCHAR(256);
DECLARE PIDBNAME VARCHAR(32);
DECLARE PIMONTH  INTEGER;
DECLARE PICURYM  INTEGER;
DECLARE PISQL VARCHAR(1024);
DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP (COUNT INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP1 (SPNUMBER VARCHAR(21),PHONE VARCHAR(21),DONEDATE CHAR(10),
ERRORCODE CHAR(7),RECVRPTTIME VARCHAR(22)) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PICOUNT = 0;
SET PIDBNAME = 'MTTASK';

SELECT COUNT(*) INTO PICOUNT FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID;
IF PICOUNT > 0 THEN
	C1:BEGIN
	DECLARE C_1 CURSOR WITH RETURN FOR
	SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,RECVTIME AS RECVRPTTIME  FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID;
	OPEN C_1;
	END C1;
ELSE
	SELECT COUNT(*) INTO PICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
    IF PICOUNT > 0 THEN
		C2:BEGIN
		DECLARE C_1 CURSOR WITH RETURN FOR
	    SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME  FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
		OPEN C_1;
		END C2;
	ELSE
	    SELECT COUNT(*) INTO PICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
        IF PICOUNT > 0 THEN
			C3:BEGIN
			DECLARE C_1 CURSOR WITH RETURN FOR
		    SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME  FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
			OPEN C_1;
			END C3;
	    ELSE
		    --取当前月份,在当月历史中查询
			SET PICURYM = CAST((SUBSTR(CHAR(CURRENT TIMESTAMP),1,4)||SUBSTR(CHAR(CURRENT TIMESTAMP),6,2))AS INT);--获取当前时间的年月
		    SET  PIDBNAME = 'MTTASK'||CHAR(PICURYM);--当前月份的历史表名
		    SET PICOUNT = 0;
			SET PISQLSTR1 = 'SELECT COUNT(*) FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID);
			SET PISQL='INSERT INTO SESSION.TEMP(COUNT) SELECT COUNT(*)  FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID) ;
			EXECUTE IMMEDIATE PISQL;
			SELECT COUNT INTO PICOUNT FROM SESSION.TEMP;
			COMMIT;
		    IF PICOUNT > 0 THEN
			    SET PISQLSTR2 = 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
			    C4:BEGIN
			    DECLARE C_1 CURSOR WITH RETURN FOR S1;
			    PREPARE S1 FROM PISQLSTR2;
			    OPEN C_1;
			    END C4;
		        RETURN;
		    ELSE
		       --若当月历史表中没有,则遍历近三个月的历史表
			   SET PIMONTH = 1;
		       WHILE PIMONTH <3 DO
		       --格式化数据库名称
			   SET   PICURYM=CAST((SUBSTR(CHAR(CURRENT TIMESTAMP - PIMONTH MONTHS),1,4)||SUBSTR(CHAR(CURRENT TIMESTAMP - PIMONTH MONTHS),6,2))AS INT);
		       SET   PIDBNAME = 'MTTASK'||CHAR(PICURYM);
			   --判断表名是否存在
			   SELECT COUNT(TABNAME) INTO PICNTTB FROM SYSCAT.TABLES WHERE TABNAME=PIDBNAME;
			   IF PICNTTB>0 THEN
			      SET  PICOUNT = 0;
			      SET PISQLSTR3 = 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
			      SET PISQL='INSERT INTO SESSION.TEMP(COUNT) SELECT COUNT(*)  FROM '||PIDBNAME|| ' WHERE PTMSGID='||CHAR(PIPTMSGID) ;
			      EXECUTE IMMEDIATE PISQL;
			      SELECT COUNT INTO PICOUNT FROM SESSION.TEMP;
			      COMMIT;
		          IF PICOUNT > 0 THEN
		             SET  PISQLSTRING = 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,SENDTIME AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID='||CHAR(PIPTMSGID);
					 C5:BEGIN
					 DECLARE C_1 CURSOR WITH RETURN FOR S2;
					 PREPARE S2 FROM PISQLSTRING;
					 OPEN C_1;
					 END C5;
					 RETURN;----查询到需要的数据后，跳出循环
		          END IF;
			   END IF;--END OF IF PICNTTB>0 THEN

		            SET PIMONTH = PIMONTH+1;
			        IF PIMONTH=3 AND PICOUNT=0 AND PICNTTB=1 THEN   ---便利完历史表还不存在  返回空值

						 C11:BEGIN
						DECLARE C_1 CURSOR WITH RETURN FOR
							SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,RECVTIME AS RECVRPTTIME  FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID;
							OPEN C_1;
						 END C11;
						 RETURN;----查询三次历史表 还不存在 跳出循环
					  END IF;  ----END  IF PIMONTH=3 AND PICOUNT=0 THEN  无数据 返回空值
					 IF PICNTTB=0 THEN   ---当表不存在  则返回空值
							C10:BEGIN
							DECLARE C_1 CURSOR WITH RETURN FOR
							SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,RECVTIME AS RECVRPTTIME  FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID;
							OPEN C_1;
							END C10;
							RETURN;----查询到不存在表  跳出循环
					END IF;   ---END IF PICNTTB=0 THEN   ---当表不存在  则返回空值
		       END WHILE;
		     END IF;--end of 查询当月历史表
			 C6:BEGIN
			    DECLARE C_1 CURSOR WITH RETURN FOR
				SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,RECVRPTTIME FROM SESSION.TEMP1;
			 END C6;
  END IF;--end of 查询实时表
  END IF;--gw_mt_task_bak
  END IF;--GW_RPTRVOK
END  &&

CREATE OR REPLACE  PROCEDURE  GW_MTTASKSUPPV1
 (IN "PIOLDMSGID" BIGINT,
  IN "PINEWMSGID" BIGINT,
  IN "PISRCUID" INTEGER,
  IN "PISRCUSRID" VARCHAR(11),
  IN "PISRCSPGATE" VARCHAR(21),
  IN "PISRCSPNUMBER" VARCHAR(21),
  IN "PIDESTUID" INTEGER,
  IN "PIDESTUSRID" VARCHAR(11),
  IN "PIDESTSPGATE" VARCHAR(21),
  IN "PIDESTSPNUMBER" VARCHAR(21),
  IN "PIDESTFEEFLAG" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PINEWSIGNLEN" SMALLINT,
  IN "PIOLDSIGNLEN" SMALLINT,
  IN "PISIGNATURE" VARCHAR(20),
  IN "PINEWSIGNPOS" INTEGER,
  IN "PIOLDSIGNPOS" INTEGER,
  IN "PIENSPLITLEN" INTEGER, --英文短信单条长度，小于等于0标识不支持英文短信
  IN "PIENMULTILEN1" INTEGER, --英文长短信拆分长度
  IN "PIENMULTILEN2" INTEGER, --英文长短信最后一条长度
  IN "PINEWENSIGNLEN" INTEGER, --补发英文签名长度
  IN "PIOLDENSIGNLEN" INTEGER, --原英文签名长度
  IN "PIENSIGNATURE" VARCHAR(20) --英文签名
 )
  SPECIFIC  GW_MTTASKSUPPV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISENDNUM INTEGER;
	DECLARE PIPKTOTAL INTEGER;
	DECLARE PIPKNUM	 INTEGER;
	DECLARE PIINITMSGID BIGINT;
	DECLARE PISINGLEMSG VARCHAR(720);
	DECLARE PILONGMSG VARCHAR(3000);
	DECLARE PITOTALCNT INTEGER;
	DECLARE PILONGMSGLEN INTEGER;
	DECLARE PIECID INTEGER;
	DECLARE PIPHONE VARCHAR(21);
	DECLARE PISENDLEVEL SMALLINT;
	DECLARE PITASKID INTEGER;
	DECLARE PIRECVMTTIME TIMESTAMP;
	DECLARE PISRCCPNO  VARCHAR(21);
	DECLARE PIDESTCPNO VARCHAR(21);
	DECLARE PITPUDHI SMALLINT;
	DECLARE PITPPID SMALLINT;
	DECLARE PILONGMSGSEQ SMALLINT;
	DECLARE PIMSGFMT SMALLINT;
	DECLARE PIUNICOM SMALLINT;
	DECLARE PIMOBILEAREA INTEGER;
	DECLARE PISVRTYPE VARCHAR(64);
	DECLARE PIUSERMSGID BIGINT;
	DECLARE PISENDTYPE SMALLINT;
	DECLARE PIP1 VARCHAR(64);
	DECLARE PIP2 VARCHAR(64);
	DECLARE PIP3 VARCHAR(64);
	DECLARE PIP4 VARCHAR(64);
	DECLARE PIMODULEID INTEGER;
	DECLARE PIATTIME BIGINT;
	DECLARE PIVALIDTIME BIGINT;
	DECLARE PIRCOUNT1 INTEGER;
        DECLARE PIRCOUNT2 INTEGER;
  DECLARE PIBATCHID BIGINT;
  DECLARE PIAREACODE INTEGER;

  DECLARE PISPLITLEN_V  INTEGER;
  DECLARE PIMULTILEN1_V  INTEGER;
  DECLARE PIMULTILEN2_V  INTEGER;
  DECLARE PINEWSIGNLEN_V  INTEGER;
  DECLARE PIOLDSIGNLEN_V  INTEGER;
  DECLARE PISIGNATURE_V  VARCHAR(22);

	SET PILONGMSG='';
	SET PIRECVMTTIME = CURRENT TIMESTAMP;
	SET PISRCCPNO  = SUBSTRING(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE),CODEUNITS32);
	SET PIDESTCPNO = SUBSTRING(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE),CODEUNITS32);
	DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPTB_RDMTTASK (
	UID INTEGER,
	PTMSGID BIGINT,
	ECID INTEGER,
	TASKID INTEGER,
	USERID VARCHAR(11),
	SPGATE VARCHAR(21),
	CPNO VARCHAR(21),
	PHONE VARCHAR(21),
	SPMSGID BIGINT,
	RETFLAG SMALLINT,
	FEEFLAG SMALLINT,
	PKNUMBER SMALLINT,
	PKTOTAL SMALLINT,
	SENDSTATUS SMALLINT,
	SENDFLAG SMALLINT,
	RECVFLAG SMALLINT,
	PASSTHROUGH SMALLINT,
	DONEDATE CHAR(10),
	ERRORCODE CHAR(7),
	SENDLEVEL SMALLINT,
	SENDTYPE SMALLINT,
	UNICOM SMALLINT,
	RESENDCNT SMALLINT,
	RECVMTTIME TIMESTAMP,
	RECVTIME TIMESTAMP,
	USERMSGID BIGINT,
	MESSAGE VARCHAR(3000),
	TPUDHI SMALLINT,
	LONGMSGSEQ SMALLINT,
	MSGFMT SMALLINT,
	MOBILEAREA INTEGER,
	SVRTYPE VARCHAR(64),
	TPPID SMALLINT,
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
	MODULEID INTEGER,
	ATTIME BIGINT,
	VALIDTIME BIGINT,
	BATCHID BIGINT,
	AREACODE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	--取补发帐号的费用
	SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE UCASE(USERID)=UCASE(PIDESTUSRID);
	--该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;
    DELETE FROM SESSION.TMPTB_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
    GET DIAGNOSTICS PIRCOUNT2 = ROW_COUNT;
  IF PIRCOUNT1-PIRCOUNT2  <>0 THEN
	--BEGIN
		SELECT PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME,BATCHID,AREACODE
		       INTO PIPKTOTAL ,PIPKNUM ,PIECID ,PIPHONE ,PISENDLEVEL ,PITASKID ,PITPUDHI ,PILONGMSGSEQ ,PIMSGFMT ,PIUNICOM ,PIMOBILEAREA  ,PISVRTYPE ,PITPPID ,PIUSERMSGID ,PISENDTYPE ,PIP1 ,PIP2 ,PIP3 ,PIP4 ,PIMODULEID ,PIATTIME ,PIVALIDTIME,PIBATCHID,PIAREACODE
		       FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;

    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       SET PIOLDSIGNLEN_V=PIOLDENSIGNLEN;
     ELSE
       SET PIOLDSIGNLEN_V=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       SET PISPLITLEN_V  =PIENSPLITLEN;
       SET PIMULTILEN1_V =PIENMULTILEN1;
       SET PIMULTILEN2_V =PIENMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWENSIGNLEN;
       SET PISIGNATURE_V =PIENSIGNATURE;
     ELSE
       SET PISPLITLEN_V  =PISPLITLEN;
       SET PIMULTILEN1_V =PIMULTILEN1;
       SET PIMULTILEN2_V =PIMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWSIGNLEN;
       SET PISIGNATURE_V =PISIGNATURE;
     END IF;

		 IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN --对于非长短信补发的处理
			--BEGIN PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME
				SET PILONGMSG='';
				--取短信内容
				SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
				--更新替换MSGID
				UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF; --END OF LONGMSGLEN<=SPLITLEN

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = PILONGMSG||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||PILONGMSG;
					END IF;

					--调用插入存储过程
					CALL S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END;--END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF; --END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1;
			--END ; --END OF PKTOTAL = 1
        /*
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN --对标准协议长短信的补发
		--BEGIN
			SET PILONGMSG='';
			--取短信内容
			SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
			--更新替换MSGID
			UPDATE GW_MT_TASK_BAK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
			IF (PIPKTOTAL=PIPKNUM) THEN--如果是最后一条，去掉旧签名，加上新签名
			--BEGIN
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN; --减去签名的净长度
				SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				SET PILONGMSG =PILONGMSG||PISIGNATURE;
			END IF;
			SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
			IF PILONGMSGLEN > 0 THEN
			--BEGIN
				--调用插入存储过程
				CALL S_WR_MTTASKSR (PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
								PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
								PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,'',PITPUDHI,
								PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
								PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);

			--END --END OF IF LONGMSGLEN > 0
			ELSE
				SET PILONGMSG='';
			END IF; --IF LONGMSGLEN > 0
		*/
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0) THEN--对非标准长短信协议的处理
		--BEGIN
			SET PILONGMSG='';
			--没有补发过且通道号跟源通道号相等
			IF EXISTS(SELECT * FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID) THEN
			--BEGIN
				--循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
				--计算起始MSGID
				SET PIINITMSGID = PIOLDMSGID-(PIPKNUM-1)*17179869184;
				SET PIPKNUM = 1;
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					--取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
					SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					IF PISINGLEMSG = '' THEN
					--BEGIN
						SET PILONGMSG='';
						SET PIPKNUM=PIPKTOTAL;
					END IF; --IF SINGLEMSG = ''
					--更新替换MSGID
					UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					--拼接短信内容
					SET PILONGMSG = PILONGMSG||PISINGLEMSG;
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END OF WHILE PKNUM <= PKTOTAL

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
                SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF;

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = PILONGMSG||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||PILONGMSG;
					END IF;

					--调用插入存储过程
					CALL S_WR_MTTASK (PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME ,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END --END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF;--END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1 ;
			END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM TMP WHERE PTMSGID=OLDMSGID AND RESENDCNT<1 AND (RTRIM(SPGATE)+RTRIM(CPNO))=SRCSPNUMBER)
		END IF;--END OF IF PKTOTAL > 1
	END IF;--END OF IF ROWCOUNT<>0
	PRET: BEGIN

	DECLARE C_3 CURSOR WITH RETURN FOR
	SELECT PIDESTUID AS UID,PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
	PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,PIPKNUM AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
	SENDSTATUS,1 AS SENDLEVEL,PIRECVMTTIME AS RECVMTTIME,PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
	MOBILEAREA,SVRTYPE,TPPID,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM SESSION.TMPTB_RDMTTASK WHERE PILONGMSG<>'' ;
	OPEN C_3;
	END PRET;
END  &&

CREATE OR REPLACE  PROCEDURE  GW_MTTASKSUPPV2
 (IN "PIOLDMSGID" BIGINT,
  IN "PINEWMSGID" BIGINT,
  IN "PISRCUID" INTEGER,
  IN "PISRCUSRID" VARCHAR(11),
  IN "PISRCSPGATE" VARCHAR(21),
  IN "PISRCSPNUMBER" VARCHAR(21),
  IN "PIDESTUID" INTEGER,
  IN "PIDESTUSRID" VARCHAR(11),
  IN "PIDESTSPGATE" VARCHAR(21),
  IN "PIDESTSPNUMBER" VARCHAR(21),
  IN "PIDESTFEEFLAG" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PINEWSIGNLEN" SMALLINT,
  IN "PIOLDSIGNLEN" SMALLINT,
  IN "PISIGNATURE" VARCHAR(20),
  IN "PINEWSIGNPOS" INTEGER,
  IN "PIOLDSIGNPOS" INTEGER,
  IN "PIENSPLITLEN" INTEGER, --英文短信单条长度，小于等于0标识不支持英文短信
  IN "PIENMULTILEN1" INTEGER, --英文长短信拆分长度
  IN "PIENMULTILEN2" INTEGER, --英文长短信最后一条长度
  IN "PINEWENSIGNLEN" INTEGER, --补发英文签名长度
  IN "PIOLDENSIGNLEN" INTEGER, --原英文签名长度
  IN "PIENSIGNATURE" VARCHAR(20) --英文签名
 )
  SPECIFIC  GW_MTTASKSUPPV2
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISENDNUM INTEGER;
	DECLARE PIPKTOTAL INTEGER;
	DECLARE PIPKNUM	 INTEGER;
	DECLARE PIINITMSGID BIGINT;
	DECLARE PISINGLEMSG VARCHAR(720);
	DECLARE PISINGLEMSG1 VARCHAR(720);
	DECLARE PILONGMSG VARCHAR(3000);
	DECLARE PITOTALCNT INTEGER;
	DECLARE PILONGMSGLEN INTEGER;
	DECLARE PIECID INTEGER;
	DECLARE PIPHONE VARCHAR(21);
	DECLARE PISENDLEVEL SMALLINT;
	DECLARE PITASKID INTEGER;
	DECLARE PIRECVMTTIME TIMESTAMP;
	DECLARE PISRCCPNO  VARCHAR(21);
	DECLARE PIDESTCPNO VARCHAR(21);
	DECLARE PITPUDHI SMALLINT;
	DECLARE PITPPID SMALLINT;
	DECLARE PILONGMSGSEQ SMALLINT;
	DECLARE PIMSGFMT SMALLINT;
	DECLARE PIUNICOM SMALLINT;
	DECLARE PIMOBILEAREA INTEGER;
	DECLARE PISVRTYPE VARCHAR(64);
	DECLARE PIUSERMSGID BIGINT;
	DECLARE PISENDTYPE SMALLINT;
	DECLARE PIP1 VARCHAR(64);
	DECLARE PIP2 VARCHAR(64);
	DECLARE PIP3 VARCHAR(64);
	DECLARE PIP4 VARCHAR(64);
	DECLARE PIMODULEID INTEGER;
	DECLARE PIATTIME BIGINT;
	DECLARE PIVALIDTIME BIGINT;
	DECLARE PIRCOUNT1 INTEGER;
    DECLARE PIRCOUNT2 INTEGER;
  DECLARE PIBATCHID BIGINT;
  DECLARE PIAREACODE INTEGER;

  DECLARE PISPLITLEN_V  INTEGER;
  DECLARE PIMULTILEN1_V  INTEGER;
  DECLARE PIMULTILEN2_V  INTEGER;
  DECLARE PINEWSIGNLEN_V  INTEGER;
  DECLARE PIOLDSIGNLEN_V  INTEGER;
  DECLARE PISIGNATURE_V  VARCHAR(22);

	SET PILONGMSG='';
	SET PIRECVMTTIME = CURRENT TIMESTAMP;
	SET PISRCCPNO  = SUBSTRING(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE),CODEUNITS32);
	SET PIDESTCPNO = SUBSTRING(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE),CODEUNITS32);
	DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPTB_RDMTTASK (
	UID INTEGER,
	PTMSGID BIGINT,
	ECID INTEGER,
	TASKID INTEGER,
	USERID VARCHAR(11),
	SPGATE VARCHAR(21),
	CPNO VARCHAR(21),
	PHONE VARCHAR(21),
	SPMSGID BIGINT,
	RETFLAG SMALLINT,
	FEEFLAG SMALLINT,
	PKNUMBER SMALLINT,
	PKTOTAL SMALLINT,
	SENDSTATUS SMALLINT,
	SENDFLAG SMALLINT,
	RECVFLAG SMALLINT,
	PASSTHROUGH SMALLINT,
	DONEDATE CHAR(10),
	ERRORCODE CHAR(7),
	SENDLEVEL SMALLINT,
	SENDTYPE SMALLINT,
	UNICOM SMALLINT,
	RESENDCNT SMALLINT,
	RECVMTTIME TIMESTAMP,
	RECVTIME TIMESTAMP,
	USERMSGID BIGINT,
	MESSAGE VARCHAR(3000),
	TPUDHI SMALLINT,
	LONGMSGSEQ SMALLINT,
	MSGFMT SMALLINT,
	MOBILEAREA INTEGER,
	SVRTYPE VARCHAR(64),
	TPPID SMALLINT,
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
	MODULEID INTEGER,
	ATTIME BIGINT,
	VALIDTIME BIGINT,
	BATCHID BIGINT,
	AREACODE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	--取补发帐号的费用
	SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE UCASE(USERID)=UCASE(PIDESTUSRID);
	--该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;

	IF COALESCE(PIRCOUNT1,0)<=0 THEN
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;
	END IF;

    DELETE FROM SESSION.TMPTB_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
    GET DIAGNOSTICS PIRCOUNT2 = ROW_COUNT;

  IF PIRCOUNT1-PIRCOUNT2  <>0 THEN
	--BEGIN
		SELECT PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME,BATCHID,AREACODE
		       INTO PIPKTOTAL ,PIPKNUM ,PIECID ,PIPHONE ,PISENDLEVEL ,PITASKID ,PITPUDHI ,PILONGMSGSEQ ,PIMSGFMT ,PIUNICOM ,PIMOBILEAREA  ,PISVRTYPE ,PITPPID ,PIUSERMSGID ,PISENDTYPE ,PIP1 ,PIP2 ,PIP3 ,PIP4 ,PIMODULEID ,PIATTIME ,PIVALIDTIME,PIBATCHID,PIAREACODE
		       FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;

    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       SET PIOLDSIGNLEN_V=PIOLDENSIGNLEN;
     ELSE
       SET PIOLDSIGNLEN_V=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       SET PISPLITLEN_V  =PIENSPLITLEN;
       SET PIMULTILEN1_V =PIENMULTILEN1;
       SET PIMULTILEN2_V =PIENMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWENSIGNLEN;
       SET PISIGNATURE_V =PIENSIGNATURE;
     ELSE
       SET PISPLITLEN_V  =PISPLITLEN;
       SET PIMULTILEN1_V =PIMULTILEN1;
       SET PIMULTILEN2_V =PIMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWSIGNLEN;
       SET PISIGNATURE_V =PISIGNATURE;
     END IF;

		 IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN --对于非长短信补发的处理
			--BEGIN PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME
				SET PILONGMSG='';
				--取短信内容
				SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
				--更新替换MSGID
				UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF; --END OF LONGMSGLEN<=SPLITLEN

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END;--END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF; --END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1;
			--END ; --END OF PKTOTAL = 1
        /*
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN --对标准协议长短信的补发
		--BEGIN
			SET PILONGMSG='';
			--取短信内容
			SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
			--更新替换MSGID
			UPDATE GW_MT_TASK_BAK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
			IF (PIPKTOTAL=PIPKNUM) THEN--如果是最后一条，去掉旧签名，加上新签名
			--BEGIN
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN; --减去签名的净长度
				SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				SET PILONGMSG =PILONGMSG||PISIGNATURE;
			END IF;
			SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
			IF PILONGMSGLEN > 0 THEN
			--BEGIN
				--调用插入存储过程
				CALL S_WR_MTTASKSR (PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
								PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
								PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,'',PITPUDHI,
								PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
								PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);

			--END --END OF IF LONGMSGLEN > 0
			ELSE
				SET PILONGMSG='';
			END IF; --IF LONGMSGLEN > 0
		*/
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0) THEN--对非标准长短信协议的处理
		--BEGIN
			SET PILONGMSG='';
			--没有补发过且通道号跟源通道号相等
			IF EXISTS(SELECT * FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID) THEN
			--BEGIN
				--循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
				--计算起始MSGID
				SET PIINITMSGID = PIOLDMSGID-(PIPKNUM-1)*17179869184;
				SET PIPKNUM = 1;

				WHILE PIPKNUM <= PIPKTOTAL
				DO
					--取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
					SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					IF PISINGLEMSG IS NULL THEN
					  SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  IF PISINGLEMSG1 IS NOT NULL THEN
					    UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					    --拼接短信内容
					    SET PILONGMSG = PILONGMSG||PISINGLEMSG1;
					  END IF;
					ELSE
					  UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  --拼接短信内容
					  SET PILONGMSG = PILONGMSG||PISINGLEMSG;
					END IF; --IF SINGLEMSG = ''
					--更新替换MSGID
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END OF WHILE PKNUM <= PKTOTAL

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
                SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF;

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL S_WR_MTTASK (PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME ,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END --END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF;--END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1 ;
			END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM TMP WHERE PTMSGID=OLDMSGID AND RESENDCNT<1 AND (RTRIM(SPGATE)+RTRIM(CPNO))=SRCSPNUMBER)
		END IF;--END OF IF PKTOTAL > 1
	END IF;--END OF IF ROWCOUNT<>0
	PRET: BEGIN

	DECLARE C_3 CURSOR WITH RETURN FOR
	SELECT PIDESTUID AS UID,PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
	PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,PIPKNUM AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
	SENDSTATUS,1 AS SENDLEVEL,PIRECVMTTIME AS RECVMTTIME,PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
	MOBILEAREA,SVRTYPE,TPPID,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM SESSION.TMPTB_RDMTTASK WHERE PILONGMSG<>'' ;
	OPEN C_3;
	END PRET;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITBV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIECID" INTEGER,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERID" VARCHAR(11),
  IN "PIORGUID" INTEGER,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PISPMSGID" BIGINT
 )
  SPECIFIC "GW_WRRPTWAITBV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_B(UID, PTMSGID, SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, USERID, ECID, ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID)
	   VALUES(PIUID, PIPTMSGID, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PIUSERID, PIECID, PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID);
	END IF;
END  &&



CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITCV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPGATE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" INTEGER,
  IN "PIRECVFLAG" INTEGER,
  IN "PISENDTIME" INTEGER,
  IN "PISPMSGID" BIGINT,
  IN "PIWTRPTFLAG" INTEGER,
  IN "PIRECVTIME"  TIMESTAMP

 )
  SPECIFIC "GW_WRRPTWAITCV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_C(UID, PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, RECVFLAG ,
	   ERRORCODE, LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME)
	   VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG ,
	   PIERRORCODE, PILOGINID,PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME);
	END IF;
END  &&


  CREATE OR REPLACE  PROCEDURE "GW_WRMTTASKCV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PITPUDHI" SMALLINT,
  IN "PILOGINID" VARCHAR(11),
  IN "PITRANSMTTIME" TIMESTAMP,
  IN "PIMSGFMT" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PISENDLEVEL" SMALLINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PIUNICOM"     SMALLINT,
  IN "PITASKID"     INTEGER,
  IN "PIMOBILEAREA" INTEGER,

  IN "PINETERRORCNT" INTEGER,
  IN "PISUBMITERRORCNT" INTEGER

 )
  SPECIFIC "GW_WRMTTASKCV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO MT_TASK_C(UID, LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
	   SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME,TPUDHI,LONGMSGSEQ,TRANSMTTIME,MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT )
	   VALUES(PIUID, PILOGINID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
	   PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVTIME,PITPUDHI,PILONGMSGSEQ,PITRANSMTTIME,PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA,PINETERRORCNT,PISUBMITERRORCNT );
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRMTTASKCV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PITPUDHI" SMALLINT,
  IN "PILOGINID" VARCHAR(11),
  IN "PITRANSMTTIME" TIMESTAMP,
  IN "PIMSGFMT" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PISENDLEVEL" SMALLINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PIUNICOM"     SMALLINT,
  IN "PITASKID"     INTEGER,
  IN "PIMOBILEAREA" INTEGER,

  IN "PINETERRORCNT" INTEGER,
  IN "PISUBMITERRORCNT" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64)

 )
  SPECIFIC "GW_WRMTTASKCV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO MT_TASK_C(UID, LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
	   SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME,TPUDHI,LONGMSGSEQ,TRANSMTTIME,MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT,CUSTID,EXDATA)
	   VALUES(PIUID, PILOGINID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
	   PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVTIME,PITPUDHI,PILONGMSGSEQ,PITRANSMTTIME,PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA,PINETERRORCNT,PISUBMITERRORCNT,PICUSTID,PIEXDATA)  ;
	END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_LOADSVRTYPE"()
  SPECIFIC "GW_LOADSVRTYPE"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(1000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT BUS_ID AS SVRID,UCASE(BUS_CODE) AS SVRCODE,BUS_NAME AS SVRNAME,STATE AS SVRSTATE FROM LF_BUSMANAGER';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_DELWAIT"
 (IN "EACHMAX" INTEGER
 )
  SPECIFIC "GW_DELWAIT"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC

    DECLARE PIMOWAITAMIN BIGINT;
    DECLARE PIMOWAITAMAX BIGINT;
    DECLARE PIMOWAITACURMAX BIGINT;

    DECLARE PIRPTWAITAMIN BIGINT;
    DECLARE PIRPTWAITAMAX BIGINT;
    DECLARE PIRPTWAITACURMAX BIGINT;

    DECLARE PIRPTWAITBMIN BIGINT;
    DECLARE PIRPTWAITBMAX BIGINT;
    DECLARE PIRPTWAITBCURMAX BIGINT;

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

      SET PIMOWAITAMIN=0;
	  SET PIMOWAITAMAX=0;
	  SELECT MIN(ID),MAX(ID) INTO PIMOWAITAMIN,PIMOWAITAMAX FROM MO_WAIT_A WHERE  DELIVERTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  WHILE PIMOWAITAMIN<=PIMOWAITAMAX DO
	  SET  PIERROR='';
	  SET PIMOWAITACURMAX=PIMOWAITAMIN+EACHMAX-1;
	  IF PIMOWAITACURMAX>PIMOWAITAMAX THEN
	   SET PIMOWAITACURMAX=PIMOWAITAMAX;
	  END IF;
	  DELETE FROM MO_WAIT_A WHERE ID BETWEEN PIMOWAITAMIN AND PIMOWAITACURMAX;
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
	  END IF;
	  SET PIMOWAITAMIN=PIMOWAITAMIN+EACHMAX;
	  COMMIT;
      END WHILE;

	  SET PIRPTWAITAMIN=0;
	  SET PIRPTWAITAMAX=0;
	  SELECT MIN(ID) , MAX(ID) INTO PIRPTWAITAMIN,PIRPTWAITAMAX FROM RPT_WAIT_A WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  WHILE PIRPTWAITAMIN<=PIRPTWAITAMAX DO
	   SET  PIERROR='';
	  SET PIRPTWAITACURMAX=PIRPTWAITAMIN+EACHMAX-1;
	  IF PIRPTWAITACURMAX>PIRPTWAITAMAX THEN
	   SET PIRPTWAITACURMAX=PIRPTWAITAMAX;
	  END IF;
      DELETE FROM RPT_WAIT_A WHERE ID BETWEEN PIRPTWAITAMIN AND PIRPTWAITACURMAX;
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
	  END IF;
       SET PIRPTWAITAMIN=PIRPTWAITAMIN+EACHMAX;
	  COMMIT;
      END WHILE;

	  SET PIRPTWAITBMIN=0;
	  SET PIRPTWAITBMAX=0;
	  SELECT MIN(ID) , MAX(ID) INTO PIRPTWAITBMIN,PIRPTWAITBMAX FROM RPT_WAIT_B WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
	  WHILE PIRPTWAITBMIN<=PIRPTWAITBMAX DO
	   SET  PIERROR='';
	  SET PIRPTWAITBCURMAX=PIRPTWAITBMIN+EACHMAX-1;
	  IF PIRPTWAITBCURMAX>PIRPTWAITBMAX THEN
	   SET PIRPTWAITBCURMAX=PIRPTWAITBMAX;
	  END IF;
      DELETE FROM RPT_WAIT_B WHERE ID BETWEEN PIRPTWAITBMIN AND PIRPTWAITBCURMAX;
	  IF PIERROR <> '' THEN
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
	  END IF;
	   SET PIRPTWAITBMIN=PIRPTWAITBMIN+EACHMAX;
	  COMMIT;
      END WHILE;


END NAP  &&

CREATE OR REPLACE  PROCEDURE "GW_H_DATATRANV2"
 (IN "ISP1" INTEGER,
  IN "ISP2" INTEGER,
  IN "ISP3" INTEGER,
  IN "ISP4" INTEGER
 )
  SPECIFIC "GW_H_DATATRANV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  DECLARE PIUSEID                 INTEGER; --使用哪一个USEID作为当前状态处理
  DECLARE PICURRINDEX             BIGINT; --当前处理位置
  DECLARE PIMAXINDEX              BIGINT; --此次执行的最大位置
  DECLARE PICOUNTSTATUS           INTEGER; --统计状态0:正常,1:错误
  DECLARE PIDISTRACTSTATUS        INTEGER; --数据转移状态0:正常,1:错误
  DECLARE PIDELETESTATUS          INTEGER; --删除状态0:正常,1:错误
  DECLARE PIPROCESSFLAG           INTEGER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,

  --异常退出
  DECLARE PICOUNTEXCEPTION        INTEGER; --允许统计异常最大值
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --允许数据转移异常最大值
  DECLARE PIDELETEEXCEPTION       INTEGER; --允许删除数据异常最大值
  DECLARE PIALLEXCEPTION          INTEGER; --允许所有异常最大值

  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

--------------------VER 3.2------------------------------------
--初始化
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 1;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  SET PIPROCESSFLAG           = 3;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;

      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV2','短信汇总调度存储过程执行开始');

      --先汇总

	  CALL GW_H_STATISTIV2(PIPROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV2',PIERROR);
	  END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
       BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
	  END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     --转移符合当前时间的数据
     SELECT VALUE(MIN(ID),0) INTO PIMAXINDEX FROM GW_MT_TASK_BAK  WHERE  SENDTIME>=TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
IF  PIMAXINDEX>0 THEN
SET PIMAXINDEX=PIMAXINDEX-1;
END IF;
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM GW_MT_TASK_BAK  WHERE ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		  --创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL   GW_H_TRANSFERV1(PI_MININDEX,PI_CURINDEX);
       CALL   GW_H_DELTASKV1(PI_MININDEX,PI_CURINDEX);
       CALL   H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
	      SET  PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	 IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF; --END OF IF PIERROR <> '' THEN
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_TRANSFERMO();

	--删除短信文件请求历史表数据
	DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
    END IF;

	IF DAY(CURRENT DATE)=1 THEN
	  CALL GW_DELWAIT(EACHMAX);
	END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS,RUNFLAG) VALUES('SMS','GW_H_DATATRANV2','短信汇总调度存储过程执行结束',1);
END NAP  &&


CREATE OR REPLACE  PROCEDURE GW_H_MMSDATATV1
 (IN "PIPROCESSFLAG" INTEGER,IN "ISP1" INTEGER,IN "ISP2" INTEGER,IN "ISP3" INTEGER,IN "ISP4" INTEGER
 )
  SPECIFIC GW_H_MMSDATATV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS(USEID,1)
  DECLARE PIUSEID                 INTEGER; --USEID
  DECLARE PICURRINDEX             BIGINT; --
  DECLARE PIMAXINDEX              BIGINT; --
  DECLARE PICOUNTSTATUS           INTEGER; --0:,1:
  DECLARE PIDISTRACTSTATUS        INTEGER; --0:,1:
  DECLARE PIDELETESTATUS          INTEGER; --0:,1:
  --
  DECLARE PICOUNTEXCEPTION        INTEGER; --
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --
  DECLARE PIDELETEEXCEPTION       INTEGER; --
  DECLARE PIALLEXCEPTION          INTEGER; --
  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;
--------------------VER 3.2-------------------------------------
--
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 2;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  --SET PIPROCESSFLAG           = 2;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;
  --SET PITRANSFERFLAG          = 0;
  --SET SQLCODE               = 0;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','GW_H_MMSDATATV1','彩信汇总调度存储过程执行开始');

      SELECT VALUE(MIN(ID),0),VALUE(MAX(ID),0)INTO PICURRINDEX,PIMAXINDEX  FROM MMS_TASK
      WHERE SENDTIME>= TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000') AND SENDTIME < TIMESTAMP (TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000');
      CALL GW_H_MMSSTATIV1(PIPROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行汇总GW_H_MMSSTATIV1',PIERROR);
	  END IF;

      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
	   BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
		END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     SELECT VALUE(MAX(ID),0) INTO PIMAXINDEX FROM MMS_TASK  WHERE  SENDTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
     --判断是否存在未转移的数据
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM MMS_TASK  WHERE  ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		--创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MMSTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (2,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL  H_MMSTRANSFER(PI_MININDEX,PI_CURINDEX);
       CALL  H_MMSDELTETASK(PI_MININDEX,PI_CURINDEX);
       CALL  H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行数据转移',PIERROR);
	      SET PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF;
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_MMSTRANSFERMO();

	--删除彩信文件请求历史表数据
	DELETE FROM MMS_BMTREQHIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_BMTREQHIS表记录',PIERROR);
  END IF;

  IF DAY(CURRENT DATE)=1 THEN
  DELETE FROM MMS_RPT WHERE RECVTIME<TIMESTAMP(TRIM(CAST((CURRENT DATE- 1 MONTHS) AS CHAR(32)))||' 00:00:00.000000');
    IF PIERROR <> '' THEN
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_RPT表记录',PIERROR);
    END IF;
  END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS,RUNFLAG) VALUES('MMS','GW_H_MMSDATATV1','彩信汇总调度存储过程执行结束',1);
END NAP  &&



CREATE OR REPLACE  PROCEDURE GW_CMTDATARPT(PIYM INTEGER)
BEGIN

	DECLARE PISTR VARCHAR(4000);
	DECLARE PISTR_1 VARCHAR(256);
	DECLARE PITABLENAME VARCHAR(20);

    SET PITABLENAME='GW_MTDRPT'||CAST(PIYM AS CHAR(6));
    SET PISTR='CREATE TABLE '||PITABLENAME||
    '(
    USERID        VARCHAR(11)     NOT NULL,
   TASKID        INTEGER         NOT NULL  DEFAULT 0,
   SPGATE        VARCHAR(21)     NOT NULL,
   IYMD          INTEGER         NOT NULL,
   IHOUR         SMALLINT        NOT NULL,
   PTCODE        VARCHAR(10)     NOT NULL  DEFAULT ''JH'',
   IMONTH        SMALLINT        NOT NULL,
   ICOUNT        INTEGER         NOT NULL  DEFAULT 0,
   SUCC          INTEGER         NOT NULL  DEFAULT 0,
   FAIL1         INTEGER         NOT NULL  DEFAULT 0,
   FAIL2         INTEGER         NOT NULL  DEFAULT 0,
   FAIL3         INTEGER         NOT NULL  DEFAULT 0,
   NRET          INTEGER         NOT NULL  DEFAULT 0,
   RSUCC         INTEGER         NOT NULL  DEFAULT 0,
   RFAIL1        INTEGER         NOT NULL  DEFAULT 0,
   RFAIL2        INTEGER         NOT NULL  DEFAULT 0,
   RNRET         INTEGER         NOT NULL  DEFAULT 0,
   RELEASEFLAG   SMALLINT        NOT NULL  DEFAULT 1,
   STARTTIME     TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
   ENDTIME       TIMESTAMP       NOT NULL  DEFAULT CURRENT TIMESTAMP,
   ID            INTEGER         NOT NULL  GENERATED BY DEFAULT
    AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE, MINVALUE 1, MAXVALUE 2147483647, NO CYCLE, NO ORDER),
   Y             SMALLINT        NOT NULL  DEFAULT 0,
   SPISUNCM      SMALLINT        NOT NULL  DEFAULT 0,
   SPID          VARCHAR(32)     NOT NULL  DEFAULT '''',
   SVRTYPE       VARCHAR(64)     NOT NULL  DEFAULT '''',
   P1            VARCHAR(64)     NOT NULL  DEFAULT '''',
   P2            VARCHAR(64)     NOT NULL  DEFAULT '''',
   P3            VARCHAR(64)     NOT NULL  DEFAULT '''',
   P4            VARCHAR(64)     NOT NULL  DEFAULT '''',
   MOBILEAREA 	 INTEGER	       NOT NULL DEFAULT 0,
   SENDTYPE      INTEGER         NOT NULL DEFAULT 1,
   BATCHID       BIGINT          NOT NULL DEFAULT 0,
   AREACODE 	  INTEGER 				NOT NULL DEFAULT 0
 )
  DATA CAPTURE NONE
IN  TBSPHISTORY';

	EXECUTE IMMEDIATE PISTR;

   SET PISTR_1= 'ALTER TABLE '||PITABLENAME||
    ' LOCKSIZE ROW
    APPEND OFF
    NOT VOLATILE
    LOG INDEX BUILD NULL';

	 EXECUTE IMMEDIATE PISTR_1;

    SET PISTR_1='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||'(TASKID)';
    EXECUTE IMMEDIATE PISTR_1;
    SET PISTR_1='CREATE UNIQUE INDEX PK_'||PITABLENAME||' ON '||PITABLENAME||'(USERID ,TASKID ,SPGATE ,IYMD , IHOUR ,SPISUNCM ,SVRTYPE ,P1 , P2 ,P3 , P4 , SPID , MOBILEAREA , SENDTYPE , BATCHID , AREACODE)';
    EXECUTE IMMEDIATE PISTR_1;

  END  &&


CALL DELPROC('GW_H_STATISTIV3')   &&
CREATE OR REPLACE  PROCEDURE "GW_H_STATISTIV3"
 (IN "PIPROCESSFLAG" INTEGER,
  IN "ISP1" INTEGER,
  IN "ISP2" INTEGER,
  IN "ISP3" INTEGER,
  IN "ISP4" INTEGER
 )
  SPECIFIC "GW_H_STATISTIV3"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE STR VARCHAR(4000);
	DECLARE BEGTIME VARCHAR(32);
	DECLARE ENDTIME VARCHAR(32);
	DECLARE MAXIYMD INTEGER;
	DECLARE DIFFDATE INTEGER;
	DECLARE MINTMIYMD INTEGER;
	DECLARE MAXTMIYMD INTEGER;

	DECLARE GLOBAL TEMPORARY TABLE SESSION.TEMP_STATISTICS (
	USERID VARCHAR(11),
	TASKID INTEGER,
	SPGATE VARCHAR(21),
	SPISUNCM INTEGER,
	SPID VARCHAR(32),
	SVRTYPE VARCHAR(64),
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
    IYMD INTEGER,
	IYEAR INTEGER,
	IMONTH INTEGER,
	IHOUR INTEGER,
	ICOUNT INTEGER,
	SUCC INTEGER,
	FAIL INTEGER,
	NRET INTEGER,
	MOBILEAREA INTEGER,
	SENDTYPE INTEGER,
	BATCHID BIGINT,AREACODE INTEGER,TMPLID BIGINT,CHGRADE SMALLINT,MSGTYPE SMALLINT) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

     SELECT  COALESCE(MAX(IYMD),20000101)  INTO MAXIYMD FROM MT_DATAREPORT ;
	SET DIFFDATE=days(CURRENT DATE - 2 days) - days(date(SUBSTR(CHAR(MAXIYMD),1,4)||'-'||SUBSTR(CHAR(MAXIYMD),5,2)||'-'||SUBSTR(CHAR(MAXIYMD),7,2)));
	IF DIFFDATE>0 THEN
          SET PIPROCESSFLAG=PIPROCESSFLAG+DIFFDATE;
	END IF;

	SET BEGTIME = TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000';
	SET ENDTIME = TRIM(CAST((CURRENT DATE) AS CHAR(32)))||' 00:00:00.000000';



	SET STR= 'INSERT INTO SESSION.TEMP_STATISTICS(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,MOBILEAREA,SENDTYPE,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
			   IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
			   ELSE
			    SET STR=STR||','' '' AS P1';
			   END IF;
			   IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
			   ELSE
			    SET STR=STR||','' '' AS P2';
			   END IF;
			   IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   ELSE
			    SET STR=STR||','' '' AS P3';
			   END IF;
			   IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   ELSE
			    SET STR=STR||','' '' AS P4';
			   END IF;

               SET STR=STR||', INT(DATE(SENDTIME)) AS IYMD,
               INT(YEAR(SENDTIME)) AS IYEAR,
               INT(MONTH(SENDTIME)) AS MON,
               INT(HOUR(SENDTIME)) AS HOUR,
               COUNT(ID),
			         VALUE(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
			         VALUE(COUNT(CASE LENGTH(TRIM(ERRORCODE))  WHEN 0 THEN 1 ELSE NULL END ),0),
			         MOBILEAREA,
			         SENDTYPE,
			         BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE
               FROM GW_MT_TASK_BAK
               WHERE SENDTIME BETWEEN '''||BEGTIME|| ''' AND '''||ENDTIME||''' GROUP BY
               USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
	         IF ISP1 =1 THEN
			    SET STR=STR||' ,P1';
             END IF;
			 IF ISP2 =1 THEN
			    SET STR=STR||' ,P2';
             END IF;
			 IF ISP3 =1 THEN
			    SET STR=STR||' ,P3';
			   END IF;
			 IF ISP4 =1 THEN
			    SET STR=STR||' ,P4';
			   END IF;
	 SET STR=STR||',MOBILEAREA,SENDTYPE,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE,
               INT(DATE(SENDTIME)),
               INT(YEAR(SENDTIME)),
               INT(MONTH(SENDTIME)),
               INT(HOUR(SENDTIME))';

       EXECUTE IMMEDIATE STR;
       --插入或更新统计表
	  SELECT MIN(IYMD) , MAX(IYMD) INTO MINTMIYMD,MAXTMIYMD FROM SESSION.TEMP_STATISTICS;
      DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN MINTMIYMD AND MAXTMIYMD;

      INSERT INTO MT_DATAREPORT(USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET, SENDTYPE, MOBILEAREA,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE)
      SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET, T.SENDTYPE, T.MOBILEAREA,T.BATCHID ,T.AREACODE, T.TMPLID,T.CHGRADE,T.MSGTYPE
      FROM SESSION.TEMP_STATISTICS  T;
      COMMIT;
   END  &&

CREATE OR REPLACE  PROCEDURE "GW_H_DATATRANV3"
 (IN "ISP1" INTEGER,
  IN "ISP2" INTEGER,
  IN "ISP3" INTEGER,
  IN "ISP4" INTEGER
 )
  SPECIFIC "GW_H_DATATRANV3"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  NAP:BEGIN NOT ATOMIC
  DECLARE PIPROCESSINGSTATUSCOUNT INTEGER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  DECLARE PIUSEID                 INTEGER; --使用哪一个USEID作为当前状态处理
  DECLARE PICURRINDEX             BIGINT; --当前处理位置
  DECLARE PIMAXINDEX              BIGINT; --此次执行的最大位置
  DECLARE PICOUNTSTATUS           INTEGER; --统计状态0:正常,1:错误
  DECLARE PIDISTRACTSTATUS        INTEGER; --数据转移状态0:正常,1:错误
  DECLARE PIDELETESTATUS          INTEGER; --删除状态0:正常,1:错误
  DECLARE PIPROCESSFLAG           INTEGER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,

  --异常退出
  DECLARE PICOUNTEXCEPTION        INTEGER; --允许统计异常最大值
  DECLARE PIDISTRACTEXCEPTION     INTEGER; --允许数据转移异常最大值
  DECLARE PIDELETEEXCEPTION       INTEGER; --允许删除数据异常最大值
  DECLARE PIALLEXCEPTION          INTEGER; --允许所有异常最大值

  --批量转移临时变量
  DECLARE PI_CURINDEX           BIGINT;
  DECLARE PI_MAXINDEX           BIGINT;
  DECLARE PI_MININDEX           BIGINT;
  DECLARE EACHMAX               INTEGER; --每次处理最大数

  DECLARE MINYM   INTEGER;
  DECLARE MAXYM   INTEGER;
  DECLARE CURYM   INTEGER;
  DECLARE PITABLENAME VARCHAR(20);
  DECLARE MAXTIME TIMESTAMP;
  DECLARE MINTIME TIMESTAMP;
  DECLARE ISEXIST INTEGER;
  DECLARE PISTR   VARCHAR(256);

  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

--------------------VER 3.2------------------------------------
--初始化
  SET PIPROCESSINGSTATUSCOUNT = 0;
  SET PIUSEID                 = 1;
  SET PICURRINDEX             = 0;
  SET PIMAXINDEX              = 0;
  SET PICOUNTSTATUS           = 1;
  SET PIDISTRACTSTATUS        = 1;
  SET PIDELETESTATUS          = 1;
  SET PIPROCESSFLAG           = 3;
  SET EACHMAX               = 500000;
  SET PICOUNTEXCEPTION        = 5;
  SET PIDISTRACTEXCEPTION     = 5;
  SET PIDELETEEXCEPTION       = 5;
  SET PIALLEXCEPTION          = 10;

      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV3','短信汇总调度存储过程执行开始');

      --先汇总

	  CALL GW_H_STATISTIV3(PIPROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
	  IF PIERROR <> '' THEN
	    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV3',PIERROR);
	  END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PIPROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PIPROCESSINGSTATUSCOUNT = 0) THEN
       BEGIN
        CALL H_PROCESSINGSTATUS(PIUSEID,0,0,0,0,0);
	    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
	  END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,PICOUNTSTATUS,PIDISTRACTSTATUS,PIDELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

     --转移符合当前时间的数据
     SELECT VALUE(MIN(ID),0) INTO PIMAXINDEX FROM GW_MT_TASK_BAK  WHERE  SENDTIME>=TIMESTAMP (TRIM(CAST((CURRENT DATE - PIPROCESSFLAG DAYS) AS CHAR(32)))||' 00:00:00.000000');
IF  PIMAXINDEX>0 THEN
SET PIMAXINDEX=PIMAXINDEX-1;
END IF;
     IF(PICURRINDEX<PIMAXINDEX)THEN
     SELECT MIN(SENDTIME),MAX(SENDTIME) INTO MINTIME,MAXTIME FROM GW_MT_TASK_BAK  WHERE ID<=PIMAXINDEX;
	    SET MINYM=CAST((SUBSTR(CHAR(MINTIME),1,4)||SUBSTR(CHAR(MINTIME),6,2))AS INT);
        SET MAXYM=CAST((SUBSTR(CHAR(MAXTIME),1,4)||SUBSTR(CHAR(MAXTIME),6,2))AS INT);
		  --创建不存在的历史表
		SET CURYM=MINYM;
		WHILE CURYM<=MAXYM DO
		      SET PITABLENAME = 'MTTASK'||CAST(CURYM AS CHAR(6));
		      SELECT COUNT(1) INTO ISEXIST FROM SYSCAT.TABLES WHERE TABNAME=PITABLENAME;

		  IF ISEXIST<1 THEN
		      SET PISTR='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR(6))||')';
		      EXECUTE IMMEDIATE PISTR;
			  IF PIERROR <> '' THEN
			    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
	          END IF;
		  END IF;

		  IF INT(SUBSTR(CAST(CURYM AS CHAR(6)),5,2))=12 THEN
		       SET CURYM = CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR(6)),1,4)AS INT)+1 AS CHAR(4))||'01' AS INT);
		  ELSE
		       SET CURYM = CURYM+1;
		  END IF;
	   END WHILE;

	   --转移数据
	   IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PI_MININDEX+EACHMAX;
       ELSE
          SET PI_MININDEX=PICURRINDEX;
          SET PI_CURINDEX=PIMAXINDEX;
       END IF;

    WHILE (PI_MININDEX < PIMAXINDEX) DO
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       --转移数据
       CALL   GW_H_TRANSFERV1(PI_MININDEX,PI_CURINDEX);
       CALL   GW_H_DELTASKV1(PI_MININDEX,PI_CURINDEX);
       CALL   H_PROCESSINGSTATUS (PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
	   IF PIERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
	      SET  PIDISTRACTEXCEPTION = PIDISTRACTEXCEPTION - 1;
          SET PIALLEXCEPTION      = PIALLEXCEPTION - 1;
          IF(PIDISTRACTEXCEPTION <= 0 OR PIALLEXCEPTION <= 0) THEN
             RETURN;
          END IF;
	   ELSE
	 IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
            SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          ELSE
            SET PI_CURINDEX=PIMAXINDEX;
            SET PI_MININDEX=PI_MININDEX+EACHMAX;
          END IF;
          COMMIT ;--事务提交
       END IF; --END OF IF PIERROR <> '' THEN
	END WHILE;
    END IF;
    -- 执行上行统计
    CALL  H_TRANSFERMO();

	--删除短信文件请求历史表数据
	DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TIMESTAMP (TRIM(CAST((CURRENT DATE - 60 DAYS) AS CHAR(32)))||' 00:00:00.000000');
	IF PIERROR <> '' THEN
	  INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
    END IF;

	IF DAY(CURRENT DATE)=1 THEN
	  CALL GW_DELWAIT(EACHMAX);
	END IF;

	INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS,RUNFLAG) VALUES('SMS','GW_H_DATATRANV3','短信汇总调度存储过程执行结束',1);
END NAP  &&


CREATE OR REPLACE  PROCEDURE "GW_LOADCLUBIND"(IN "P_GWNO" INT)
SPECIFIC "GW_LOADCLUBIND"
LANGUAGE SQL
NOT DETERMINISTIC
CALLED ON NULL INPUT
EXTERNAL ACTION
OLD SAVEPOINT LEVEL
MODIFIES SQL DATA
INHERIT SPECIAL REGISTERS
BEGIN
DECLARE RS1 CURSOR WITH RETURN FOR
SELECT ID,PTACCUID,GWNO,GWEIGHT,UPDTIME FROM GW_CLUSPBIND
WHERE PTACCUID=(SELECT PTACCUID FROM GW_CLUSPBIND WHERE GWNO=P_GWNO);
OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_UPDCLUSTATS"(IN P_GWTYPE INTEGER,IN P_GWNO INTEGER,IN P_PRIGWNO INTEGER,IN P_OLDPRIGWNO INTEGER,IN P_RUNSTATUS INTEGER,IN P_WEIGHT INTEGER,IN P_RUNWEIGHT INTEGER,IN P_UPDTYPE INTEGER)
SPECIFIC "GW_UPDCLUSTATS"
LANGUAGE SQL
NOT DETERMINISTIC
CALLED ON NULL INPUT
EXTERNAL ACTION
OLD SAVEPOINT LEVEL
MODIFIES SQL DATA
INHERIT SPECIAL REGISTERS
BEGIN
DECLARE P_UPDRESULT INTEGER;
DECLARE P_ERROR VARCHAR(4000);
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 P_ERROR = MESSAGE_TEXT;
  END ;
  SET P_ERROR='';
IF P_UPDTYPE=1 THEN

		UPDATE GW_CLUSTATUS
		SET RUNSTATUS=P_RUNSTATUS,GWEIGHT=P_WEIGHT,RUNWEIGHT=P_RUNWEIGHT,UPDTIME=CURRENT TIMESTAMP
		WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO ;

		UPDATE GW_CLUDECISION
		SET RUNGWNO=P_GWNO,RUNUPDTIME=CURRENT TIMESTAMP
		WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO AND RUNGWNO=P_OLDPRIGWNO;
        GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
        P5:BEGIN
        DECLARE C_1 CURSOR WITH RETURN FOR
       	  	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
       OPEN C_1;
         END P5;
	END IF;

IF P_UPDTYPE=2 THEN

        UPDATE GW_CLUDECISION
        SET APPLYGWNO=P_PRIGWNO,APPLYSTATUS=1
        WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO;
        GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
        P1:BEGIN
        DECLARE C_1 CURSOR WITH RETURN FOR
       	  	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
       OPEN C_1;
         END P1;
	END IF;

IF P_UPDTYPE=3 THEN

    UPDATE GW_CLUSTATUS
		SET RUNSTATUS=P_RUNSTATUS,GWEIGHT=P_WEIGHT,RUNWEIGHT=P_RUNWEIGHT,UPDTIME=CURRENT TIMESTAMP
		WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO;

		UPDATE GW_CLUDECISION
		SET RUNGWNO=0,RUNUPDTIME=CURRENT TIMESTAMP,APPLYGWNO=0,APPLYSTATUS=0
		WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO;
		GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
        P6:BEGIN
        DECLARE C_1 CURSOR WITH RETURN FOR
       	  	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
       OPEN C_1;
         END P6;
	END IF;

IF P_UPDTYPE=4 THEN

	    SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
			UPDATE GW_CLUDECISION SET RUNGWNO=P_GWNO,RUNUPDTIME=CURRENT TIMESTAMP,APPLYGWNO=0,APPLYSTATUS=0
			WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO AND RUNGWNO=P_OLDPRIGWNO;
			GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
		IF P_UPDRESULT>0 THEN
			UPDATE GW_CLUSTATUS
			SET RUNSTATUS=P_RUNSTATUS,GWEIGHT=P_WEIGHT,RUNWEIGHT=0,UPDTIME=CURRENT TIMESTAMP
			WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO;
			END IF;
			IF P_ERROR <> '' THEN
	      ROLLBACK TO SAVEPOINT A;
	     ELSE
	      COMMIT ;
	    END IF;
	    P2:BEGIN
      DECLARE C_1 CURSOR WITH RETURN FOR
				   	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
			OPEN C_1;
      END P2;

	END IF;

IF P_UPDTYPE=5 THEN

       UPDATE GW_CLUDECISION SET RUNGWNO=0,RUNUPDTIME=CURRENT TIMESTAMP
       WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO ;
       UPDATE GW_CLUSTATUS SET GWEIGHT=P_WEIGHT,UPDTIME=CURRENT TIMESTAMP
       WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO ;
       GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
       P3:BEGIN
      DECLARE C_1 CURSOR WITH RETURN FOR
       	   	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
	   OPEN C_1;
     END P3;
	END IF;

IF P_UPDTYPE=6 THEN

       UPDATE GW_CLUSTATUS SET RUNSTATUS=P_RUNSTATUS,GWEIGHT=P_WEIGHT,RUNWEIGHT=P_RUNWEIGHT,UPDTIME=CURRENT TIMESTAMP
       WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO ;
        GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
       P4:BEGIN
      DECLARE C_1 CURSOR WITH RETURN FOR
        	   	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
		  OPEN C_1;
     END P4;
	END IF;

IF P_UPDTYPE=7 THEN

       UPDATE GW_CLUSTATUS SET RUNSTATUS=0,UPDTIME=CURRENT TIMESTAMP
       WHERE GWTYPE=P_GWTYPE AND GWNO=P_PRIGWNO ;
   GET DIAGNOSTICS P_UPDRESULT = ROW_COUNT;
       P7:BEGIN
      DECLARE C_1 CURSOR WITH RETURN FOR
        	   	SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,GC.RUNPRIGWNO,GC.APPLYGWNO,GC.APPLYSTATUS,
		GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,GWCLUSTATUS.UPDTIME,P_UPDRESULT AS UPDRESULT,CURRENT TIMESTAMP AS DBTIME  FROM GW_CLUSTATUS GWCLUSTATUS,
		(SELECT RUNGWNO AS RUNPRIGWNO,APPLYGWNO,APPLYSTATUS   FROM GW_CLUDECISION WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO)) GC
			   WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=P_GWTYPE AND GWNO=P_GWNO);
		  OPEN C_1;
     END P7;
 END IF;
END  &&

CREATE OR REPLACE  PROCEDURE GW_RD_BATREQV1
 (IN "PILOGINID" VARCHAR(11),
  IN "PIDOWNLOADFLAG" SMALLINT,
  IN "PICLUGWNO" INTEGER
 )
  SPECIFIC GW_RD_BATREQV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  IF  PIDOWNLOADFLAG =0 THEN
    P1:BEGIN
	  DECLARE C1 CURSOR WITH RETURN FOR
	  SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,
  		  TASKID,TITLE,MSG,MSGFMT,REMOTEURL,TRIM(LOCALPATH) AS LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TOTALNUM,SENDNUM,TASKTYPE,BATCHID,CLUPATH,CLUGWNO FROM BATCH_MT_REQ
	  WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND SENDSTATUS=3 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH)='' ORDER BY SENDLEVEL FETCH FIRST 1000 ROWS ONLY;
	  OPEN C1;
    END P1;
  ELSEIF PIDOWNLOADFLAG =1 AND PICLUGWNO<>99 THEN
    P2:BEGIN
	  DECLARE C2 CURSOR WITH RETURN FOR
	  SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,
  		  TASKID,TITLE,MSG,MSGFMT,REMOTEURL,TRIM(LOCALPATH) AS LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TOTALNUM,SENDNUM,TASKTYPE,BATCHID,CLUPATH,CLUGWNO FROM BATCH_MT_REQ
	  WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND (SENDSTATUS=4 OR SENDSTATUS=5) AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD'AND TRIM(LOCALPATH)<>'' AND TRIM(CLUPATH)<>'' ORDER BY SENDLEVEL FETCH FIRST 1000 ROWS ONLY;
	  OPEN C2;
	END P2;
  ELSE
    P3:BEGIN
	  DECLARE C3 CURSOR WITH RETURN FOR
	  SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SA,SENDTYPE,
  		  TASKID,TITLE,MSG,MSGFMT,REMOTEURL,TRIM(LOCALPATH) AS LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TOTALNUM,SENDNUM,TASKTYPE,BATCHID,CLUPATH,CLUGWNO FROM BATCH_MT_REQ
	  WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND (SENDSTATUS=4 OR SENDSTATUS=5) AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD'AND TRIM(LOCALPATH)<>''  ORDER BY SENDLEVEL FETCH FIRST 1000 ROWS ONLY;
	  OPEN C3;
	END P3;
  END IF;
END  &&


CREATE OR REPLACE  PROCEDURE GW_UPDBATREQV1
 (IN "PIUSERID" VARCHAR(6),
  IN "PIUSERUID" INTEGER,
  IN "PILOGINID" VARCHAR(11),
  IN "PISENDSTATUS" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIMSGID" BIGINT,
  IN "PILOCALPATH" VARCHAR(256),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIBMTMSGID" BIGINT,
  IN "PICLUPATH" VARCHAR(256),
  IN "PICLUGWNO" INTEGER,
  IN "PITOTALNUM" INTEGER,
  IN "PISENDNUM" INTEGER
 )
  SPECIFIC GW_UPDBATREQV1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
  --异常代码
  DECLARE SQLCODE INTEGER;
  DECLARE PIROWCOUNT INTEGER;

  IF PISENDSTATUS=0 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
	   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID));
       DELETE FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
       DELETE FROM ATTIME_TASK WHERE UCASE(LOGINID)=UCASE(PILOGINID) AND BMTMSGID=PIBMTMSGID;
	   IF SQLCODE<>0 AND SQLCODE<>100 THEN
	     ROLLBACK TO SAVEPOINT A;
	   ELSE
	     COMMIT;
	   END IF;
  ELSEIF PISENDSTATUS=2 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=CURRENT TIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=3 THEN
       UPDATE BATCH_MT_REQ SET USERUID=PIUSERUID,SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,MSGID=PIMSGID,SENDTIME=CURRENT TIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=4 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,LOCALPATH=PILOCALPATH,SENDNUM=PISENDNUM,SENDTIME=CURRENT TIMESTAMP,TOTALNUM=PITOTALNUM,CLUPATH=PICLUPATH,CLUGWNO=PICLUGWNO
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID) AND SENDSTATUS=3;
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
	   IF PIROWCOUNT<> 1 THEN
		   SAVEPOINT A ON ROLLBACK RETAIN CURSORS;
		   UPDATE BATCH_MT_REQ SET SENDSTATUS=0,ERRORCODE='UPDFAIL',SENDTIME=CURRENT TIMESTAMP WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID));
	       DELETE FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	       DELETE FROM ATTIME_TASK WHERE BMTMSGID=PIBMTMSGID AND UCASE(LOGINID)=UCASE(PILOGINID)  ;
		   IF SQLCODE<>0 AND SQLCODE<>100 THEN
		     ROLLBACK TO SAVEPOINT A;
		   ELSE
		     COMMIT;
		   END IF;
	   END IF;
  ELSEIF PISENDSTATUS=5 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,
       SENDTIME=CURRENT TIMESTAMP WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSEIF PISENDSTATUS=6 THEN
       UPDATE BATCH_MT_REQ SET ERRORCODE=PIERRORCODE,SENDNUM=PISENDNUM,
       SENDTIME=CURRENT TIMESTAMP WHERE BMTMSGID=PIBMTMSGID AND LOGINID=UCASE(PILOGINID);
	   GET DIAGNOSTICS PIROWCOUNT = ROW_COUNT;
  ELSE
       SET PIROWCOUNT = 0;
  END IF;

  P1:BEGIN
  DECLARE C1 CURSOR  WITH RETURN FOR
             SELECT PIROWCOUNT AS UPDROWCOUNT FROM SYSIBM.SYSDUMMY1;
  OPEN C1;
  END P1;
END  &&

CREATE OR REPLACE  PROCEDURE GW_WR_MTTASKBAK
 (
    IN PIUID         INTEGER,
    IN PIPTMSGID     BIGINT,
    IN PIECID        INTEGER,
    IN PISENDSTATUS  INTEGER,
    IN PIRETFLAG     SMALLINT,
    IN PIPKNUMBER    SMALLINT,
    IN PIPKTOTAL     SMALLINT,
    IN PIFEEFLAG     SMALLINT,
    IN PISENDLEVEL   SMALLINT,
    IN PIRECVMTTIME  TIMESTAMP,
    IN PIUSERID      VARCHAR(11),
    IN PISPGATE      VARCHAR(21),
    IN PICPNO        VARCHAR(21),
    IN PIPHONE       VARCHAR(21),
    IN PIMESSAGE     VARCHAR(3000),
    IN PITASKID      INTEGER,
    IN PIERRORCODE   CHARACTER(7),
    IN PITPUDHI      SMALLINT,
    IN PILONGMSGSEQ  SMALLINT,
    IN PIMSGFMT      SMALLINT,
    IN PIUNICOM      SMALLINT,
    IN PIMOBILEAREA  INTEGER,
    IN PISVRTYPE     VARCHAR(64),
    IN PIP1          VARCHAR(64),
    IN PIP2          VARCHAR(64),
    IN PIP3          VARCHAR(64),
    IN PIP4          VARCHAR(64),
    IN PIUSERMSGID   BIGINT,
    IN PIMODULEID    INTEGER,
    IN PIATTIME      BIGINT,
    IN PIVALIDTIME   BIGINT,
    IN PISENDTYPE    SMALLINT,
    IN PIBATCHID     BIGINT,
    IN PIAREACODE    INTEGER
 )
BEGIN
    DECLARE PICNT INTEGER;
    SELECT COUNT(ID) INTO PICNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID;
  IF PICNT=0 THEN
    INSERT INTO GW_MT_TASK_BAK(UID,PTMSGID,ECID,SENDSTATUS,RETFLAG,PKNUMBER,PKTOTAL,FEEFLAG,SENDLEVEL,
    RECVMTTIME,USERID,SPGATE,CPNO,PHONE,MESSAGE,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
    MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIPTMSGID,PIECID,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIFEEFLAG,PISENDLEVEL,PIRECVMTTIME,
    PIUSERID,PISPGATE,PICPNO,PIPHONE,PIMESSAGE,PITASKID,PIERRORCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
    PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_RDRPTWAITBV1"
 (IN "PIUID" INTEGER,
  IN "PIMAXREADCNT" INTEGER
 )
  SPECIFIC "GW_RDRPTWAITBV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT ID,"UID",ORGUID,ECID,USERID,SUBMITTIME,DONETIME,PHONE,SPNUMBER,PTMSGID,ERRORCODE,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA,RESENDCNT FROM RPT_WAIT_B '||
		'WHERE UID='||CAST(PIUID AS CHAR(12))||' FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITBV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIECID" INTEGER,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERID" VARCHAR(11),
  IN "PIORGUID" INTEGER,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PISPMSGID" BIGINT,
  IN "PIPKTOTAL" INTEGER

 )
  SPECIFIC "GW_WRRPTWAITBV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_B(UID, PTMSGID, SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, USERID, ECID, ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL)
	   VALUES(PIUID, PIPTMSGID, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PIUSERID, PIECID, PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL);
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITBV3"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIECID" INTEGER,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERID" VARCHAR(11),
  IN "PIORGUID" INTEGER,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PISPMSGID" BIGINT,
  IN "PIPKTOTAL" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64)
 )
  SPECIFIC "GW_WRRPTWAITBV3"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_B(UID, PTMSGID, SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, USERID, ECID, ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA)
	   VALUES(PIUID, PIPTMSGID, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PIUSERID, PIECID, PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL,PICUSTID,PIEXDATA);
	END IF;
END  &&



CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITCV3"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPGATE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" INTEGER,
  IN "PIRECVFLAG" INTEGER,
  IN "PISENDTIME" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PIWTRPTFLAG" INTEGER,
  IN "PIRECVTIME"  TIMESTAMP,
  IN "PIPKTOTAL" INTEGER

 )
  SPECIFIC "GW_WRRPTWAITCV3"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_C(UID, PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, RECVFLAG ,
	   ERRORCODE, LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME,PKTOTAL)
	   VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG ,
	   PIERRORCODE, PILOGINID,PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME,PIPKTOTAL)  ;
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITCV4"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISPGATE" VARCHAR(21),
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PILOGINID" VARCHAR(11),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRETFLAG" INTEGER,
  IN "PIRECVFLAG" INTEGER,
  IN "PISENDTIME" BIGINT,
  IN "PISPMSGID" BIGINT,
  IN "PIWTRPTFLAG" INTEGER,
  IN "PIRECVTIME"  TIMESTAMP,
  IN "PIPKTOTAL" INTEGER,
IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64)
 )
  SPECIFIC "GW_WRRPTWAITCV4"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_C(UID, PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, RECVFLAG ,
	   ERRORCODE, LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME,PKTOTAL,CUSTID,EXDATA)
	   VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG ,
	   PIERRORCODE, PILOGINID,PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME,PIPKTOTAL,PICUSTID,PIEXDATA) ;
	END IF;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_LOADDATAV1"
 (IN "FLAG" BIGINT,
  IN "INCRES" BIGINT,
  IN "PRETIME" INTEGER)
  SPECIFIC "GW_LOADDATAV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
DECLARE STR VARCHAR(3000);
DECLARE STR1 VARCHAR(3000);
DECLARE STR2 VARCHAR(3000);
DECLARE TBNAME VARCHAR(30);
DECLARE TBNAMEBAK VARCHAR(30);
DECLARE TBNAMEERR VARCHAR(30);

DECLARE A INTEGER;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE STARTID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE ENDID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE CURMINID1 BIGINT DEFAULT 0;
DECLARE REMAINDER BIGINT DEFAULT 0;
DECLARE ISSUCCES BIGINT DEFAULT 1;
DECLARE TRANLOGID BIGINT DEFAULT 0;
DECLARE P_COUNT BIGINT DEFAULT 0;
DECLARE I BIGINT DEFAULT 0;
DECLARE J BIGINT DEFAULT 0;
DECLARE NUM BIGINT DEFAULT 0;
DECLARE TNUM BIGINT DEFAULT 0;
DECLARE INTERROR1 BIGINT DEFAULT 0;
DECLARE INTERROR2 BIGINT DEFAULT 0;
 ---YICHANG
 DECLARE PIERROR VARCHAR(3000);
 DECLARE PIERROR1 VARCHAR(3000);

 DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;

  DECLARE CONTINUE HANDLER FOR   SQLSTATE   '23505'
  BEGIN
	 SET INTERROR1=23505;
  END ;



SELECT  COALESCE(ENDID,0) INTO STARTID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG AND ISSUCCES = 1 ORDER BY ID DESC FETCH  FIRST 1 ROWS ONLY ;   ----根据 上次成功转移的记录查找本次转移的开始id

IF FLAG =1 THEN
 SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0)  INTO  MINID,ENDID  FROM  MT_TASK WHERE SENDTIME<=CURRENT TIMESTAMP-PRETIME minutes WITH UR;
 SET TBNAME ='MT_TASK';
 SET TBNAMEBAK ='GW_MT_TASK_BAK';
 SET TBNAMEERR ='GW_MT_TASK_ERR';

 SET STR1 = 'PTMSGID,UID, ECID,  USERID, SPGATE, CPNO, PHONE, SPMSGID, RETFLAG,FEEFLAG, PKNUMBER , PKTOTAL, SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE , ERRORCODE,SENDLEVEL ,SENDTYPE ,UNICOM , SENDTIME, RECVTIME, MESSAGE   , RESENDCNT , TASKID ,  SPID   ,  MOBILEAREA , RECVMTTIME , TRANSMTTIME  ,TRANSRPTTIME , SENDRPTTIME  ,  MSGFMT  , LONGMSGSEQ ,  TPPID   , TPUDHI  ,  SVRTYPE ,  P1 , P2 ,  P3 ,  P4 ,  USERMSGID , MODULEID  ,ATTIME , VALIDTIME , BATCHID   ,  AREACODE,0 AS FLAGMTSDOK,0 AS FLAGRPTRVOK, 0 AS FLAGRPTSDOK, CURRENT TIMESTAMP AS  MTSUBMITTIME,0 AS ERRRESENDCNT,0 AS NETERRCNT,1 AS SENDRESULT,'' '' AS SPGATESEND, '' '' AS SPNUMBER,'' '' AS SENDERRCODE,'' '' AS  SUBMITDATE ';
 SET STR2 ='(PTMSGID ,UID, ECID,  USERID, SPGATE, CPNO, PHONE, SPMSGID, RETFLAG,FEEFLAG, PKNUMBER , PKTOTAL, SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE , ERRORCODE,SENDLEVEL ,SENDTYPE ,UNICOM , SENDTIME, RECVTIME, MESSAGE   , RESENDCNT , TASKID ,  SPID   ,  MOBILEAREA , RECVMTTIME , TRANSMTTIME  ,TRANSRPTTIME , SENDRPTTIME  ,  MSGFMT  , LONGMSGSEQ ,  TPPID   , TPUDHI  ,  SVRTYPE ,  P1 , P2 ,  P3 ,  P4 ,  USERMSGID , MODULEID  , ATTIME , VALIDTIME , BATCHID   ,  AREACODE, FLAGMTSDOK,FLAGRPTRVOK, FLAGRPTSDOK,  MTSUBMITTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,SENDERRCODE,SUBMITDATE) ';

ELSE
 RETURN;
END IF;


----如果表中无数据 则退出
IF ( 0=ENDID and 0=MINID ) THEN
RETURN;
END IF;

-----针对 前几次 删除 不成功处理   循环读出 然后删除  更新控制表
IF MINID  < STARTID+1  THEN
for v_row as c1 cursor with hold for SELECT  ID,STARTID,ENDID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG+4 AND ISSUCCES = 0
do
SET PIERROR = NULL;
SET STR = 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(v_row.STARTID)||' AND '||CHAR(v_row.ENDID);
PREPARE ST FROM STR;
EXECUTE  ST;
IF PIERROR IS NULL THEN
 UPDATE GW_TRAN_DEL_LOG SET END_TIME=CURRENT TIMESTAMP ,ISSUCCES=1 WHERE ID=v_row.ID;
END IF;
 COMMIT;
end for;
----------把此次转移的起始id重置 根据控制表上次转移成功id 重置
SET MINID =  STARTID+1;
END IF;

----若此次转移的最大id 等于上次成功转移的最大id 则退出
IF  ENDID=MINID-1 THEN
RETURN;
END IF;

-------加分批循环   设定步长

SELECT (ENDID-MINID+1)/INCRES,MOD((ENDID-MINID+1),INCRES) INTO TNUM,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET TNUM=TNUM+1;END IF;

WHILE ( NUM < TNUM ) DO
SET CURMINID=MINID+INCRES*NUM;
SET CURMAXID=CURMINID+INCRES-1;
IF NUM=TNUM-1 THEN
  SET CURMAXID=ENDID;
END IF;
INSERT INTO GW_TRAN_DEL_LOG(OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(FLAG,CURMINID,CURMAXID,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO TRANLOGID FROM SYSIBM.SYSDUMMY1;    ------此次转移的 控制信息
--- 转移数据 循环执行3次

SET I=0;
WHILE (I<3) DO
  SET PIERROR1 = NULL; SET PIERROR = NULL;
  SET STR ='INSERT INTO '||TBNAMEBAK||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID)||' WITH UR';

  EXECUTE IMMEDIATE STR;
  SET PIERROR1=PIERROR ;
  SET INTERROR2=INTERROR1;
   COMMIT;
  IF PIERROR1 is null  AND INTERROR2<>23505 THEN
      UPDATE GW_TRAN_DEL_LOG SET END_TIME= CURRENT TIMESTAMP,ISSUCCES=1 WHERE ID=TRANLOGID;
      INSERT INTO GW_TRAN_DEL_LOG(OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(FLAG+4,CURMINID,CURMAXID,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
      SELECT IDENTITY_VAL_LOCAL() INTO TRANLOGID FROM SYSIBM.SYSDUMMY1;    ------此次删除 的 控制信息
	  SET J=0;
	  WHILE J<3 DO
       SET PIERROR = NULL;
       SET STR = 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID);
       PREPARE ST FROM STR;
       EXECUTE  ST;
        IF PIERROR IS NULL THEN
          UPDATE GW_TRAN_DEL_LOG SET END_TIME=CURRENT TIMESTAMP ,ISSUCCES=1 WHERE ID=TRANLOGID;
          SET J=3;

        ELSE

          SET J=J+1;
        END IF;
      END WHILE;   -----END  WHILE J<3 DO
	  SET I=3;
  ELSE
      IF INTERROR2=23505 THEN
	   SET CURMINID1=CURMINID;
	   WHILE CURMINID1<=CURMAXID DO
	     SET INTERROR1=0;
	     SET STR ='INSERT INTO '||TBNAMEBAK||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||CHAR(CURMINID1)||' WITH UR';
         EXECUTE IMMEDIATE STR;
		 IF INTERROR1=23505 THEN
		  SET STR ='INSERT INTO '||TBNAMEERR||STR2||' SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||CHAR(CURMINID1)||' WITH UR';
          EXECUTE IMMEDIATE STR;
		 END IF; ---IF INTERROR1=23505 THEN
		  SET STR = 'DELETE FROM '||TBNAME||'  WHERE ID = '||CHAR(CURMINID1);
	      PREPARE ST FROM STR;
		  EXECUTE  ST;
		 SET CURMINID1=CURMINID1+1;
		 COMMIT;
	   END WHILE;---WHILE CURMINID1<=CURMAXID DO
	  ELSE
      SET STR = 'DELETE FROM '||TBNAMEBAK||' WHERE PTMSGID IN (SELECT PTMSGID FROM MT_TASK WHERE ID  BETWEEN  '||CHAR(CURMINID)||' AND '||CHAR(CURMAXID)||')';
	  PREPARE ST FROM STR;
      EXECUTE  ST;
	  SET I=I+1;
	  END IF; ---IF INTERROR2=23505 THEN
 END IF;
END WHILE;--WHILE (I<3) DO

SET NUM=NUM+1;
COMMIT;
END WHILE ;   ---- end  WHILE ( NUM < TNUM ) DO
END  &&

CREATE OR REPLACE  PROCEDURE "GW_UPPDATAMODE2"
 (IN PRETIME  INTEGER,IN INCRES_LOAD  BIGINT,IN INCRES_UPP  BIGINT
 )
  SPECIFIC "GW_UPPDATAMODE2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE STARTTIME VARCHAR(30);
DECLARE MINLONG BIGINT;
DECLARE I BIGINT;

SET I=0;
WHILE (I<3) DO
 SET STARTTIME=CHAR(CURRENT TIMESTAMP);
 CALL GW_LOADDATAV1(1,INCRES_LOAD,PRETIME) ;
 SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
IF MINLONG>=PRETIME THEN
   SET I=I+1;
ELSE
   CALL GW_UPPMTSDOK(PRETIME,INCRES_UPP,STARTTIME);
   SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
   IF MINLONG>=PRETIME THEN
   SET I=I+1;
   ELSE
      CALL GW_UPPRPTRVOK(PRETIME,INCRES_UPP,STARTTIME);
      SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
      IF MINLONG>=PRETIME THEN
        SET I=I+1;
     ELSE
           CALL GW_UPPRPTSDOK(PRETIME,INCRES_UPP,STARTTIME);
           SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
            IF MINLONG>=PRETIME THEN
             SET I=I+1;
            ELSE
              SET I=5;
            END IF;
     END IF;
  END IF;
END IF;
END WHILE;
END  &&

CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PISIGNLEN" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER
 )
  SPECIFIC "GW_WR_MTTASKV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PITMPMSGID BIGINT;
DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
DECLARE PILEN INT;
DECLARE PIRESULTMSG VARCHAR(3000);
DECLARE PIPKNUM INT;
DECLARE PITMPNUM INT;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPMTTASK(UID INT,
USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
PHONE VARCHAR(21),PTMSGID BIGINT ,MESSAGE VARCHAR(3000),
SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,
FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER,AREACODE INTEGER) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PILEN = LENGTH(PIMESSAGE, CODEUNITS32)-PISIGNLEN;
SET PITMPNUM = 0;
SET PIPKNUM = 1;
SET PISTRSPLIT = ',';

IF PIPHONECOUNT < 1 THEN
	RETURN;
END IF;

IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
	SET PISPLITLEN=140;
	SET PIMULTILEN1=134;
	SET PIMULTILEN2=134;
	SET PISIGNLEN=0;
END IF;

IF PIMSGFMT=25  THEN
		IF NOT EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID) THEN
		   INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,
		   TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		   VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI,PIPTMSGID,PIMESSAGE,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,
		   PIRECVMTTIME,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		   PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
		END IF;
		RETURN;
END IF;

IF PIPHONECOUNT = 1
THEN
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
	THEN
		IF PIPKTOTAL = 1
		THEN
			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,
			SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,
			TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
			SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
			VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE,
			PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,
			PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
			PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
		ELSE
			SET PIPKNUM = 1;
			SET PITMPMSGID = PIPTMSGID;
			IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
			THEN
				SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1,PISPLITLEN, CODEUNITS32);
				SET PITMPMSGID = PITMPMSGID;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,
					PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				IF  PILEN-PISPLITLEN+PISIGNLEN>=0
				  THEN
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
				  ELSE
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
				END IF;
				SET PITMPMSGID = PITMPMSGID+17179869184;
				SET PIPKNUM = PIPKNUM+1;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
					PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
			ELSE
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					IF PIPKNUM = PIPKTOTAL
					THEN
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSEIF PIPKNUM = PIPKTOTAL-1
					THEN
						IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
						THEN
						    IF  PILEN-(PIPKNUM-1)*PIMULTILEN1-1 >=0 THEN
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
							ELSE
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, 0, CODEUNITS32);
							END IF;
							SET PITMPNUM = PILEN-1;
						ELSE
							SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
							SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
						END IF;--END IF OF IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1;
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSE
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					END IF;--END IF OF IF PIPKNUM = PIPKTOTAL
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
						RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
						MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
						VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
						PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
						PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
					END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
			END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;

			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
			RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,
			LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME, A.ECID, A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
			A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.TMPMTTASK A;
		END IF;--END IF OF IF PIPKTOTAL = 1
	END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);

	IF PIPKTOTAL < 1 --
	THEN
		RETURN;
	END IF;

	IF PIPKTOTAL >= 1 --
	THEN
		WHILE PILOCATION <> 0 --
		DO
			SET PISTART = PILOCATION;
			SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
			IF PILOCATION > 0
			THEN
				SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);--
				IF PIRESULTPHONE <> ''
				THEN
					SET PITMPMSGID = PIPTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						IF PIPKTOTAL = 1
						THEN
							INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
							RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
							MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
							VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIMESSAGE, PISENDSTATUS,
							PIRETFLAG, PIPKTOTAL, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
							PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
						ELSE
							SET PIPKNUM = 1;
							IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
							THEN
								SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1, PISPLITLEN, CODEUNITS32);--
								SET PITMPMSGID = PITMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
									PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								IF PILEN-PISPLITLEN+PISIGNLEN>=0 THEN
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
								ELSE
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
								END IF;
								SET PITMPMSGID = PITMPMSGID+17179869184;
								SET PIPKNUM = PIPKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
									PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
									PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
							ELSE
								WHILE PIPKNUM <= PIPKTOTAL
								DO
									IF PIPKNUM = PIPKTOTAL
									THEN
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSEIF PIPKNUM = PIPKTOTAL-1
									THEN
										IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										THEN
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
											SET PITMPNUM = PILEN-1;
										ELSE
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
											SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
										END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSE
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
									IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
									THEN
										INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
										PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
										UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE)
										VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
										PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
										PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE);
									END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									SET PIPKNUM = PIPKNUM+1;
								END WHILE;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
							END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
						END	IF;--END IF OF IF PIPKTOTAL = 1
					END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
				END IF; --END IF OF IF PIRESULTPHONE <> ''
				SET PIPTMSGID = PIPTMSGID+1;
			END	IF; --END IF OF IF PILOCATION > 0
		END WHILE; --END WHILE OF WHILE PILOCATION <> 0

		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
		PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
		UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
		A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
		A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.TMPMTTASK A;
	END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --
END  &&


CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKSRV1"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER
 )
  SPECIFIC "GW_WR_MTTASKSRV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
SET PISTRSPLIT = ',';
--SET PIRECVMTTIME =CURRENT TIMESTAMP;
DECLARE GLOBAL TEMPORARY TABLE SESSION.PITMP(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),PHONE VARCHAR(21),
PTMSGID BIGINT ,MESSAGE VARCHAR(3000),SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

IF PIPHONECOUNT < 1 THEN--
	RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
		PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
		VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
		PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
	END IF;
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);
	WHILE PILOCATION <> 0 --
	DO
	  SET PISTART = PILOCATION;
	  SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
	  IF PILOCATION > 0
	  THEN
		  IF PILOCATION-PISTART-1 >=0 THEN
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);
		  ELSE
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,0, CODEUNITS32);
		  END IF;
		  IF PIRESULTPHONE <> ''
		  THEN
			  IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
				  INSERT INTO SESSION.PITMP(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
				  PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
				  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
				  VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
				  PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
				  PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
			  END IF;
			  SET PIPTMSGID = PIPTMSGID+1;
		  END IF;
	    END IF;
	 END WHILE;

	 INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
	 PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
	 SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
	 SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
	 A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
	 A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM SESSION.PITMP A;
END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKSRV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKSRV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
SET PISTRSPLIT = ',';
--SET PIRECVMTTIME =CURRENT TIMESTAMP;
DECLARE GLOBAL TEMPORARY TABLE SESSION.PITMP(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),PHONE VARCHAR(21),
PTMSGID BIGINT ,MESSAGE VARCHAR(3000),SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

IF PIPHONECOUNT < 1 THEN--
	RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
		PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
		VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
		PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
	END IF;
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);
	WHILE PILOCATION <> 0 --
	DO
	  SET PISTART = PILOCATION;
	  SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
	  IF PILOCATION > 0
	  THEN
		  IF PILOCATION-PISTART-1 >=0 THEN
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);
		  ELSE
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,0, CODEUNITS32);
		  END IF;
		  IF PIRESULTPHONE <> ''
		  THEN
			  IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
				  INSERT INTO SESSION.PITMP(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
				  PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
				  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
				  VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
				  PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
				  PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
			  END IF;
			  SET PIPTMSGID = PIPTMSGID+1;
		  END IF;
	    END IF;
	 END WHILE;

	 INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
	 PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
	 SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	 SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
	 A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
	 A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM SESSION.PITMP A;
END IF;
END  &&


CREATE OR REPLACE  PROCEDURE  GW_MTTASKSUPPV3
 (IN "PIOLDMSGID" BIGINT,
  IN "PINEWMSGID" BIGINT,
  IN "PISRCUID" INTEGER,
  IN "PISRCUSRID" VARCHAR(11),
  IN "PISRCSPGATE" VARCHAR(21),
  IN "PISRCSPNUMBER" VARCHAR(21),
  IN "PIDESTUID" INTEGER,
  IN "PIDESTUSRID" VARCHAR(11),
  IN "PIDESTSPGATE" VARCHAR(21),
  IN "PIDESTSPNUMBER" VARCHAR(21),
  IN "PIDESTFEEFLAG" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PINEWSIGNLEN" SMALLINT,
  IN "PIOLDSIGNLEN" SMALLINT,
  IN "PISIGNATURE" VARCHAR(20),
  IN "PINEWSIGNPOS" INTEGER,
  IN "PIOLDSIGNPOS" INTEGER,
  IN "PIENSPLITLEN" INTEGER, --英文短信单条长度，小于等于0标识不支持英文短信
  IN "PIENMULTILEN1" INTEGER, --英文长短信拆分长度
  IN "PIENMULTILEN2" INTEGER, --英文长短信最后一条长度
  IN "PINEWENSIGNLEN" INTEGER, --补发英文签名长度
  IN "PIOLDENSIGNLEN" INTEGER, --原英文签名长度
  IN "PIENSIGNATURE" VARCHAR(20) --英文签名
 )
  SPECIFIC  GW_MTTASKSUPPV3
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISENDNUM INTEGER;
	DECLARE PIPKTOTAL INTEGER;
	DECLARE PIPKNUM	 INTEGER;
	DECLARE PIINITMSGID BIGINT;
	DECLARE PISINGLEMSG VARCHAR(720);
	DECLARE PISINGLEMSG1 VARCHAR(720);
	DECLARE PILONGMSG VARCHAR(3000);
	DECLARE PITOTALCNT INTEGER;
	DECLARE PILONGMSGLEN INTEGER;
	DECLARE PIECID INTEGER;
	DECLARE PIPHONE VARCHAR(21);
	DECLARE PISENDLEVEL SMALLINT;
	DECLARE PITASKID INTEGER;
	DECLARE PIRECVMTTIME TIMESTAMP;
	DECLARE PISRCCPNO  VARCHAR(21);
	DECLARE PIDESTCPNO VARCHAR(21);
	DECLARE PITPUDHI SMALLINT;
	DECLARE PITPPID SMALLINT;
	DECLARE PILONGMSGSEQ SMALLINT;
	DECLARE PIMSGFMT SMALLINT;
	DECLARE PIUNICOM SMALLINT;
	DECLARE PIMOBILEAREA INTEGER;
	DECLARE PISVRTYPE VARCHAR(64);
	DECLARE PIUSERMSGID BIGINT;
	DECLARE PISENDTYPE SMALLINT;
	DECLARE PIP1 VARCHAR(64);
	DECLARE PIP2 VARCHAR(64);
	DECLARE PIP3 VARCHAR(64);
	DECLARE PIP4 VARCHAR(64);
	DECLARE PIMODULEID INTEGER;
	DECLARE PIATTIME BIGINT;
	DECLARE PIVALIDTIME BIGINT;
	DECLARE PIRCOUNT1 INTEGER;
    DECLARE PIRCOUNT2 INTEGER;
  DECLARE PIBATCHID BIGINT;
  DECLARE PIAREACODE INTEGER;

  DECLARE PISPLITLEN_V  INTEGER;
  DECLARE PIMULTILEN1_V  INTEGER;
  DECLARE PIMULTILEN2_V  INTEGER;
  DECLARE PINEWSIGNLEN_V  INTEGER;
  DECLARE PIOLDSIGNLEN_V  INTEGER;
  DECLARE PISIGNATURE_V  VARCHAR(22);

	SET PILONGMSG='';
	SET PIRECVMTTIME = CURRENT TIMESTAMP;
	SET PISRCCPNO  = SUBSTRING(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE),CODEUNITS32);
	SET PIDESTCPNO = SUBSTRING(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE),CODEUNITS32);
	DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPTB_RDMTTASK (
	UID INTEGER,
	PTMSGID BIGINT,
	ECID INTEGER,
	TASKID INTEGER,
	USERID VARCHAR(11),
	SPGATE VARCHAR(21),
	CPNO VARCHAR(21),
	PHONE VARCHAR(21),
	SPMSGID BIGINT,
	RETFLAG SMALLINT,
	FEEFLAG SMALLINT,
	PKNUMBER SMALLINT,
	PKTOTAL SMALLINT,
	SENDSTATUS SMALLINT,
	SENDFLAG SMALLINT,
	RECVFLAG SMALLINT,
	PASSTHROUGH SMALLINT,
	DONEDATE CHAR(10),
	ERRORCODE CHAR(7),
	SENDLEVEL SMALLINT,
	SENDTYPE SMALLINT,
	UNICOM SMALLINT,
	RESENDCNT SMALLINT,
	RECVMTTIME TIMESTAMP,
	RECVTIME TIMESTAMP,
	USERMSGID BIGINT,
	MESSAGE VARCHAR(3000),
	TPUDHI SMALLINT,
	LONGMSGSEQ SMALLINT,
	MSGFMT SMALLINT,
	MOBILEAREA INTEGER,
	SVRTYPE VARCHAR(64),
	TPPID SMALLINT,
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
	MODULEID INTEGER,
	ATTIME BIGINT,
	VALIDTIME BIGINT,
	BATCHID BIGINT,
	AREACODE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	--取补发帐号的费用
	SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE UCASE(USERID)=UCASE(PIDESTUSRID);
	--该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;

	IF COALESCE(PIRCOUNT1,0)<=0 THEN
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;
	END IF;

    DELETE FROM SESSION.TMPTB_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
    GET DIAGNOSTICS PIRCOUNT2 = ROW_COUNT;

  IF PIRCOUNT1-PIRCOUNT2  <>0 THEN
	--BEGIN
		SELECT PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME,BATCHID,AREACODE
		       INTO PIPKTOTAL ,PIPKNUM ,PIECID ,PIPHONE ,PISENDLEVEL ,PITASKID ,PITPUDHI ,PILONGMSGSEQ ,PIMSGFMT ,PIUNICOM ,PIMOBILEAREA  ,PISVRTYPE ,PITPPID ,PIUSERMSGID ,PISENDTYPE ,PIP1 ,PIP2 ,PIP3 ,PIP4 ,PIMODULEID ,PIATTIME ,PIVALIDTIME,PIBATCHID,PIAREACODE
		       FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;

    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       SET PIOLDSIGNLEN_V=PIOLDENSIGNLEN;
     ELSE
       SET PIOLDSIGNLEN_V=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       SET PISPLITLEN_V  =PIENSPLITLEN;
       SET PIMULTILEN1_V =PIENMULTILEN1;
       SET PIMULTILEN2_V =PIENMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWENSIGNLEN;
       SET PISIGNATURE_V =PIENSIGNATURE;
     ELSE
       SET PISPLITLEN_V  =PISPLITLEN;
       SET PIMULTILEN1_V =PIMULTILEN1;
       SET PIMULTILEN2_V =PIMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWSIGNLEN;
       SET PISIGNATURE_V =PISIGNATURE;
     END IF;

		 IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN --对于非长短信补发的处理
			--BEGIN PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME
				SET PILONGMSG='';
				--取短信内容
				SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
				--更新替换MSGID
				UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF; --END OF LONGMSGLEN<=SPLITLEN

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV1(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END;--END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF; --END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1;
			--END ; --END OF PKTOTAL = 1
        /*
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN --对标准协议长短信的补发
		--BEGIN
			SET PILONGMSG='';
			--取短信内容
			SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
			--更新替换MSGID
			UPDATE GW_MT_TASK_BAK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
			IF (PIPKTOTAL=PIPKNUM) THEN--如果是最后一条，去掉旧签名，加上新签名
			--BEGIN
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN; --减去签名的净长度
				SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				SET PILONGMSG =PILONGMSG||PISIGNATURE;
			END IF;
			SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
			IF PILONGMSGLEN > 0 THEN
			--BEGIN
				--调用插入存储过程
				CALL GW_WR_MTTASKSRV1(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
								PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
								PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,'',PITPUDHI,
								PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
								PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);

			--END --END OF IF LONGMSGLEN > 0
			ELSE
				SET PILONGMSG='';
			END IF; --IF LONGMSGLEN > 0
		*/
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0) THEN--对非标准长短信协议的处理
		--BEGIN
			SET PILONGMSG='';
			--没有补发过且通道号跟源通道号相等
			IF EXISTS(SELECT * FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID) THEN
			--BEGIN
				--循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
				--计算起始MSGID
				SET PIINITMSGID = PIOLDMSGID-(PIPKNUM-1)*17179869184;
				SET PIPKNUM = 1;

				WHILE PIPKNUM <= PIPKTOTAL
				DO
					--取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
					SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					IF PISINGLEMSG IS NULL THEN
					  SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  IF PISINGLEMSG1 IS NOT NULL THEN
					    UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					    --拼接短信内容
					    SET PILONGMSG = PILONGMSG||PISINGLEMSG1;
					  END IF;
					ELSE
					  UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  --拼接短信内容
					  SET PILONGMSG = PILONGMSG||PISINGLEMSG;
					END IF; --IF SINGLEMSG = ''
					--更新替换MSGID
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END OF WHILE PKNUM <= PKTOTAL

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
                SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF;

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV1 (PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME ,PISENDTYPE,PIBATCHID,PIAREACODE);
				--END --END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF;--END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1 ;
			END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM TMP WHERE PTMSGID=OLDMSGID AND RESENDCNT<1 AND (RTRIM(SPGATE)+RTRIM(CPNO))=SRCSPNUMBER)
		END IF;--END OF IF PKTOTAL > 1
	END IF;--END OF IF ROWCOUNT<>0
	PRET: BEGIN

	DECLARE C_3 CURSOR WITH RETURN FOR
	SELECT PIDESTUID AS UID,PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
	PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,PIPKNUM AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
	SENDSTATUS,1 AS SENDLEVEL,PIRECVMTTIME AS RECVMTTIME,PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
	MOBILEAREA,SVRTYPE,TPPID,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM SESSION.TMPTB_RDMTTASK WHERE PILONGMSG<>'' ;
	OPEN C_3;
	END PRET;
END  &&

CREATE OR REPLACE  PROCEDURE  GW_MTTASKSUPPV4
 (IN "PIOLDMSGID" BIGINT,
  IN "PINEWMSGID" BIGINT,
  IN "PISRCUID" INTEGER,
  IN "PISRCUSRID" VARCHAR(11),
  IN "PISRCSPGATE" VARCHAR(21),
  IN "PISRCSPNUMBER" VARCHAR(21),
  IN "PIDESTUID" INTEGER,
  IN "PIDESTUSRID" VARCHAR(11),
  IN "PIDESTSPGATE" VARCHAR(21),
  IN "PIDESTSPNUMBER" VARCHAR(21),
  IN "PIDESTFEEFLAG" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PINEWSIGNLEN" SMALLINT,
  IN "PIOLDSIGNLEN" SMALLINT,
  IN "PISIGNATURE" VARCHAR(60),
  IN "PINEWSIGNPOS" INTEGER,
  IN "PIOLDSIGNPOS" INTEGER,
  IN "PIENSPLITLEN" INTEGER, --英文短信单条长度，小于等于0标识不支持英文短信
  IN "PIENMULTILEN1" INTEGER, --英文长短信拆分长度
  IN "PIENMULTILEN2" INTEGER, --英文长短信最后一条长度
  IN "PINEWENSIGNLEN" INTEGER, --补发英文签名长度
  IN "PIOLDENSIGNLEN" INTEGER, --原英文签名长度
  IN "PIENSIGNATURE" VARCHAR(60) --英文签名
 )
  SPECIFIC  GW_MTTASKSUPPV4
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISENDNUM INTEGER;
	DECLARE PIPKTOTAL INTEGER;
	DECLARE PIPKNUM	 INTEGER;
	DECLARE PIINITMSGID BIGINT;
	DECLARE PISINGLEMSG VARCHAR(720);
	DECLARE PISINGLEMSG1 VARCHAR(720);
	DECLARE PILONGMSG VARCHAR(3000);
	DECLARE PITOTALCNT INTEGER;
	DECLARE PILONGMSGLEN INTEGER;
	DECLARE PIECID INTEGER;
	DECLARE PIPHONE VARCHAR(21);
	DECLARE PISENDLEVEL SMALLINT;
	DECLARE PITASKID INTEGER;
	DECLARE PIRECVMTTIME TIMESTAMP;
	DECLARE PISRCCPNO  VARCHAR(21);
	DECLARE PIDESTCPNO VARCHAR(21);
	DECLARE PITPUDHI SMALLINT;
	DECLARE PITPPID SMALLINT;
	DECLARE PILONGMSGSEQ SMALLINT;
	DECLARE PIMSGFMT SMALLINT;
	DECLARE PIUNICOM SMALLINT;
	DECLARE PIMOBILEAREA INTEGER;
	DECLARE PISVRTYPE VARCHAR(64);
	DECLARE PIUSERMSGID BIGINT;
	DECLARE PISENDTYPE SMALLINT;
	DECLARE PIP1 VARCHAR(64);
	DECLARE PIP2 VARCHAR(64);
	DECLARE PIP3 VARCHAR(64);
	DECLARE PIP4 VARCHAR(64);
	DECLARE PIMODULEID INTEGER;
	DECLARE PIATTIME BIGINT;
	DECLARE PIVALIDTIME BIGINT;
	DECLARE PIRCOUNT1 INTEGER;
    DECLARE PIRCOUNT2 INTEGER;
  DECLARE PIBATCHID BIGINT;
  DECLARE PIAREACODE INTEGER;
  DECLARE PICUSTID VARCHAR(64);
	DECLARE PIEXDATA VARCHAR(64);

  DECLARE PISPLITLEN_V  INTEGER;
  DECLARE PIMULTILEN1_V  INTEGER;
  DECLARE PIMULTILEN2_V  INTEGER;
  DECLARE PINEWSIGNLEN_V  INTEGER;
  DECLARE PIOLDSIGNLEN_V  INTEGER;
  DECLARE PISIGNATURE_V  VARCHAR(62);

	SET PILONGMSG='';
	SET PIRECVMTTIME = CURRENT TIMESTAMP;
	SET PISRCCPNO  = SUBSTRING(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE),CODEUNITS32);
	SET PIDESTCPNO = SUBSTRING(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE),CODEUNITS32);
	DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPTB_RDMTTASK (
	UID INTEGER,
	PTMSGID BIGINT,
	ECID INTEGER,
	TASKID INTEGER,
	USERID VARCHAR(11),
	SPGATE VARCHAR(21),
	CPNO VARCHAR(21),
	PHONE VARCHAR(21),
	SPMSGID BIGINT,
	RETFLAG SMALLINT,
	FEEFLAG SMALLINT,
	PKNUMBER SMALLINT,
	PKTOTAL SMALLINT,
	SENDSTATUS SMALLINT,
	SENDFLAG SMALLINT,
	RECVFLAG SMALLINT,
	PASSTHROUGH SMALLINT,
	DONEDATE CHAR(10),
	ERRORCODE CHAR(7),
	SENDLEVEL SMALLINT,
	SENDTYPE SMALLINT,
	UNICOM SMALLINT,
	RESENDCNT SMALLINT,
	RECVMTTIME TIMESTAMP,
	RECVTIME TIMESTAMP,
	USERMSGID BIGINT,
	MESSAGE VARCHAR(3000),
	TPUDHI SMALLINT,
	LONGMSGSEQ SMALLINT,
	MSGFMT SMALLINT,
	MOBILEAREA INTEGER,
	SVRTYPE VARCHAR(64),
	TPPID SMALLINT,
	P1 VARCHAR(64),
	P2 VARCHAR(64),
	P3 VARCHAR(64),
	P4 VARCHAR(64),
	MODULEID INTEGER,
	ATTIME BIGINT,
	VALIDTIME BIGINT,
	BATCHID BIGINT,
	AREACODE INTEGER,CUSTID VARCHAR(64),EXDATA VARCHAR(64))ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

	--取补发帐号的费用
	SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE UCASE(USERID)=UCASE(PIDESTUSRID);
	--该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;

	IF COALESCE(PIRCOUNT1,0)<=0 THEN
	INSERT INTO SESSION.TMPTB_RDMTTASK(UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
	SELECT UID,PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
	SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
	DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
	MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
	P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,'',''
	--只对0,8,15编码和人工实时、批量实时短信进行补发,其他不补发
	FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND UCASE(USERID)=UCASE(PISRCUSRID) AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND LOCATE(PISRCSPNUMBER,RTRIM(SPGATE)||RTRIM(CPNO),1)=1 ;
	GET DIAGNOSTICS PIRCOUNT1 = ROW_COUNT;
	END IF;

    DELETE FROM SESSION.TMPTB_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
    GET DIAGNOSTICS PIRCOUNT2 = ROW_COUNT;

  IF PIRCOUNT1-PIRCOUNT2  <>0 THEN
	--BEGIN
		SELECT PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
		       INTO PIPKTOTAL ,PIPKNUM ,PIECID ,PIPHONE ,PISENDLEVEL ,PITASKID ,PITPUDHI ,PILONGMSGSEQ ,PIMSGFMT ,PIUNICOM ,PIMOBILEAREA  ,PISVRTYPE ,PITPPID ,PIUSERMSGID ,PISENDTYPE ,PIP1 ,PIP2 ,PIP3 ,PIP4 ,PIMODULEID ,PIATTIME ,PIVALIDTIME,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA
		       FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;

    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       SET PIOLDSIGNLEN_V=PIOLDENSIGNLEN;
     ELSE
       SET PIOLDSIGNLEN_V=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       SET PISPLITLEN_V  =PIENSPLITLEN;
       SET PIMULTILEN1_V =PIENMULTILEN1;
       SET PIMULTILEN2_V =PIENMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWENSIGNLEN;
       SET PISIGNATURE_V =PIENSIGNATURE;
     ELSE
       SET PISPLITLEN_V  =PISPLITLEN;
       SET PIMULTILEN1_V =PIMULTILEN1;
       SET PIMULTILEN2_V =PIMULTILEN2;
       SET PINEWSIGNLEN_V=PINEWSIGNLEN;
       SET PISIGNATURE_V =PISIGNATURE;
     END IF;

		 IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN --对于非长短信补发的处理
			--BEGIN PKTOTAL ,PKNUMBER ,ECID ,PHONE ,SENDLEVEL ,TASKID ,TPUDHI ,LONGMSGSEQ ,MSGFMT ,UNICOM ,MOBILEAREA  ,SVRTYPE ,TPPID ,USERMSGID ,SENDTYPE ,P1 ,P2 ,P3 ,P4 ,MODULEID ,ATTIME ,VALIDTIME
				SET PILONGMSG='';
				--取短信内容
				SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
				--更新替换MSGID
				UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				   SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF; --END OF LONGMSGLEN<=SPLITLEN

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV2(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
				--END;--END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF; --END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1;
			--END ; --END OF PKTOTAL = 1
        /*
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN --对标准协议长短信的补发
		--BEGIN
			SET PILONGMSG='';
			--取短信内容
			SELECT MESSAGE INTO PILONGMSG FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
			--更新替换MSGID
			UPDATE GW_MT_TASK_BAK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
			IF (PIPKTOTAL=PIPKNUM) THEN--如果是最后一条，去掉旧签名，加上新签名
			--BEGIN
				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN; --减去签名的净长度
				SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				SET PILONGMSG =PILONGMSG||PISIGNATURE;
			END IF;
			SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
			IF PILONGMSGLEN > 0 THEN
			--BEGIN
				--调用插入存储过程
				CALL GW_WR_MTTASKSRV2(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
								PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
								PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,'',PITPUDHI,
								PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
								PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);

			--END --END OF IF LONGMSGLEN > 0
			ELSE
				SET PILONGMSG='';
			END IF; --IF LONGMSGLEN > 0
		*/
		ELSEIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0) THEN--对非标准长短信协议的处理
		--BEGIN
			SET PILONGMSG='';
			--没有补发过且通道号跟源通道号相等
			IF EXISTS(SELECT * FROM SESSION.TMPTB_RDMTTASK WHERE PTMSGID=PIOLDMSGID) THEN
			--BEGIN
				--循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
				--计算起始MSGID
				SET PIINITMSGID = PIOLDMSGID-(PIPKNUM-1)*17179869184;
				SET PIPKNUM = 1;

				WHILE PIPKNUM <= PIPKTOTAL
				DO
					--取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
					SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					IF PISINGLEMSG IS NULL THEN
					  SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  IF PISINGLEMSG1 IS NOT NULL THEN
					    UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					    --拼接短信内容
					    SET PILONGMSG = PILONGMSG||PISINGLEMSG1;
					  END IF;
					ELSE
					  UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
					  --拼接短信内容
					  SET PILONGMSG = PILONGMSG||PISINGLEMSG;
					END IF; --IF SINGLEMSG = ''
					--更新替换MSGID
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END OF WHILE PKNUM <= PKTOTAL

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32)-PIOLDSIGNLEN_V; --减去签名的净长度

				IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
                SET PILONGMSG=SUBSTRING(PILONGMSG,1,PILONGMSGLEN,CODEUNITS32);
				ELSE
				SET PILONGMSG=SUBSTRING(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN,CODEUNITS32);
				END IF;

				SET PILONGMSGLEN = LENGTH(PILONGMSG, CODEUNITS32);
				IF PILONGMSGLEN > 0 THEN
				--BEGIN
					--计算拆分条数
					IF PILONGMSGLEN<=PISPLITLEN_V THEN
					SET PIPKTOTAL=1;
					ELSE
					SET PIPKTOTAL=1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V);
					END IF;

					IF PINEWSIGNPOS=0 THEN--添加新短信的签名
					SET PILONGMSG = TRIM(PILONGMSG)||PISIGNATURE_V;
					ELSE
					SET PILONGMSG = PISIGNATURE_V||TRIM(PILONGMSG);
					END IF;

					--调用插入存储过程
					CALL GW_WR_MTTASKV2 (PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
									PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
									PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
									PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,'',PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
									PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME ,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
				--END --END OF IF LONGMSGLEN > 0
				ELSE
					SET PILONGMSG='';
				END IF;--END OF IF LONGMSGLEN > 0
				SET PIPKNUM=1 ;
			END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM TMP WHERE PTMSGID=OLDMSGID AND RESENDCNT<1 AND (RTRIM(SPGATE)+RTRIM(CPNO))=SRCSPNUMBER)
		END IF;--END OF IF PKTOTAL > 1
	END IF;--END OF IF ROWCOUNT<>0
	PRET: BEGIN

	DECLARE C_3 CURSOR WITH RETURN FOR
	SELECT PIDESTUID AS UID,PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
	PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,PIPKNUM AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
	SENDSTATUS,1 AS SENDLEVEL,PIRECVMTTIME AS RECVMTTIME,PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
	MOBILEAREA,SVRTYPE,TPPID,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA FROM SESSION.TMPTB_RDMTTASK WHERE PILONGMSG<>'' ;
	OPEN C_3;
	END PRET;
END  &&

CALL DELPROC('INSGATE')   &&
CREATE OR REPLACE  PROCEDURE "INSGATE"( )
BEGIN
DECLARE STR1 VARCHAR(500);
DECLARE CNT INT;
DECLARE I INT;
DECLARE TEMPIPLA  INT;
DECLARE TEMPPORTLA  INT;
DECLARE TEMPSTRLA  INT;
DECLARE TEMPIP  VARCHAR(50);
DECLARE TEMPPORT  INT;
DECLARE TEMPSTR  VARCHAR(500);
DECLARE TEMPSTRFR  VARCHAR(256);
DECLARE V_SQL  VARCHAR(800);
DECLARE　AT_END　INT　DEFAULT　0;
DECLARE  NOT_FOUND  CONDITION  FOR  SQLSTATE  '02000';
DECLARE V_STMT statement;
DECLARE CUR_TABLE  cursor with hold for V_STMT ;
DECLARE　CONTINUE　HANDLER　FOR　NOT_FOUND
set AT_END=1;

SET V_SQL ='SELECT  SUBSTR(PROTOCOLPARAM ,LOCATE(''backupip='',PROTOCOLPARAM)+9,LENGTH(PROTOCOLPARAM)-(LOCATE(''backupip='',PROTOCOLPARAM)+9)) from A_GWACCOUNT where PROTOCOLPARAM like ''%backupip%''';
prepare V_STMT from V_SQL;

OPEN CUR_TABLE;
set AT_END=0;
FETCH CUR_TABLE INTO STR1;
WHILE AT_END=0 DO

    SET CNT=LENGTH(STR1)-LENGTH(REPLACE(STR1,',',''))+1 ;
    SET I=0;
    WHILE I<CNT DO

   IF I=CNT-1 THEN

      SET  TEMPIPLA= LOCATE(':',STR1 );
      SET  TEMPIP=LEFT(STR1,TEMPIPLA-1) ;
      SET  TEMPPORT=RIGHT(STR1,LENGTH(STR1)-TEMPIPLA);
   ELSE
    SET  TEMPIPLA= LOCATE(':',STR1 );
    SET  TEMPIP=LEFT(STR1,TEMPIPLA-1) ;
    SET  TEMPSTRLA= LOCATE(',',STR1) ;
    SET  TEMPSTRFR=  LEFT(STR1,TEMPSTRLA-1);
    SET  TEMPPORT=    RIGHT(TEMPSTRFR,LENGTH(TEMPSTRFR )-TEMPIPLA);
    SET  TEMPSTR=  RIGHT(STR1 ,LENGTH(STR1 )-TEMPSTRLA) ;
     SET  STR1=TEMPSTR;
  END IF;
     INSERT INTO GW_GATECONNINFO(LINKLEVEL,IP,PORT) SELECT 1,TEMPIP,TEMPPORT  FROM  SYSIBM.SYSDUMMY1 WHERE NOT EXISTS (SELECT IP,PORT  FROM GW_GATECONNINFO WHERE IP=TEMPIP  AND  PORT=TEMPPORT);
     SET I=I+1;
   END WHILE;
  FETCH CUR_TABLE INTO STR1;
   END WHILE;
CLOSE CUR_TABLE;
END  &&

INSERT INTO GW_GATECONNINFO(PTACCID,IP,PORT) SELECT PTACCID,SPIP,SPPORT FROM A_GWACCOUNT A WHERE NOT EXISTS (SELECT PTACCID,IP,PORT  FROM GW_GATECONNINFO WHERE A.SPIP=IP AND A.PTACCID=PTACCID AND PORT=A.SPPORT)  &&
CALL INSGATE()  &&
CALL DELPROC('INSGATE')  &&


CALL DELPROC('GW_LOADBASEPARA')  &&
CREATE OR REPLACE  PROCEDURE   GW_LOADBASEPARA()
SPECIFIC "GW_LOADBASEPARA"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
      SELECT ID,FUNNAME,CMDTYPE,ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE,CREATETIME,MODIFTIME,RESERVE  FROM GW_BASEPARA;
      OPEN RS1;
	   END P1;
END  &&

CALL DELPROC('GW_LOADPROTOMTCH')   &&
CREATE OR REPLACE  PROCEDURE   GW_LOADPROTOMTCH()
SPECIFIC "GW_LOADPROTOMTCH"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
       SELECT GP.ID,GP.ECID,GP.FUNTYPE,GP.FUNNAME,GP.CMDTYPE,GP.CARGNAME,GP.MARGNAME,GP.CARGTYPE,GP.CARGVALUE,GP.BELONGTYPE,GP.BELONG,GP.CREATETIME,GP.MODIFTIME,GP.RESERVE,GB.RETTYPE,GB.STATUS,GB.CFUNNAME
       FROM GW_PROTOMTCH GP, GW_BASEPROTOCOL GB
       WHERE GP.FUNTYPE=GB.FUNTYPE AND GP.FUNNAME=GB.FUNNAME AND GP.CMDTYPE=GB.CMDTYPE AND GP.ECID=GB.ECID AND GB.STATUS=1;
      OPEN RS1;
	   END P1;
END  &&


CALL DELPROC('GW_GETALLUSRINFOV1')   &&
CREATE OR REPLACE  PROCEDURE "GW_GETALLUSRINFOV1" (
IN PISPTYPE INTEGER --=1
)
  SPECIFIC "GW_GETALLUSRINFOV1"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

  IF PISPTYPE IS NULL THEN
  SET PISPTYPE=1;
  END IF;
  P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
	SELECT COALESCE(B.UID,A.UID) AS  SVRID,A.UID,A.USERID,A.USERTYPE,A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,
	A.STAFFNAME AS CORPNAME,A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,
	A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE,
	GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,GU.
    PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT
	FROM USERDATA A LEFT JOIN (SELECT UID,USERID FROM USERDATA WHERE NUMBER_TO_BIT(USERPRIVILEGE) = '1' AND ACCOUNTTYPE=PISPTYPE) B
	ON (UCASE(A.LOGINID) = UCASE(B.USERID)) OR B.USERID IS NULL
	INNER JOIN 	GW_USERPROPERTY GU ON GU.USERID=A.USERID
	WHERE A.STATUS=0 AND A.USERTYPE=0 AND A.ACCOUNTTYPE=PISPTYPE;

	OPEN RS1;
	END P1;
END  &&




CALL DELPROC('GW_LOADPUSHPROMH')   &&
CREATE OR REPLACE  PROCEDURE GW_LOADPUSHPROMH()
SPECIFIC "GW_LOADPUSHPROMH"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
    SELECT GP.ID,GP.ECID,GP.USERID,GP.PUSHFLAG,GP.CMDTYPE,GP.CARGNAME,GP.CARGTYPE,GP.MARGNAME,GP.CARGVALUE,GP.BELONGTYPE,GP.BELONG,GP.RESERVE,GB.RETTYPE,GB.STATUS
    FROM GW_PUSHPROTOMTCH GP,(SELECT ECID,CMDTYPE,STATUS,CASE WHEN FUNNAME='MO' THEN 1 WHEN FUNNAME='RPT' THEN 2 ELSE 0 END AS  PUSHFLAG,RETTYPE FROM GW_BASEPROTOCOL) GB
   WHERE  GP.CMDTYPE=GB.CMDTYPE AND GP.ECID=GB.ECID AND GP.PUSHFLAG=GB.PUSHFLAG AND GB.STATUS=1;
      OPEN RS1;
	   END P1;
END  &&

CALL DELPROC('GW_LOADPUSHPROCOL')   &&
CREATE OR REPLACE  PROCEDURE  GW_LOADPUSHPROCOL()
SPECIFIC "GW_LOADPUSHPROCOL"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
      SELECT ID,ECID,USERID,RSPCMD,CARGNAME,RSPSTATUS,CRSPFMT,CARGVALUE  FROM GW_PUSHRSPROTOCOL;
      OPEN RS1;
	   END P1;
END  &&


CALL DELPROC('GW_LOADLFTEMPLATE')   &&
CREATE OR REPLACE  PROCEDURE GW_LOADLFTEMPLATE()
SPECIFIC "GW_LOADLFTEMPLATE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
        DECLARE PISQLSTR VARCHAR(1000)  ;
   	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT TM_ID,USER_ID,TM_NAME,TM_MSG,DSFLAG,TM_STATE,ADDTIME,ISPASS,TMP_TYPE,BIZ_CODE,CORP_CODE,PARAMCNT,TM_CODE,SP_TEMPLID,DEGREE,RMSRESSIZE,H5RESSIZE,ISPUBLIC,PARAMSNUM,VER  FROM LF_TEMPLATE WHERE TM_STATE=1 AND (TMP_TYPE=3 OR TMP_TYPE=11)';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;

END  &&


CALL DELPROC('GW_LOADGTCONNINFO')   &&
CREATE OR REPLACE  PROCEDURE GW_LOADGTCONNINFO(IN P_PIPTACCID VARCHAR(11))
SPECIFIC "GW_LOADGTCONNINFO"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
    SELECT  ID,PTID,GATEID,CONNTYPE,PTACCID,IP,PORT,LINKCNT,SPEEDLIMIT,LINKLEVEL,LINKSTATUS,PING,MINLINKS,KEEPCONN,RECONNCNT,RELOGINCNT,SWITCHMAINIP,TESTMETHOD,TESTTIMES,ABNORMALONG,ABNORMALTMS,ABNORMALONG,ABNORMALTMS
    FROM GW_GATECONNINFO WHERE PTACCID=P_PIPTACCID;
      OPEN RS1;
	   END P1;
END  &&


CALL DELPROC('GW_LOADUSRFEE')   &&
CREATE OR REPLACE  PROCEDURE GW_LOADUSRFEE(IN PISPTYPE INTEGER)
SPECIFIC "GW_LOADUSRFEE"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
     P1:BEGIN
	    DECLARE RS1 CURSOR WITH RETURN TO CLIENT FOR
  SELECT F.UID,F.SENDNUM,F.USERID FROM USERFEE F
  INNER JOIN USERDATA U ON F.USERID=U.USERID
  WHERE U.USERTYPE=0 AND U.STATUS=0 AND U.ACCOUNTTYPE=PISPTYPE;
      OPEN RS1;
	   END P1;
END  &&

CALL DELPROC('GW_GETURLBINDV1')   &&
CREATE OR REPLACE  PROCEDURE "GW_GETURLBINDV1"
(
	IN PIUID INTEGER,--=0,
    IN PISPTYPE INTEGER--=1
	)
SPECIFIC "GW_GETURLBINDV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
 IF PISPTYPE IS NULL THEN
 SET PISPTYPE=1;
 END IF;

 IF PIUID IS NULL THEN
 SET PIUID=0;
 END IF;

	IF PIUID=0 THEN
	P1:BEGIN
	DECLARE RS1 CURSOR WITH RETURN FOR
		SELECT UD.UID,UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
		CASE WHEN(VALUE(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE '' END AS MOURL,
		CASE WHEN(VALUE(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE '' END AS RPTURL,
		GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
		GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,UD.PUSHVERSION,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST
		FROM USERDATA UD INNER JOIN 	GW_USERPROPERTY GU ON GU.USERID=UD.USERID
		WHERE UD.USERTYPE=0 AND UD.STATUS=0
		AND ((VALUE(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) OR (VALUE(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2))
		AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD.UID;
		OPEN RS1;
	END P1;
	ELSE
	P2:BEGIN
	DECLARE RS2 CURSOR WITH RETURN FOR
		SELECT UD.UID,UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
		CASE WHEN(VALUE(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE '' END AS MOURL,
		CASE WHEN(VALUE(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE '' END AS RPTURL,
		GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
		GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,UD.PUSHVERSION,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST
		FROM USERDATA UD INNER JOIN 	GW_USERPROPERTY GU ON GU.USERID=UD.USERID
		WHERE UD.UID=PIUID AND UD.USERTYPE=0 AND UD.STATUS=0
		AND ((VALUE(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) OR (VALUE(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2))
		AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD.UID;
	OPEN RS2;
	END P2;
	END IF;
END  &&


CREATE OR REPLACE  PROCEDURE GW_WR_MTTASKBAKV2
 (
    IN PIUID         INTEGER,
    IN PIPTMSGID     BIGINT,
    IN PIECID        INTEGER,
    IN PISENDSTATUS  INTEGER,
    IN PIRETFLAG     SMALLINT,
    IN PIPKNUMBER    SMALLINT,
    IN PIPKTOTAL     SMALLINT,
    IN PIFEEFLAG     SMALLINT,
    IN PISENDLEVEL   SMALLINT,
    IN PIRECVMTTIME  TIMESTAMP,
    IN PIUSERID      VARCHAR(11),
    IN PISPGATE      VARCHAR(21),
    IN PICPNO        VARCHAR(21),
    IN PIPHONE       VARCHAR(21),
    IN PIMESSAGE     VARCHAR(3000),
    IN PITASKID      INTEGER,
    IN PIERRORCODE   CHARACTER(7),
    IN PITPUDHI      SMALLINT,
    IN PILONGMSGSEQ  SMALLINT,
    IN PIMSGFMT      SMALLINT,
    IN PIUNICOM      SMALLINT,
    IN PIMOBILEAREA  INTEGER,
    IN PISVRTYPE     VARCHAR(64),
    IN PIP1          VARCHAR(64),
    IN PIP2          VARCHAR(64),
    IN PIP3          VARCHAR(64),
    IN PIP4          VARCHAR(64),
    IN PIUSERMSGID   BIGINT,
    IN PIMODULEID    INTEGER,
    IN PIATTIME      BIGINT,
    IN PIVALIDTIME   BIGINT,
    IN PISENDTYPE    SMALLINT,
    IN PIBATCHID     BIGINT,
    IN PIAREACODE    INTEGER,
    IN PICUSTID VARCHAR(64),
    IN PIEXDATA VARCHAR(64),
	IN PISUID1 VARCHAR(64),
	IN PILUID1 VARCHAR(64)
 )
BEGIN
    DECLARE PICNT INTEGER;
    SELECT COUNT(ID) INTO PICNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID;
  IF PICNT=0 THEN
    INSERT INTO GW_MT_TASK_BAK(UID,PTMSGID,ECID,SENDSTATUS,RETFLAG,PKNUMBER,PKTOTAL,FEEFLAG,SENDLEVEL,
    RECVMTTIME,USERID,SPGATE,CPNO,PHONE,MESSAGE,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
    MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
    VALUES(PIUID,PIPTMSGID,PIECID,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIFEEFLAG,PISENDLEVEL,PIRECVMTTIME,
    PIUSERID,PISPGATE,PICPNO,PIPHONE,PIMESSAGE,PITASKID,PIERRORCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
    PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1)  ;
  END IF;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_UPD_MOTASKV1"
 (IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIUID" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PIRESENDCNT" INTEGER
 )
  SPECIFIC "GW_UPD_MOTASKV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

	IF PIUID=0 AND PIECID=0 AND PIUSERID='' THEN
		UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,RESENDCNT=PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
	ELSE
		UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,UID=PIUID,ECID=PIECID,USERID=PIUSERID,RESENDCNT=PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
	END IF;

END  &&

CREATE OR REPLACE  PROCEDURE "GW_WRRPTWAITBV4"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIECID" INTEGER,
  IN "PISPNUMBER" VARCHAR(21),
  IN "PIPHONE" VARCHAR(21),
  IN "PISUBMITTIME" CHARACTER(10),
  IN "PIDONETIME" CHARACTER(10),
  IN "PIERRORCODE" CHARACTER(7),
  IN "PIUSERID" VARCHAR(11),
  IN "PIORGUID" INTEGER,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIRECVTIME" TIMESTAMP,
  IN "PISPMSGID" BIGINT,
  IN "PIPKTOTAL" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64),
  IN "PIRESENDCNT" INTEGER
 )
  SPECIFIC "GW_WRRPTWAITBV4"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO RPT_WAIT_B(UID, PTMSGID, SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE, USERID, ECID, ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA,RESENDCNT)
	   VALUES(PIUID, PIPTMSGID, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE, PIUSERID, PIECID, PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL,PICUSTID,PIEXDATA,PIRESENDCNT)  ;
	END IF;
END  &&



CREATE OR REPLACE  PROCEDURE "GW_LOADTDCMD"()
  SPECIFIC "GW_LOADTDCMD"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(3000)  ;
	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT TD_CMD,MATCHTYPE FROM GW_TDCMD';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


CREATE OR REPLACE  PROCEDURE "GW_ADDPBLISTBLACK"(
IN PIPHONE BIGINT,
IN PITDCMD VARCHAR(64),
IN PIUSERID VARCHAR(11),
IN PISPNUMBER VARCHAR(21),
IN PISVRTYPE VARCHAR(64),
IN PIECID INTEGER,
IN PIMOMSGID BIGINT)
 SPECIFIC "GW_ADDPBLISTBLACK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
BEGIN
DECLARE PIOPTYPE SMALLINT;
DECLARE PIPBUSERID VARCHAR(11);
DECLARE PIPBSPNUMBER VARCHAR(21);
DECLARE PIPBSVRTYPE VARCHAR(64);
DECLARE PIPBCROPCODE VARCHAR(64);



	--表的策略信息决定是否需要添加黑名单
       IF EXISTS (SELECT * FROM GW_TDCMD WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE TD_SPNUMBER||'%')) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0) THEN
		    SELECT OPTYPE,PB_USERID,PB_SPNUMBER,PB_SVRTYPE,PB_CROPCODE INTO PIOPTYPE,PIPBUSERID,PIPBSPNUMBER,PIPBSVRTYPE,PIPBCROPCODE FROM GW_TDCMD  WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE TD_SPNUMBER||'%')) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0 FETCH FIRST 1 ROW ONLY;

		 --PB_LIST_BLACK表中是否已经存在对应的黑名单数据
		IF NOT EXISTS(SELECT * FROM PB_LIST_BLACK WHERE USERID=PIPBUSERID AND SPGATE='' AND SPNUMBER=PIPBSPNUMBER AND PHONE=PIPHONE AND SVRTYPE=PIPBSVRTYPE AND CORPCODE=PIPBCROPCODE AND OPTYPE=1) THEN
		   INSERT INTO PB_LIST_BLACK(USERID,SPGATE,SPNUMBER,PHONE,OPTYPE,OPTTIME,MSG,SVRTYPE,SPISUNCM,CORPCODE,BLTYPE)
		          VALUES(PIPBUSERID,'',PIPBSPNUMBER,PIPHONE,PIOPTYPE,CURRENT TIMESTAMP,'',PIPBSVRTYPE,0,PIPBCROPCODE,1);
		   INSERT INTO GW_TDCMD_HIS(TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID,OPTYPE,MO_MSGID,TD_TIME)
		          VALUES(PIPHONE,PITDCMD,PIUSERID,PISPNUMBER,PIECID,PIOPTYPE,PIMOMSGID,CURRENT TIMESTAMP);
                END IF;


        END IF;
END  &&


CALL DELPROC('GW_RD_MTLVLQUEV1')   &&
CREATE OR REPLACE  PROCEDURE "GW_RD_MTLVLQUEV1"
 (IN "PIDESTUID" INTEGER,
  IN "PISENDLEVEL" INTEGER,
  IN "PIMAXREADCNT" INTEGER,
  IN "PISTRUID" VARCHAR(4000),
  IN "PICURTIME" BIGINT,
  IN P_TABLENO INTEGER
 )
  SPECIFIC "GW_RD_MTLVLQUEV1"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	DECLARE PISQLSTR VARCHAR(6000);
	DECLARE P_TABNAME VARCHAR(6000);
	DECLARE RS1 CURSOR WITH RETURN FOR S1;

	 IF  P_TABLENO>=0  AND   P_TABLENO<=9 THEN
	   SET P_TABNAME='MT_LEVEL'||CAST(P_TABLENO AS CHAR(1))||'_QUEUE';
	 ELSE
	   SET P_TABNAME='MT_LEVEL0_QUEUE';
	 END IF;

	SET PISQLSTR = 'SELECT ID,UID,DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,SENDTIME AS RECVMTTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1 FROM '||P_TABNAME||' WHERE DESTUID='||
		CAST(PIDESTUID AS CHAR(12))||' AND UID NOT IN ('||PISTRUID||')AND SENDLEVEL='||CAST(PISENDLEVEL AS CHAR(12))||' AND (ATTIME<='||CAST(PICURTIME AS CHAR(20))||' OR ATTIME<0) FETCH FIRST '||CAST(PIMAXREADCNT AS CHAR(12))||' ROW ONLY';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;
END  &&


CALL DELPROC('GW_WR_MTLVLQUEV2')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTLVLQUEV2"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64),
  IN P_TABLENO INTEGER
 )
  SPECIFIC "GW_WR_MTLVLQUEV2"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF P_TABLENO =0 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =1 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL1_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL1_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =2 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL2_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL2_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =3 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL3_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL3_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =4 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL4_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL4_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =5 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL5_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL5_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =6 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL6_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL6_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =7 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL7_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL7_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =8 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL8_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL8_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
ELSEIF P_TABLENO =9 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL9_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL9_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
   END IF;
END IF;
END  &&


CALL DELPROC('GW_WR_RMSRPT_RVOK')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_RMSRPT_RVOK"
 (IN "PIUSERID" INTEGER,
  IN "PIUSERUID" BIGINT,
  IN "PIPTMSGID" SMALLINT,
  IN "PISPNUMBER" SMALLINT,
  IN "PIPHONE" INTEGER,
  IN "PIERRORCODE" SMALLINT,
  IN "PIMOBILEAREA" SMALLINT,
  IN "PIMOBILETYPE" INTEGER,
  IN "PISENDSTATUS" VARCHAR(11),
  IN "PIFIRSTDOWNTM" VARCHAR(21),
  IN "PIENDDOWNTM" VARCHAR(21),
  IN "PIRDNRPTOKTM" TIMESTAMP,
  IN "PIRDNTRANSRPTTM" VARCHAR(3500),
  IN "PIRECVRDNRPTTM" VARCHAR(3000),
  IN "PIMOBILECOUNTRY" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIMSGTYPE" INTEGER
 )
  SPECIFIC "GW_WR_RMSRPT_RVOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS (SELECT PTMSGID  FROM GW_RMSRPT_RVOK WHERE PTMSGID = PIPTMSGID ) THEN
     INSERT INTO GW_RMSRPT_RVOK(USERID,USERUID,PTMSGID,SPNUMBER,PHONE,ERRORCODE,MOBILEAREA,MOBILETYPE,SENDSTATUS,FIRSTDOWNTM,ENDDOWNTM,RDNRPTOKTM,
	 RDNTRANSRPTTM,RECVRDNRPTTM,MOBILECOUNTRY,ECID,MSGTYPE )
     VALUES(PIUSERID,PIUSERUID,PIPTMSGID,PISPNUMBER,PIPHONE,PIERRORCODE,PIMOBILEAREA,PIMOBILETYPE,PISENDSTATUS,PIFIRSTDOWNTM,PIENDDOWNTM,PIRDNRPTOKTM,
	 PIRDNTRANSRPTTM,PIRECVRDNRPTTM,PIMOBILECOUNTRY,PIECID,PIMSGTYPE)  ;
	END IF;
END  &&


CALL DELPROC('GW_UPPRMSRPTRVOK')   &&
CREATE OR REPLACE  PROCEDURE "GW_UPPRMSRPTRVOK"
 (IN "PRETIME" INTEGER,IN "INCRES" BIGINT,IN "STARTTIME" VARCHAR(30)
 )
  SPECIFIC "GW_UPPRMSRPTRVOK"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  begin
DECLARE STR VARCHAR(256);
DECLARE A INTEGER;
DECLARE rows1 INTEGER ;
DECLARE LOGID INTEGER ;
DECLARE I INTEGER DEFAULT 0;
DECLARE J INTEGER DEFAULT 0;
DECLARE REMAINDER INTEGER DEFAULT 0;
DECLARE COUNTID BIGINT DEFAULT 0;
DECLARE MAXID BIGINT DEFAULT 0;
DECLARE CURMINID BIGINT DEFAULT 0;
DECLARE CURMAXID BIGINT DEFAULT 0;
DECLARE MINID BIGINT DEFAULT 0;
DECLARE MINLONG BIGINT DEFAULT 0;
declare  locl result_set_locator varying;
DECLARE PIERROR VARCHAR(3000);
DECLARE CONTINUE HANDLER FOR SQLSTATE '21506'
  BEGIN
	GET DIAGNOSTICS EXCEPTION 1 PIERROR = MESSAGE_TEXT;
  END ;


------------------更新GW_RMSRPT_RVOK表-------------------------------------------


SELECT COALESCE(MIN(ID),0),COALESCE(MAX(ID),0) INTO MINID,MAXID FROM GW_RMSRPT_RVOK WITH UR;

IF ( 0=MAXID and 0=MINID ) THEN
RETURN;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM SYSIBM.SYSDUMMY1;
IF REMAINDER<>0 THEN
SET J=J+1;END IF;

WHILE (I < J) DO
INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(7,1,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
SET CURMINID=MINID+INCRES*I;
SET CURMAXID=CURMINID+INCRES-1;
IF I=J-1 THEN
  SET CURMAXID=MAXID;
END IF;
set PIERROR=null;
MERGE INTO  GW_MT_TASK_BAK AS A using GW_RMSRPT_RVOK AS B on ( A.PTMSGID=B.PTMSGID AND B.ID >= CURMINID AND B.ID <= CURMAXID)
WHEN MATCHED THEN
UPDATE SET  A.ERRORCODE2  =B.ERRORCODE,
      A.DOWNTM      =B.FIRSTDOWNTM;   ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
GET DIAGNOSTICS rows1 = ROW_COUNT;
IF PIERROR IS NOT NULL THEN
  set PIERROR=null;
  set rows1=null;
--------------若有重复的 则去重 更新
   MERGE INTO  GW_MT_TASK_BAK A using (SELECT  PTMSGID,ERRORCODE,FIRSTDOWNTM  FROM  GW_RMSRPT_RVOK WHERE  ID >= CURMINID AND ID <= CURMAXID GROUP BY PTMSGID,ERRORCODE,FIRSTDOWNTM ) AS  B  on ( A.PTMSGID=B.PTMSGID )
   WHEN MATCHED THEN
   UPDATE SET   A.ERRORCODE2  =B.ERRORCODE,
      A.DOWNTM      =B.FIRSTDOWNTM;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
   UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=rows1, ISSUCCES=1,END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
   set rows1=null;
 ELSE
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
END IF;
  set PIERROR=null;
COMMIT;
 -------------删除更新成功的
  INSERT INTO GW_UPD_DEL_LOG(OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(8,0,0,0,CURRENT TIMESTAMP,CURRENT TIMESTAMP);
  SELECT IDENTITY_VAL_LOCAL() INTO LOGID FROM SYSIBM.SYSDUMMY1;
  DELETE FROM  GW_RMSRPT_RVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RMSRPT_RVOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGMTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
   GET DIAGNOSTICS rows1 = ROW_COUNT;
  IF PIERROR IS  NULL THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=rows1,ISSUCCES=1, END_TIME=CURRENT TIMESTAMP WHERE ID=LOGID;
  END IF;
  SET  MINLONG=TIMESTAMPDIFF(4,CHAR(CURRENT TIMESTAMP - TIMESTAMP(STARTTIME)));
  IF MINLONG>=PRETIME THEN
      SET  I=J;
  ELSE
      SET I=I+1;
 END IF;
COMMIT;
END WHILE;

END  &&


CALL DELPROC('GW_WR_MTTASKV4')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKV4"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PISIGNLEN" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64),
  IN "PILONGMSG" VARCHAR(4000),
  IN "PITMPLID" BIGINT,
  IN "PICHGRADE" SMALLINT,
  IN "PIMSGTYPE" SMALLINT,
  IN "PIRMSVALIDTM" SMALLINT,
  IN "PIRMSRPTFLAG" SMALLINT,
  IN "PIPROTOCOLVER" SMALLINT,
  IN "PITMPLTYPE" SMALLINT,
  IN "PITITLE" VARCHAR(40),
  IN "PISHOWAY" VARCHAR(16),
  IN "PIDLDWAY" INTEGER,
  IN "PIDLDNEY" INTEGER,
  IN "PIISFREE" INTEGER,
  IN "PISHOWTIME" BIGINT,
  IN "PISUID1" VARCHAR(64),
  IN "PILUID1" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKV4"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PITMPMSGID BIGINT;
DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
DECLARE PILEN INT;
DECLARE PIRESULTMSG VARCHAR(3000);
DECLARE PIPKNUM INT;
DECLARE PITMPNUM INT;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPMTTASK(UID INT,
USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
PHONE VARCHAR(21),PTMSGID BIGINT ,MESSAGE VARCHAR(3000),
SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,
FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER,AREACODE INTEGER,CUSTID VARCHAR(64),EXDATA VARCHAR(64),LONGMSG VARCHAR(4000),TMPLID BIGINT,CHGRADE SMALLINT,MSGTYPE SMALLINT,RMSVALIDTM SMALLINT,RMSRPTFLAG SMALLINT,PROTOCOLVER SMALLINT,TMPLTYPE SMALLINT,TITLE VARCHAR(40),SHOWAY VARCHAR(16),DLDWAY INTEGER,DLDNEY INTEGER,ISFREE INTEGER,SHOWTIME BIGINT,SUID1 VARCHAR(64),LUID1 VARCHAR(64)) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PILEN = LENGTH(PILONGMSG, CODEUNITS32)-PISIGNLEN;
SET PITMPNUM = 0;
SET PIPKNUM = 1;
SET PISTRSPLIT = ',';

IF PIPHONECOUNT < 1 THEN
	RETURN;
END IF;

IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
	SET PISPLITLEN=140;
	SET PIMULTILEN1=134;
	SET PIMULTILEN2=134;
	SET PISIGNLEN=0;
END IF;

IF PIMSGFMT=25  THEN
		IF NOT EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID) THEN
		   INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,
		   TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
		   VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI,PIPTMSGID,PIMESSAGE,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,
		   PIRECVMTTIME,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		   PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
		END IF;
		RETURN;
END IF;

IF PIPHONECOUNT = 1
THEN
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
	THEN
		IF PIPKTOTAL = 1
		THEN
			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,
			SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,
			TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
			SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
			VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE,
			PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,
			PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
			PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
		ELSE
			SET PIPKNUM = 1;
			SET PITMPMSGID = PIPTMSGID;
			IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
			THEN
				SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1,PISPLITLEN, CODEUNITS32);
				SET PITMPMSGID = PITMPMSGID;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,
					PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				IF  PILEN-PISPLITLEN+PISIGNLEN>=0
				  THEN
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
				  ELSE
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
				END IF;
				SET PITMPMSGID = PITMPMSGID+17179869184;
				SET PIPKNUM = PIPKNUM+1;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
					PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
			ELSE
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					IF PIPKNUM = PIPKTOTAL
					THEN
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSEIF PIPKNUM = PIPKTOTAL-1
					THEN
						IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
						THEN
						    IF  PILEN-(PIPKNUM-1)*PIMULTILEN1-1 >=0 THEN
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
							ELSE
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, 0, CODEUNITS32);
							END IF;
							SET PITMPNUM = PILEN-1;
						ELSE
							SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
							SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
						END IF;--END IF OF IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1;
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSE
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					END IF;--END IF OF IF PIPKNUM = PIPKTOTAL
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
						RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
						MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
						VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
						PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
						PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
					END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
			END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;

			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
			RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,
			LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME, A.ECID, A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
			A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,A.AREACODE,A.CUSTID,A.EXDATA,A.LONGMSG,A.TMPLID,A.CHGRADE,A.MSGTYPE,A.RMSVALIDTM,A.RMSRPTFLAG,A.PROTOCOLVER,A.TMPLTYPE,A.TITLE,A.SHOWAY,A.DLDWAY,A.DLDNEY,A.ISFREE,A.SHOWTIME,A.SUID1,A.LUID1 FROM SESSION.TMPMTTASK A;
		END IF;--END IF OF IF PIPKTOTAL = 1
	END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);

	IF PIPKTOTAL < 1 --
	THEN
		RETURN;
	END IF;

	IF PIPKTOTAL >= 1 --
	THEN
		WHILE PILOCATION <> 0 --
		DO
			SET PISTART = PILOCATION;
			SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
			IF PILOCATION > 0
			THEN
				SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);--
				IF PIRESULTPHONE <> ''
				THEN
					SET PITMPMSGID = PIPTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						IF PIPKTOTAL = 1
						THEN
							INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
							RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
							MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
							VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIMESSAGE, PISENDSTATUS,
							PIRETFLAG, PIPKTOTAL, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
							PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
						ELSE
							SET PIPKNUM = 1;
							IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
							THEN
								SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1, PISPLITLEN, CODEUNITS32);--
								SET PITMPMSGID = PITMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
									PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								IF PILEN-PISPLITLEN+PISIGNLEN>=0 THEN
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
								ELSE
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
								END IF;
								SET PITMPMSGID = PITMPMSGID+17179869184;
								SET PIPKNUM = PIPKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
									PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
									PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
							ELSE
								WHILE PIPKNUM <= PIPKTOTAL
								DO
									IF PIPKNUM = PIPKTOTAL
									THEN
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSEIF PIPKNUM = PIPKTOTAL-1
									THEN
										IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										THEN
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
											SET PITMPNUM = PILEN-1;
										ELSE
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
											SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
										END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSE
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
									IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
									THEN
										INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
										PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
										UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
										VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
										PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
										PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
									END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									SET PIPKNUM = PIPKNUM+1;
								END WHILE;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
							END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
						END	IF;--END IF OF IF PIPKTOTAL = 1
					END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
				END IF; --END IF OF IF PIRESULTPHONE <> ''
				SET PIPTMSGID = PIPTMSGID+1;
			END	IF; --END IF OF IF PILOCATION > 0
		END WHILE; --END WHILE OF WHILE PILOCATION <> 0

		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
		PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
		UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
		A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
		A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,A.AREACODE,A.CUSTID,A.EXDATA,A.LONGMSG,A.TMPLID,A.CHGRADE,A.MSGTYPE,A.RMSVALIDTM,A.RMSRPTFLAG,A.PROTOCOLVER,A.TMPLTYPE,A.TITLE,A.SHOWAY,A.DLDWAY,A.DLDNEY,A.ISFREE,A.SHOWTIME,A.SUID1,A.LUID1 FROM SESSION.TMPMTTASK A;
	END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --
END  &&

CALL DELPROC('GW_WR_MTTASKV5')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKV5"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISPLITLEN" SMALLINT,
  IN "PIMULTILEN1" SMALLINT,
  IN "PIMULTILEN2" SMALLINT,
  IN "PISIGNLEN" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64),
  IN "PISUID1" VARCHAR(64),
  IN "PILUID1" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKV5"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PITMPMSGID BIGINT;
DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
DECLARE PILEN INT;
DECLARE PIRESULTMSG VARCHAR(3000);
DECLARE PIPKNUM INT;
DECLARE PITMPNUM INT;
DECLARE GLOBAL TEMPORARY TABLE SESSION.TMPMTTASK(UID INT,
USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
PHONE VARCHAR(21),PTMSGID BIGINT ,MESSAGE VARCHAR(3000),
SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,
FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER,AREACODE INTEGER,CUSTID VARCHAR(64),EXDATA VARCHAR(64),SUID1 VARCHAR(64),LUID1 VARCHAR(64)) ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

SET PILEN = LENGTH(PIMESSAGE, CODEUNITS32)-PISIGNLEN;
SET PITMPNUM = 0;
SET PIPKNUM = 1;
SET PISTRSPLIT = ',';

IF PIPHONECOUNT < 1 THEN
	RETURN;
END IF;

IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
	SET PISPLITLEN=140;
	SET PIMULTILEN1=134;
	SET PIMULTILEN2=134;
	SET PISIGNLEN=0;
END IF;

IF PIMSGFMT=25  THEN
		IF NOT EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID) THEN
		   INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,
		   TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
		   VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI,PIPTMSGID,PIMESSAGE,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,
		   PIRECVMTTIME,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		   PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
		END IF;
		RETURN;
END IF;

IF PIPHONECOUNT = 1
THEN
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
	THEN
		IF PIPKTOTAL = 1
		THEN
			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,
			SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,
			TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
			SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
			VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE,
			PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,
			PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
			PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
		ELSE
			SET PIPKNUM = 1;
			SET PITMPMSGID = PIPTMSGID;
			IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
			THEN
				SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1,PISPLITLEN, CODEUNITS32);
				SET PITMPMSGID = PITMPMSGID;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,
					PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
				IF  PILEN-PISPLITLEN+PISIGNLEN>=0
				  THEN
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
				  ELSE
				    SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
				END IF;
				SET PITMPMSGID = PITMPMSGID+17179869184;
				SET PIPKNUM = PIPKNUM+1;
				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
				THEN
					INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
					RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
					MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
					VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
					PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
					PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
				END IF;--END OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID)
			ELSE
				WHILE PIPKNUM <= PIPKTOTAL
				DO
					IF PIPKNUM = PIPKTOTAL
					THEN
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSEIF PIPKNUM = PIPKTOTAL-1
					THEN
						IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
						THEN
						    IF  PILEN-(PIPKNUM-1)*PIMULTILEN1-1 >=0 THEN
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
							ELSE
							   SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, 0, CODEUNITS32);
							END IF;
							SET PITMPNUM = PILEN-1;
						ELSE
							SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
							SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
						END IF;--END IF OF IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1;
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					ELSE
						SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
						SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
					END IF;--END IF OF IF PIPKNUM = PIPKTOTAL
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
						RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
						MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
						VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
						PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
						PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
					END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
					SET PIPKNUM = PIPKNUM+1;
				END WHILE;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
			END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;

			INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
			RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,
			LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME, A.ECID, A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
			A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,A.AREACODE,A.CUSTID,A.EXDATA,A.SUID1,A.LUID1 FROM SESSION.TMPMTTASK A;
		END IF;--END IF OF IF PIPKTOTAL = 1
	END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID)
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);

	IF PIPKTOTAL < 1 --
	THEN
		RETURN;
	END IF;

	IF PIPKTOTAL >= 1 --
	THEN
		WHILE PILOCATION <> 0 --
		DO
			SET PISTART = PILOCATION;
			SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
			IF PILOCATION > 0
			THEN
				SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);--
				IF PIRESULTPHONE <> ''
				THEN
					SET PITMPMSGID = PIPTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
					THEN
						IF PIPKTOTAL = 1
						THEN
							INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS,
							RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
							MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
							VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIMESSAGE, PISENDSTATUS,
							PIRETFLAG, PIPKTOTAL, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
							PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
						ELSE
							SET PIPKNUM = 1;
							IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
							THEN
								SET PIRESULTMSG = SUBSTRING(PIMESSAGE,1, PISPLITLEN, CODEUNITS32);--
								SET PITMPMSGID = PITMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS,
									PIRETFLAG, PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
									PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								IF PILEN-PISPLITLEN+PISIGNLEN>=0 THEN
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN, CODEUNITS32);
								ELSE
								  SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PISPLITLEN+1, 0, CODEUNITS32);
								END IF;
								SET PITMPMSGID = PITMPMSGID+17179869184;
								SET PIPKNUM = PIPKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
								THEN
									INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
									PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
									UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
									VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
									PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
									PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
								END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
							ELSE
								WHILE PIPKNUM <= PIPKTOTAL
								DO
									IF PIPKNUM = PIPKTOTAL
									THEN
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSEIF PIPKNUM = PIPKTOTAL-1
									THEN
										IF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										THEN
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1, CODEUNITS32);
											SET PITMPNUM = PILEN-1;
										ELSE
											SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
											SET PITMPNUM = (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
										END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									ELSE
										SET PIRESULTMSG = SUBSTRING(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1, CODEUNITS32);
										SET PITMPMSGID = PIPTMSGID+(PIPKNUM-1)*17179869184;
									END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
									IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
									THEN
										INSERT INTO SESSION.TMPMTTASK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
										PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
										UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
										VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PITMPMSGID, PIRESULTMSG, PISENDSTATUS, PIRETFLAG,
										PIPKNUM, PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
										PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
									END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
									SET PIPKNUM = PIPKNUM+1;
								END WHILE;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
							END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
						END	IF;--END IF OF IF PIPKTOTAL = 1
					END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
				END IF; --END IF OF IF PIRESULTPHONE <> ''
				SET PIPTMSGID = PIPTMSGID+1;
			END	IF; --END IF OF IF PILOCATION > 0
		END WHILE; --END WHILE OF WHILE PILOCATION <> 0

		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG,
		PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
		UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
		A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
		A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,A.AREACODE,A.CUSTID,A.EXDATA,A.SUID1,A.LUID1 FROM SESSION.TMPMTTASK A;
	END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --
END  &&


CALL DELPROC('GW_WR_MTTASKSRV4')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKSRV4"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64),
  IN "PILONGMSG" VARCHAR(4000),
  IN "PITMPLID" BIGINT,
  IN "PICHGRADE" SMALLINT,
  IN "PIMSGTYPE" SMALLINT,
  IN "PIRMSVALIDTM" SMALLINT,
  IN "PIRMSRPTFLAG" SMALLINT,
  IN "PIPROTOCOLVER" SMALLINT,
  IN "PITMPLTYPE" SMALLINT,
  IN "PITITLE" VARCHAR(40),
  IN "PISHOWAY" VARCHAR(16),
  IN "PIDLDWAY" INTEGER,
  IN "PIDLDNEY" INTEGER,
  IN "PIISFREE" INTEGER,
  IN "PISHOWTIME" BIGINT,
  IN "PISUID1" VARCHAR(64),
  IN "PILUID1" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKSRV4"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
SET PISTRSPLIT = ',';
--SET PIRECVMTTIME =CURRENT TIMESTAMP;
DECLARE GLOBAL TEMPORARY TABLE SESSION.PITMP(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),PHONE VARCHAR(21),
PTMSGID BIGINT ,MESSAGE VARCHAR(3000),SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

IF PIPHONECOUNT < 1 THEN--
	RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
		PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
		VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
		PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
	END IF;
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);
	WHILE PILOCATION <> 0 --
	DO
	  SET PISTART = PILOCATION;
	  SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
	  IF PILOCATION > 0
	  THEN
		  IF PILOCATION-PISTART-1 >=0 THEN
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);
		  ELSE
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,0, CODEUNITS32);
		  END IF;
		  IF PIRESULTPHONE <> ''
		  THEN
			  IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
				  INSERT INTO SESSION.PITMP(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
				  PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
				  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
				  VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
				  PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
				  PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
			  END IF;
			  SET PIPTMSGID = PIPTMSGID+1;
		  END IF;
	    END IF;
	 END WHILE;

	 INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
	 PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
	 SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
	 SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
	 A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
	 A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1 FROM SESSION.PITMP A;
END IF;
END  &&

CALL DELPROC('GW_WR_MTTASKSRV5')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTTASKSRV5"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" SMALLINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PISHOUJI" VARCHAR(3500),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PIERCODE" CHARACTER(7),
  IN "PITPUDHI" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PIUNICOM" SMALLINT,
  IN "PIMOBILEAREA" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64),
  IN "PISUID1" VARCHAR(64),
  IN "PILUID1" VARCHAR(64)
 )
  SPECIFIC "GW_WR_MTTASKSRV5"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN

DECLARE PILOCATION INT;
DECLARE PISTART INT;
DECLARE PIRESULTPHONE VARCHAR(21);
DECLARE PISTRSPLIT VARCHAR(2);
SET PISTRSPLIT = ',';
--SET PIRECVMTTIME =CURRENT TIMESTAMP;
DECLARE GLOBAL TEMPORARY TABLE SESSION.PITMP(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),PHONE VARCHAR(21),
PTMSGID BIGINT ,MESSAGE VARCHAR(3000),SENDSTATUS SMALLINT,RETFLAG SMALLINT,PKNUMBER SMALLINT,
PKTOTAL SMALLINT,RECVMTTIME TIMESTAMP,ECID INT,FEEFLAG SMALLINT,SENDLEVEL SMALLINT,TASKID INT,ERRORCODE CHAR(7),
TPUDHI SMALLINT,LONGMSGSEQ SMALLINT,MSGFMT SMALLINT,UNICOM SMALLINT,MOBILEAREA INT,
SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INTEGER)ON COMMIT DELETE ROWS NOT LOGGED WITH REPLACE;

IF PIPHONECOUNT < 1 THEN--
	RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--
	IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
		INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
		PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
		SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
		VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
		PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
		PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
	END IF;
ELSE --
	SET PISHOUJI = PISTRSPLIT||PISHOUJI||PISTRSPLIT;
	SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI, CODEUNITS32);
	WHILE PILOCATION <> 0 --
	DO
	  SET PISTART = PILOCATION;
	  SET PILOCATION = LOCATE(PISTRSPLIT,PISHOUJI,PISTART+1, CODEUNITS32);
	  IF PILOCATION > 0
	  THEN
		  IF PILOCATION-PISTART-1 >=0 THEN
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,PILOCATION-PISTART-1, CODEUNITS32);
		  ELSE
		    SET PIRESULTPHONE = SUBSTRING(PISHOUJI,PISTART+1,0, CODEUNITS32);
		  END IF;
		  IF PIRESULTPHONE <> ''
		  THEN
			  IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID) THEN
				  INSERT INTO SESSION.PITMP(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
				  PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
				  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
				  VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PIRESULTPHONE, PIPTMSGID, PIMESSAGE, PISENDSTATUS, PIRETFLAG, PIPKNUMBER,
				  PIPKTOTAL, PIRECVMTTIME, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,
				  PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
			  END IF;
			  SET PIPTMSGID = PIPTMSGID+1;
		  END IF;
	    END IF;
	 END WHILE;

	 INSERT INTO GW_MT_TASK_BAK(UID,USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, SENDSTATUS, RETFLAG, PKNUMBER,
	 PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
	 SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
	 SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,A.PKNUMBER,
	 A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
	 A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1 FROM SESSION.PITMP A;
END IF;
END  &&


CALL DELPROC('GW_WR_MTLVLQUEV4')   &&
CREATE OR REPLACE  PROCEDURE "GW_WR_MTLVLQUEV4"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PISENDSTATUS" SMALLINT,
  IN "PISPLITFLAG" SMALLINT,
  IN "PIECID" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVMTTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(3000),
  IN "PIFEEFLAG" SMALLINT,
  IN "PIDESTUID" INTEGER,
  IN "PILOGINUID" INTEGER,
  IN "PIPKNUMBER" SMALLINT,
  IN "PISENDLEVEL" SMALLINT,
  IN "PITPUDHI" SMALLINT,
  IN "PITASKID" INTEGER,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIMSGFMT" SMALLINT,
  IN "PITOTALCOUNT" INTEGER,
  IN "PISVRTYPE" VARCHAR(64),
  IN "PIP1" VARCHAR(64),
  IN "PIP2" VARCHAR(64),
  IN "PIP3" VARCHAR(64),
  IN "PIP4" VARCHAR(64),
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PIATTIME" BIGINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PISENDTYPE" INTEGER,
  IN "PIBATCHID" BIGINT,
  IN "PIAREACODE" INTEGER,
  IN "PICUSTID" VARCHAR(64),
  IN "PIEXDATA" VARCHAR(64),
  IN "PILONGMSG" VARCHAR(4000),
  IN "PITMPLID" BIGINT,
  IN "PICHGRADE" SMALLINT,
  IN "PIMSGTYPE" SMALLINT,
  IN "PIRMSVALIDTM" SMALLINT,
  IN "PIPROTOCOLVER" SMALLINT,
  IN "PITMPLTYPE" SMALLINT,
  IN "PITITLE" VARCHAR(40),
  IN "PISHOWAY" VARCHAR(16),
  IN "PIDLDWAY" INTEGER,
  IN "PIDLDNEY" INTEGER,
  IN "PIISFREE" INTEGER,
  IN "PISHOWTIME" BIGINT,
  IN "PISUID1" VARCHAR(64),
  IN "PILUID1" VARCHAR(64),
  IN P_TABLENO INTEGER
 )
  SPECIFIC "GW_WR_MTLVLQUEV4"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF P_TABLENO =0 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =1 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL1_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL1_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =2 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL2_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL2_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =3 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL3_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL3_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =4 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL4_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL4_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =5 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL5_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL5_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =6 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL6_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL6_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =7 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL7_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL7_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =8 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL8_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL8_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
ELSEIF P_TABLENO =9 THEN
   IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL9_QUEUE WHERE PTMSGID=PIPTMSGID) THEN
      INSERT INTO MT_LEVEL9_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
      PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,
      TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT,
      PIPHONECOUNT,PIRECVMTTIME, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,
      PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
   END IF;
END IF;
END  &&


CALL DELPROC('GW_WRMTTASKCV3')   &&
CREATE OR REPLACE  PROCEDURE "GW_WRMTTASKCV3"
 (IN "PIUID" INTEGER,
  IN "PIPTMSGID" BIGINT,
  IN "PISENDSTATUS" INTEGER,
  IN "PIRETFLAG" SMALLINT,
  IN "PIPKNUMBER" SMALLINT,
  IN "PIPKTOTAL" SMALLINT,
  IN "PIPHONECOUNT" INTEGER,
  IN "PIUSERID" VARCHAR(11),
  IN "PISPGATE" VARCHAR(21),
  IN "PICPNO" VARCHAR(21),
  IN "PIRECVTIME" TIMESTAMP,
  IN "PIPHONE" VARCHAR(3500),
  IN "PIMESSAGE" VARCHAR(4000),
  IN "PITPUDHI" SMALLINT,
  IN "PILOGINID" VARCHAR(11),
  IN "PITRANSMTTIME" TIMESTAMP,
  IN "PIMSGFMT" SMALLINT,
  IN "PILONGMSGSEQ" SMALLINT,
  IN "PIUSERMSGID" BIGINT,
  IN "PIMODULEID" INTEGER,
  IN "PISENDLEVEL" SMALLINT,
  IN "PIVALIDTIME" BIGINT,
  IN "PIUNICOM"     SMALLINT,
  IN "PITASKID"     INTEGER,
  IN "PIMOBILEAREA" INTEGER,
  IN "PINETERRORCNT" INTEGER,
  IN "PISUBMITERRORCNT" INTEGER,
  IN PICUSTID VARCHAR(64),
  IN PIEXDATA VARCHAR(64),
  IN "PIMSGTYPE" SMALLINT,
  IN "PIVALIDTM" SMALLINT,
  IN "PITMPLID" INTEGER,
  IN "PIPROTOCOLVER"		SMALLINT,
  IN "PITITLE"				VARCHAR(40),
  IN "PISHOWAY"				VARCHAR(16),
  IN "PIDLDWAY"				INTEGER,
  IN "PIDLDNEY"				INTEGER,
  IN "PIISFREE"				INTEGER,
  IN "PISHOWTIME"			BIGINT

 )
  SPECIFIC "GW_WRMTTASKCV3"
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  MODIFIES SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
	IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID) THEN
	   INSERT INTO MT_TASK_C(UID, LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
	   SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME,TPUDHI,LONGMSGSEQ,TRANSMTTIME,MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT,CUSTID,EXDATA,MSGTYPE,VALIDTM,TMPLID,PROTOCOLVER,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME)
	   VALUES(PIUID, PILOGINID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
	   PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVTIME,PITPUDHI,PILONGMSGSEQ,PITRANSMTTIME,PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA,PINETERRORCNT,PISUBMITERRORCNT,PICUSTID,PIEXDATA,PIMSGTYPE,PIVALIDTM,PITMPLID,PIPROTOCOLVER,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME);
	END IF;
END  &&

DROP PROCEDURE "DELPROC"  &&

ALTER TABLE GT_PORT_USED ALTER COLUMN SIGNSTR SET DATA TYPE VARCHAR(60)  &&
ALTER TABLE GT_PORT_USED ALTER COLUMN ENSIGNSTR SET DATA TYPE VARCHAR(60)  &&

ALTER TABLE XT_GATE_QUEUE ALTER COLUMN SIGNSTR SET DATA TYPE VARCHAR(60)  &&
ALTER TABLE XT_GATE_QUEUE ALTER COLUMN ENSIGNSTR SET DATA TYPE VARCHAR(60)  &&

BEGIN ATOMIC
DECLARE PIVERSION VARCHAR(32);
SET PIVERSION = '4.06.07';
IF NOT EXISTS (SELECT VERSION FROM VERSION_CMPP WHERE VERSION = PIVERSION) THEN
INSERT INTO VERSION_CMPP (VERSION,VERSIONDATE,UPGRADETIME)
VALUES (PIVERSION,CURRENT DATE,(TRIM(CHAR(YEAR(CURRENT TIMESTAMP)))||'-'|| (CASE MONTH(CURRENT TIMESTAMP) WHEN
1 THEN '01' WHEN 2 THEN '02' WHEN 3 THEN '03' WHEN 4 THEN '04' WHEN 5 THEN '05' WHEN 6 THEN '06'WHEN 7 THEN '07' WHEN 8 THEN '08' WHEN 9 THEN '09'   ELSE
TRIM(CHAR(MONTH(CURRENT TIMESTAMP))) END)||'-'||TRIM(CHAR(DAY(CURRENT TIMESTAMP)))||' '||TRIM(CHAR(HOUR(CURRENT TIMESTAMP)))||':'||TRIM(CHAR(MINUTE(CURRENT TIMESTAMP)))||':'||TRIM(CHAR(SECOND(CURRENT TIMESTAMP)))));
END IF;
END   &&

CREATE OR REPLACE PROCEDURE "DELPROC"(IN "PROCNAME1" VARCHAR(30))
  begin
DECLARE STR VARCHAR (256);
DECLARE STR1 VARCHAR (256);
SELECT PROCNAME INTO STR1 FROM SYSCAT.PROCEDURES WHERE  PROCNAME=PROCNAME1;
if  STR1 is not null THEN
  SET STR ='DROP PROCEDURE '||PROCNAME1;
  execute immediate str ;
end if;
end  &&


CALL DELPROC('GW_LOAD_ECERRCODEBIND')   &&
CREATE OR REPLACE  PROCEDURE GW_LOAD_ECERRCODEBIND()
SPECIFIC "GW_LOAD_ECERRCODEBIND"
  DYNAMIC RESULT SETS 1
  LANGUAGE SQL
  NOT DETERMINISTIC
  CALLED ON NULL INPUT
  EXTERNAL ACTION
  OLD SAVEPOINT LEVEL
  READS SQL DATA
  INHERIT SPECIAL REGISTERS
  BEGIN
        DECLARE PISQLSTR VARCHAR(1000)  ;
   	DECLARE RS1 CURSOR WITH RETURN FOR S1;
	SET PISQLSTR = 'SELECT CORP_CODE,STATE_CODE,MAPPING_CODE,STATE_DES  FROM LF_STATECODE';
	PREPARE S1 FROM PISQLSTR;
	OPEN RS1;

END  &&

DROP PROCEDURE "DELPROC"  &&

BEGIN ATOMIC
DECLARE PIVERSION VARCHAR(32)  ;
SET PIVERSION = '4.06.08';
IF NOT EXISTS (SELECT VERSION FROM VERSION_CMPP WHERE VERSION = PIVERSION) THEN
INSERT INTO VERSION_CMPP (VERSION,VERSIONDATE,UPGRADETIME)
VALUES (PIVERSION,CURRENT DATE,(TRIM(CHAR(YEAR(CURRENT TIMESTAMP)))||'-'|| (CASE MONTH(CURRENT TIMESTAMP) WHEN
1 THEN '01' WHEN 2 THEN '02' WHEN 3 THEN '03' WHEN 4 THEN '04' WHEN 5 THEN '05' WHEN 6 THEN '06'WHEN 7 THEN '07' WHEN 8 THEN '08' WHEN 9 THEN '09'   ELSE
TRIM(CHAR(MONTH(CURRENT TIMESTAMP))) END)||'-'||TRIM(CHAR(DAY(CURRENT TIMESTAMP)))||' '||TRIM(CHAR(HOUR(CURRENT TIMESTAMP)))||':'||TRIM(CHAR(MINUTE(CURRENT TIMESTAMP)))||':'||TRIM(CHAR(SECOND(CURRENT TIMESTAMP)))))  ;
END IF;
END  &&








--增加版本信息
BEGIN ATOMIC
DECLARE DBVERSIONSTR VARCHAR(32);
DECLARE NUMSTR INT;
DECLARE TOTALSTR INT;
SET DBVERSIONSTR = '73.09';
SET NUMSTR=1;
SET TOTALSTR=3;
IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR AND CURRENT_NO=NUMSTR AND TOTAL=TOTALSTR) THEN
--EMP产品数据库版本信息表
INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
VALUES(DBVERSIONSTR ,CURRENT TIMESTAMP,CURRENT TIMESTAMP,NUMSTR,TOTALSTR,2,'1号脚本');
ELSE
UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=CURRENT TIMESTAMP WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=NUMSTR AND TOTAL=TOTALSTR;
END IF;
END  &&