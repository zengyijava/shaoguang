DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='LF_VERSION';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE '--EMP产品版本版本信息表
CREATE TABLE LF_VERSION(
 ID NUMBER(20) PRIMARY KEY NOT NULL,    --自增ID
 PRODUCT_ID NUMBER(20) DEFAULT 0 NOT NULL,  --产品编号:1000：EMP系统
 PROCESS_ID NUMBER(20) DEFAULT 0 NOT NULL,  --程序编号:1000: EMP-WEB,2000: EMP-网关WBS,3000: EMP-网关SPGATE
 MODULE_ID NUMBER(20) DEFAULT 0  NOT NULL,  --模块编号模块编号四位（WEB前端模块以1开头，WBS以2开头，SPGATE以3开头）
 MODULE_NAME VARCHAR2(32) DEFAULT '' '' NOT NULL,--模块名称
 VERSION VARCHAR2(16) DEFAULT ''0'' NOT NULL,--模块版本号
 UPDATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,--更新时间
 CREATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,  --创建时间
 MEMO VARCHAR2(128) DEFAULT '' '' NOT NULL --备注
)
TABLESPACE EMP_TABLESPACE
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
       INITIAL 64K
       MINEXTENTS 1
       MAXEXTENTS UNLIMITED
     )';
  END IF;
END;
/



DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='S_LF_VERSION';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE S_LF_VERSION
MINVALUE 1
MAXVALUE 999999999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20';
  END IF;
END;
/


CREATE OR REPLACE TRIGGER LF_VERSION_Q
BEFORE INSERT ON LF_VERSION
FOR EACH ROW
  BEGIN
    IF(:NEW.ID IS NULL)
    THEN
      SELECT S_LF_VERSION.NEXTVAL INTO :NEW.ID FROM DUAL;
      END IF;
      END;
/




DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='LF_VERSION_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE '--EMP产品版本版本信息历史表,LF_VERSION_HIS
CREATE TABLE LF_VERSION_HIS
(
  ID NUMBER(38) NOT NULL,     --自增ID
  PRODUCT_ID NUMBER(38) DEFAULT 0 NOT NULL, --产品编号1000：EMP系统
  PROCESS_ID NUMBER(38) DEFAULT 0 NOT NULL, --程序编号1000: EMP-WEB,2000: EMP-网关WBS,3000: EMP-网关SPGATE
  MODULE_ID NUMBER(38) DEFAULT 0  NOT NULL,  --模块编号四位（WEB前端模块以1开头，WBS以2开头，SPGATE以3开头）
  MODULE_NAME VARCHAR2(32) DEFAULT '' '' NOT NULL,--模块名称
  VERSION VARCHAR2(16) DEFAULT ''0'' NOT NULL,--模块版本号
  UPDATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,--更新时间
  CREATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,--创建时间
  MEMO VARCHAR2(128) DEFAULT '' '' NOT NULL --备注
)
TABLESPACE EMP_TABLESPACE
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
       INITIAL 64K
       MINEXTENTS 1
       MAXEXTENTS UNLIMITED
     )';
  END IF;
END;
/


DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='S_LF_VERSIONH';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE S_LF_VERSIONH
MINVALUE 1
MAXVALUE 999999999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20';
  END IF;
END;
/


CREATE OR REPLACE TRIGGER LF_VERSIONH_Q
BEFORE INSERT ON LF_VERSION_HIS
FOR EACH ROW
  BEGIN
    IF(:NEW.ID IS NULL)
    THEN
      SELECT S_LF_VERSIONH.NEXTVAL INTO :NEW.ID FROM DUAL;
      END IF;
      END;
/




DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='LF_DB_SCRIPT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE '--EMP产品版本版本信息历史表,LF_DB_SCRIPT
CREATE TABLE LF_DB_SCRIPT
(
ID NUMBER(20) PRIMARY KEY NOT NULL,--自增ID
VERSION VARCHAR2(16) DEFAULT ''0'' NOT NULL, --脚本版本号
UPDATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,    --更新时间
CREATETIME TIMESTAMP(8) DEFAULT SYSDATE NOT NULL,    --创建时间
CURRENT_NO NUMBER(20) DEFAULT 0 NOT NULL,      --当前脚本序号
TOTAL NUMBER(20) DEFAULT 0  NOT NULL,      --总脚本个数
STATE NUMBER(2) DEFAULT -1 NOT NULL,  --1执行中；2执行成功；
MEMO VARCHAR2(128) DEFAULT '' '' NOT NULL --备注
)
TABLESPACE EMP_TABLESPACE
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
       INITIAL 64K
       MINEXTENTS 1
       MAXEXTENTS UNLIMITED
     )';
  END IF;
END;
/



DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='S_LF_DBSCRIPT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE S_LF_DBSCRIPT
MINVALUE 1
MAXVALUE 999999999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER LF_DBSCRIPT_Q
BEFORE INSERT ON LF_DB_SCRIPT
FOR EACH ROW
  BEGIN
    IF(:NEW.ID IS NULL)
    THEN
      SELECT S_LF_DBSCRIPT.NEXTVAL INTO :NEW.ID FROM DUAL;
      END IF;
      END;
/

DECLARE COUNTNUM INT;
        VERSIONSTR VARCHAR2(32);
        DBVERSIONSTR VARCHAR2(32);
        WBSVERSIONSTR VARCHAR2(32);
        SPGATEVERSIONSTR VARCHAR2(32);
        NUMNO INT;
        TOTALINT INT;
BEGIN
    VERSIONSTR:='7.3.8.617.SP8';
    DBVERSIONSTR:='73.08';
    WBSVERSIONSTR:='8.6.4.219';
    SPGATEVERSIONSTR:='6.1.52.344';
    NUMNO:=1;
    TOTALINT:=5;
    --EMP产品版本记录
    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
    IF COUNTNUM=0 THEN
      --EMP-WEB
      INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,1000,VERSIONSTR,SYSDATE,SYSDATE,'EMP-WEB');
      COMMIT;
    END IF;

    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION WHERE VERSION=WBSVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
    IF COUNTNUM=0 THEN
      --EMP_GATEWAY
      INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,2000,WBSVERSIONSTR,SYSDATE,SYSDATE,'EMP_GATEWAY');
      COMMIT;
    END IF;

    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION WHERE VERSION=SPGATEVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
    IF COUNTNUM=0 THEN
      --SMT_SPGATE
      INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,3000,SPGATEVERSIONSTR,SYSDATE,SYSDATE,'SMT_SPGATE');
      COMMIT;
    END IF;

    --EMP产品版本历史记录
    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
    IF COUNTNUM=0 THEN
      --EMP-WEB
      INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,1000,VERSIONSTR,SYSDATE,SYSDATE,'EMP-WEB');
      COMMIT;
    END IF;

    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION_HIS WHERE VERSION=WBSVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
    IF COUNTNUM=0 THEN
      --EMP_GATEWAY
      INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,2000,WBSVERSIONSTR,SYSDATE,SYSDATE,'EMP_GATEWAY');
      COMMIT;
    END IF;

    SELECT COUNT(*) INTO COUNTNUM FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
    IF COUNTNUM=0 THEN
      --SMT_SPGATE
      INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
      VALUES(1000,3000,SPGATEVERSIONSTR,SYSDATE,SYSDATE,'SMT_SPGATE');
      COMMIT;
    END IF;

    SELECT COUNT(*) INTO COUNTNUM FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR AND CURRENT_NO=NUMNO AND TOTAL=TOTALINT;
    IF COUNTNUM=0 THEN
      --EMP产品数据库版本信息表
      INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
      VALUES(DBVERSIONSTR,SYSDATE,SYSDATE,NUMNO,TOTALINT,1,'1号脚本');
      COMMIT;
    END IF;
END;
/

------------------------------------------------------
-- EXPORT FILE FOR USER WJ_BB                       --
-- CREATED BY ADMINISTRATOR ON 2013-03-22, 15:38:05 --
------------------------------------------------------

----PROMPT
----PROMPT CREATING TABLE AGENTACCOUNT
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='AGENTACCOUNT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
	CREATE TABLE AGENTACCOUNT
	(
	  LOGINID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
	  DESCRIPTION   VARCHAR2(100) DEFAULT ''代理帐号'' NOT NULL,
	  PRIVILEGE     NUMBER(11) DEFAULT 11 NOT NULL,
	  USERFEEFLAG   NUMBER(11) DEFAULT 1 NOT NULL,
	  PRIVILEGEINFO VARCHAR2(500) DEFAULT ''具有代理帐号权限'' NOT NULL
	)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 1
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('AGENTACCOUNT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE AGENTACCOUNT
	  ADD CONSTRAINT PK_AGENTACCOUNT PRIMARY KEY (LOGINID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE ATTIME_TASK
----PROMPT ==========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='ATTIME_TASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE ATTIME_TASK
(
  ID        NUMBER(11) NOT NULL,
  LOGINID   VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  TASKID    NUMBER(11) DEFAULT 0 NOT NULL,
  BMTMSGID  NUMBER(21) DEFAULT 0 NOT NULL,
  ATTIME    NUMBER(21) DEFAULT 0 NOT NULL,
  VALIDTIME NUMBER(21) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('ATTIME_TASK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE ATTIME_TASK
	  ADD CONSTRAINT PK_ATTMTASK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('ATTIME_TASK') AND T.INDEX_NAME = UPPER('IX_ATTMTASK');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_ATTMTASK ON ATTIME_TASK (LOGINID, BMTMSGID, TASKID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_CHANNELMAP
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_CHANNELMAP';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_CHANNELMAP
(
  ID       INTEGER DEFAULT 0 NOT NULL,
  SPNUMBER VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO     VARCHAR2(21) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_CHANNELMAP') AND T.INDEX_NAME = UPPER('IX_A_CHMAP_CPNO');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_CHANNELMAP
	  ADD CONSTRAINT IX_A_CHMAP_CPNO UNIQUE (CPNO)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_CHANNELMAP') AND T.INDEX_NAME = UPPER('IX_A_CHMAP_SPNO');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_CHANNELMAP
	  ADD CONSTRAINT IX_A_CHMAP_SPNO UNIQUE (SPNUMBER)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
		END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_CMDQUE
----PROMPT =======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_CMDQUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_CMDQUE
(
  ID         NUMBER(11) NOT NULL,
  GWNO       NUMBER(11) DEFAULT 2999 NOT NULL,
  GWTYPE     NUMBER(11) DEFAULT 4000 NOT NULL,
  CMDTYPE    NUMBER(11) DEFAULT 0 NOT NULL,
  CMDINFO    VARCHAR2(512) DEFAULT ('' '') NOT NULL,
  CMDPARAM   VARCHAR2(1024) DEFAULT ('' '') NOT NULL,
  DEALSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  RESULTCODE VARCHAR2(32) DEFAULT (''SUCCESS'') NOT NULL,
  REQTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  DONETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_CMDQUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_CMDQUE
	  ADD CONSTRAINT PK_A_CMDQUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_CMDQUE_HIS
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_CMDQUE_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_CMDQUE_HIS
(
  ID         NUMBER(11) NOT NULL,
  GWNO       NUMBER(11) DEFAULT 2999 NOT NULL,
  GWTYPE     NUMBER(11) DEFAULT 4000 NOT NULL,
  CMDTYPE    NUMBER(11) DEFAULT 0 NOT NULL,
  CMDINFO    VARCHAR2(512) DEFAULT ('' '') NOT NULL,
  CMDPARAM   VARCHAR2(1024) DEFAULT ('' '') NOT NULL,
  DEALSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  RESULTCODE VARCHAR2(32) DEFAULT (''SUCCESS'') NOT NULL,
  REQTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  DONETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWACCOUNT
----PROMPT ==========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWACCOUNT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWACCOUNT
(
  GWNO          NUMBER(11) DEFAULT 2999 NOT NULL,
  PTACCUID      NUMBER(11) DEFAULT 0 NOT NULL,
  PTACCID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  PTACCPWD      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPACCID       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPACCPWD      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPID          VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SERVICETYPE   VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  FEEUSERTYPE   NUMBER(11) DEFAULT 2 NOT NULL,
  SPTYPE        NUMBER(11) DEFAULT 0 NOT NULL,
  SPIP          VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPPORT        NUMBER(11) DEFAULT 7890 NOT NULL,
  SPEEDLIMIT    NUMBER(11) DEFAULT 100 NOT NULL,
  PROTOCOLCODE  NUMBER(11) DEFAULT 5 NOT NULL,
  PROTOCOLPARAM VARCHAR2(1024) DEFAULT ('' '') NOT NULL,
  PTACCNAME     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  PTIP          VARCHAR2(32) DEFAULT (''127.0.0.1'') NOT NULL,
  PTPORT        NUMBER(11) DEFAULT 7892 NOT NULL,
  FEEURL        VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  BALANCE       NUMBER(11)    DEFAULT 0 NOT NULL,
  BALANCETH     NUMBER(11)    DEFAULT 0 NOT NULL,
  UPDATETIME    TIMESTAMP(6)	DEFAULT SYSTIMESTAMP NOT NULL,
  SPFEEFLAG     NUMBER(11)    DEFAULT 1 NOT NULL,
  PTNODE        VARCHAR2(1024) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_GWACCOUNT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_GWACCOUNT
	  ADD CONSTRAINT PK_A_GWACCOUNT PRIMARY KEY (GWNO, PTACCUID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWDBCONF
----PROMPT =========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWDBCONF';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
	CREATE TABLE A_GWDBCONF
	(
	  DBTYPE NUMBER(11) DEFAULT 2 NOT NULL,
	  DBIP   VARCHAR2(64) DEFAULT (''127.0.0.1'') NOT NULL,
	  DBPORT NUMBER(11) DEFAULT 1521 NOT NULL,
	  DBNAME VARCHAR2(64) DEFAULT (''EMPSVR'') NOT NULL,
	  DBUSER VARCHAR2(64) DEFAULT (''EMPSVR'') NOT NULL,
	  DBPWD  VARCHAR2(64) DEFAULT (''123456'') NOT NULL
	)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 1
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	  EXECUTE IMMEDIATE 'COMMENT ON COLUMN A_GWDBCONF.DBTYPE IS ''0:SQL 1:DB2 2:ORACLE 3:MYSQL''';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWLOGS
----PROMPT =======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWLOGS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWLOGS
(
  ID       NUMBER(11) NOT NULL,
  GWNO     NUMBER(11) DEFAULT 2999 NOT NULL,
  GWTYPE   NUMBER(11) DEFAULT 4000 NOT NULL,
  LOGTYPE  NUMBER(11) DEFAULT 0 NOT NULL,
  LOGLEVEL NUMBER(11) DEFAULT 0 NOT NULL,
  LOGTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  LOGS     VARCHAR2(4000) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_GWLOGS') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_GWLOGS
	  ADD CONSTRAINT PK_A_GWLOGS PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWPARAMCONF
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWPARAMCONF';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWPARAMCONF
(
  PARAMITEM      VARCHAR2(64) DEFAULT (''PARAMITEM'') NOT NULL,
  PARAMNAME      VARCHAR2(64) DEFAULT (''PARAMNAME'') NOT NULL,
  PARAMATTRIBUTE NUMBER(11) DEFAULT 0 NOT NULL,
  PARAMMEMO      VARCHAR2(256) DEFAULT (''PARAMMEMO'') NOT NULL,
  DEFAULTVALUE   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  VALUERANGE     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  CONTROLTYPE    NUMBER(11) DEFAULT 0 NOT NULL,
  GWTYPE         NUMBER(11) DEFAULT 4000 NOT NULL,
  HKPARAMNAME    varchar2(256) DEFAULT '' '' NOT NULL,
  HKPARAMMEMO    varchar2(512) DEFAULT '' '' NOT NULL,
  ENPARAMNAME    varchar2(256) DEFAULT '' '' NOT NULL,
  ENPARAMMEMO    varchar2(512) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_GWPARAMCONF') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_GWPARAMCONF
	  ADD CONSTRAINT A_GWPARAMCONF_ITEM_KEY PRIMARY KEY (PARAMITEM, GWTYPE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWPARAMTMPL
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWPARAMTMPL';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWPARAMTMPL
(
  GWTYPE     NUMBER(11) DEFAULT 4000 NOT NULL,
  PARAMITEM  VARCHAR2(64) DEFAULT (''PARAMITEM''),
  PARAMVALUE VARCHAR2(255) DEFAULT (''PARAMVALUE'')
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWPARAMVALUE
----PROMPT =============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWPARAMVALUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWPARAMVALUE
(
  GWNO       NUMBER(11) DEFAULT 2999 NOT NULL,
  GWTYPE     NUMBER(11) DEFAULT 4000 NOT NULL,
  PARAMITEM  VARCHAR2(64) DEFAULT ''PARAMITEM'' NOT NULL,
  PARAMVALUE VARCHAR2(256) DEFAULT ''PARAMVALUE'' NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_GWPARAMVALUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_GWPARAMVALUE
	  ADD CONSTRAINT PK_GWPARAMVALUE PRIMARY KEY (GWNO, GWTYPE, PARAMITEM)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_GWSPBIND
----PROMPT =========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWSPBIND';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWSPBIND
(
  PTACCUID NUMBER(11) DEFAULT 0 NOT NULL,
  GATEID   NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_PROINFO
----PROMPT ========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_PROINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_PROINFO
(
  SERIALNUM  VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  PROTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  PROSTATUS  NUMBER(11) DEFAULT 100 NOT NULL,
  STATUSINFO VARCHAR2(1024) DEFAULT ('' '') NOT NULL,
  VALIDDAYS  NUMBER(11) DEFAULT 0 NOT NULL,
  CORPNAME   VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  SENDSPEED  NUMBER(11) DEFAULT 100 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_PROINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_PROINFO
	  ADD CONSTRAINT PK_A_PROINFO PRIMARY KEY (SERIALNUM)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_PROTOCOLTMPL
----PROMPT =============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_PROTOCOLTMPL';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_PROTOCOLTMPL
(
  PROTOCOLCODE  NUMBER(11) DEFAULT 5 NOT NULL,
  PROTOCOL      VARCHAR2(32) DEFAULT ''CMPP2.0'' NOT NULL,
  PROTOCOLPARAM VARCHAR2(1024) DEFAULT ''EXPIREHOUR=24;'' NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_PROTOCOLTMPL') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_PROTOCOLTMPL
	  ADD CONSTRAINT PK_A_PROTOCOLTMPL PRIMARY KEY (PROTOCOLCODE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_SMSFWDCONF
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SMSFWDCONF';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SMSFWDCONF
(
  PROTOCOLCODE VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  PROTOCOLNAME VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  FWDSNDURL    VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  FWDRECVURL   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  FWDACCOUNT   VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  FWDPASSWD    VARCHAR2(32) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_SMSFWDCONF') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_SMSFWDCONF
	  ADD PRIMARY KEY (PROTOCOLCODE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_SMSMSGIDMAP
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SMSMSGIDMAP';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SMSMSGIDMAP
(
  ID        NUMBER(22) NOT NULL,
  PTMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  USERMSGID VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  PITIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_SMSMSGIDMAP') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_SMSMSGIDMAP
	  ADD PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SMSMSGIDMAP') AND T.INDEX_NAME = UPPER('IX_A_SMSMSGIDMAP');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_A_SMSMSGIDMAP ON A_SMSMSGIDMAP (ID, PTMSGID, USERMSGID, PITIME)
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_SMSPUSHBIND
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SMSPUSHBIND';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SMSPUSHBIND
(
  PROTOCOLCODE VARCHAR2(64) NOT NULL,
  USERUID      INTEGER NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE A_SMSPUSHCONF
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SMSPUSHCONF';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SMSPUSHCONF
(
  ID           NUMBER(22) NOT NULL,
  PROTOCOLCODE VARCHAR2(64) NOT NULL,
  PROTOCOLNAME VARCHAR2(128) NOT NULL,
  PUSHURL      VARCHAR2(256) NOT NULL,
  PUSHACCOUNT  VARCHAR2(32) NOT NULL,
  PUSHPASSWD   VARCHAR2(32) NOT NULL,
  PUSHKEY      VARCHAR2(256) NOT NULL,
  PUSHFLAG     NUMBER(22) DEFAULT 0 NOT NULL,
  MAXBATCHNUM  NUMBER(22) DEFAULT 1 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_SMSPUSHCONF') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_SMSPUSHCONF
	  ADD CONSTRAINT PK_A_SMSPUSHCONF PRIMARY KEY (ID, PROTOCOLCODE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE BATCH_MT_REQ
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='BATCH_MT_REQ';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE BATCH_MT_REQ
(
  ID          NUMBER(11) NOT NULL,
  MSGID       NUMBER(22) DEFAULT 0 NOT NULL,
  BMTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID     NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICETYPE VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  MSG         VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  REMOTEURL   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LOCALPATH   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 0 NOT NULL,
  ATTIME      CHAR(14) DEFAULT ('' '') NOT NULL,
  VALIDTIME   CHAR(14) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORCODE   CHAR(7) DEFAULT ('' '') NOT NULL,
  RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  ATTIMEFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  SA          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  TOTALNUM    NUMBER(11) DEFAULT 0 NOT NULL,
  SENDNUM     NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE       VARCHAR2(500) DEFAULT ('' '') NOT NULL,
  TASKTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID     NUMBER(22) DEFAULT 0,
  CLUPATH     VARCHAR2(256) DEFAULT '' '' NOT NULL,
  CLUGWNO     NUMBER(11) DEFAULT 0	NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE BATCH_MT_REQ
	  ADD CONSTRAINT PK_BATMTREQ PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BMTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_BMTMSGID ON BATCH_MT_REQ (BMTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_LGNID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_LGNID ON BATCH_MT_REQ (LOGINID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_MSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_MSGID ON BATCH_MT_REQ (MSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_SDSTS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_SDSTS ON BATCH_MT_REQ (SENDSTATUS)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_TASKID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_TASKID ON BATCH_MT_REQ (TASKID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_USRID ON BATCH_MT_REQ (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ') AND T.INDEX_NAME = UPPER('IX_BATMTREQ_BATCHID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQ_BATCHID ON BATCH_MT_REQ (BATCHID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE BATCH_MT_REQ_HIS
----PROMPT ===============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='BATCH_MT_REQ_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE BATCH_MT_REQ_HIS
(
  ID          NUMBER(11) NOT NULL,
  MSGID       NUMBER(22) DEFAULT 0 NOT NULL,
  BMTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID     NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICETYPE VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  MSG         VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  REMOTEURL   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LOCALPATH   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 0 NOT NULL,
  ATTIME      CHAR(14) DEFAULT ('' '') NOT NULL,
  VALIDTIME   CHAR(14) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORCODE   CHAR(7) DEFAULT ('' '') NOT NULL,
  RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  ATTIMEFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  SA          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  TOTALNUM    NUMBER(11) DEFAULT 0 NOT NULL,
  SENDNUM     NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE       VARCHAR2(500) DEFAULT ('' '') NOT NULL,
  TASKTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID     NUMBER(22) DEFAULT 0,
  CLUPATH     VARCHAR2(256) DEFAULT '' '' NOT NULL,
  CLUGWNO     NUMBER(11) DEFAULT 0	NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ_HIS') AND T.INDEX_NAME = UPPER('IX_BATMTREQHIS_BATCHID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQHIS_BATCHID ON BATCH_MT_REQ_HIS (BATCHID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('BATCH_MT_REQ_HIS') AND T.INDEX_NAME = UPPER('IX_BATMTREQHIS_RECVTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_BATMTREQHIS_RECVTIME ON BATCH_MT_REQ_HIS (RECVTIME)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE GT_PORT_USED
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GT_PORT_USED';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GT_PORT_USED
(
  ID            NUMBER(11) NOT NULL,
  GATETYPE      NUMBER(11) DEFAULT 1 NOT NULL,
  SPGATE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PORTTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  USERCODE      VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  SPISUNCM      NUMBER(11) DEFAULT 0 NOT NULL,
  ROUTEFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  STATUS        NUMBER(11) DEFAULT 0 NOT NULL,
  USERID        VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPNUMBER      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  FEEFLAG       NUMBER(11) DEFAULT 1 NOT NULL,
  MEMO          VARCHAR2(100) DEFAULT ('' '') NOT NULL,
  SIGNSTR       VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  SIGNLEN       NUMBER(11) DEFAULT 10 NOT NULL,
  MAXWORDS      NUMBER(11) DEFAULT 360 NOT NULL,
  SINGLELEN     NUMBER(11) DEFAULT 70 NOT NULL,
  MULTILEN1     NUMBER(11) DEFAULT 67 NOT NULL,
  MULTILEN2     NUMBER(11) DEFAULT 67 NOT NULL,
  SENDTMSPAN    VARCHAR2(512) DEFAULT ''00:00:00-23:59:59'' NOT NULL,
  FORBIDTMSPAN  VARCHAR2(512) DEFAULT ''00:00:00-00:00:00'' NOT NULL,
  GATESEQ       NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIMEBEGIN CHAR(8) DEFAULT ''00:00:00'' NOT NULL,
  SENDTIMEEND   CHAR(8) DEFAULT ''23:59:59'' NOT NULL,
  MOBIAREA      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  ENSIGNSTR   VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  ENSIGNLEN   NUMBER(11)   DEFAULT 20    NOT NULL,
  ENMAXWORDS  NUMBER(11)   DEFAULT 720   NOT NULL,
  ENSINGLELEN NUMBER(11)   DEFAULT 160   NOT NULL,
  ENMULTILEN1 NUMBER(11)   DEFAULT 153   NOT NULL,
  ENMULTILEN2 NUMBER(11)   DEFAULT 133   NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GT_PORT_USED') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GT_PORT_USED
	  ADD CONSTRAINT PK_GTPORTUSED PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GT_PORT_USED') AND T.INDEX_NAME = UPPER('IX_GTPORTUSED');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_GTPORTUSED ON GT_PORT_USED (SPGATE, CPNO, SPISUNCM, ROUTEFLAG, USERID, GATESEQ, MOBIAREA, GATETYPE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GT_PORT_USED') AND T.INDEX_NAME = UPPER('IX_GTPORT_LGNID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GTPORT_LGNID ON GT_PORT_USED (LOGINID)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GT_PORT_USED') AND T.INDEX_NAME = UPPER('IX_GTPORT_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GTPORT_USRID ON GT_PORT_USED (USERID)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE HTTPERRCODE
----PROMPT ==========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='HTTPERRCODE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE HTTPERRCODE
(
  ID           NUMBER(22) NOT NULL,
  ERRSTATUS    VARCHAR2(16) DEFAULT ('' '') NOT NULL,
  PROTOCOLTYPE VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  ERRCODE      VARCHAR2(8) DEFAULT ('' '') NOT NULL,
  DESCRPTINFO  VARCHAR2(128) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('HTTPERRCODE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE HTTPERRCODE
	  ADD PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('HTTPERRCODE') AND T.INDEX_NAME = UPPER('IX_HTTPERRCODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_HTTPERRCODE ON HTTPERRCODE (ERRSTATUS, PROTOCOLTYPE, ERRCODE, DESCRPTINFO)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE KEYWORD_BLACK
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='KEYWORD_BLACK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE KEYWORD_BLACK
(
  ID        NUMBER(11) NOT NULL,
  KEYTYPE   NUMBER(11) DEFAULT 0 NOT NULL,
  KEYLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  KEYWORD   VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  COMMENTS  VARCHAR2(512) DEFAULT ('' '') NOT NULL,
  OPTTYPE   NUMBER(11) DEFAULT 1 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

--表KEYWORD_BLACK丢失了主键KEYWORD，重新加上
DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('KEYWORD_BLACK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE KEYWORD_BLACK
	  ADD CONSTRAINT PK_KEYWORD_BLACK PRIMARY KEY (KEYWORD)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE KF_CORPBASE
----PROMPT ==========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='KF_CORPBASE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE KF_CORPBASE
(
  ECID           NUMBER(11) DEFAULT 0 NOT NULL,
  CORPACCOUNT    VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  CORPNAME       VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LICENSE        VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  OPTYPE         VARCHAR2(8) DEFAULT ''0'' NOT NULL,
  STATUS         NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  ECCPNO         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  ECSIGN         CHAR(16) DEFAULT ('' '') NOT NULL,
  MAXPERDAY      NUMBER(11) DEFAULT 10000000 NOT NULL,
  WHITEVER       NUMBER(11) DEFAULT 0 NOT NULL,
  ORDERTIME      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  CANCELTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MODITIME       TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  EXPANLIMIT     NUMBER(11) DEFAULT 10 NOT NULL,
  STAFFLIMIT     NUMBER(11) DEFAULT 10 NOT NULL,
  MAINNOLIMIT    NUMBER(11) DEFAULT 10 NOT NULL,
  NEEDSIGN       NUMBER(11) DEFAULT 0 NOT NULL,
  WHTLEVEL       NUMBER(11) DEFAULT 0 NOT NULL,
  SPEEDLIMIT     NUMBER(11) DEFAULT 1000 NOT NULL,
  ORDERNUM       NUMBER(11) DEFAULT 0 NOT NULL,
  EXPRIEDDATE    CHAR(10) DEFAULT ('' '') NOT NULL,
  ECMANGER       CHAR(11) DEFAULT ('' '') NOT NULL,
  ECMEMO         VARCHAR2(100) DEFAULT ('' '') NOT NULL,
  ECIDBAK        NUMBER(11) DEFAULT 0 NOT NULL,
  CORPACCOUNTBAK VARCHAR2(32) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('KF_CORPBASE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE KF_CORPBASE
	  ADD CONSTRAINT PK_KFCORPBASE PRIMARY KEY (ECID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE KF_PARAMS
----PROMPT ========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='KF_PARAMS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE KF_PARAMS
(
  PARACODE NUMBER(11) DEFAULT 0 NOT NULL,
  PARAVAL1 NUMBER(11) DEFAULT 0 NOT NULL,
  PARAVAL2 VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  PARAINFO VARCHAR2(100) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('KF_PARAMS') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE KF_PARAMS
	  ADD CONSTRAINT PK_KFPARAMS PRIMARY KEY (PARACODE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_BMTREQ
----PROMPT =========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_BMTREQ';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_BMTREQ
(
  ID          NUMBER(11) NOT NULL,
  MSGID       NUMBER(22) DEFAULT 0 NOT NULL,
  BMTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID     NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICETYPE VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  MSGTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE       VARCHAR2(100) DEFAULT ('' '') NOT NULL,
  TMPLID      NUMBER(22) DEFAULT 0 NOT NULL,
  MSG         VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  REMOTEURL   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LOCALPATH   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 5 NOT NULL,
  ATTIME      VARCHAR2(14) DEFAULT ('' '') NOT NULL,
  VALIDTIME   VARCHAR2(14) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORCODE   VARCHAR2(7) DEFAULT ('' '') NOT NULL,
  RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  ATTIMEFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  SA          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQ') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_BMTREQ
	  ADD CONSTRAINT PK_MMS_BMTREQ PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQ') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQ_BMTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQ_BMTMSGID ON MMS_BMTREQ (BMTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQ') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQ_MSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQ_MSGID ON MMS_BMTREQ (MSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQ') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQ_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQ_USERID ON MMS_BMTREQ (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_BMTREQHIS
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_BMTREQHIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_BMTREQHIS
(
  ID          NUMBER(11) NOT NULL,
  MSGID       NUMBER(22) DEFAULT 0 NOT NULL,
  BMTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID     NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICETYPE VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  MSGTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE       VARCHAR2(100) DEFAULT ('' '') NOT NULL,
  TMPLID      NUMBER(22) DEFAULT 0 NOT NULL,
  MSG         VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  REMOTEURL   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LOCALPATH   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 5 NOT NULL,
  ATTIME      VARCHAR2(14) DEFAULT ('' '') NOT NULL,
  VALIDTIME   VARCHAR2(14) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORCODE   VARCHAR2(7) DEFAULT ('' '') NOT NULL,
  RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  ATTIMEFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  SA          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQHIS') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_BMTREQHIS
	  ADD CONSTRAINT PK_MMS_BMTREQHIS PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQHIS') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQHIS_BMTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQHIS_BMTMSGID ON MMS_BMTREQHIS (BMTMSGID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQHIS') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQHIS_MSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQHIS_MSGID ON MMS_BMTREQHIS (MSGID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_BMTREQHIS') AND T.INDEX_NAME = UPPER('IX_MMS_BMTREQHIS_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_BMTREQHIS_USERID ON MMS_BMTREQHIS (USERID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_DATAREPORT
----PROMPT =============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_DATAREPORT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_DATAREPORT
(
  USERID      VARCHAR2(11) NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE      VARCHAR2(21) NOT NULL,
  IYMD        NUMBER(11) NOT NULL,
  IHOUR       NUMBER(11) NOT NULL,
  PTCODE      VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  IMONTH      NUMBER(11) NOT NULL,
  ICOUNT      NUMBER(11) DEFAULT 0 NOT NULL,
  SUCC        NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL1       NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL2       NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL3       NUMBER(11) DEFAULT 0 NOT NULL,
  NRET        NUMBER(11) DEFAULT 0 NOT NULL,
  RSUCC       NUMBER(11) DEFAULT 0 NOT NULL,
  RFAIL1      NUMBER(11) DEFAULT 0 NOT NULL,
  RFAIL2      NUMBER(11) DEFAULT 0 NOT NULL,
  RNRET       NUMBER(11) DEFAULT 0 NOT NULL,
  RELEASEFLAG NUMBER(11) DEFAULT 1 NOT NULL,
  STARTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID          NUMBER(22) NOT NULL,
  Y           NUMBER(11) DEFAULT 0 NOT NULL,
  SPISUNCM    NUMBER(11) DEFAULT 0 NOT NULL,
  SPID        VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_DATAREPORT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_DATAREPORT
	  ADD CONSTRAINT MMS_DATAREPORT_PRIMARY PRIMARY KEY (USERID, TASKID, SPGATE, IYMD, IHOUR, PTCODE, SPISUNCM, SPID, SVRTYPE, P1, P2, P3, P4, SENDTYPE, MOBILEAREA)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_LEVEL_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_LEVEL_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_LEVEL_QUEUE
(
  ID          NUMBER(22) NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"         NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID     NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID    NUMBER(11) DEFAULT 0 NOT NULL,
  DEALSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID       NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI      NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  TOTALCOUNT  NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT  NUMBER(11) DEFAULT 1 NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG   NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG     NUMBER(11) DEFAULT 2 NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 5 NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  MSGTYPE     NUMBER(11) DEFAULT 10 NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  ECID        NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTITLE    VARCHAR2(200) DEFAULT ('' '') NOT NULL,
  TMPLID      NUMBER(22) DEFAULT 0 NOT NULL,
  MESSAGE     VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE       VARCHAR2(1500) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  JTYPE       NUMBER(11) DEFAULT 0 NOT NULL,
  ORDERCPNO   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PASSTHROUGH NUMBER(11) DEFAULT 0 NOT NULL,
  SA          VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_LEVEL_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_LEVEL_QUEUE
	  ADD CONSTRAINT PK_MMSLEVELQUEUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_LEVEL_QUEUE') AND T.INDEX_NAME = UPPER('IX_MMS_LEVEL_QUEUE_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_LEVEL_QUEUE_PTMSGID ON MMS_LEVEL_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_LEVEL_QUEUE') AND T.INDEX_NAME = UPPER('IX_MMS_LEVEL_QUEUE_SENDTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_LEVEL_QUEUE_SENDTIME ON MMS_LEVEL_QUEUE (SENDTIME)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_LEVEL_QUEUE') AND T.INDEX_NAME = UPPER('IX_MMS_LEVEL_QUEUE_SPGATE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_LEVEL_QUEUE_SPGATE ON MMS_LEVEL_QUEUE (SPGATE)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_LEVEL_QUEUE') AND T.INDEX_NAME = UPPER('IX_MMS_LEVEL_QUEUE_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_LEVEL_QUEUE_USERID ON MMS_LEVEL_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_MO
----PROMPT =====================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_MO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_MO
(
  ID          NUMBER(22) NOT NULL,
  "UID"         NUMBER(22) DEFAULT 0 NOT NULL,
  ORGUID      NUMBER(22) DEFAULT 0 NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPNUMBER    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SERVICEID   VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  MSGTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  TP_PID      NUMBER(11) DEFAULT 0 NOT NULL,
  TP_UDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  PTNOTICE    NUMBER(11) DEFAULT 0 NOT NULL,
  RESENDCNT   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID        NUMBER(22) DEFAULT 0 NOT NULL,
  MSGTITLE    VARCHAR2(200) DEFAULT ('' '') NOT NULL,
  MSGCONTENT  VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PASSTHROUGH NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_MO
	  ADD CONSTRAINT PK_MMS_MO PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_PTMSGID ON MMS_MO (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_UID ON MMS_MO ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_USERID ON MMS_MO (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_MODATAREPORT
----PROMPT ===============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_MODATAREPORT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_MODATAREPORT
(
  IYMD     NUMBER(11) DEFAULT 0 NOT NULL,
  USERID   VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  IHOUR    NUMBER(11) DEFAULT 0 NOT NULL,
  ICOUNT   NUMBER(11) DEFAULT 0 NOT NULL,
  IMONTH   NUMBER(11) DEFAULT 0 NOT NULL,
  IYEAR    NUMBER(11) DEFAULT 0 NOT NULL,
  RECVDATE NUMBER(11) DEFAULT 0 NOT NULL,
  SPISUNCM NUMBER(22) DEFAULT 0 NOT NULL,
  ID       NUMBER(22) NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_MODATAREPORT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_MODATAREPORT
	  ADD CONSTRAINT MMS_MODATAREPORT_PRIMARY PRIMARY KEY (USERID, SPGATE, SPISUNCM, IYMD, IYEAR, IMONTH, IHOUR)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_RPT
----PROMPT ======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_RPT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_RPT
(
  ID          NUMBER(22) NOT NULL,
  "UID"         NUMBER(11) DEFAULT 0 NOT NULL,
  ORGUID      NUMBER(11) DEFAULT 0 NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPNUMBER    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  SPMSGID2    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  SUBMITTIME  CHAR(10) DEFAULT ('' '') NOT NULL,
  DONEDATE    CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE   CHAR(7) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 5 NOT NULL,
  RESENDCNT   NUMBER(11) DEFAULT 0 NOT NULL,
  RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ECID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  SENDSATATUS NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORMSG    VARCHAR2(256) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_RPT
	  ADD CONSTRAINT PK_MMS_RPT PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.INDEX_NAME = UPPER('IX_MMS_RPT_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_RPT_PTMSGID ON MMS_RPT (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.INDEX_NAME = UPPER('IX_MMS_RPT_SPMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_RPT_SPMSGID ON MMS_RPT (SPMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.INDEX_NAME = UPPER('IX_MMS_RPT_SPMSGID2');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_RPT_SPMSGID2 ON MMS_RPT (SPMSGID2)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.INDEX_NAME = UPPER('IX_MMS_RPT_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_RPT_UID ON MMS_RPT ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_RPT') AND T.INDEX_NAME = UPPER('IX_MMS_RPT_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_RPT_USERID ON MMS_RPT (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_TASK
----PROMPT =======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_TASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_TASK
(
  ID           NUMBER(22) NOT NULL,
  "UID"          NUMBER(11) DEFAULT 0 NOT NULL,
  PTMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  TASKID       NUMBER(11) DEFAULT 0 NOT NULL,
  SPMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  SPMSGID2     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  RETFLAG      NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG      NUMBER(11) DEFAULT 2 NOT NULL,
  PKNUMBER     NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL      NUMBER(11) DEFAULT 1 NOT NULL,
  UNICOM       NUMBER(11) DEFAULT 0 NOT NULL,
  SENDSTATUS   NUMBER(11) DEFAULT 1 NOT NULL,
  SENDFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  DONEDATE     CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE    CHAR(7) DEFAULT ('' '') NOT NULL,
  ERRORMSG     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SENDLEVEL    NUMBER(11) DEFAULT 5 NOT NULL,
  SENDTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  MOBILEAREA   NUMBER(11) DEFAULT 0 NOT NULL,
  RESENDCNT    NUMBER(11) DEFAULT 0 NOT NULL,
  RECVMTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSMTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSRPTTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDRPTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MSGFMT       NUMBER(11) DEFAULT 15 NOT NULL,
  MSGTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  LONGMSGSEQ   NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID        NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI       NUMBER(11) DEFAULT 0 NOT NULL,
  RECVFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTITLE     VARCHAR2(720) DEFAULT ('' '') NOT NULL,
  TMPLID       NUMBER(22) DEFAULT 0 NOT NULL,
  MESSAGE      VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  ECID         NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE      VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  JTYPE        NUMBER(11) DEFAULT 0 NOT NULL,
  ORDERCPNO    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PASSTHROUGH  NUMBER(11) DEFAULT 0 NOT NULL,
  SPID         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  P1           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  USERMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID     NUMBER(11) DEFAULT 0 NOT NULL,
  ATTIME       NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME    NUMBER(22) DEFAULT 0 NOT NULL
)
TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_TASK
	  ADD CONSTRAINT PK_MMS_TASK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMS_TASK_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MMS_TASK_PTMSGID ON MMS_TASK (PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MMS_TEMPLATE
----PROMPT ===========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MMS_TEMPLATE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MMS_TEMPLATE
(
  ID           NUMBER(22) NOT NULL,
  TMPLID       NUMBER(22) DEFAULT 0 NOT NULL,
  EMP_TMPLID   VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  AUDITSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLSTATUS   NUMBER(11) DEFAULT 0 NOT NULL,
  PARAMCNT     NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLPATH     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RECVTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  AUDITTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  AUDITOR      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  REMARKS      VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RESERVE1     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RESERVE2     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RESERVE3     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RESERVE4     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RESERVE5     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SUBMITSTATUS NUMBER(11) DEFAULT 0 NOT NULL,
  ERRCODE      NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MMS_TEMPLATE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MMS_TEMPLATE
	  ADD CONSTRAINT PK_MMSTEMPLATE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TEMPLATE') AND T.INDEX_NAME = UPPER('IX_MMS_TEMPLATE_TMPLID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_TEMPLATE_TMPLID ON MMS_TEMPLATE (TMPLID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TEMPLATE') AND T.INDEX_NAME = UPPER('IX_MMS_TEMPLATE_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_TEMPLATE_USERID ON MMS_TEMPLATE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MO_DATAREPORT
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MO_DATAREPORT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MO_DATAREPORT
(
  IYMD     NUMBER(11) NOT NULL,
  USERID   VARCHAR2(11) NOT NULL,
  SPGATE   VARCHAR2(21) NOT NULL,
  IHOUR    NUMBER(11) DEFAULT 0 NOT NULL,
  ICOUNT   NUMBER(11) DEFAULT 0 NOT NULL,
  IMONTH   NUMBER(11) DEFAULT 0 NOT NULL,
  IYEAR    NUMBER(11) DEFAULT 0 NOT NULL,
  ID       NUMBER(11) NOT NULL,
  RECVDATE TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SPISUNCM NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MO_DATAREPORT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MO_DATAREPORT
	  ADD CONSTRAINT MO_DATAREPORT_PRI PRIMARY KEY (USERID, SPGATE, SPISUNCM, IYMD, IYEAR, IMONTH, IHOUR)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MO_TASK
----PROMPT ======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MO_TASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MO_TASK
(
  ID          NUMBER(22) NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"         NUMBER(11) DEFAULT 0 NOT NULL,
  ORGUID      NUMBER(11) DEFAULT 0 NOT NULL,
  ECID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPNUMBER    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SERVICEID   VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 1 NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  TP_PID      NUMBER(11) DEFAULT 0 NOT NULL,
  TP_UDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MSGCONTENT  VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RESENDCNT   NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  PTNOTICE    NUMBER(11) DEFAULT 0 NOT NULL,
  CMDID       NUMBER(22) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MO_TASK
	  ADD CONSTRAINT PK_MOTASK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.INDEX_NAME = UPPER('IX_MOTASK_ORGUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOTASK_ORGUID ON MO_TASK (ORGUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.INDEX_NAME = UPPER('IX_MOTASK_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MOTASK_PTID ON MO_TASK (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.INDEX_NAME = UPPER('IX_MOTASK_SDSTS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOTASK_SDSTS ON MO_TASK (SENDSTATUS)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.INDEX_NAME = UPPER('IX_MOTASK_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOTASK_UID ON MO_TASK ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_TASK') AND T.INDEX_NAME = UPPER('IX_MOTASK_UIDSTS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOTASK_UIDSTS ON MO_TASK ("UID", SENDSTATUS)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MO_TASK_HIS
----PROMPT ==========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MO_TASK_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MO_TASK_HIS
(
  ID          NUMBER(22) NOT NULL,
  "UID"         NUMBER(11) NOT NULL,
  USERID      VARCHAR2(11) NOT NULL,
  SPNUMBER    VARCHAR2(21) NOT NULL,
  SERVICEID   VARCHAR2(10) NOT NULL,
  SENDSTATUS  NUMBER(11) NOT NULL,
  DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  PHONE       VARCHAR2(21) NOT NULL,
  MSGCONTENT  VARCHAR2(3000) NOT NULL,
  ECID        NUMBER(11) NOT NULL,
  ORGUID      NUMBER(11) NOT NULL,
  PTMSGID     NUMBER(22) NOT NULL,
  TP_PID      NUMBER(11) NOT NULL,
  TP_UDHI     NUMBER(11) NOT NULL,
  MSGFMT      NUMBER(11) NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MO_TASK_HIS') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MO_TASK_HIS
	  ADD CONSTRAINT MOTASKHIS_PRIMARY PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MO_WAIT_A
----PROMPT ========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MO_WAIT_A';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MO_WAIT_A
(
  ID          NUMBER(22) NOT NULL,
  ECID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERUID     NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID    NUMBER(11) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  SPNUMBER    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE     VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
  TP_UDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  TP_PID      NUMBER(11) DEFAULT 0 NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICEID   VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  PTNOTICE    NUMBER(11) DEFAULT 0 NOT NULL,
  CPNO        VARCHAR2(21) DEFAULT '' '' NOT NULL,
  CMDID       NUMBER(22) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MO_WAIT_A') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MO_WAIT_A
	  ADD CONSTRAINT PK_MOWAITA PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_WAIT_A') AND T.INDEX_NAME = UPPER('IX_MOWAITA_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOWAITA_PTID ON MO_WAIT_A (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_WAIT_A') AND T.INDEX_NAME = UPPER('IX_MOWAITA_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOWAITA_UID ON MO_WAIT_A (USERUID, LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MO_WAIT_C
----PROMPT ========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MO_WAIT_C';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MO_WAIT_C
(
  ID          NUMBER(22) NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"         NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPNUMBER    VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SERVICEID   VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
  STATUS      NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  TP_PID      NUMBER(11) DEFAULT 0 NOT NULL,
  TP_UDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MSGCONTENT  VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  PTNOTICE    NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MO_WAIT_C') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MO_WAIT_C
	  ADD CONSTRAINT PK_MOWAITC PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_WAIT_C') AND T.INDEX_NAME = UPPER('IX_MOWAITC_LGNID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOWAITC_LGNID ON MO_WAIT_C (LOGINID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_WAIT_C') AND T.INDEX_NAME = UPPER('IX_MOWAITC_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MOWAITC_PTID ON MO_WAIT_C (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MO_WAIT_C') AND T.INDEX_NAME = UPPER('IX_MOWAITC_SPGATE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MOWAITC_SPGATE ON MO_WAIT_C (SPGATE)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MR_SPGATE_WATCH
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MR_SPGATE_WATCH';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MR_SPGATE_WATCH
(
  GATEID       NUMBER(11) NOT NULL,
  SPGATE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PTCODE       CHAR(10) DEFAULT ''0'',
  STATE        NUMBER(11) DEFAULT 1,
  LSSENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
  LSRECVTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
  DELAYSS      NUMBER(11) DEFAULT 0,
  WATCHNUM     NUMBER(11) DEFAULT 0,
  WATCHSUCC    NUMBER(11) DEFAULT 0,
  WATCHDELAY   NUMBER(11) DEFAULT 0,
  NUMMT        NUMBER(11) DEFAULT 0,
  NUMRPT       NUMBER(11) DEFAULT 0,
  NUMMO        NUMBER(11) DEFAULT 0,
  SPEEDMT      NUMBER(11) DEFAULT 0,
  SPEEDMO      NUMBER(11) DEFAULT 0,
  SPEEDRPT     NUMBER(11) DEFAULT 0,
  UPDATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
  DEALFLAG     NUMBER(11) DEFAULT 1,
  ERRORINFO    VARCHAR2(200) DEFAULT ('' ''),
  USRID        VARCHAR2(11),
  ONLINESTATUS NUMBER(11) DEFAULT 0,
  TOTALRPTSEND NUMBER(11) DEFAULT 0,
  TOTALMOSEND  NUMBER(11) DEFAULT 0,
  HAVESENDMO   NUMBER(11) DEFAULT 0,
  HAVESENDRPT  NUMBER(11) DEFAULT 0,
  RECVMT       NUMBER(11) DEFAULT 0,
  REMAINEDMT   NUMBER(11) DEFAULT 0,
  TIMERSENDMT  NUMBER(11) DEFAULT 0,
  REMAINEDRPT  NUMBER(11) DEFAULT 0,
  REMAINEDMO   NUMBER(11) DEFAULT 0,
  RECVSPEED    NUMBER(11) DEFAULT 0,
  PARAM1       NUMBER(11) DEFAULT 0,
  PARAM2       NUMBER(11) DEFAULT 0,
  PARAM3       NUMBER(11) DEFAULT 0,
  PARAM4       NUMBER(11) DEFAULT 0,
  PARAM5       NUMBER(11) DEFAULT 0,
  PARAM6       VARCHAR2(100) DEFAULT ('' ''),
  PARAM7       VARCHAR2(100) DEFAULT ('' '')
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_DATAREPORT
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_DATAREPORT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_DATAREPORT
(
  USERID      VARCHAR2(11) NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE      VARCHAR2(21) NOT NULL,
  IYMD        NUMBER(11) NOT NULL,
  IHOUR       NUMBER(11) NOT NULL,
  PTCODE      CHAR(10) DEFAULT ('' '') NOT NULL,
  IMONTH      NUMBER(11) NOT NULL,
  ICOUNT      NUMBER(11) DEFAULT 0 NOT NULL,
  SUCC        NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL1       NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL2       NUMBER(11) DEFAULT 0 NOT NULL,
  FAIL3       NUMBER(11) DEFAULT 0 NOT NULL,
  NRET        NUMBER(11) DEFAULT 0 NOT NULL,
  RSUCC       NUMBER(11) DEFAULT 0 NOT NULL,
  RFAIL1      NUMBER(11) DEFAULT 0 NOT NULL,
  RFAIL2      NUMBER(11) DEFAULT 0 NOT NULL,
  RNRET       NUMBER(11) DEFAULT 0 NOT NULL,
  RELEASEFLAG NUMBER(11) DEFAULT 1 NOT NULL,
  STARTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID          NUMBER(11) NOT NULL,
  Y           NUMBER(11) DEFAULT 0 NOT NULL,
  SPISUNCM    NUMBER(11) DEFAULT 0 NOT NULL,
  SPID        VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
  MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL,
  BATCHID     NUMBER(22) DEFAULT 0 NOT NULL,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLID	  NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE	  NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE	  NUMBER(11) DEFAULT 0 NOT NULL,
  RECFAIL 	  NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_DATAREPORT') AND T.INDEX_NAME = UPPER('IX_MT_DATAREPORT_UNION');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX  IX_MT_DATAREPORT_UNION ON MT_DATAREPORT (USERID, TASKID, SPGATE, IYMD, IHOUR, SPISUNCM, SPID, SVRTYPE, P1, P2, P3, P4, SENDTYPE, MOBILEAREA,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_DATAREPORT') AND T.INDEX_NAME = UPPER('IX_MT_DATAREPORT_TASKID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MT_DATAREPORT_TASKID ON MT_DATAREPORT (TASKID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_DATAREPORT') AND T.INDEX_NAME = UPPER('IX_Y_IMONTH');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_Y_IMONTH ON MT_DATAREPORT (
		IMONTH ASC,
		Y DESC,
	  ICOUNT,
	  RFAIL1,
	  RFAIL2,
	  SPISUNCM,
	  SPID)
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_DATAREPORT_SP
----PROMPT ===============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_DATAREPORT_SP';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_DATAREPORT_SP
(
  IYMD       NUMBER(11) NOT NULL,
  USERID     VARCHAR2(11) NOT NULL,
  SPGATE     VARCHAR2(21) NOT NULL,
  SPISUNCM   NUMBER(11) DEFAULT 0 NOT NULL,
  ICOUNT     NUMBER(11) DEFAULT 0 NOT NULL,
  ISUCC      NUMBER(11) DEFAULT 0 NOT NULL,
  IFAIL      NUMBER(11) DEFAULT 0 NOT NULL,
  UPDATETIME TIMESTAMP(6) NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_DATAREPORT_SP') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_DATAREPORT_SP
	  ADD CONSTRAINT MT_DATAREPORT_SP_PRIMARY PRIMARY KEY (IYMD, USERID, SPGATE, SPISUNCM)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL0_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL0_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL0_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL0_QUEUE
	  ADD CONSTRAINT PK_MTLVL0QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_AGE ON MT_LEVEL0_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_DESTUID ON MT_LEVEL0_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_END ON MT_LEVEL0_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_LGNUID ON MT_LEVEL0_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_PRE ON MT_LEVEL0_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL0_PTID ON MT_LEVEL0_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_UID ON MT_LEVEL0_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_USRID ON MT_LEVEL0_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL0_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL0_ATTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL0_ATTIME ON MT_LEVEL0_QUEUE (ATTIME)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL1_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL1_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL1_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL1_QUEUE
	  ADD CONSTRAINT PK_MTLVL1QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_AGE ON MT_LEVEL1_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_DESTUID ON MT_LEVEL1_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_END ON MT_LEVEL1_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_LGNUID ON MT_LEVEL1_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_PRE ON MT_LEVEL1_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL1_PTID ON MT_LEVEL1_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_UID ON MT_LEVEL1_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL1_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL1_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL1_USRID ON MT_LEVEL1_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL2_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL2_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL2_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL2_QUEUE
	  ADD CONSTRAINT PK_MTLVL2QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_AGE ON MT_LEVEL2_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_DESTUID ON MT_LEVEL2_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_END ON MT_LEVEL2_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_LGNUID ON MT_LEVEL2_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_PRE ON MT_LEVEL2_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL2_PTID ON MT_LEVEL2_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_UID ON MT_LEVEL2_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL2_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL2_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL2_USRID ON MT_LEVEL2_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL3_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL3_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL3_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL3_QUEUE
	  ADD CONSTRAINT PK_MTLVL3QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_AGE ON MT_LEVEL3_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_DESTUID ON MT_LEVEL3_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_END ON MT_LEVEL3_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_LGNUID ON MT_LEVEL3_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_PRE ON MT_LEVEL3_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL3_PTID ON MT_LEVEL3_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_UID ON MT_LEVEL3_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL3_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL3_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL3_USRID ON MT_LEVEL3_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL4_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL4_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL4_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL4_QUEUE
	  ADD CONSTRAINT PK_MTLVL4QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_AGE ON MT_LEVEL4_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_DESTUID ON MT_LEVEL4_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_END ON MT_LEVEL4_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_LGNUID ON MT_LEVEL4_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_PRE ON MT_LEVEL4_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL4_PTID ON MT_LEVEL4_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_UID ON MT_LEVEL4_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL4_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL4_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL4_USRID ON MT_LEVEL4_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL5_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL5_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL5_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL5_QUEUE
	  ADD CONSTRAINT PK_MTLVL5QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_AGE ON MT_LEVEL5_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_DESTUID ON MT_LEVEL5_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_END ON MT_LEVEL5_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_LGNUID ON MT_LEVEL5_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_PRE ON MT_LEVEL5_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL5_PTID ON MT_LEVEL5_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_UID ON MT_LEVEL5_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL5_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL5_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL5_USRID ON MT_LEVEL5_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL6_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL6_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL6_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL6_QUEUE
	  ADD CONSTRAINT PK_MTLVL6QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_AGE ON MT_LEVEL6_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_DESTUID ON MT_LEVEL6_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_END ON MT_LEVEL6_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_LGNUID ON MT_LEVEL6_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_PRE ON MT_LEVEL6_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL6_PTID ON MT_LEVEL6_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_UID ON MT_LEVEL6_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL6_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL6_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL6_USRID ON MT_LEVEL6_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL7_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL7_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL7_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL7_QUEUE
	  ADD CONSTRAINT PK_MTLVL7QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_AGE ON MT_LEVEL7_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_DESTUID ON MT_LEVEL7_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_END ON MT_LEVEL7_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_LGNUID ON MT_LEVEL7_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_PRE ON MT_LEVEL7_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL7_PTID ON MT_LEVEL7_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_UID ON MT_LEVEL7_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL7_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL7_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL7_USRID ON MT_LEVEL7_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL8_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL8_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL8_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL8_QUEUE
	  ADD CONSTRAINT PK_MTLVL8QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_AGE ON MT_LEVEL8_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_DESTUID ON MT_LEVEL8_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_END ON MT_LEVEL8_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_LGNUID ON MT_LEVEL8_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_PRE ON MT_LEVEL8_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL8_PTID ON MT_LEVEL8_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_UID ON MT_LEVEL8_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL8_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL8_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL8_USRID ON MT_LEVEL8_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_LEVEL9_QUEUE
----PROMPT ==============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_LEVEL9_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_LEVEL9_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE    NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_LEVEL9_QUEUE
	  ADD CONSTRAINT PK_MTLVL9QUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_AGE ON MT_LEVEL9_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_DESTUID ON MT_LEVEL9_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_END ON MT_LEVEL9_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_LGNUID ON MT_LEVEL9_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_PRE ON MT_LEVEL9_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTLVL9_PTID ON MT_LEVEL9_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_UID ON MT_LEVEL9_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_LEVEL9_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTLVL9_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTLVL9_USRID ON MT_LEVEL9_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_ROUTETABLE
----PROMPT ============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_ROUTETABLE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_ROUTETABLE
(
  ID         NUMBER(11) NOT NULL,
  EXNOHOLD   NUMBER(11) DEFAULT 1 NOT NULL,
  EXPIREDTM  NUMBER(11) DEFAULT 60 NOT NULL,
  SRCUSERID  VARCHAR2(11) DEFAULT '' '' NOT NULL,
  DESTUSERID VARCHAR2(11) DEFAULT '' '' NOT NULL,
  SRCBINDID  NUMBER(11) DEFAULT 0 NOT NULL,
  DESTBINDID NUMBER(11) DEFAULT 0 NOT NULL,
  PARAMS     VARCHAR2(100) DEFAULT '' '' NOT NULL,
  ROUTETYPE  NUMBER(11) DEFAULT 1 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_ROUTETABLE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_ROUTETABLE
	  ADD CONSTRAINT PK_MTROUTETB PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_TASK
----PROMPT ======================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_TASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_TASK
(
  ID           NUMBER(22) NOT NULL,
  PTMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"          NUMBER(11) DEFAULT 0 NOT NULL,
  ECID         NUMBER(11) DEFAULT 0 NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPID         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPGATE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  RETFLAG      NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG      NUMBER(11) DEFAULT 1 NOT NULL,
  PKNUMBER     NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL      NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS   NUMBER(11) DEFAULT 2 NOT NULL,
  SENDFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  RECVFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  DONEDATE     CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE    CHAR(7) DEFAULT ('' '') NOT NULL,
  SENDLEVEL    NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  UNICOM       NUMBER(11) DEFAULT 0 NOT NULL,
  MOBILEAREA   NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE      VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  RESENDCNT    NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID       NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT       NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ   NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI       NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID     NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE      VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  RECVMTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSMTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSRPTTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDRPTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ATTIME       NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME    NUMBER(22) DEFAULT 0 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_TASK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_TASK
	  ADD CONSTRAINT PK_MTTASK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TASK') AND T.INDEX_NAME = UPPER('IX_MTTASK_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTTASK_PTID ON MT_TASK (PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TASK') AND T.INDEX_NAME = UPPER('IX_MTTASK_SDTM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTASK_SDTM ON MT_TASK (SENDTIME)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_TASK_C
----PROMPT ========================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_TASK_C';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_TASK_C
(
  ID          NUMBER(22) NOT NULL,
  PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SHOUJI      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
  RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG     NUMBER(11) DEFAULT 1 NOT NULL,
  TPUDHI      NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER    NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL     NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  RECVFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  DONEDATE    VARCHAR2(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE   VARCHAR2(7) DEFAULT ('' '') NOT NULL,
  SENDLEVEL   NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 0 NOT NULL,
  UNICOM      NUMBER(4) DEFAULT 0 NOT NULL,
  FIXEDCH     NUMBER(11) DEFAULT 0 NOT NULL,
  SENDCH      NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE     VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
  LOGINID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ  NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID       NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
  TRANSMTTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL,
  MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL,
 NETERRORCNT  NUMBER(11) DEFAULT 0 NOT NULL,
SUBMITERRORCNT  NUMBER(11) DEFAULT 0 NOT NULL,
 CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
 EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
 MSGTYPE NUMBER(11) DEFAULT 0 NOT NULL,
 VALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
 TMPLID NUMBER(11) DEFAULT 0 NOT NULL,
 PROTOCOLVER NUMBER(11) DEFAULT 0 NOT NULL,
TITLE     VARCHAR2(40) DEFAULT '' '' NOT NULL,
SHOWAY     VARCHAR2(16) DEFAULT '' '' NOT NULL,
DLDWAY NUMBER(11) DEFAULT 0 NOT NULL,
DLDNEY NUMBER(11) DEFAULT 0 NOT NULL,
ISFREE NUMBER(11) DEFAULT 0 NOT NULL,
SHOWTIME NUMBER(22) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_TASK_C') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_TASK_C
	  ADD CONSTRAINT PK_MTTASKC PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TASK_C') AND T.INDEX_NAME = UPPER('IX_MTTASKC_LGNID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTASKC_LGNID ON MT_TASK_C (LOGINID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TASK_C') AND T.INDEX_NAME = UPPER('IX_MTTASKC_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTTASKC_PTID ON MT_TASK_C (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_TIMER_QUEUE
----PROMPT =============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_TIMER_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_TIMER_QUEUE
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 2 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_TIMER_QUEUE
	  ADD CONSTRAINT PK_MTTMRQUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_AGE ON MT_TIMER_QUEUE (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_DESTUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_DESTUID ON MT_TIMER_QUEUE (DESTUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_END ON MT_TIMER_QUEUE (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_LGNUID ON MT_TIMER_QUEUE (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_PRE ON MT_TIMER_QUEUE ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTTMR_PTID ON MT_TIMER_QUEUE (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_SDLVL');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_SDLVL ON MT_TIMER_QUEUE (SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_UID ON MT_TIMER_QUEUE ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_UIDSDLVL');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_UIDSDLVL ON MT_TIMER_QUEUE ("UID", DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_TIMER_QUEUE') AND T.INDEX_NAME = UPPER('IX_MTTMR_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTTMR_USRID ON MT_TIMER_QUEUE (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
----PROMPT CREATING TABLE MT_VERIFY_TASK
----PROMPT =============================
----PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_VERIFY_TASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_VERIFY_TASK
(
  ID           NUMBER(22) NOT NULL,
  DEALSTATUS   NUMBER(11) DEFAULT 0 NOT NULL,
  VERIFYSTATUS NUMBER(11) DEFAULT 0 NOT NULL,
  CMDTEXT      VARCHAR2(1000) DEFAULT ('' '') NOT NULL,
  PARAMS       VARCHAR2(1000) DEFAULT ('' '') NOT NULL,
  MEMO         VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_TASK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_VERIFY_TASK
	  ADD CONSTRAINT PK_MTVFYTASK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

----PROMPT
--PROMPT CREATING TABLE MT_VERIFY_WAIT
--PROMPT =============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_VERIFY_WAIT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_VERIFY_WAIT
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  DESTUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  DEALSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT '' '' NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT '' '' NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT '' '' NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 0 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SPLITFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG    NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 5 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT '' '' NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT '' '' NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  TOTALCOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_VERIFY_WAIT
	  ADD CONSTRAINT PK_MTVFYWAIT PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.INDEX_NAME = UPPER('IX_MTVFY_AGE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTVFY_AGE ON MT_VERIFY_WAIT (LOGINUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.INDEX_NAME = UPPER('IX_MTVFY_END');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTVFY_END ON MT_VERIFY_WAIT (DESTUID, SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.INDEX_NAME = UPPER('IX_MTVFY_PRE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTVFY_PRE ON MT_VERIFY_WAIT ("UID", SENDLEVEL)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.INDEX_NAME = UPPER('IX_MTVFY_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTVFY_PTID ON MT_VERIFY_WAIT (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_VERIFY_WAIT') AND T.INDEX_NAME = UPPER('IX_MTVFY_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTVFY_USRID ON MT_VERIFY_WAIT (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE MT_WAIT_A
--PROMPT ========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='MT_WAIT_A';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE MT_WAIT_A
(
  ID         NUMBER(22) NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERUID    NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID     NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  SPNUMBER   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT 1 NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  PHONECOUNT NUMBER(11) DEFAULT 1 NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(3500) DEFAULT ('' '') NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI     NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID      NUMBER(11) DEFAULT 0 NOT NULL,
  PKNUMBER   NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL    NUMBER(11) DEFAULT 1 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  TOTALCOUNT NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('MT_WAIT_A') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE MT_WAIT_A
	  ADD CONSTRAINT PK_MTWAITA PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_WAIT_A') AND T.INDEX_NAME = UPPER('IX_MTWAITA_LGNUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTWAITA_LGNUID ON MT_WAIT_A (LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_WAIT_A') AND T.INDEX_NAME = UPPER('IX_MTWAITA_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MTWAITA_PTID ON MT_WAIT_A (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MT_WAIT_A') AND T.INDEX_NAME = UPPER('IX_MTWAITA_UIDSTS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTWAITA_UIDSTS ON MT_WAIT_A (USERUID, SENDSTATUS)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_BUFINFO
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_BUFINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_BUFINFO
(
  PTCODE       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  ENDCNT       NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MTTOTALSND   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMOBUF      NUMBER(11) DEFAULT (0) NOT NULL,
  UPDMOBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  UPDRPTBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  WRRPTBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  ENDRSPBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  SMTSNDBUF    VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  NMTSNDBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  MTWAITBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  PRECNT       NUMBER(11) DEFAULT (0) NOT NULL,
  MTTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALSND   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTTASKBUF  NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTTMBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTVFYBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTLVLBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  PRERSPBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  PRERSPTMPBUF NUMBER(11) DEFAULT (0) NOT NULL,
  MOSNDBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTSNDBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  MORPTWAITBUF NUMBER(11) DEFAULT (0) NOT NULL,
  LOGFILENUM   NUMBER(11) DEFAULT (0) NOT NULL,
  LOGBUF       NUMBER(11) DEFAULT (0) NOT NULL,
  RECVBUF      NUMBER(11) DEFAULT (0) NOT NULL,
  RESNDBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  SUPPSNDBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  MONLOGBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  UPDATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID           NUMBER(22) NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.ENDCNT IS ''后端连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MOTOTALRECV IS ''后端转发至网关的MO总数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MTTOTALSND IS ''网关成功转发至后端的MT总数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRMOBUF IS ''写MO_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.UPDMOBUF IS ''更新MO_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.UPDRPTBUF IS ''更新MT_TASK表中SENDSTATUS字段''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRRPTBUF IS ''写RPT_WAIT_B表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.ENDRSPBUF IS ''后端高级别回应缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.SMTSNDBUF IS ''网关向后端转发MT的发送缓冲（0-9级）中间以/分隔，如0/1/2/3/4/5/6/7/8/9 中间以/分隔，如0/1/2/3/4/5/6/7/8/9''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MTWAITBUF IS ''网关向后端转发MT的发送缓冲（0-9级）0-9级别的总和''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.PRECNT IS ''前端连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MTTOTALRECV IS ''接收到前端MT的总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MOTOTALSND IS ''接收到前端MT的总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRMTTASKBUF IS ''写MT_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRMTTMBUF IS ''写MT_TIMER_QUE表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRMTVFYBUF IS ''写MT_VERIFY_WAIT表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.WRMTLVLBUF IS ''写MT_LEVEL_QUE表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.PRERSPBUF IS ''前端高级别回应缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.PRERSPTMPBUF IS ''前端高级别回应临时缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MOSNDBUF IS ''MO发送缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.RPTSNDBUF IS ''RPT发送缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MORPTWAITBUF IS ''MO/RPT发送等待缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.LOGFILENUM IS ''日志文件数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.LOGBUF IS ''日志缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.RECVBUF IS ''接收缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.RESNDBUF IS ''重发缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.SUPPSNDBUF IS ''补发缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.MONLOGBUF IS ''监控日志缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUFINFO.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_BUF_HIS
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_BUF_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_BUF_HIS
(
  ID           NUMBER(22) NOT NULL,
  PTCODE       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  ENDCNT       NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MTTOTALSND   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMOBUF      NUMBER(11) DEFAULT (0) NOT NULL,
  UPDMOBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  UPDRPTBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  WRRPTBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  ENDRSPBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  SMTSNDBUF    VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  NMTSNDBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  MTWAITBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  PRECNT       NUMBER(11) DEFAULT (0) NOT NULL,
  MTTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALSND   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTTASKBUF  NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTTMBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTVFYBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  WRMTLVLBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  PRERSPBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  PRERSPTMPBUF NUMBER(11) DEFAULT (0) NOT NULL,
  MOSNDBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTSNDBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  MORPTWAITBUF NUMBER(11) DEFAULT (0) NOT NULL,
  LOGFILENUM   NUMBER(11) DEFAULT (0) NOT NULL,
  LOGBUF       NUMBER(11) DEFAULT (0) NOT NULL,
  RECVBUF      NUMBER(11) DEFAULT (0) NOT NULL,
  RESNDBUF     NUMBER(11) DEFAULT (0) NOT NULL,
  SUPPSNDBUF   NUMBER(11) DEFAULT (0) NOT NULL,
  MONLOGBUF    NUMBER(11) DEFAULT (0) NOT NULL,
  UPDATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.ENDCNT IS ''后端连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MOTOTALRECV IS ''后端转发至网关的MO总数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MTTOTALSND IS ''网关成功转发至后端的MT总数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRMOBUF IS ''写MO_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.UPDMOBUF IS ''更新MO_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.UPDRPTBUF IS ''更新MT_TASK表中SENDSTATUS字段''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRRPTBUF IS ''写RPT_WAIT_B表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.ENDRSPBUF IS ''后端高级别回应缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.SMTSNDBUF IS ''网关向后端转发MT的发送缓冲（0-9级）中间以/分隔，如0/1/2/3/4/5/6/7/8/9 中间以/分隔，如0/1/2/3/4/5/6/7/8/9''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MTWAITBUF IS ''网关向后端转发MT的发送缓冲（0-9级）0-9级别的总和''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.PRECNT IS ''前端连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MTTOTALRECV IS ''接收到前端MT的总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MOTOTALSND IS ''接收到前端MT的总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRMTTASKBUF IS ''写MT_TASK表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRMTTMBUF IS ''写MT_TIMER_QUE表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRMTVFYBUF IS ''写MT_VERIFY_WAIT表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.WRMTLVLBUF IS ''写MT_LEVEL_QUE表缓冲大小''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.PRERSPBUF IS ''前端高级别回应缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.PRERSPTMPBUF IS ''前端高级别回应临时缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MOSNDBUF IS ''MO发送缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.RPTSNDBUF IS ''RPT发送缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MORPTWAITBUF IS ''MO/RPT发送等待缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.LOGFILENUM IS ''日志文件数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.LOGBUF IS ''日志缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.RECVBUF IS ''接收缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.RESNDBUF IS ''重发缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.SUPPSNDBUF IS ''补发缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.MONLOGBUF IS ''监控日志缓冲''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_BUF_HIS.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_LOGINFO
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_LOGINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_LOGINFO
(
  ID         NUMBER(22) NOT NULL,
  PTCODE     VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  LOGTYPE    NUMBER(11) DEFAULT (0) NOT NULL,
  LOGS       VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
  CREATETIME VARCHAR2(35) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOGINFO.ID IS ''自增ID，主键''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOGINFO.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOGINFO.LOGTYPE IS ''100-199）登陆日志（对接入服务器来说是帐号的登陆日志，对SPGATE来说是登陆PT和SP的日志）''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOGINFO.LOGS IS ''日志信息''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_LOGINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_LOGINFO
	  ADD CONSTRAINT PK_M_MON_LOGINFO PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_LOG_HIS
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_LOG_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_LOG_HIS
(
  ID         NUMBER(22) NOT NULL,
  PTCODE     VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  LOGTYPE    NUMBER(11) DEFAULT (0) NOT NULL,
  LOGS       VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
  CREATETIME VARCHAR2(35) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOG_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOG_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOG_HIS.LOGTYPE IS ''100-199）登陆日志（对接入服务器来说是帐号的登陆日志，对SPGATE来说是登陆PT和SP的日志）''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_LOG_HIS.LOGS IS ''日志信息''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_MONLOG
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_MONLOG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_MONLOG
(
  ID      NUMBER(22) NOT NULL,
  PTCODE  VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  LOGTYPE NUMBER(11) DEFAULT (0) NOT NULL,
  LOGS    VARCHAR2(4000) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONLOG.LOGTYPE IS ''0：来自于后台监控程序1：来自于前台监控页面''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONLOG.LOGS IS ''流水日志''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_MONLOG') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_MONLOG
	  ADD CONSTRAINT PK_M_MON_MONLOG PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_MONLOG_HIS
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_MONLOG_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_MONLOG_HIS
(
  ID      NUMBER(22) NOT NULL,
  PTCODE  VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  LOGTYPE NUMBER(11) DEFAULT (0) NOT NULL,
  LOGS    VARCHAR2(4000) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONLOG_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONLOG_HIS.LOGTYPE IS ''0：来自于后台监控程序1：来自于前台监控页面''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONLOG_HIS.LOGS IS ''流水日志''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_MONMSG
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_MONMSG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_MONMSG
(
  ID         NUMBER(22) NOT NULL,
  PTCODE     VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  MSGTYPE    NUMBER(11) DEFAULT (0) NOT NULL,
  MSGID      NUMBER(22) DEFAULT (0) NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MOBILE     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  MOBILETYPE NUMBER(11) DEFAULT (0) NOT NULL,
  MOBILEAREA NUMBER(11) DEFAULT (0) NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT (0) NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT (15) NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT (1) NOT NULL,
  RESENDCNT  NUMBER(11) DEFAULT (0) NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT ('' '') NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  SENDTIME   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  RECVTIME   VARCHAR2(35) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MSGTYPE IS ''100-199：检测短信(通道检测，新通道各区域发送情况检测等)200-299：报警短信(前面报警，后台报警)''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MSGID IS ''取发送后平台返回的流水号''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MOBILE IS ''最大支持10个手机号，中间英文逗号隔开''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MOBILETYPE IS ''0：移动1：联通2：小灵通21：电信手机255：未知''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MOBILEAREA IS ''手机号归属地''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.SENDLEVEL IS ''0-255：值越小，级别越高''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MSGFMT IS ''默认取15''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.SENDSTATUS IS ''1:新插入，待发送2:发送至下级网关3:接交下级网失败0:状态报告已返回''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.RESENDCNT IS ''接交下级网关失败后，重发的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.ERRORCODE IS ''状态报告错误码''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.MESSAGE IS ''短信内容''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.SENDTIME IS ''短信发送至下级网关的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG.RECVTIME IS ''状态报告返回时间''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_MONMSG') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_MONMSG
	  ADD CONSTRAINT PK_M_MON_MONMSG PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_MONMSG_HIS
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_MONMSG_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_MONMSG_HIS
(
  ID         NUMBER(22) NOT NULL,
  PTCODE     VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  MSGTYPE    NUMBER(11) DEFAULT (0) NOT NULL,
  MSGID      NUMBER(22) DEFAULT (0) NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MOBILE     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  MOBILETYPE NUMBER(11) DEFAULT (0) NOT NULL,
  MOBILEAREA NUMBER(11) DEFAULT (0) NOT NULL,
  SENDLEVEL  NUMBER(11) DEFAULT (0) NOT NULL,
  MSGFMT     NUMBER(11) DEFAULT (15) NOT NULL,
  SENDSTATUS NUMBER(11) DEFAULT (1) NOT NULL,
  RESENDCNT  NUMBER(11) DEFAULT (0) NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT ('' '') NOT NULL,
  MESSAGE    VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  SENDTIME   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  RECVTIME   VARCHAR2(35) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MSGTYPE IS ''100-199：检测短信(通道检测，新通道各区域发送情况检测等)200-299：报警短信(前面报警，后台报警)''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MSGID IS ''取发送后平台返回的流水号''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MOBILE IS ''最大支持10个手机号，中间英文逗号隔开''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MOBILETYPE IS ''0：移动1：联通2：小灵通21：电信手机255：未知''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MOBILEAREA IS ''手机号归属地''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.SENDLEVEL IS ''0-255：值越小，级别越高''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MSGFMT IS ''默认取15''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.SENDSTATUS IS ''1:新插入，待发送2:发送至下级网关3:接交下级网失败0:状态报告已返回''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.RESENDCNT IS ''接交下级网关失败后，重发的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.ERRORCODE IS ''状态报告错误码''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.MESSAGE IS ''短信内容''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.SENDTIME IS ''短信发送至下级网关的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_MONMSG_HIS.RECVTIME IS ''状态报告返回时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_PTINFO
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_PTINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_PTINFO
(
  PTCODE      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  PTNAME      VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  PTIP        VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
  PTPORT      NUMBER(11) DEFAULT (9001) NOT NULL,
  PTTYPE      NUMBER(11) DEFAULT (100) NOT NULL,
  PTSTATUS    NUMBER(11) DEFAULT (0) NOT NULL,
  MONUSERID   VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  MONUSERPWD  VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  MONFREQ     NUMBER(11) DEFAULT (5) NOT NULL,
  MAXRPTDELAY NUMBER(11) DEFAULT (65) NOT NULL,
  WARNPHONE   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LINKMAN     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  ID          NUMBER(22) NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTNAME IS ''平台名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTIP IS ''平台IP地址''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTPORT IS ''平台监听端口''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTTYPE IS ''平台类型''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.PTSTATUS IS ''0：正常非0：各种各样的异常''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.MONUSERID IS ''监控帐号''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.MONUSERPWD IS ''监控帐号PWD''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.MONFREQ IS ''通道监测频率''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.MAXRPTDELAY IS ''通道状态报告返回最大延时时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.WARNPHONE IS ''报警手机''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PTINFO.LINKMAN IS ''平台联系人''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_PTINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_PTINFO
	  ADD CONSTRAINT PK_M_MON_PTINFO PRIMARY KEY (PTCODE)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_PT_HIS
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_PT_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_PT_HIS
(
  ID          NUMBER(22) NOT NULL,
  PTCODE      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  PTNAME      VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  PTIP        VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
  PTPORT      NUMBER(11) DEFAULT (9001) NOT NULL,
  PTTYPE      NUMBER(11) DEFAULT (100) NOT NULL,
  PTSTATUS    NUMBER(11) DEFAULT (0) NOT NULL,
  MONUSERID   VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  MONUSERPWD  VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  MONFREQ     NUMBER(11) DEFAULT (5) NOT NULL,
  MAXRPTDELAY NUMBER(11) DEFAULT (65) NOT NULL,
  WARNPHONE   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LINKMAN     VARCHAR2(256) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTNAME IS ''平台名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTIP IS ''平台IP地址''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTPORT IS ''平台监听端口''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTTYPE IS ''平台类型''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.PTSTATUS IS ''0：正常非0：各种各样的异常''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.MONUSERID IS ''监控帐号''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.MONUSERPWD IS ''监控帐号PWD''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.MONFREQ IS ''通道监测频率''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.MAXRPTDELAY IS ''通道状态报告返回最大延时时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.WARNPHONE IS ''报警手机''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_PT_HIS.LINKMAN IS ''平台联系人''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_SPGATEINFO
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_SPGATEINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_SPGATEINFO
(
  PTCODE       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID      NUMBER(11) DEFAULT (0) NOT NULL,
  USERNAME     VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  JTYPE        VARCHAR2(64) DEFAULT ''直连用户(CMPP)'' NOT NULL,
  LINKNUM      NUMBER(11) DEFAULT (1) NOT NULL,
  LOGINIP      VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ONLINESTATUS NUMBER(11) DEFAULT (0) NOT NULL,
  MTHAVESND    NUMBER(11) DEFAULT (0) NOT NULL,
  MTREMAINED   NUMBER(11) DEFAULT (0) NOT NULL,
  MTRECVSPD    NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MOHAVESND    NUMBER(11) DEFAULT (0) NOT NULL,
  MOREMAINED   NUMBER(11) DEFAULT (0) NOT NULL,
  MOSNDSPD     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTOTALRECV NUMBER(11) DEFAULT (0) NOT NULL,
  RPTHAVESND   NUMBER(11) DEFAULT (0) NOT NULL,
  RPTREMAINED  NUMBER(11) DEFAULT (0) NOT NULL,
  RPTSNDSPD    NUMBER(11) DEFAULT (0) NOT NULL,
  SNDERCNT     NUMBER(11) DEFAULT (0) NOT NULL,
  LASTSNDERTM  VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGININTM    VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGINOUTTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID           NUMBER(22) NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.USERID IS ''用户帐号，主键''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.USERUID IS ''用户帐号UID，与帐号一一对应''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.USERNAME IS ''帐号对应的客户名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.JTYPE IS ''用户使用的接入方式及接入协议''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.LINKNUM IS ''帐号连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.LOGINIP IS ''帐号登陆IP''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.ONLINESTATUS IS ''0：在线1：离线''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MTHAVESND IS ''已成功转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MTREMAINED IS ''当前滞留平台未转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MTRECVSPD IS ''该通道接收网关转发MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MOTOTALRECV IS ''客户当前收到的MO总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MOHAVESND IS ''已转发给用户的该通道的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MOREMAINED IS ''客户当前滞留在平台的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.MOSNDSPD IS ''客户提交MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.RPTTOTALRECV IS ''客户当前收到的RPT总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.RPTHAVESND IS ''已转发给用户的该通道的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.RPTREMAINED IS ''客户当前滞留在平台的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.RPTSNDSPD IS ''客户接收RPT时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.LOGININTM IS ''最后一次登陆的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.LOGINOUTTM IS ''最后一次离线的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATEINFO.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_SPGATEINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_SPGATEINFO
	  ADD CONSTRAINT PK_M_MON_SPGATEINFO PRIMARY KEY (PTCODE, USERID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_SPGATE_HIS
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_SPGATE_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_SPGATE_HIS
(
  ID           NUMBER(22) NOT NULL,
  PTCODE       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID      NUMBER(11) DEFAULT (0) NOT NULL,
  USERNAME     VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  JTYPE        VARCHAR2(64) DEFAULT ''直连用户(CMPP)'' NOT NULL,
  LINKNUM      NUMBER(11) DEFAULT (1) NOT NULL,
  LOGINIP      VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ONLINESTATUS NUMBER(11) DEFAULT (0) NOT NULL,
  MTHAVESND    NUMBER(11) DEFAULT (0) NOT NULL,
  MTREMAINED   NUMBER(11) DEFAULT (0) NOT NULL,
  MTRECVSPD    NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV  NUMBER(11) DEFAULT (0) NOT NULL,
  MOHAVESND    NUMBER(11) DEFAULT (0) NOT NULL,
  MOREMAINED   NUMBER(11) DEFAULT (0) NOT NULL,
  MOSNDSPD     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTOTALRECV NUMBER(11) DEFAULT (0) NOT NULL,
  RPTHAVESND   NUMBER(11) DEFAULT (0) NOT NULL,
  RPTREMAINED  NUMBER(11) DEFAULT (0) NOT NULL,
  RPTSNDSPD    NUMBER(11) DEFAULT (0) NOT NULL,
  SNDERCNT     NUMBER(11) DEFAULT (0) NOT NULL,
  LASTSNDERTM  VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGININTM    VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGINOUTTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.USERID IS ''用户帐号，主键''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.USERUID IS ''用户帐号UID，与帐号一一对应''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.USERNAME IS ''帐号对应的客户名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.JTYPE IS ''用户使用的接入方式及接入协议''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.LINKNUM IS ''帐号连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.LOGINIP IS ''帐号登陆IP''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.ONLINESTATUS IS ''0：在线1：离线''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MTHAVESND IS ''已成功转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MTREMAINED IS ''当前滞留平台未转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MTRECVSPD IS ''该通道接收网关转发MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MOTOTALRECV IS ''客户当前收到的MO总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MOHAVESND IS ''已转发给用户的该通道的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MOREMAINED IS ''客户当前滞留在平台的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.MOSNDSPD IS ''客户提交MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.RPTTOTALRECV IS ''客户当前收到的RPT总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.RPTHAVESND IS ''已转发给用户的该通道的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.RPTREMAINED IS ''客户当前滞留在平台的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.RPTSNDSPD IS ''客户接收RPT时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.LOGININTM IS ''最后一次登陆的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.LOGINOUTTM IS ''最后一次离线的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SPGATE_HIS.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_SYSINFO
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_SYSINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_SYSINFO
(
  PTCODE        VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  CPUUSAGE      NUMBER(11) DEFAULT (0) NOT NULL,
  MEMUSAGE      NUMBER(11) DEFAULT (0) NOT NULL,
  VMEMUSAGE     NUMBER(11) DEFAULT (0) NOT NULL,
  DISKFREESPACE NUMBER(11) DEFAULT (0) NOT NULL,
  UPDATETIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID            NUMBER(22) NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYSINFO.CPUUSAGE IS ''CPU使用量，有必要是格式成XX%的字符串后显示''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYSINFO.MEMUSAGE IS ''物理内存使用量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYSINFO.VMEMUSAGE IS ''虚拟内存使用量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYSINFO.DISKFREESPACE IS ''磁盘剩余量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYSINFO.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_SYS_HIS
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_SYS_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_SYS_HIS
(
  ID            NUMBER(22) NOT NULL,
  PTCODE        VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  CPUUSAGE      NUMBER(11) DEFAULT (0) NOT NULL,
  MEMUSAGE      NUMBER(11) DEFAULT (0) NOT NULL,
  VMEMUSAGE     NUMBER(11) DEFAULT (0) NOT NULL,
  DISKFREESPACE NUMBER(11) DEFAULT (0) NOT NULL,
  UPDATETIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.CPUUSAGE IS ''CPU使用量，有必要是格式成XX%的字符串后显示''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.MEMUSAGE IS ''物理内存使用量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.VMEMUSAGE IS ''虚拟内存使用量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.DISKFREESPACE IS ''磁盘剩余量，以M为单位''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_SYS_HIS.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_THREADINFO
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_THREADINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_THREADINFO
(
  ID          NUMBER(22) NOT NULL,
  PTCODE      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  THRID       NUMBER(11) DEFAULT (0) NOT NULL,
  THRNAME     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  THRSTATUS   NUMBER(11) DEFAULT (0) NOT NULL,
  ERRORCNT    NUMBER(11) DEFAULT (0) NOT NULL,
  LASTERRORTM VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  THRLOGS     VARCHAR2(2048) DEFAULT ('' '') NOT NULL,
  LASTRUNTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  THISRUNTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.THRID IS ''主键，对网关来说，启动后进程 内的线程它的ID是唯一的''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.THRNAME IS ''线程名称描述''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.THRSTATUS IS ''00：线程正在启动中(初始状态)''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.ERRORCNT IS ''线程异常次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.LASTERRORTM IS ''最后一次出现异常的时间，仅当异常次数大于0时该值才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.THRLOGS IS ''线程输出日志''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.LASTRUNTM IS ''上一次线程执行时网关记下的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.THISRUNTM IS ''本次执行时网关记下的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREADINFO.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_THREADINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_THREADINFO
	  ADD CONSTRAINT PK_M_MON_THREADINFO PRIMARY KEY (THRID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_THREAD_HIS
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_THREAD_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_THREAD_HIS
(
  ID          NUMBER(22) NOT NULL,
  PTCODE      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  THRID       NUMBER(11) DEFAULT (0) NOT NULL,
  THRNAME     VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  THRSTATUS   NUMBER(11) DEFAULT (0) NOT NULL,
  ERRORCNT    NUMBER(11) DEFAULT (0) NOT NULL,
  LASTERRORTM VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  THRLOGS     VARCHAR2(2048) DEFAULT ('' '') NOT NULL,
  LASTRUNTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  THISRUNTM   VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.THRID IS ''主键，对网关来说，启动后进程 内的线程它的ID是唯一的''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.THRNAME IS ''线程名称描述''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.THRSTATUS IS ''00：线程正在启动中(初始状态)''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.ERRORCNT IS ''线程异常次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.LASTERRORTM IS ''最后一次出现异常的时间，仅当异常次数大于0时该值才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.THRLOGS IS ''线程输出日志''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.LASTRUNTM IS ''上一次线程执行时网关记下的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.THISRUNTM IS ''本次执行时网关记下的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_THREAD_HIS.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_USERINFO
--PROMPT =============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_USERINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_USERINFO
(
  PTCODE         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  USERID         VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID        NUMBER(11) DEFAULT (0) NOT NULL,
  USERNAME       VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  USERPRIVILEGE  NUMBER(11) DEFAULT (0) NOT NULL,
  JTYPE          VARCHAR2(64) DEFAULT ''直连用户(CMPP)'' NOT NULL,
  LINKNUM        NUMBER(11) DEFAULT (1) NOT NULL,
  LOGINIP        VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ONLINESTATUS   NUMBER(11) DEFAULT (0) NOT NULL,
  USERFEE        NUMBER(11) DEFAULT (0) NOT NULL,
  FIXFAILURERATE NUMBER(11) DEFAULT (0) NOT NULL,
  FAILURENUM     NUMBER(11) DEFAULT (0) NOT NULL,
  FAILURERATE    NUMBER(11) DEFAULT (0) NOT NULL,
  BINDINFO       VARCHAR2(2000) DEFAULT ('' '') NOT NULL,
  MTTOTALSND     NUMBER(11) DEFAULT (0) NOT NULL,
  MTHAVESND      NUMBER(11) DEFAULT (0) NOT NULL,
  MTREMAINED     NUMBER(11) DEFAULT (0) NOT NULL,
  MTSNDINFO      VARCHAR2(2000) DEFAULT ('' '') NOT NULL,
  MTSNDSPD       NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV    NUMBER(11) DEFAULT (0) NOT NULL,
  MOREMAINED     NUMBER(11) DEFAULT (0) NOT NULL,
  MORPTRECVSPD   NUMBER(11) DEFAULT (0) NOT NULL,
  MOTMOUTCNT     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTOTALRECV   NUMBER(11) DEFAULT (0) NOT NULL,
  RPTREMAINED    NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTMOUTCNT    NUMBER(11) DEFAULT (0) NOT NULL,
  LOGININTM      VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGINOUTTM     VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID             NUMBER(22) NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.USERID IS ''用户帐号，主键''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.USERUID IS ''用户帐号UID，与帐号一一对应''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.USERNAME IS ''帐号对应的客户名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.USERPRIVILEGE IS ''与USERDATA表中字段意义和取值均相同。需解析出来后在界面展现出具体的权限''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.JTYPE IS ''用户使用的接入方式及接入协议''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.LINKNUM IS ''帐号连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.LOGINIP IS ''帐号登陆IP''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.ONLINESTATUS IS ''0：在线1：离线''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.USERFEE IS ''帐号费用''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.FIXFAILURERATE IS ''0：表示没有失败率真控制,大于0表示有失几率控制。失败率FIXFAILURERATE /10000来代表失败率的值''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.FAILURENUM IS ''当FIXFAILURERATE>0时才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.FAILURERATE IS ''当FIXFAILURERATE>0时才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.BINDINFO IS ''以字符串的形式体现该帐号的绑定信息''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MTTOTALSND IS ''客户接交MT的总数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MTHAVESND IS ''已成功转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MTREMAINED IS ''当前滞留平台未转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MTSNDINFO IS ''以字符串的形式描述用户每个通道的发送量/滞留量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MTSNDSPD IS ''客户提交MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MOTOTALRECV IS ''客户当前收到的MO总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MOREMAINED IS ''客户当前滞留在平台的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MORPTRECVSPD IS ''客户接收MO/RPT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.MOTMOUTCNT IS ''客户接收MO时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.RPTTOTALRECV IS ''客户当前收到的RPT总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.RPTREMAINED IS ''客户当前滞留在平台的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.RPTTMOUTCNT IS ''客户接收RPT时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.LOGININTM IS ''最后一次登陆的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.LOGINOUTTM IS ''最后一次离线的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USERINFO.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('M_MON_USERINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE M_MON_USERINFO
	  ADD CONSTRAINT PK_M_MON_USERINFO PRIMARY KEY (PTCODE, USERID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE M_MON_USER_HIS
--PROMPT =============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='M_MON_USER_HIS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE M_MON_USER_HIS
(
  ID             NUMBER(22) NOT NULL,
  PTCODE         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  USERID         VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  USERUID        NUMBER(11) DEFAULT (0) NOT NULL,
  USERNAME       VARCHAR2(128) DEFAULT ('' '') NOT NULL,
  USERPRIVILEGE  NUMBER(11) DEFAULT (0) NOT NULL,
  JTYPE          VARCHAR2(64) DEFAULT ''直连用户(CMPP)'' NOT NULL,
  LINKNUM        NUMBER(11) DEFAULT (1) NOT NULL,
  LOGINIP        VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  ONLINESTATUS   NUMBER(11) DEFAULT (0) NOT NULL,
  USERFEE        NUMBER(11) DEFAULT (0) NOT NULL,
  FIXFAILURERATE NUMBER(11) DEFAULT (0) NOT NULL,
  FAILURENUM     NUMBER(11) DEFAULT (0) NOT NULL,
  FAILURERATE    NUMBER(11) DEFAULT (0) NOT NULL,
  BINDINFO       VARCHAR2(2000) DEFAULT ('' '') NOT NULL,
  MTTOTALSND     NUMBER(11) DEFAULT (0) NOT NULL,
  MTHAVESND      NUMBER(11) DEFAULT (0) NOT NULL,
  MTREMAINED     NUMBER(11) DEFAULT (0) NOT NULL,
  MTSNDINFO      VARCHAR2(2000) DEFAULT ('' '') NOT NULL,
  MTSNDSPD       NUMBER(11) DEFAULT (0) NOT NULL,
  MOTOTALRECV    NUMBER(11) DEFAULT (0) NOT NULL,
  MOREMAINED     NUMBER(11) DEFAULT (0) NOT NULL,
  MORPTRECVSPD   NUMBER(11) DEFAULT (0) NOT NULL,
  MOTMOUTCNT     NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTOTALRECV   NUMBER(11) DEFAULT (0) NOT NULL,
  RPTREMAINED    NUMBER(11) DEFAULT (0) NOT NULL,
  RPTTMOUTCNT    NUMBER(11) DEFAULT (0) NOT NULL,
  LOGININTM      VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  LOGINOUTTM     VARCHAR2(35) DEFAULT ('' '') NOT NULL,
  UPDATETIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.ID IS ''自增ID''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.PTCODE IS ''平台编号，用来唯一标识当前监控信息属于哪个子平台''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.USERID IS ''用户帐号，主键''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.USERUID IS ''用户帐号UID，与帐号一一对应''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.USERNAME IS ''帐号对应的客户名称''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.USERPRIVILEGE IS ''与USERDATA表中字段意义和取值均相同。需解析出来后在界面展现出具体的权限''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.JTYPE IS ''用户使用的接入方式及接入协议''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.LINKNUM IS ''帐号连接数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.LOGINIP IS ''帐号登陆IP''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.ONLINESTATUS IS ''0：在线1：离线''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.USERFEE IS ''帐号费用''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.FIXFAILURERATE IS ''0：表示没有失败率真控制,大于0表示有失几率控制。失败率FIXFAILURERATE /10000来代表失败率的值''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.FAILURENUM IS ''当FIXFAILURERATE>0时才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.FAILURERATE IS ''当FIXFAILURERATE>0时才有意义''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.BINDINFO IS ''以字符串的形式体现该帐号的绑定信息''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MTTOTALSND IS ''客户接交MT的总数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MTHAVESND IS ''已成功转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MTREMAINED IS ''当前滞留平台未转发的MT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MTSNDINFO IS ''以字符串的形式描述用户每个通道的发送量/滞留量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MTSNDSPD IS ''客户提交MT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MOTOTALRECV IS ''客户当前收到的MO总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MOREMAINED IS ''客户当前滞留在平台的MO数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MORPTRECVSPD IS ''客户接收MO/RPT的速度''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.MOTMOUTCNT IS ''客户接收MO时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.RPTTOTALRECV IS ''客户当前收到的RPT总量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.RPTREMAINED IS ''客户当前滞留在平台的RPT数量''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.RPTTMOUTCNT IS ''客户接收RPT时超过时的次数''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.LOGININTM IS ''最后一次登陆的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.LOGINOUTTM IS ''最后一次离线的时间''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN M_MON_USER_HIS.UPDATETIME IS ''该条记录最后一次被更新的时间''';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE PB_LIST_BLACK
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='PB_LIST_BLACK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE PB_LIST_BLACK
(
  ID       NUMBER(11) NOT NULL,
  USERID   VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPGATE   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPNUMBER VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE    NUMBER(21) DEFAULT 0 NOT NULL,
  OPTYPE   NUMBER(11) DEFAULT 0 NOT NULL,
  OPTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MSG      VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  SVRTYPE  VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  SPISUNCM NUMBER(11) DEFAULT 0 NOT NULL,
  CORPCODE VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  BLTYPE   NUMBER(4) DEFAULT 1 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE PB_LIST_BLACK
	  ADD CONSTRAINT PK_PBLISTBLACK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_CORPCODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_CORPCODE ON PB_LIST_BLACK (CORPCODE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_PHONE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_PHONE ON PB_LIST_BLACK (PHONE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_SPGATE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_SPGATE ON PB_LIST_BLACK (SPGATE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_SPNUMBER');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_SPNUMBER ON PB_LIST_BLACK (SPNUMBER)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_SVRTYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_SVRTYPE ON PB_LIST_BLACK (SVRTYPE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('PB_LIST_BLACK') AND T.INDEX_NAME = UPPER('IX_PB_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PB_USERID ON PB_LIST_BLACK (USERID)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE PB_SERVICETYPE
--PROMPT =============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='PB_SERVICETYPE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE PB_SERVICETYPE
(
  SPISUNCM    NUMBER(11) DEFAULT 0 NOT NULL,
  SERVICENO   VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SERVICEINFO VARCHAR2(100) DEFAULT ('' '') NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('PB_SERVICETYPE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE PB_SERVICETYPE
	  ADD CONSTRAINT PK_PBSVRTYPE PRIMARY KEY (SPISUNCM)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE PB_WEBZZCMD_LOG
--PROMPT ==============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='PB_WEBZZCMD_LOG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE PB_WEBZZCMD_LOG
(
  STIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ID       NUMBER(11) NOT NULL,
  SID      VARCHAR2(21) NOT NULL,
  CMDTYPE  NUMBER(11) NOT NULL,
  USERID   VARCHAR2(11),
  CMDPARAM VARCHAR2(21) DEFAULT ''0'',
  EXECTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
  USEIP    VARCHAR2(50) NOT NULL,
  EXECFLAG NUMBER(11) DEFAULT -1,
  MEMO     VARCHAR2(100) DEFAULT ('' ''),
  PRODID   NUMBER(11) DEFAULT 0,
  OPID     VARCHAR2(21) DEFAULT ('' ''),
  FEETYPE  NUMBER(11) DEFAULT 0,
  FEE      NUMBER(6,3) NOT NULL,
  SENDNUM  NUMBER(19) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE PB_WEBZZCMD_QUEUE
--PROMPT ================================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='PB_WEBZZCMD_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE PB_WEBZZCMD_QUEUE
(
  ID       NUMBER(11) NOT NULL,
  STIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SID      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CMDTYPE  NUMBER(11) NOT NULL,
  USERID   VARCHAR2(11) NOT NULL,
  CMDPARAM VARCHAR2(21) DEFAULT ''0'',
  EXECTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP,
  USEIP    VARCHAR2(50) DEFAULT ('' ''),
  EXECFLAG NUMBER(11) DEFAULT 1,
  MEMO     VARCHAR2(100) DEFAULT ('' ''),
  PRODID   NUMBER(11) DEFAULT 0,
  OPID     VARCHAR2(21) DEFAULT ('' ''),
  FEETYPE  NUMBER(11) DEFAULT 0,
  FEE      NUMBER(6,3) DEFAULT 0
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('PB_WEBZZCMD_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE PB_WEBZZCMD_QUEUE
	  ADD PRIMARY KEY (STIME, SID, CMDTYPE, USERID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE PROCESSINGSTATUS
--PROMPT ===============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='PROCESSINGSTATUS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE PROCESSINGSTATUS
(
  USEID          NUMBER NOT NULL,
  CURRINDEX      NUMBER(19) DEFAULT 0 NOT NULL,
  MAXINDEX       NUMBER(19) DEFAULT 0 NOT NULL,
  COUNTSTATUS    NUMBER DEFAULT 0 NOT NULL,
  DISTRACTSTATUS NUMBER DEFAULT 0 NOT NULL,
  DELETESTATUS   NUMBER DEFAULT 0 NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('PROCESSINGSTATUS') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE PROCESSINGSTATUS
	  ADD CONSTRAINT PK_KEY PRIMARY KEY (USEID)
	  USING INDEX
	  TABLESPACE TBSHISINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE RPT_WAIT_A
--PROMPT =========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='RPT_WAIT_A';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE RPT_WAIT_A
(
  ID         NUMBER(22) NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERUID    NUMBER(11) DEFAULT 0 NOT NULL,
  LOGINUID   NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SPNUMBER   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SUBMITTIME CHAR(10) DEFAULT ('' '') NOT NULL,
  DONETIME   CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT ('' '') NOT NULL,
  RECVTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_A') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE RPT_WAIT_A
	  ADD CONSTRAINT PK_RPTWAITA PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_A') AND T.INDEX_NAME = UPPER('IX_RPTWAITA_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITA_PTID ON RPT_WAIT_A (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_A') AND T.INDEX_NAME = UPPER('IX_RPTWAITA_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITA_UID ON RPT_WAIT_A (USERUID, LOGINUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE RPT_WAIT_B
--PROMPT =========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='RPT_WAIT_B';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE RPT_WAIT_B
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  ORGUID     NUMBER(11) DEFAULT 0 NOT NULL,
  ECID       NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  USERID     VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPNUMBER   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SUBMITTIME CHAR(10) DEFAULT ('' '') NOT NULL,
  DONETIME   CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT ('' '') NOT NULL,
  RECVTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SPMSGID	   NUMBER(22) DEFAULT 0 NOT NULL,
  PKTOTAL    NUMBER(22) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  RESENDCNT   NUMBER(11) DEFAULT 0 NOT NULL,
  RPTTYPE	NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_B') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE RPT_WAIT_B
	  ADD CONSTRAINT PK_RPTWAITB PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_B') AND T.INDEX_NAME = UPPER('IX_RPTWAITB_ORGUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITB_ORGUID ON RPT_WAIT_B (ORGUID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_B') AND T.INDEX_NAME = UPPER('IX_RPTWAITB_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITB_PTID ON RPT_WAIT_B (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_B') AND T.INDEX_NAME = UPPER('IX_RPTWAITB_UID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITB_UID ON RPT_WAIT_B ("UID")
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE RPT_WAIT_C
--PROMPT =========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='RPT_WAIT_C';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE RPT_WAIT_C
(
  ID         NUMBER(22) NOT NULL,
  PTMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"        NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
  SPGATE     VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPNUMBER   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SUBMITTIME CHAR(10) DEFAULT ('' '') NOT NULL,
  DONETIME   CHAR(10) DEFAULT ('' '') NOT NULL,
  RECVFLAG   NUMBER(11) DEFAULT 1 NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT ('' '') NOT NULL,
  LOGINID    VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  RECVTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RETFLAG    NUMBER(11)  DEFAULT 1 NOT NULL,
  SENDTIME   NUMBER(22)  DEFAULT 0 NOT NULL,
  SPMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  WTRPTFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
  PKTOTAL    NUMBER(22) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_C') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE RPT_WAIT_C
	  ADD CONSTRAINT PK_RPTWAITC PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_C') AND T.INDEX_NAME = UPPER('IX_RPTWAITC_LGNID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITC_LGNID ON RPT_WAIT_C (LOGINID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('RPT_WAIT_C') AND T.INDEX_NAME = UPPER('IX_RPTWAITC_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTWAITC_PTID ON RPT_WAIT_C (PTMSGID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE TMP_MTTASK
--PROMPT =========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TMP_MTTASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE GLOBAL TEMPORARY TABLE TMP_MTTASK
(
  "UID"         NUMBER(11),
  USERID      VARCHAR2(11),
  SPGATE      VARCHAR2(21),
  CPNO        VARCHAR2(21),
  PHONE       VARCHAR2(21),
  PTMSGID     NUMBER(22),
  MESSAGE     VARCHAR2(3000),
  SENDSTATUS  NUMBER(11),
  RETFLAG     NUMBER(11),
  PKNUMBER    NUMBER(11),
  PKTOTAL     NUMBER(11),
  ECID        NUMBER(11),
  FEEFLAG     NUMBER(11),
  SENDLEVEL   NUMBER(11),
  TASKID      NUMBER(11),
  ERRORCODE   CHAR(7),
  TPUDHI      NUMBER(11),
  LONGMSGSEQ  NUMBER(11),
  MSGFMT      NUMBER(11),
  UNICOM      NUMBER(11),
  MOBILEAREA  NUMBER(11),
  TPPID       NUMBER(11),
  USERMSGID   NUMBER(22),
  MODULEID    NUMBER(11),
  SVRTYPE     VARCHAR2(64),
  P1          VARCHAR2(64),
  P2          VARCHAR2(64),
  P3          VARCHAR2(64),
  P4          VARCHAR2(64),
  SENDRPTTIME TIMESTAMP(6),
  RECVMTTIME  TIMESTAMP(6),
  ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL
)
ON COMMIT DELETE ROWS';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE TMP_MTTASKSR
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TMP_MTTASKSR';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE GLOBAL TEMPORARY TABLE TMP_MTTASKSR
(
  "UID"         NUMBER(11),
  USERID      VARCHAR2(11),
  SPGATE      VARCHAR2(21),
  CPNO        VARCHAR2(21),
  PHONE       VARCHAR2(21),
  PTMSGID     NUMBER(22),
  MESSAGE     VARCHAR2(3000),
  SENDSTATUS  NUMBER(11),
  RETFLAG     NUMBER(11),
  PKNUMBER    NUMBER(11),
  PKTOTAL     NUMBER(11),
  ECID        NUMBER(11),
  FEEFLAG     NUMBER(11),
  SENDLEVEL   NUMBER(11),
  TASKID      NUMBER(11),
  ERRORCODE   CHAR(7),
  TPUDHI      NUMBER(11),
  LONGMSGSEQ  NUMBER(11),
  MSGFMT      NUMBER(11),
  UNICOM      NUMBER(11),
  MOBILEAREA  NUMBER(11),
  TPPID       NUMBER(11),
  USERMSGID   NUMBER(22),
  MODULEID    NUMBER(11),
  SVRTYPE     VARCHAR2(64),
  P1          VARCHAR2(64),
  P2          VARCHAR2(64),
  P3          VARCHAR2(64),
  P4          VARCHAR2(64),
  SENDRPTTIME TIMESTAMP(6),
  RECVMTTIME  TIMESTAMP(6),
  ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL,
  SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL
)
ON COMMIT DELETE ROWS';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE TMP_RDMTTASK
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TMP_RDMTTASK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE GLOBAL TEMPORARY TABLE TMP_RDMTTASK
(
  "UID"       NUMBER(11),
  PTMSGID     NUMBER(22),
  PTNEWMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
  ECID        NUMBER(11),
  TASKID      NUMBER(11),
  USERID      VARCHAR2(11),
  SPGATE      VARCHAR2(21),
  CPNO        VARCHAR2(21),
  PHONE       VARCHAR2(21),
  SPMSGID     NUMBER(22),
  RETFLAG     NUMBER(11),
  FEEFLAG     NUMBER(11),
  PKNUMBER    NUMBER(11),
  PKTOTAL     NUMBER(11),
  SENDSTATUS  NUMBER(11),
  SENDFLAG    NUMBER(11),
  RECVFLAG    NUMBER(11),
  DONEDATE    CHAR(10),
  ERRORCODE   CHAR(7),
  SENDLEVEL   NUMBER(11),
  SENDTYPE    NUMBER(11),
  UNICOM      NUMBER(11),
  MOBILEAREA  NUMBER(11),
  RESENDCNT   NUMBER(11),
  RECVTIME    TIMESTAMP(6),
  MESSAGE     VARCHAR2(3000),
  LONGMSGSEQ  NUMBER(11),
  MSGFMT      NUMBER(11),
  TPUDHI      NUMBER(11),
  TPPID       NUMBER(11),
  USERMSGID   NUMBER(22),
  MODULEID    NUMBER(11),
  SVRTYPE     VARCHAR2(64),
  P1          VARCHAR2(64),
  P2          VARCHAR2(64),
  P3          VARCHAR2(64),
  P4          VARCHAR2(64),
  SENDRPTTIME TIMESTAMP(6),
  RECVMTTIME  TIMESTAMP(6),
  ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL,
  BATCHID     NUMBER(22) DEFAULT 0,
  AREACODE     NUMBER(11) DEFAULT 0 NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL
)
ON COMMIT PRESERVE ROWS';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE TRANSFLAG
--PROMPT ========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TRANSFLAG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE TRANSFLAG
(
  ITYPE    NUMBER(11) DEFAULT 0 NOT NULL,
  IYMD     NUMBER(11) DEFAULT 0 NOT NULL,
  DONEFLAG NUMBER(11) DEFAULT 1 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('TRANSFLAG') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE TRANSFLAG
	  ADD CONSTRAINT TRAN_PRI PRIMARY KEY (ITYPE, IYMD)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE TRANSTATUS
--PROMPT =========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TRANSTATUS';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE TRANSTATUS
(
  HZINDEX   NUMBER DEFAULT 0 NOT NULL,
  MOVEINDEX NUMBER DEFAULT 0 NOT NULL,
  DELINDEX  NUMBER DEFAULT 0 NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE USERDATA
--PROMPT =======================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='USERDATA';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE USERDATA
(
  "UID"           NUMBER(11) NOT NULL,
  USERID        VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  LOGINID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  STAFFNAME     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  CORPACCOUNT   VARCHAR2(32) DEFAULT (''200001'') NOT NULL,
  USERACCOUNT   VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  MOBILE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  ORDERTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  CANCELTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MODITIME      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  USERTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  STATUS        NUMBER(11) DEFAULT 0 NOT NULL,
  USERPASSWORD  VARCHAR2(32) DEFAULT ''147258'' NOT NULL,
  SMSTYPE       NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG       NUMBER(11) DEFAULT 0 NOT NULL,
  RETFLAG       NUMBER(11) DEFAULT 0 NOT NULL,
  USERPRIVILEGE NUMBER(11) DEFAULT 0 NOT NULL,
  SUBMITCNT     NUMBER(11) DEFAULT 0 NOT NULL,
  COMPANY       VARCHAR2(100) DEFAULT ('' '') NOT NULL,
  SALEMAN       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  MEMO          VARCHAR2(200) DEFAULT ('' '') NOT NULL,
  SPEEDLIMIT    NUMBER(11) DEFAULT 0 NOT NULL,
  RISELEVEL     NUMBER(11) DEFAULT 0 NOT NULL,
  MTURL         VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  MOURL         VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  RPTURL        VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  LOGINIP       VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  MAXDAYNUM     NUMBER(11) DEFAULT 100000 NOT NULL,
  SENDTMSPAN    VARCHAR2(512) DEFAULT ''00:00:00-23:59:59'' NOT NULL,
  FORBIDTMSPAN  VARCHAR2(512) DEFAULT ''00:00:00-00:00:00'' NOT NULL,
  ACCOUNTTYPE   NUMBER(11) DEFAULT 1 NOT NULL,
  SPBINDURL     VARCHAR2(256) DEFAULT ('' '')  NOT NULL,
  SRCNODE       NUMBER(11) DEFAULT 0 NOT NULL,
  SPTYPE        NUMBER(4) DEFAULT 1 NOT NULL,
  TRANSMOTYPE   NUMBER(11) DEFAULT 0 NOT NULL,
  TRANSRPTYPE   NUMBER(11) DEFAULT 0 NOT NULL,
 PUSHVERSION  NUMBER(11) DEFAULT 16 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('USERDATA') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE USERDATA
	  ADD CONSTRAINT PK_USERDATA PRIMARY KEY (ACCOUNTTYPE, USERID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('USERDATA') AND INDEX_NAME =UPPER('IX_USEDT_USERID');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_USEDT_USERID ON USERDATA(USERID)
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE USERFEE
--PROMPT ======================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='USERFEE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE USERFEE
(
  "UID"         NUMBER(11) NOT NULL,
  ECID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SENDNUM     NUMBER(11) DEFAULT 0 NOT NULL,
  SENDEDNUM   NUMBER(22) DEFAULT 0 NOT NULL,
  POSTPAYUSED NUMBER(22) DEFAULT 0 NOT NULL,
  THRESHOLD   NUMBER(11) DEFAULT 10000 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('USERFEE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE USERFEE
	  ADD CONSTRAINT PK_USERFEE PRIMARY KEY ("UID")
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('USERFEE') AND INDEX_NAME =UPPER('IX_USERF_USERID');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_USERF_USERID ON USERFEE(USERID)
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE VERSION_CMPP
--PROMPT ===========================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='VERSION_CMPP';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE VERSION_CMPP
(
  VERSION     CHAR(32) NOT NULL,
  VERSIONDATE CHAR(10) NOT NULL,
  UPGRADETIME CHAR(19) DEFAULT SYSDATE NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN VERSION_CMPP.VERSION IS ''数据库版本号(高位1个字符表示主版本号,低位2个字符表示次版本号)如：1.01''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN VERSION_CMPP.VERSIONDATE IS ''数据库脚本发布日期，如：2011-08-08''';
  EXECUTE IMMEDIATE 'COMMENT ON COLUMN VERSION_CMPP.UPGRADETIME IS ''数据库版本升级时间，如：2011-01-01 08:08:08''';
  END IF;
END;
/


DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('VERSION_CMPP') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE VERSION_CMPP
	  ADD CONSTRAINT VERSION_CMPP_PRIMARY PRIMARY KEY (VERSION)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

--PROMPT
--PROMPT CREATING TABLE XT_GATE_QUEUE
--PROMPT ============================
--PROMPT
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='XT_GATE_QUEUE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE XT_GATE_QUEUE
(
  ID            NUMBER(11) NOT NULL,
  SPGATE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  STATUS        NUMBER(11) DEFAULT 0 NOT NULL,
  SPISUNCM      NUMBER(11) DEFAULT 0 NOT NULL,
  GATETYPE      NUMBER(11) DEFAULT 1 NOT NULL,
  GATENAME      VARCHAR2(56) DEFAULT ('' '') NOT NULL,
  PORTTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  SINGLELEN     NUMBER(11) DEFAULT 70 NOT NULL,
  SIGNSTR       VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  RISELEVEL     NUMBER(11) DEFAULT 0 NOT NULL,
  SPEED         NUMBER(11) DEFAULT 100 NOT NULL,
  LONGSMS       NUMBER(11) DEFAULT 1 NOT NULL,
  MAXWORDS      NUMBER(11) DEFAULT 0 NOT NULL,
  SUBLEN        NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG       NUMBER(11) DEFAULT 2 NOT NULL,
  SIGNLEN       NUMBER(11) DEFAULT 8 NOT NULL,
  FEE           NUMBER(4,2) DEFAULT 0.00 NOT NULL,
  GATEINFO      VARCHAR2(50) DEFAULT ('' '') NOT NULL,
  SPLITRULE     NUMBER(11) DEFAULT 1 NOT NULL,
  WORDLEN       NUMBER(11) DEFAULT 70 NOT NULL,
  SHOWFLAG      NUMBER(11) DEFAULT 1 NOT NULL,
  SORTID        NUMBER(11) DEFAULT 1 NOT NULL,
  MULTILEN1     NUMBER(11) DEFAULT 67 NOT NULL,
  MULTILEN2     NUMBER(11) DEFAULT 67 NOT NULL,
  GATENO        NUMBER(11) DEFAULT 0 NOT NULL,
  SIGNTYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  SIGNFIXLEN    NUMBER(11) DEFAULT 10 NOT NULL,
  PREFIXLEN     NUMBER(11) DEFAULT 3 NOT NULL,
  MAXLONGMSGSEQ NUMBER(11) DEFAULT 255 NOT NULL,
  ENDSPLIT      NUMBER(11) DEFAULT 0 NOT NULL,
  GATESEQ       NUMBER(11) DEFAULT 0 NOT NULL,
  SIGNDROPTYPE  NUMBER(11) DEFAULT 1 NOT NULL,
  GATEAREA      VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  AREATYPE      NUMBER(11) DEFAULT 0 NOT NULL,
  EACHSIGN      NUMBER(11) DEFAULT 0 NOT NULL,
  GATEPRIVILEGE NUMBER(11) DEFAULT 0 NOT NULL,
  ENSIGNSTR   VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  ENSIGNLEN   NUMBER(11)   DEFAULT 20    NOT NULL,
  ENPREFIXLEN NUMBER(11)   DEFAULT 6     NOT NULL,
  ENMAXWORDS  NUMBER(11)   DEFAULT 720   NOT NULL,
  ENSINGLELEN NUMBER(11)   DEFAULT 160   NOT NULL,
  ENMULTILEN1 NUMBER(11)   DEFAULT 153   NOT NULL,
  ENMULTILEN2 NUMBER(11)   DEFAULT 133   NOT NULL,
  ESPLITMAXWD NUMBER(11)   DEFAULT 360   NOT NULL,
  ESPLITENMAXWD NUMBER(11)   DEFAULT 720   NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('XT_GATE_QUEUE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE XT_GATE_QUEUE
	  ADD CONSTRAINT PK_XTGATEQUE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_CMD_ROUTE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_CMD_ROUTE(
  ID NUMBER(22),
  NAME VARCHAR2(50) DEFAULT ('' '') NOT NULL,
  STRUCTCODE VARCHAR2(20) DEFAULT ('' '') NOT NULL,
  TRUCTTYPE  CHAR(2) DEFAULT (''01'') NOT NULL,
  BUSSYSNAME VARCHAR2(256) DEFAULT ('' '') NOT NULL,
  SP_ID  NUMBER(11) DEFAULT ((0)) NOT NULL,
  STATUS CHAR(2) DEFAULT (''01'') NOT NULL,
  MATCHMODE  NUMBER(11) DEFAULT ((0)) NOT NULL,
  CMDTYPE	NUMBER(11) DEFAULT ((0)) NOT NULL,
  CMDPARAM 	NUMBER(11) DEFAULT ((0)) NOT NULL,
  CMDATTRI VARCHAR2(64) DEFAULT ('' ''),
  PUSHURL	VARCHAR2(256) DEFAULT ('' ''),
  PUSHPROTOCOL VARCHAR2(256) DEFAULT ('' ''),
  CREATER  VARCHAR2(20)  DEFAULT ('' '') NOT NULL,
  CREATTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RESERVE1 VARCHAR2(64) DEFAULT ('' ''),
  RESERVE2 VARCHAR2(64) DEFAULT ('' '')
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_CMD_ROUTE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_CMD_ROUTE ADD CONSTRAINT PK_A_CMD_ROUTE PRIMARY KEY (ID)
		USING INDEX
		  TABLESPACE TBSSMSACC
		  PCTFREE 10
		  INITRANS 2
		  MAXTRANS 255
		  STORAGE
		  (
			INITIAL 64K
			MINEXTENTS 1
			MAXEXTENTS UNLIMITED
		  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_CMD_ROUTE') AND T.INDEX_NAME = UPPER('IX_STRUCTCODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_STRUCTCODE ON A_CMD_ROUTE (STRUCTCODE)';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_CMD_ROUTE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_CMD_ROUTE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_CMD_ROUTE" BEFORE
INSERT ON  "A_CMD_ROUTE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_CMD_ROUTE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_CMD_PORT';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_CMD_PORT(
ID NUMBER(22),
GATEID  NUMBER(22) DEFAULT ((0))   NOT NULL,
CMDID  NUMBER(22) DEFAULT ((0))  NOT NULL,
STATUS  NUMBER(11) DEFAULT ((0))   NOT NULL,
CPNO  VARCHAR2(21)  DEFAULT ('' ''),
FAILOPT  NUMBER(11) DEFAULT ((0))  NOT NULL,
DEFCMDID  NUMBER(22) DEFAULT ((0)),
RESERVE1  VARCHAR2(64) DEFAULT ('' ''),
RESERVE2  VARCHAR2(64) DEFAULT ('' '')
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_CMD_PORT') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_CMD_PORT ADD CONSTRAINT PK_A_CMD_PORT PRIMARY KEY (ID)
	USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_CMD_PORT') AND T.INDEX_NAME = UPPER('UNIQUE_ACMDPORT');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE 'ALTER TABLE A_CMD_PORT ADD CONSTRAINT UNIQUE_ACMDPORT UNIQUE (GATEID,CMDID,CPNO)';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_CMD_PORT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_CMD_PORT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_CMD_PORT" BEFORE
INSERT ON  "A_CMD_PORT"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_CMD_PORT.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_ATTIME_TASK
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_ATTIME_TASK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_ATTIME_TASK
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_CHANNELMAP
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_CHANNELMAP';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_CHANNELMAP
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_CMDQUE
--PROMPT ==============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_CMDQUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_CMDQUE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_GWACC
--PROMPT =============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_GWACC';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_GWACC
	MINVALUE 1
	MAXVALUE 9999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_GWLOGS
--PROMPT ==============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_GWLOGS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_GWLOGS
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_SMSMSGIDMAP
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_SMSMSGIDMAP';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_SMSMSGIDMAP
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_A_SMSPUSHCONF
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_SMSPUSHCONF';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_SMSPUSHCONF
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_BAT_MT_REQ
--PROMPT ================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_BAT_MT_REQ';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_BAT_MT_REQ
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_BAT_MT_REQ_HIS
--PROMPT ====================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_BAT_MT_REQ_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_BAT_MT_REQ_HIS
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_GT_PORT_USED
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GT_PORT_USED';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GT_PORT_USED
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_HTTPERRCODE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_HTTPERRCODE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_HTTPERRCODE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_KEYWORD_BLACK
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_KEYWORD_BLACK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_KEYWORD_BLACK
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_BMTREQ
--PROMPT ================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_BMTREQ';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_BMTREQ
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_BMTREQHIS
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_BMTREQHIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_BMTREQHIS
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_DATAREPORT
--PROMPT ====================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_DATAREPORT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_DATAREPORT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_LEVEL_QUEUE
--PROMPT =====================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_LEVEL_QUEUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_LEVEL_QUEUE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_MO
--PROMPT ============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_MO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_MO
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_MODATAREPORT
--PROMPT ======================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_MODATAREPORT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_MODATAREPORT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_RPT
--PROMPT =============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_RPT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_RPT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_TASK
--PROMPT ==============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_TASK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_TASK
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MMS_TEMPLATE
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MMS_TEMPLATE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MMS_TEMPLATE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MO_DATAREPORT
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MO_DATAREPORT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MO_DATAREPORT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MO_TASK
--PROMPT =============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MO_TASK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MO_TASK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MO_WAIT_A
--PROMPT ===============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MO_WAIT_A';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MO_WAIT_A
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MO_WAIT_C
--PROMPT ===============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MO_WAIT_C';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MO_WAIT_C
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_DATAREPORT
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_DATAREPORT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_DATAREPORT
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL0_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL0_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL0_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL1_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL1_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL1_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL2_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL2_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL2_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL3_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL3_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL3_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL4_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL4_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL4_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL5_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL5_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL5_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL6_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL6_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL6_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL7_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL7_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL7_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL8_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL8_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL8_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_LVL9_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_LVL9_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_LVL9_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_ROUTETABLE
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_ROUTETABLE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_ROUTETABLE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_TASK
--PROMPT =============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_TASK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_TASK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_TASK
--PROMPT =============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_TASK_BAK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_TASK_BAK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_TASK_C
--PROMPT ===============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_TASK_C';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_TASK_C
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_TIMER_QUE
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_TIMER_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_TIMER_QUE
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_VFY_TASK
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_VFY_TASK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_VFY_TASK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_VFY_WAIT
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_VFY_WAIT';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_VFY_WAIT
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_WAIT_A
--PROMPT ===============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_WAIT_A';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_WAIT_A
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_MT_WAIT_C
--PROMPT ===============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_MT_WAIT_C';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_MT_WAIT_C
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_BUFINFO
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_BUFINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_BUFINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_BUF_HIS
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_BUF_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_BUF_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_LOGINFO
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_LOGINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_LOGINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_LOG_HIS
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_LOG_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_LOG_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_MONLOG
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_MONLOG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_MONLOG
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_MONLOG_HIS
--PROMPT ======================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_MONLOG_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_MONLOG_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_MONMSG
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_MONMSG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_MONMSG
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_MONMSG_HIS
--PROMPT ======================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_MONMSG_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_MONMSG_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_PTINFO
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_PTINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_PTINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_PT_HIS
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_PT_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_PT_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_SPINFO
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_SPINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_SPINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_SP_HIS
--PROMPT ==================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_SP_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_SP_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_SYSINFO
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_SYSINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_SYSINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_SYS_HIS
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_SYS_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_SYS_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_THDINFO
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_THDINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_THDINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_THD_HIS
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_THD_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_THD_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_USERINFO
--PROMPT ====================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_USERINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_USERINFO
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_M_MON_USER_HIS
--PROMPT ====================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_M_MON_USER_HIS';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_M_MON_USER_HIS
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 20001
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_PBWEBZZCMDLOG
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_PBWEBZZCMDLOG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_PBWEBZZCMDLOG
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_PBWEBZZCMDQUE
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_PBWEBZZCMDQUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_PBWEBZZCMDQUE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_PB_LIST_BLACK
--PROMPT ===================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_PB_LIST_BLACK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_PB_LIST_BLACK
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_RPT_WAIT_A
--PROMPT ================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_RPT_WAIT_A';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_RPT_WAIT_A
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_RPT_WAIT_B
--PROMPT ================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_RPT_WAIT_B';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_RPT_WAIT_B
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_RPT_WAIT_C
--PROMPT ================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_RPT_WAIT_C';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_RPT_WAIT_C
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_USERDATA
--PROMPT ==============================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_USERDATA';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_USERDATA
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 100000
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

--PROMPT
--PROMPT CREATING SEQUENCE SEQ_XT_GATE_QUE
--PROMPT =================================
--PROMPT
DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_XT_GATE_QUE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_XT_GATE_QUE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	NOCACHE
	ORDER';
  END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_PROVINCECITY';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_PROVINCECITY
(
ID  NUMBER(11)  NOT NULL,
PROVINCE  VARCHAR2(256)  DEFAULT ('' '') ,
CITY	VARCHAR2(256) DEFAULT ('' '') NOT NULL,
AREACODE	NUMBER(11) DEFAULT 0 NOT NULL,
PROVINCECODE	NUMBER(11) DEFAULT 0 NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_PROVINCECITY') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_PROVINCECITY ADD CONSTRAINT PK_A_PROVINCECITY PRIMARY KEY (ID)
	USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_PROVINCECITY') AND T.INDEX_NAME = UPPER('IX_A_PC_PROVINCE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_A_PC_PROVINCE ON A_PROVINCECITY(PROVINCE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_PROVINCECITY') AND T.INDEX_NAME = UPPER('IX_A_PC_CITY');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_A_PC_CITY ON A_PROVINCECITY(CITY)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_PROVINCECITY') AND T.INDEX_NAME = UPPER('IX_A_PC_AREACODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_A_PC_AREACODE ON A_PROVINCECITY(AREACODE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_PROCITY';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_PROCITY
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_PROCITY" BEFORE
INSERT ON  "A_PROVINCECITY"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_PROCITY.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_MOBILEAREA';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_MOBILEAREA
(
ID  NUMBER(11) NOT NULL,
MOBILE  NUMBER(11) DEFAULT 0 NOT NULL,
AREACODE  NUMBER(11) DEFAULT 0 NOT NULL,
CREATETIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_MOBILEAREA') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_MOBILEAREA ADD CONSTRAINT PK_A_MOBILEAREA PRIMARY KEY (ID)
	USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/


DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_MOBILEAREA') AND T.INDEX_NAME = UPPER('IX_A_MA_MOBILE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE 'CREATE UNIQUE INDEX IX_A_MA_MOBILE ON A_MOBILEAREA(MOBILE)';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_MOBILEAREA';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_MOBILEAREA
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_MOBILEAREA" BEFORE
INSERT ON  "A_MOBILEAREA"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_MOBILEAREA.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMSTASK_P1');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMSTASK_P1 ON MMS_TASK
	(
	  P1
	)';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMSTASK_SDTM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMSTASK_SDTM ON MMS_TASK
	(
	  SENDTIME
	)';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMSTASK_SVRTYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMSTASK_SVRTYPE ON MMS_TASK
	(
	  SVRTYPE
	)';
		END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMSTASK_TASKID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMSTASK_TASKID ON MMS_TASK
	(
	  TASKID
	)';
		END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_TASK') AND T.INDEX_NAME = UPPER('IX_MMSTASK_USRID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMSTASK_USRID ON MMS_TASK
	(
	  USERID
	)';
		END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_ORGUID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_ORGUID ON MMS_MO
	(
	  ORGUID
	)';
		END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_SENDSTATUS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_SENDSTATUS ON MMS_MO
	(
	  SENDSTATUS
	)';
		END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('MMS_MO') AND T.INDEX_NAME = UPPER('IX_MMS_MO_US');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MMS_MO_US ON MMS_MO
	(
	  "UID" ,
	  SENDSTATUS
	)';
	END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_IPCOMINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_IPCOMINFO(
ID        NUMBER(11) NOT NULL,
GATENAME  VARCHAR2(32)  NOT NULL ,
PTIP        VARCHAR2(32) DEFAULT '' ''  NOT NULL,
PTPORT      NUMBER(11) DEFAULT 0 NOT NULL,
IP        VARCHAR2(32) DEFAULT '' ''  NOT NULL,
PORT      NUMBER(11) DEFAULT 0 NOT NULL,
GATEID    NUMBER(11) DEFAULT 0 NOT NULL,
CORPSIGN  VARCHAR2(20)  DEFAULT '' '',
COMMON    VARCHAR2(256) DEFAULT '' '',
CREATETIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_IPCOMINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_IPCOMINFO
	  ADD CONSTRAINT PK_IPCOM PRIMARY KEY (GATEID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_IPCOMINFO') AND T.INDEX_NAME = UPPER('IX_IPCOM_ID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_IPCOM_ID ON A_IPCOMINFO (ID)
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_IPCOMINFO') AND T.INDEX_NAME = UPPER('IX_IPCOM_IP');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_IPCOM_IP ON A_IPCOMINFO (IP)
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_IPCOMINFO') AND T.INDEX_NAME = UPPER('IX_IPCOM_PORT');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_IPCOM_PORT ON A_IPCOMINFO (PORT)
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_IPCOMINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_IPCOMINFO
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_IPCOMINFO" BEFORE
INSERT ON  "A_IPCOMINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_IPCOMINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SIMINFO';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SIMINFO(
ID          NUMBER(11) NOT NULL,
GATEID      NUMBER(11) DEFAULT  0 NOT NULL ,
UNICOM      NUMBER(11) DEFAULT  0 NOT NULL ,
PHONENO      VARCHAR2(21)  DEFAULT '' '' NOT NULL,
MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL,
DESCRIPTION  VARCHAR2(256) DEFAULT '' '',
SIMNO        NUMBER(11)   DEFAULT  0 NOT NULL,
HOURLIMIT    NUMBER(11)   DEFAULT  0 NOT NULL,
DAYLIMIT    NUMBER(11)   DEFAULT  0 NOT NULL,
MONTHLIMIT  NUMBER(11)   DEFAULT  0 NOT NULL,
CREATETIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_SIMINFO') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_SIMINFO
	  ADD CONSTRAINT PK_ASIM PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SIMINFO') AND T.INDEX_NAME = UPPER('IX_ASIM_GATEID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_ASIM_GATEID ON A_SIMINFO(GATEID)
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SIMINFO') AND T.INDEX_NAME = UPPER('IX_ASIM_UNICOM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_ASIM_UNICOM ON A_SIMINFO(UNICOM)
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SIMINFO') AND T.INDEX_NAME = UPPER('IX_ASIM_EAREA');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_ASIM_EAREA  ON A_SIMINFO(MOBILEAREA)
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SIMINFO') AND T.INDEX_NAME = UPPER('IX_ASIM_SIMNO');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_ASIM_SIMNO  ON A_SIMINFO(SIMNO)
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_SIMINFO';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_SIMINFO
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_SIMINFO" BEFORE
INSERT ON  "A_SIMINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_SIMINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_MNP';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_MNP(
ID NUMBER(11) NOT NULL,
PHONE VARCHAR2(21) DEFAULT '' '' NOT NULL,
UNICOM NUMBER(11)   DEFAULT 0 NOT NULL ,
PHONETYPE	NUMBER(11) DEFAULT 0 NOT NULL ,
ADDTYPE  NUMBER(11)  DEFAULT 0 NOT NULL ,
OPTTYPE  NUMBER(11)  DEFAULT 0 NOT NULL ,
CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_MNP') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_MNP ADD
	CONSTRAINT PK_AMNP PRIMARY KEY (ID)
	USING INDEX
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_MNP') AND T.INDEX_NAME = UPPER('IX_MNP_PHOTYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MNP_PHOTYPE ON A_MNP (PHONETYPE)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_MNP';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_MNP
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_MNP" BEFORE
INSERT ON  "A_MNP"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_MNP.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_MNPERRCODE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_MNPERRCODE(
ID  NUMBER(11) NOT NULL,
TYPE NUMBER(11) DEFAULT 0 NOT NULL ,
MNPTYPE NUMBER(11) DEFAULT 0 NOT NULL ,
ERRORCODE  VARCHAR2(7) DEFAULT '' '' NOT NULL ,
STATUS  NUMBER(11) DEFAULT 0 NOT NULL,
CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_MNPERRCODE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_MNPERRCODE
	  ADD CONSTRAINT PK_MNPERRCODE PRIMARY KEY (ERRORCODE)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_MNPERRCODE') AND T.INDEX_NAME = UPPER('IX_MNPERR_ID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_MNPERR_ID ON A_MNPERRCODE (ID)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_MNPERRCODE') AND T.INDEX_NAME = UPPER('IX_MNPERR_TYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MNPERR_TYPE ON A_MNPERRCODE (TYPE)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_MNPERRCODE') AND T.INDEX_NAME = UPPER('IX_MNPERR_MNPTYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MNPERR_MNPTYPE ON A_MNPERRCODE (MNPTYPE)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_MNPERRCODE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_MNPERRCODE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_MNPERRCODE" BEFORE
INSERT ON  "A_MNPERRCODE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_MNPERRCODE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_SPE_PHONE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_SPE_PHONE(
ID  NUMBER(11) NOT NULL ,
PHONE  VARCHAR2(21)  DEFAULT '' '' NOT NULL ,
CUSTID  NUMBER(11)  DEFAULT 0  NOT NULL ,
USERID VARCHAR2(11) DEFAULT '' '' NOT NULL ,
SPECTYPE NUMBER(11) DEFAULT 0  NOT NULL ,
OPTTYPE  NUMBER(11)  DEFAULT 0  NOT NULL ,
UNICOM  NUMBER(11)  DEFAULT 0  NOT NULL ,
CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_SPE_PHONE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_SPE_PHONE
	  ADD CONSTRAINT PK_SPE_PHONE PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SPE_PHONE') AND T.INDEX_NAME = UPPER('IX_SPEPHO_SPETYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_SPEPHO_SPETYPE ON A_SPE_PHONE (SPECTYPE)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_SPE_PHONE') AND T.INDEX_NAME = UPPER('IX_SPEPHO_UNICOM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_SPEPHO_UNICOM ON A_SPE_PHONE (UNICOM)
	TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/


DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_SPE_PHONE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_SPE_PHONE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_SPE_PHONE" BEFORE
INSERT ON  "A_SPE_PHONE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_SPE_PHONE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_AREACODE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_AREACODE(
ID  NUMBER(11) NOT NULL,
AREACODE  VARCHAR2(21)  DEFAULT '' '' NOT NULL,
AREANAME  VARCHAR2(256) DEFAULT '' ''  NOT NULL,
CODE NUMBER(11) DEFAULT 0 NOT NULL,
CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('A_AREACODE') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE A_AREACODE ADD CONSTRAINT PK_AREACODE PRIMARY KEY(ID)
	  USING INDEX
	  TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_AREACODE') AND T.INDEX_NAME = UPPER('IX_AREACODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_AREACODE ON A_AREACODE (AREACODE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_AREACODE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_AREACODE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_AREACODE" BEFORE
INSERT ON  "A_AREACODE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_AREACODE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='A_GWROUTE';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE A_GWROUTE(
ID  NUMBER(11) NOT NULL,
TYPE    NUMBER(11) DEFAULT 0 NOT NULL,
GATEID  NUMBER(11) DEFAULT 0 NOT NULL,
STATUS  NUMBER(11) DEFAULT 0 NOT NULL,
UNICOM  NUMBER(11) DEFAULT 0 NOT NULL,
AREA    NUMBER(11) DEFAULT 0 NOT NULL,
SIMID    NUMBER(11) DEFAULT 0 NOT NULL,
GATESEQ  NUMBER(11) DEFAULT 0 NOT NULL,
SENDTIMEBEGIN  CHAR(8) DEFAULT ''00:00:00'' NOT NULL,
SENDTIMEEND  CHAR(8) DEFAULT ''23:59:59'' NOT NULL,
P1  VARCHAR2(256) DEFAULT '' ''  NOT NULL,
P2  VARCHAR2(256) DEFAULT '' ''  NOT NULL,
CREATETIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_GWROUTE') AND T.INDEX_NAME = UPPER('IX_GWRUT_TYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRUT_TYPE ON A_GWROUTE(TYPE)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('A_GWROUTE') AND T.INDEX_NAME = UPPER('IX_GWRUT_GATEID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRUT_GATEID ON A_GWROUTE(GATEID)
	TABLESPACE TBSSMSACC
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_A_GWROUTE';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_A_GWROUTE
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_A_GWROUTE" BEFORE
INSERT ON  "A_GWROUTE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_GWROUTE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='TRANS_LOG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE TRANS_LOG (
ID NUMBER(22) NOT NULL,
USETYPE VARCHAR2(8) DEFAULT ''短信'' NOT NULL,
TRANSNAME VARCHAR2(64) DEFAULT '' '' NOT NULL,
TSTATUS VARCHAR2(4000) DEFAULT '' '' NOT NULL,
RUNFLAG  NUMBER(11) DEFAULT 0 NOT NULL,
CREATETIME TIMESTAMP (6) DEFAULT SYSTIMESTAMP NOT NULL
)
TABLESPACE TBSHISDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_TRANS_LOG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_TRANS_LOG
	MINVALUE 1
	MAXVALUE 99999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_TRANS_LOG" BEFORE
INSERT ON  "TRANS_LOG"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_TRANS_LOG.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_MT_TASK_BAK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_MT_TASK_BAK
(
  ID           NUMBER(22) NOT NULL,
  PTMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"          NUMBER(11) DEFAULT 0 NOT NULL,
  ECID         NUMBER(11) DEFAULT 0 NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPID         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPGATE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  RETFLAG      NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG      NUMBER(11) DEFAULT 1 NOT NULL,
  PKNUMBER     NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL      NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS   NUMBER(11) DEFAULT 2 NOT NULL,
  SENDFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  RECVFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  DONEDATE     CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE    CHAR(7) DEFAULT ('' '') NOT NULL,
  SENDLEVEL    NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  UNICOM       NUMBER(11) DEFAULT 0 NOT NULL,
  MOBILEAREA   NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE      VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  RESENDCNT    NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID       NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT       NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ   NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI       NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID     NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE      VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  RECVMTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSMTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSRPTTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDRPTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ATTIME       NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME    NUMBER(22) DEFAULT 0 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0  NOT NULL,
  AREACODE NUMBER(11) DEFAULT 0 NOT NULL,
  FLAGMTSDOK    NUMBER(11)          DEFAULT 0 NOT NULL,
  FLAGRPTRVOK   NUMBER(11)          DEFAULT 0 NOT NULL,
  FLAGRPTSDOK   NUMBER(11)          DEFAULT 0 NOT NULL,
  MTSUBMITTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ERRRESENDCNT  NUMBER(11)      DEFAULT 0  NOT NULL,
  NETERRCNT    NUMBER(11)      DEFAULT 0  NOT NULL,
  SENDRESULT    NUMBER(11)     DEFAULT 1  NOT NULL,
  SPGATESEND    VARCHAR2(21)      DEFAULT '' ''  NOT NULL,
  SPNUMBER     VARCHAR2(21)      DEFAULT '' ''  NOT NULL,
  SENDERRCODE   VARCHAR2(10)      DEFAULT '' ''  NOT NULL,
  SUBMITDATE   CHAR(10)     DEFAULT '' '' NOT NULL,
  CUSTID     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  EXDATA     VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LONGMSG	 VARCHAR2(4000) DEFAULT '' '' NOT NULL,
  TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
  CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
  RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
  ERRORCODE2 CHAR(7) DEFAULT '' '' NOT NULL,
  DOWNTM TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RMSRPTFLAG	NUMBER(11) DEFAULT 1 NOT NULL,
  PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
  TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
  TITLE	 VARCHAR2(40) DEFAULT '' '' NOT NULL,
  SHOWAY	 VARCHAR2(16) DEFAULT '' '' NOT NULL,
  DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
  DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
  ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
  SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
  SUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL,
  LUID1 VARCHAR2(64) DEFAULT '' '' NOT NULL
  )
 TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_MT_TASK_BAK
	  ADD CONSTRAINT PK_GWMTTASKBAK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_PTID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_GWMTTASKBAK_PTID ON GW_MT_TASK_BAK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_P1');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_P1 ON GW_MT_TASK_BAK (P1)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_SENDTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_SENDTIME ON GW_MT_TASK_BAK (SENDTIME)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_SVRTYPE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_SVRTYPE ON GW_MT_TASK_BAK (SVRTYPE)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_TASKID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_TASKID ON GW_MT_TASK_BAK (TASKID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_USERID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_USERID ON GW_MT_TASK_BAK (USERID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_BATCHID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_BATCHID ON GW_MT_TASK_BAK (BATCHID)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/
 
DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_PHONE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_PHONE ON GW_MT_TASK_BAK (PHONE)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_AREACODE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_AREACODE ON GW_MT_TASK_BAK (AREACODE)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_FMS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_FMS ON GW_MT_TASK_BAK (FLAGMTSDOK)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_FRR');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_FRR ON GW_MT_TASK_BAK (FLAGRPTRVOK)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MT_TASK_BAK') AND T.INDEX_NAME = UPPER('IX_GWMTTASKBAK_FRS');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTTASKBAK_FRS ON GW_MT_TASK_BAK (FLAGRPTSDOK)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GWMTTASKBAK" BEFORE
INSERT ON  "GW_MT_TASK_BAK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_TASK_BAK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/


DECLARE I int;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_MT_TASK_ERR';
if I=0 then
   execute immediate  'CREATE TABLE GW_MT_TASK_ERR(
  ID           NUMBER(22) NOT NULL,
  PTMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  "UID"          NUMBER(11) DEFAULT 0 NOT NULL,
  ECID         NUMBER(11) DEFAULT 0 NOT NULL,
  USERID       VARCHAR2(11) DEFAULT ('' '') NOT NULL,
  SPID         VARCHAR2(32) DEFAULT ('' '') NOT NULL,
  SPGATE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  CPNO         VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  PHONE        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
  SPMSGID      NUMBER(22) DEFAULT 0 NOT NULL,
  RETFLAG      NUMBER(11) DEFAULT 0 NOT NULL,
  FEEFLAG      NUMBER(11) DEFAULT 1 NOT NULL,
  PKNUMBER     NUMBER(11) DEFAULT 1 NOT NULL,
  PKTOTAL      NUMBER(11) DEFAULT 1 NOT NULL,
  SENDSTATUS   NUMBER(11) DEFAULT 2 NOT NULL,
  SENDFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  RECVFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
  DONEDATE     CHAR(10) DEFAULT ('' '') NOT NULL,
  ERRORCODE    CHAR(7) DEFAULT ('' '') NOT NULL,
  SENDLEVEL    NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
  UNICOM       NUMBER(11) DEFAULT 0 NOT NULL,
  MOBILEAREA   NUMBER(11) DEFAULT 0 NOT NULL,
  SENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MESSAGE      VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
  RESENDCNT    NUMBER(11) DEFAULT 0 NOT NULL,
  TASKID       NUMBER(11) DEFAULT 0 NOT NULL,
  MSGFMT       NUMBER(11) DEFAULT 15 NOT NULL,
  LONGMSGSEQ   NUMBER(11) DEFAULT 0 NOT NULL,
  TPUDHI       NUMBER(11) DEFAULT 0 NOT NULL,
  TPPID        NUMBER(11) DEFAULT 0 NOT NULL,
  USERMSGID    NUMBER(22) DEFAULT 0 NOT NULL,
  MODULEID     NUMBER(11) DEFAULT 0 NOT NULL,
  SVRTYPE      VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P1           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P2           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P3           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  P4           VARCHAR2(64) DEFAULT ('' '') NOT NULL,
  RECVMTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSMTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  TRANSRPTTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  SENDRPTTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ATTIME       NUMBER(22) DEFAULT 0 NOT NULL,
  VALIDTIME    NUMBER(22) DEFAULT 0 NOT NULL,
  BATCHID    NUMBER(22) DEFAULT 0,
  AREACODE NUMBER(11) DEFAULT 0 NOT NULL,
  FLAGMTSDOK    NUMBER(11)          DEFAULT 0 NOT NULL,
  FLAGRPTRVOK   NUMBER(11)          DEFAULT 0 NOT NULL,
  FLAGRPTSDOK   NUMBER(11)          DEFAULT 0 NOT NULL,
  MTSUBMITTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ERRRESENDCNT  NUMBER(11)      DEFAULT 0  NOT NULL,
  NETERRCNT    NUMBER(11)      DEFAULT 0  NOT NULL,
  SENDRESULT    NUMBER(11)     DEFAULT 1  NOT NULL,
  SPGATESEND    VARCHAR2(21)      DEFAULT '' ''  NOT NULL,
  SPNUMBER     VARCHAR2(21)      DEFAULT '' '' NOT NULL,
  SENDERRCODE   VARCHAR2(10)      DEFAULT '' ''  NOT NULL,
  SUBMITDATE   CHAR(10)     DEFAULT '' '' NOT NULL
)
 TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_MT_TASK_ERR') AND INDEX_NAME =UPPER('IX_GWMTTASKERR_PTID');
if i=0 then
   execute immediate 'CREATE  INDEX IX_GWMTTASKERR_PTID ON GW_MT_TASK_ERR(PTMSGID)
  TABLESPACE TBMTINDEX_PTMSGID
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_MT_TASK_ERR') AND INDEX_NAME =UPPER('IX_GWMTTASKERR_SENDTIME');
if i=0 then
   execute immediate '  CREATE INDEX IX_GWMTTASKERR_SENDTIME ON GW_MT_TASK_ERR (SENDTIME)
  TABLESPACE TBSSVRINDEX
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


  ---------------------------------------GW_MTSDOK-----------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_MTSDOK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_MTSDOK"
 ("ID"            NUMBER(22)                     NOT NULL ,
  "PTMSGID"       NUMBER(22)           DEFAULT 0 NOT NULL ,
  "SPMSGID"       NUMBER(22)           DEFAULT 0 NOT NULL ,
  "SENDSTATUS"    NUMBER(11)       DEFAULT 3               NOT NULL,
  "SPID"          VARCHAR2(32)    DEFAULT '' ''               NOT NULL,
  "TRANSMTTIME"   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "MTSUBMITTIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "SENDTIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "ERRRESENDCNT"  NUMBER(11)        DEFAULT 0    NOT NULL,
  "NETERRCNT"     NUMBER(11)        DEFAULT 0    NOT NULL,
  "SENDRESULT"    NUMBER(11)       DEFAULT 1    NOT NULL ,
  "SPGATESEND"    VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "SPNUMBER"      VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "PHONE"         VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "SENDERRCODE"   VARCHAR2(10)    DEFAULT '' ''   NOT NULL  ,
  "TPUDHI"        NUMBER(11)       DEFAULT 0    NOT NULL ,
  "TPPID"         NUMBER(11)       DEFAULT 0    NOT NULL ,
  "PKTOTAL"       NUMBER(11)       DEFAULT 0    NOT NULL ,
  "PKNUMBER"      NUMBER(11)       DEFAULT 0    NOT NULL ,
  "LONGMSGSEQ"    NUMBER(11)       DEFAULT 0    NOT NULL ,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )
  TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_MTSDOK
	  ADD CONSTRAINT PK_GW_MTSDOK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/


DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWMTSDOK');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWMTSDOK ON GW_MTSDOK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK') AND T.INDEX_NAME = UPPER('IX_MTSDOKSPGATESE');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTSDOKSPGATESE ON GW_MTSDOK(SPGATESEND)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK') AND T.INDEX_NAME = UPPER('IX_MTSDOK_SENDRES');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTSDOK_SENDRES ON GW_MTSDOK(SENDRESULT)
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/
  
DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK') AND T.INDEX_NAME = UPPER('IX_MTSDOK_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTSDOK_INTIME ON GW_MTSDOK(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_MTSDOK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_MTSDOK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_MTSDOK" BEFORE
INSERT ON  "GW_MTSDOK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_MTSDOK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

----------------------------------------------GW_MTSDOK_ERR----------------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_MTSDOK_ERR';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_MTSDOK_ERR"
 ("ID"            NUMBER(22)                     NOT NULL ,
  "PTMSGID"       NUMBER(22)           DEFAULT 0 NOT NULL ,
  "SPMSGID"       NUMBER(22)           DEFAULT 0 NOT NULL ,
  "SENDSTATUS"    NUMBER(11)       DEFAULT 3               NOT NULL,
  "SPID"          VARCHAR2(32)    DEFAULT '' ''               NOT NULL,
  "TRANSMTTIME"   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "MTSUBMITTIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "SENDTIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "ERRRESENDCNT"  NUMBER(11)        DEFAULT 0    NOT NULL,
  "NETERRCNT"     NUMBER(11)        DEFAULT 0    NOT NULL,
  "SENDRESULT"    NUMBER(11)       DEFAULT 1    NOT NULL ,
  "SPGATESEND"    VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "SPNUMBER"      VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "PHONE"         VARCHAR2(21)    DEFAULT '' ''   NOT NULL  ,
  "SENDERRCODE"   VARCHAR2(10)    DEFAULT '' ''   NOT NULL  ,
  "TPUDHI"        NUMBER(11)       DEFAULT 0    NOT NULL ,
  "TPPID"         NUMBER(11)       DEFAULT 0    NOT NULL ,
  "PKTOTAL"       NUMBER(11)       DEFAULT 0    NOT NULL ,
  "PKNUMBER"      NUMBER(11)       DEFAULT 0    NOT NULL ,
  "LONGMSGSEQ"    NUMBER(11)       DEFAULT 0    NOT NULL ,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )
   TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK_ERR') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_MTSDOK_ERR
	  ADD CONSTRAINT PK_GWMTSDOKERR PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK_ERR') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWMTSDOKERR');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWMTSDOKERR ON GW_MTSDOK_ERR(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MTSDOK_ERR') AND T.INDEX_NAME = UPPER('IX_MTSDOKERR_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MTSDOKERR_INTIME ON GW_MTSDOK_ERR(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

---------------------------------------GW_RPTRVOK-------------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RPTRVOK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_RPTRVOK"
 ("ID"          NUMBER(22)                    NOT NULL,
  "PTMSGID"     NUMBER(22)         DEFAULT 0  NOT NULL,
  "SPMSGID"     NUMBER(22)         DEFAULT 0  NOT NULL,
  "SENDSTATUS"  NUMBER(11)        DEFAULT 5   NOT NULL,
  "RECVTIME"    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "DONEDATE"    CHAR(10)     DEFAULT '' '' NOT NULL,
  "SUBMITDATE"  CHAR(10)     DEFAULT '' '' NOT NULL,
  "ERRORCODE"   CHAR(7)      DEFAULT '' '' NOT NULL,
  "PHONE"       VARCHAR2(21)       DEFAULT '' '' NOT NULL,
  "SPNUMBER"    VARCHAR2(21)       DEFAULT '' '' NOT NULL,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 ) TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RPTRVOK
	  ADD CONSTRAINT PK_GWRPTRVOK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWRPTRVOK');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWRPTRVOK ON GW_RPTRVOK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK') AND T.INDEX_NAME = UPPER('IX_RPTRVOK_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTRVOK_INTIME ON GW_RPTRVOK(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_RPTRVOK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_RPTRVOK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_RPTRVOK" BEFORE
INSERT ON  "GW_RPTRVOK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_RPTRVOK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--------------------------------GW_RPTRVOK_ERR-------------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RPTRVOK_ERR';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_RPTRVOK_ERR"
 ("ID"          NUMBER(22)                    NOT NULL,
  "PTMSGID"     NUMBER(22)         DEFAULT 0  NOT NULL,
  "SPMSGID"     NUMBER(22)         DEFAULT 0  NOT NULL,
  "SENDSTATUS"  NUMBER(11)        DEFAULT 5   NOT NULL,
  "RECVTIME"    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "DONEDATE"    CHAR(10)     DEFAULT '' '' NOT NULL,
  "SUBMITDATE"  CHAR(10)     DEFAULT '' '' NOT NULL,
  "ERRORCODE"   CHAR(7)      DEFAULT '' '' NOT NULL,
  "PHONE"       VARCHAR2(21)       DEFAULT '' '' NOT NULL,
  "SPNUMBER"    VARCHAR2(21)       DEFAULT '' '' NOT NULL,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 ) TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK_ERR') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RPTRVOK_ERR
	  ADD CONSTRAINT PK_GWRPTRVOKERR PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK_ERR') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWRPTRVOKERR');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWRPTRVOKERR ON GW_RPTRVOK_ERR(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTRVOK_ERR') AND T.INDEX_NAME = UPPER('IX_RPTRVOKERR_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTRVOKERR_INTIME ON GW_RPTRVOK_ERR(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

-------------------------------------------------GW_RPTSDOK--------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RPTSDOK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_RPTSDOK"
 ("ID"            NUMBER(22)                    NOT NULL,
  "PTMSGID"       NUMBER(22)         DEFAULT 0  NOT NULL,
  "SPMSGID"       NUMBER(22)         DEFAULT 0  NOT NULL,
  "SENDSTATUS"    NUMBER(11)         DEFAULT 5  NOT NULL,
  "SENDFLAG"      NUMBER(11)         DEFAULT 0  NOT NULL,
  "SENDRPTTIME"    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "TRANSRPTTIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "ERRORCODE"     CHARACTER(7)    DEFAULT '' ''                NOT NULL ,
  "PHONE"         VARCHAR2(21)     DEFAULT '' ''                 NOT NULL,
  "SPNUMBER"      VARCHAR2(21)     DEFAULT '' ''                 NOT NULL,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RPTSDOK
	  ADD CONSTRAINT PK_GWRPTSDOK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWRPTSDOK');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWRPTSDOK ON GW_RPTSDOK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK') AND T.INDEX_NAME = UPPER('IX_RPTSDOK_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTSDOK_INTIME ON GW_RPTSDOK(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_RPTSDOK';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_RPTSDOK
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_RPTSDOK" BEFORE
INSERT ON  "GW_RPTSDOK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_RPTSDOK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------------------------------GW_RPTSDOK_ERR--------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RPTSDOK_ERR';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_RPTSDOK_ERR"
 ("ID"            NUMBER(22)                    NOT NULL,
  "PTMSGID"       NUMBER(22)         DEFAULT 0  NOT NULL,
  "SPMSGID"       NUMBER(22)         DEFAULT 0  NOT NULL,
  "SENDSTATUS"    NUMBER(11)         DEFAULT 5  NOT NULL,
  "SENDFLAG"      NUMBER(11)         DEFAULT 0  NOT NULL,
  "SENDRPTTIME"    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "TRANSRPTTIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "ERRORCODE"     CHARACTER(7)    DEFAULT '' ''                NOT NULL ,
  "PHONE"         VARCHAR2(21)     DEFAULT '' ''                NOT NULL,
  "SPNUMBER"      VARCHAR2(21)     DEFAULT '' ''                 NOT NULL,
  "IN_TIME"      TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK_ERR') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RPTSDOK_ERR
	  ADD CONSTRAINT PK_GWRPTSDOKERR PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK_ERR') AND T.INDEX_NAME = UPPER('IX_PTMSGID_GWRPTSDOKERR');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_PTMSGID_GWRPTSDOKERR ON GW_RPTSDOK_ERR(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RPTSDOK_ERR') AND T.INDEX_NAME = UPPER('IX_RPTSDOKERR_INTIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_RPTSDOKERR_INTIME ON GW_RPTSDOK_ERR(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

 -------------------------------------------------GW_TRAN_DEL_LOG--------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_TRAN_DEL_LOG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_TRAN_DEL_LOG"
 ("ID"       NUMBER(22)     NOT NULL ,
  "OPRTYPE"  NUMBER(11)   NOT NULL,
  "STARTID"  NUMBER(22)     NOT NULL,
  "ENDID"    NUMBER(22)     NOT NULL,
  "ISSUCCES" NUMBER(11)   NOT NULL,
  "IN_TIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "END_TIME" TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_TRAN_DEL_LOG') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_TRAN_DEL_LOG
	  ADD CONSTRAINT PK_GWTRANDELLOG PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_TRAN_DEL_LOG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_TRAN_DEL_LOG
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/

 -------------------------------------------------GW_UPD_DEL_LOG--------------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_UPD_DEL_LOG';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE  "GW_UPD_DEL_LOG"
 ("ID"       NUMBER(22)     NOT NULL ,
  "OPRTYPE"  NUMBER(11)   NOT NULL,
  "UPTYPE"   NUMBER(11)   NOT NULL,
  "COUNTID"  NUMBER(22)     NOT NULL,
  "ISSUCCES" NUMBER(11)   NOT NULL,
  "IN_TIME"  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  "END_TIME" TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )TABLESPACE TBMTTASKDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_UPD_DEL_LOG') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_UPD_DEL_LOG
	  ADD CONSTRAINT PK_GWUPDDELLOG PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_UPD_DEL_LOG';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_UPD_DEL_LOG
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 200
	ORDER';
  END IF;
END;
/


-------------------------GW_MSGTAIL--------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_MSGTAIL';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_MSGTAIL(
TAIL_ID NUMBER(22) NOT NULL,
TAIL_NAME VARCHAR2(64) DEFAULT '' '' NOT NULL,
CONTENT VARCHAR2(512) DEFAULT '' '' NOT NULL,
CREATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
UPDATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
CORP_CODE VARCHAR2(64) DEFAULT '' '' NOT NULL,
USER_ID NUMBER(22) DEFAULT 0 NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MSGTAIL') AND T.INDEX_NAME = UPPER('IX_MSGTAIL_TI');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MSGTAIL_TI ON GW_MSGTAIL(TAIL_ID)
	  TABLESPACE TBSSVRDATA
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_MSGTAIL') AND T.INDEX_NAME = UPPER('IX_MSGTAIL_CC');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_MSGTAIL_CC ON GW_MSGTAIL(CORP_CODE)
	  TABLESPACE TBSSVRDATA
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_MSGTAIL';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_MSGTAIL
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';	
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_MSGTAIL" BEFORE
INSERT ON  "GW_MSGTAIL"
    FOR EACH ROW
BEGIN
IF (:NEW.TAIL_ID IS NULL)
THEN
SELECT SEQ_GW_MSGTAIL.NEXTVAL INTO :NEW.TAIL_ID FROM DUAL;
END IF;
END;
/

-------------------------GW_TAILBIND--------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_TAILBIND';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_TAILBIND(
ID NUMBER(22) NOT NULL,
TAIL_ID NUMBER(22) DEFAULT 0 NOT NULL,
BUS_CODE VARCHAR2(64) DEFAULT '' '' NOT NULL,
SPUSERID VARCHAR2(11) DEFAULT '' '' NOT NULL,
TAIL_TYPE NUMBER(2) DEFAULT 0 NOT NULL,
CORP_CODE VARCHAR2(64) DEFAULT '' '' NOT NULL,
CREATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
UPDATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
USER_ID  NUMBER(22) DEFAULT 0 NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_TAILBIND') AND T.INDEX_NAME = UPPER('IX_TAILBIND_TI');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_TAILBIND_TI ON GW_TAILBIND(TAIL_ID)
	  TABLESPACE TBSSVRDATA
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_TAILBIND') AND T.INDEX_NAME = UPPER('IX_TAILBIND_CC');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_TAILBIND_CC ON GW_TAILBIND(CORP_CODE)
	  TABLESPACE TBSSVRDATA
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_TAILBIND';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_TAILBIND
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';	
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_TAILBIND" BEFORE
INSERT ON  "GW_TAILBIND"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_TAILBIND.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------GW_TAILCTRL--------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_TAILCTRL';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_TAILCTRL(
ID NUMBER(22) NOT NULL,
OVERTAILFLAG NUMBER(1) DEFAULT 0 NOT NULL,
OTHERTAILFLAG NUMBER(2) DEFAULT 0 NOT NULL,
CREATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
UPDATE_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
CORP_CODE  VARCHAR2(64) DEFAULT '' '' NOT NULL,
USER_ID  NUMBER(22) DEFAULT 0 NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_TAILCTRL') AND T.INDEX_NAME = UPPER('IX_TAILCTRL_CC');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE UNIQUE INDEX IX_TAILCTRL_CC ON GW_TAILCTRL(CORP_CODE)
	  TABLESPACE TBSSVRDATA
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_TAILCTRL';
  IF VERSION = 0 THEN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_TAILCTRL
	MINVALUE 1
	MAXVALUE 9999999999999999999999
	START WITH 1
	INCREMENT BY 1
	CACHE 20000
	ORDER';	
  END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_TAILCTRL" BEFORE
INSERT ON  "GW_TAILCTRL"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_TAILCTRL.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------GW_CLUDECISION--------------------------
DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_CLUDECISION';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_CLUDECISION(
ID  NUMBER(11) NOT NULL,
GWTYPE  NUMBER(11) DEFAULT 0 NOT NULL,
GWNO  NUMBER(11) DEFAULT 0 NOT NULL,
RUNGWNO  NUMBER(11) DEFAULT 0 NOT NULL,
RUNUPDTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
APPLYGWNO  NUMBER(11) DEFAULT 0 NOT NULL,
APPLYSTATUS  NUMBER(11) DEFAULT 0 NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/


DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_CLUDECISION') AND INDEX_NAME =UPPER('IX_CLUDE_TP_NO');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_CLUDE_TP_NO ON GW_CLUDECISION(GWTYPE ASC,GWNO)
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/


DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_CLUDECISION';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_CLUDECISION
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_CLUDECISION" BEFORE
INSERT ON  "GW_CLUDECISION"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_CLUDECISION.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------GW_CLUSTATUS--------------------------
DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_CLUSTATUS';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_CLUSTATUS(
ID NUMBER(11) NOT NULL,
GWTYPE  NUMBER(11) DEFAULT 0 NOT NULL,
GWNO  NUMBER(11) DEFAULT 0 NOT NULL,
PRIGWNO  NUMBER(11) DEFAULT 0 NOT NULL,
RUNSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
GWEIGHT NUMBER(11) DEFAULT 0 NOT NULL,
RUNWEIGHT  NUMBER(11) DEFAULT 0 NOT NULL,
UPDTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_CLUSTATUS') AND INDEX_NAME =UPPER('IX_CLUST_TP_NO');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_CLUST_TP_NO ON GW_CLUSTATUS(GWTYPE ASC,GWNO)
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/


DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_CLUSTATUS';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_CLUSTATUS
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_CLUSTATUS" BEFORE
INSERT ON  "GW_CLUSTATUS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_CLUSTATUS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------GW_CLUSPBIND--------------------------
DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_CLUSPBIND';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_CLUSPBIND(
ID NUMBER(11) NOT NULL,
PTACCUID  NUMBER(11) DEFAULT 0 NOT NULL,
GWNO  NUMBER(11) DEFAULT 0 NOT NULL,
GWEIGHT  NUMBER(11) DEFAULT 0 NOT NULL,
UPDTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/
DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_CLUSPBIND';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_CLUSPBIND
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_CLUSPBIND" BEFORE
INSERT ON  "GW_CLUSPBIND"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_CLUSPBIND.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

-------------------------GW_DBMONITOR 新增网关数据库监控测试表 --------------------------
DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_DBMONITOR';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_DBMONITOR(
ID  NUMBER(22) NOT NULL,
GWNO NUMBER(11) DEFAULT 0 NOT NULL,
TESTSTRING VARCHAR(256) DEFAULT '' '' NOT NULL,
RUNUPDTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
 )
  TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_DBMONITOR';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_DBMONITOR
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_DBMONITOR" BEFORE
INSERT ON  "GW_DBMONITOR"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_DBMONITOR.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_BASEPARA';
if i=0 then
   execute immediate 'CREATE TABLE   GW_BASEPARA(
   ID  NUMBER(22) DEFAULT ''0'' NOT NULL ,
   FUNNAME  VARCHAR2(20)   DEFAULT '' '' NOT NULL ,
   CMDTYPE  NUMBER(11)  DEFAULT ''1'' NOT NULL  ,
   ARGNAME  VARCHAR2(50)  DEFAULT '' '' NOT NULL ,
   ARGVALUELEN  NUMBER(22)  DEFAULT ''0'' NOT NULL ,
   ARGDES  VARCHAR2(50) DEFAULT '' '' NOT NULL ,
   ARGTYPE  NUMBER(11)  DEFAULT ''1'' NOT NULL ,
   CREATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
   MODIFTIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
   RESERVE  VARCHAR2(64)  DEFAULT '' ''  NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/

declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_BASEPARA') AND INDEX_NAME =UPPER('GW_BASEPARA_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_BASEPARA
ADD CONSTRAINT  GW_BASEPARA_PK  PRIMARY KEY( FUNNAME , CMDTYPE , ARGNAME )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_PROTOMTCH';
if i=0 then
   execute immediate 'CREATE TABLE  GW_PROTOMTCH  (
   ID   NUMBER(22)            NOT NULL,
   ECID  NUMBER(22)     DEFAULT ''0'' NOT NULL,
   FUNTYPE  VARCHAR2(30)   DEFAULT '' '' NOT NULL,
   FUNNAME  VARCHAR2(20)   DEFAULT '' '' NOT NULL,
   CMDTYPE  NUMBER(11)   DEFAULT ''1'' NOT NULL,
   CARGNAME  VARCHAR2(50)   DEFAULT '' '' NOT NULL,
   MARGNAME   VARCHAR2(50)   DEFAULT '' '' NOT NULL,
   CARGTYPE  NUMBER(11)   DEFAULT ''1''  NOT NULL,
   CARGVALUE  VARCHAR2(64)   DEFAULT '' '' NOT NULL,
   BELONGTYPE  NUMBER(11)   DEFAULT ''0''  NOT NULL,
   BELONG  VARCHAR2(50)   DEFAULT '' '' NOT NULL,
   CREATETIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP   NOT NULL,
   MODIFTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP   NOT NULL,
   RESERVE  VARCHAR2(64)   DEFAULT '' ''  NOT NULL
)TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_PROTOMTCH';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_PROTOMTCH
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_PROTOMTCH" BEFORE
INSERT ON  "GW_PROTOMTCH"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_PROTOMTCH.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_PROTOMTCH') AND INDEX_NAME =UPPER('GW_PROTOMTCH_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_PROTOMTCH
ADD CONSTRAINT  GW_PROTOMTCH_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_PROTOMTCH') AND INDEX_NAME =UPPER('IX_PROTOMTCH_FFCCB');
if i=0 then
   execute immediate 'CREATE UNIQUE INDEX   IX_PROTOMTCH_FFCCB
  ON   GW_PROTOMTCH( FUNTYPE , FUNNAME , CMDTYPE , CARGNAME , BELONG)
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_USERPROPERTY';
if i=0 then
   execute immediate 'CREATE TABLE   GW_USERPROPERTY(
   ID  NUMBER(22)         NOT NULL,
   ECID  NUMBER(22)   DEFAULT ''0'' NOT NULL,
   USERID  VARCHAR2(11) DEFAULT '' '' NOT NULL,
   PWDENCODE  NUMBER(11) DEFAULT ''0''  NOT NULL,
   PWDENCODESTR   VARCHAR2(256) DEFAULT ''00000000'' NOT NULL,
   MSGCODE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   MSGENCODE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   PUSHMOFMT  NUMBER(11) DEFAULT ''2''  NOT NULL,
   PUSHRPTFMT  NUMBER(11) DEFAULT ''2''  NOT NULL,
   PUSHPWDENCODE  NUMBER(11) DEFAULT ''0''  NOT NULL,
   PUSHPWDENCODESTR  VARCHAR2(256) DEFAULT ''00000000'' NOT NULL,
   PUSHMSGCODE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   PUSHMSGENCODE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   PUSHFAILCNT  NUMBER(11) DEFAULT ''3''  NOT NULL,
   PUSHSLIDEWND  NUMBER(11) DEFAULT ''5''  NOT NULL,
   PUSHMOMAXCNT  NUMBER(22) DEFAULT ''100'' NOT NULL,
   PUSHRPTMAXCNT  NUMBER(22) DEFAULT ''100'' NOT NULL,
   GETMOMAXCNT  NUMBER(22) DEFAULT ''100'' NOT NULL,
   GETRPTMAXCNT  NUMBER(22) DEFAULT ''100'' NOT NULL,
   RESERVE  VARCHAR2(64) DEFAULT '' '',
   CACERTNAME VARCHAR2(256) DEFAULT ('' '') NOT NULL,
   VERIFYPEER NUMBER(4) DEFAULT 1 NOT NULL,
   VERIFYHOST NUMBER(4) DEFAULT 1 NOT NULL
)TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_USERPROPERTY';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_USERPROPERTY
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_USERPROPERTY" BEFORE
INSERT ON  "GW_USERPROPERTY"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_USERPROPERTY.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_USERPROPERTY') AND INDEX_NAME =UPPER('GW_USERPROPERTY_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_USERPROPERTY
ADD CONSTRAINT  GW_USERPROPERTY_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/



DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_PUSHPROTOMTCH';
if i=0 then
   execute immediate 'CREATE TABLE   GW_PUSHPROTOMTCH(
   ID  NUMBER(22)         NOT NULL,
   ECID  NUMBER(22)   DEFAULT ''0'' NOT NULL,
   USERID  VARCHAR2(11) DEFAULT '' '' NOT NULL,
   PUSHFLAG  NUMBER(11) DEFAULT ''1''  NOT NULL,
   CMDTYPE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   CARGNAME  VARCHAR2(30) DEFAULT '' '' NOT NULL,
   CARGTYPE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   MARGNAME  VARCHAR2(30) DEFAULT '' '' NOT NULL,
   CARGVALUE  VARCHAR2(30) DEFAULT '' '' NOT NULL,
   BELONGTYPE  NUMBER(11) DEFAULT ''0''  NOT NULL,
   BELONG  VARCHAR2(30) DEFAULT ''mos'' NOT NULL,
   RESERVE  VARCHAR2(64) DEFAULT '' '' NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/

DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_PUSHPROTOMTCH';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_PUSHPROTOMTCH
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_PUSHPROTOMTCH" BEFORE
INSERT ON  "GW_PUSHPROTOMTCH"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_PUSHPROTOMTCH.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_PUSHPROTOMTCH') AND INDEX_NAME =UPPER('GW_PUSHPROTOMTCH_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_PUSHPROTOMTCH
ADD CONSTRAINT  GW_PUSHPROTOMTCH_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/




DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_MULTI_ENTERP';
if i=0 then
   execute immediate 'CREATE TABLE   GW_MULTI_ENTERP(
   ECID  NUMBER(22)  NOT NULL  ,
   FUNTYPE  VARCHAR2(30) DEFAULT '' '' NOT NULL,
   RESPFMT  NUMBER(22)  DEFAULT ''2''  NOT NULL,
   STATUS  NUMBER(11) DEFAULT ''1''  NOT NULL,
   BOOKCNT  NUMBER(11) DEFAULT ''0''  NOT NULL,
   MATCHCNT  NUMBER(11) DEFAULT ''0''  NOT NULL,
   CREATETM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
   MODIYTM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
   REQFMT  NUMBER(11) DEFAULT ''2''  NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/

declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_MULTI_ENTERP') AND INDEX_NAME =UPPER('GW_MULTIENTERP_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_MULTI_ENTERP
ADD CONSTRAINT  GW_MULTIENTERP_PK  PRIMARY KEY( ECID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_BASEPROTOCOL';
if i=0 then
   execute immediate 'CREATE TABLE   GW_BASEPROTOCOL(
  ID   NUMBER(22)         NOT NULL ,
   ECID  NUMBER(22)   DEFAULT ''0'' NOT NULL,
   FUNTYPE  VARCHAR2(30) DEFAULT '' '' NOT NULL,
   FUNNAME  VARCHAR2(20) DEFAULT '' '' NOT NULL,
   CFUNNAME  VARCHAR2(50) DEFAULT '' '' NOT NULL,
   CMDTYPE  NUMBER(11) DEFAULT ''1''  NOT NULL,
   RETTYPE  NUMBER(11) DEFAULT ''2''  NOT NULL,
   STATUS  NUMBER(11) DEFAULT ''1''  NOT NULL,
   CUST_INTFNAME  VARCHAR2(64)    DEFAULT '' '' NOT NULL,
   FMTMSG  VARCHAR2(3000)    DEFAULT '' '' NOT NULL,
   CREATETM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
   MODIYTM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_BASEPROTOCOL';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_BASEPROTOCOL
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_BASEPROTOCOL" BEFORE
INSERT ON  "GW_BASEPROTOCOL"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_USERPROPERTY.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_BASEPROTOCOL') AND INDEX_NAME =UPPER('GW_BASEPROTOCOL_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_BASEPROTOCOL
ADD CONSTRAINT  GW_BASEPROTOCOL_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_BASEPROTOCOL') AND INDEX_NAME =UPPER('IDX_CFFC');
if i=0 then
   execute immediate 'CREATE UNIQUE INDEX   IDX_CFFC
  ON   GW_BASEPROTOCOL
 ( ECID , FUNTYPE , FUNNAME , CMDTYPE )
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/



DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_PUSHRSPROTOCOL';
if i=0 then
   execute immediate 'CREATE TABLE   GW_PUSHRSPROTOCOL  (
  ID  NUMBER(22)     NOT NULL,
   ECID  NUMBER(22)     DEFAULT ''0'' NOT NULL,
   USERID  VARCHAR2(11)   DEFAULT '' '' NOT NULL,
   RSPCMD  NUMBER(11)   DEFAULT ''1''  NOT NULL,
   CARGNAME  VARCHAR2(50)   DEFAULT '' '' NOT NULL,
   RSPSTATUS  NUMBER(11)   DEFAULT ''1''  NOT NULL,
   CRSPFMT  NUMBER(11)   DEFAULT ''2''  NOT NULL,
   CARGVALUE  VARCHAR2(128)   DEFAULT '' ''  NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/

DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_PUSHRSPROTOCOL';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_PUSHRSPROTOCOL
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_PUSHRSPROTOCOL" BEFORE
INSERT ON  "GW_PUSHRSPROTOCOL"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_PUSHRSPROTOCOL.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_PUSHRSPROTOCOL') AND INDEX_NAME =UPPER('GW_PUSHRSPROTOCOL_PK');
if i=0 then
   execute immediate 'ALTER TABLE  GW_PUSHRSPROTOCOL
ADD CONSTRAINT  GW_PUSHRSPROTOCOL_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_PUSHRSPROTOCOL') AND INDEX_NAME =UPPER('IDX_ERCR');
if i=0 then
   execute immediate 'CREATE UNIQUE INDEX    IDX_ERCR ON GW_PUSHRSPROTOCOL( ECID , RSPCMD , CARGNAME , RSPSTATUS )
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


DECLARE I INT;
BEGIN
SELECT count(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_GATECONNINFO';
if i=0 then
   execute immediate 'CREATE TABLE  GW_GATECONNINFO  (
  ID   NUMBER(22)          NOT NULL,
   PTID  NUMBER(22)   DEFAULT ''0''  NOT NULL,
   GATEID  NUMBER(22) DEFAULT ''0'' NOT NULL,
   CONNTYPE  NUMBER(11) DEFAULT ''0''  NOT NULL,
   PTACCID  VARCHAR2(11) DEFAULT '' '' NOT NULL,
   IP  VARCHAR2(32) DEFAULT '' '' NOT NULL,
   PORT  NUMBER(22) DEFAULT ''0'' NOT NULL,
   LINKCNT  NUMBER(22) DEFAULT ''1'' NOT NULL,
   SPEEDLIMIT  NUMBER(22) DEFAULT ''1000'' NOT NULL,
 LINKLEVEL  NUMBER(11) DEFAULT ''0''  NOT NULL,
 LINKSTATUS  NUMBER(11) DEFAULT ''0''  NOT NULL,
 PING  NUMBER(11) DEFAULT ''0''  NOT NULL,
 MINLINKS  NUMBER(11) DEFAULT ''1''  NOT NULL,
 KEEPCONN  NUMBER(11) DEFAULT ''1''  NOT NULL,
 RECONNCNT  NUMBER(11) DEFAULT ''5''  NOT NULL,
 RELOGINCNT  NUMBER(11) DEFAULT ''5''  NOT NULL,
 SWITCHMAINIP  NUMBER(11) DEFAULT ''1''  NOT NULL,
 TESTMETHOD  NUMBER(11) DEFAULT ''1''  NOT NULL,
 TESTTIMES  NUMBER(22) DEFAULT ''60'' NOT NULL,
 ABNORMALONG  NUMBER(11) DEFAULT ''300''  NOT NULL,
 ABNORMALTMS  NUMBER(11) DEFAULT ''10''  NOT NULL,
 CREATETM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
 UPDATETM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
DECLARE I int;
BEGIN
SELECT count(*) INTO I FROM  USER_SEQUENCES where SEQUENCE_NAME='SEQ_GW_GATECONNINFO';
if i=0 then
   execute immediate 'CREATE SEQUENCE SEQ_GW_GATECONNINFO
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
end if;
end;
/

CREATE OR REPLACE TRIGGER "TIG_GW_GATECONNINFO" BEFORE
INSERT ON  "GW_GATECONNINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_USERPROPERTY.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_GATECONNINFO') AND INDEX_NAME =UPPER('GW_GATECONNINFO_PK');
if i=0 then
   execute immediate 'ALTER TABLE   GW_GATECONNINFO
ADD CONSTRAINT  GW_GATECONNINFO_PK  PRIMARY KEY( ID )
    USING INDEX
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/
declare i int;
begin
SELECT count(*) into i FROM user_indexes WHERE TABLE_NAME = UPPER('GW_GATECONNINFO') AND INDEX_NAME =UPPER('IDX_PIPPGC');
if i=0 then
   execute immediate 'CREATE UNIQUE INDEX   IDX_PIPPGC
  ON   GW_GATECONNINFO
 (PTACCID , IP , PORT , PTID , GATEID , CONNTYPE)
  TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
end if;
end;
/


--增加退订指令表GW_TDCMD，用于保存上行退订指令详细信息
DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_TDCMD';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_TDCMD  (
   ID NUMBER(11) NOT NULL ,
   TD_CMD VARCHAR2(64) DEFAULT ''TD'' NOT NULL ,
   TD_USERID VARCHAR2(11) DEFAULT ''000000'' NOT NULL,
   TD_SPNUMBER VARCHAR2(21) DEFAULT '' '' NOT NULL,
   TD_ECID NUMBER(11) DEFAULT 0 NOT NULL,
   TD_TIMES NUMBER(11) DEFAULT 1 NOT NULL,
   MATCHTYPE NUMBER(4) DEFAULT 0 NOT NULL,
   OPTYPE NUMBER(4) DEFAULT 0 NOT NULL,
   PB_USERID VARCHAR2(11) DEFAULT ''000000'' NOT NULL,
   PB_SPNUMBER VARCHAR2(21) DEFAULT '' '' NOT NULL,
   PB_SVRTYPE VARCHAR2(64) DEFAULT '' '' NOT NULL,
   PB_CROPCODE VARCHAR2(64) DEFAULT '' '' NOT NULL,
   STATUS NUMBER(4) DEFAULT 0 NOT NULL
) TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_TDCMD';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_TDCMD
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_TDCMD" BEFORE
INSERT ON  "GW_TDCMD"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_TDCMD.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_TDCMD') AND INDEX_NAME =UPPER('IX_GW_TDCMD');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_GW_TDCMD ON GW_TDCMD (TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID)
  TABLESPACE TBSSVRINDEX
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_TDCMD') AND INDEX_NAME =UPPER('PK_GW_TDCMD');
IF I=0 THEN
  EXECUTE IMMEDIATE 'ALTER TABLE GW_TDCMD ADD CONSTRAINT  PK_GW_TDCMD  PRIMARY KEY( ID )
  USING INDEX
  TABLESPACE TBSSVRINDEX
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

--增加上行退订操作历史记录表 GW_TDCMD_HIS
DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I  FROM  USER_TABLES WHERE TABLE_NAME='GW_TDCMD_HIS';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE GW_TDCMD_HIS (
   ID NUMBER(11) NOT NULL ,
   TD_PHONE NUMBER(22) DEFAULT 0 NOT NULL ,
   TD_CMD VARCHAR2(64) DEFAULT ''TD'' NOT NULL,
   TD_USERID VARCHAR2(11) DEFAULT ''000000'' NOT NULL ,
   TD_SPNUMBER VARCHAR2(21) DEFAULT '' '' NOT NULL ,
   TD_ECID NUMBER(11) DEFAULT 0 NOT NULL ,
   OPTYPE NUMBER(4) DEFAULT 0 NOT NULL ,
   MO_MSGID NUMBER(22) DEFAULT 0 NOT NULL ,
   TD_TIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSVRDATA
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM  USER_SEQUENCES WHERE SEQUENCE_NAME='SEQ_GW_TDCMD_HIS';
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE SEQUENCE SEQ_GW_TDCMD_HIS
MINVALUE 1
MAXVALUE 9999999999999999999999
START WITH 1
INCREMENT BY 1
CACHE 20000
ORDER';
END IF;
END;
/

CREATE OR REPLACE TRIGGER "TIG_GW_TDCMD_HIS" BEFORE
INSERT ON  "GW_TDCMD_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_GW_TDCMD_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_TDCMD_HIS') AND INDEX_NAME =UPPER('IX_GW_TDCMD_HIS');
IF I=0 THEN
   EXECUTE IMMEDIATE 'CREATE INDEX IX_GW_TDCMD_HIS ON GW_TDCMD_HIS (TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID)
  TABLESPACE TBSSVRINDEX
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/

DECLARE I NUMBER(11);
BEGIN
SELECT COUNT(*) INTO I FROM USER_INDEXES WHERE TABLE_NAME = UPPER('GW_TDCMD_HIS') AND INDEX_NAME =UPPER('PK_GW_TDCMD_HIS');
IF I=0 THEN
   EXECUTE IMMEDIATE 'ALTER TABLE GW_TDCMD_HIS ADD CONSTRAINT PK_GW_TDCMD_HIS PRIMARY KEY( ID )
  USING INDEX
  TABLESPACE TBSSVRINDEX
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
END IF;
END;
/


CREATE OR REPLACE PROCEDURE GW_CMTDATARPT(PIYM NUMBER)
AUTHID CURRENT_USER
IS
PISTR VARCHAR2(4000);
PISTR_1 VARCHAR2(512);
PITABLENAME VARCHAR2(20);
BEGIN
    PITABLENAME:='GW_MTDRPT'||CAST(PIYM AS CHAR);
    PISTR:='CREATE TABLE '||PITABLENAME||
    '(
    USERID      VARCHAR2(11) NOT NULL,
    TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
    SPGATE      VARCHAR2(21) NOT NULL,
    IYMD        NUMBER(11) NOT NULL,
    IHOUR       NUMBER(11) NOT NULL,
    PTCODE      CHAR(10) DEFAULT ('' '') NOT NULL,
    IMONTH      NUMBER(11) NOT NULL,
    ICOUNT      NUMBER(11) DEFAULT 0 NOT NULL,
    SUCC        NUMBER(11) DEFAULT 0 NOT NULL,
    FAIL1       NUMBER(11) DEFAULT 0 NOT NULL,
    FAIL2       NUMBER(11) DEFAULT 0 NOT NULL,
    FAIL3       NUMBER(11) DEFAULT 0 NOT NULL,
    NRET        NUMBER(11) DEFAULT 0 NOT NULL,
    RSUCC       NUMBER(11) DEFAULT 0 NOT NULL,
    RFAIL1      NUMBER(11) DEFAULT 0 NOT NULL,
    RFAIL2      NUMBER(11) DEFAULT 0 NOT NULL,
    RNRET       NUMBER(11) DEFAULT 0 NOT NULL,
    RELEASEFLAG NUMBER(11) DEFAULT 1 NOT NULL,
    STARTTIME   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
    ENDTIME     TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
    ID          NUMBER(11) NOT NULL,
    Y           NUMBER(11) DEFAULT 0 NOT NULL,
    SPISUNCM    NUMBER(11) DEFAULT 0 NOT NULL,
    SPID        VARCHAR2(32) DEFAULT ('' '') NOT NULL,
    SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    SENDTYPE    NUMBER(11) DEFAULT 1 NOT NULL,
    MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL,
    BATCHID     NUMBER(22) DEFAULT 0 NOT NULL,
    AREACODE    NUMBER(11) DEFAULT 0 NOT NULL
  )
  TABLESPACE TBSHISDATA
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR;
  PISTR_1:='ALTER TABLE '||PITABLENAME||
    ' ADD CONSTRAINT '||PITABLENAME||'_PRIMARY PRIMARY KEY (USERID, TASKID, SPGATE, IYMD, IHOUR, SPISUNCM,
    SPID, SVRTYPE, P1, P2, P3, P4, SENDTYPE, MOBILEAREA,BATCHID,AREACODE)
    USING INDEX
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
  PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||' (TASKID)
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
  PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'Y_IMONTH ON '||PITABLENAME||' (
    IMONTH ASC,
    Y DESC,
    ICOUNT,
    RFAIL1,
    RFAIL2,
    SPISUNCM,
    SPID)
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;

    PISTR_1:='CREATE SEQUENCE SEQ_'||PITABLENAME||'
    MINVALUE 1
    MAXVALUE 99999999999
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    ORDER';
    EXECUTE IMMEDIATE PISTR_1;

    PISTR_1:='CREATE OR REPLACE TRIGGER TIG_'||PITABLENAME||' BEFORE
    INSERT ON  '||PITABLENAME||'
        FOR EACH ROW
    BEGIN
    IF (:NEW.ID IS NULL)
    THEN
        SELECT SEQ_'||PITABLENAME||'.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
    END;';
    EXECUTE IMMEDIATE PISTR_1;

  END;
/

CREATE OR REPLACE PROCEDURE GW_H_STATISTIV3(PROCESSFLAG IN NUMBER,ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
   MAXIYMD NUMBER;
   DIFFDATE NUMBER;
   CURPROCESSFLAG NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
    RECFAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11),
        BATCHID NUMBER(22),
        AREACODE NUMBER(11),
    TMPLID NUMBER(22),
    CHGRADE NUMBER(11),
    MSGTYPE NUMBER(11)
 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计
  CURPROCESSFLAG:=PROCESSFLAG;
  SELECT NVL(MAX(IYMD),20000101) INTO MAXIYMD  FROM MT_DATAREPORT;
  DIFFDATE:= TO_DATE(TO_CHAR(SYSDATE-2,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS')-to_date(MAXIYMD,'YYYY-MM-DD HH24:MI:SS') ;
  IF DIFFDATE>0 THEN
          CURPROCESSFLAG:=CURPROCESSFLAG+DIFFDATE;
  END IF;
 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,RECFAIL,NRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
               IF ISP1=1 THEN
                  STR:=STR||',P1';
                ELSE
                  STR:=STR||','' '' AS P1';
                END IF;
               IF ISP2=1 THEN
                  STR:=STR||',P2';
                ELSE
                  STR:=STR||','' '' AS P2';
                END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                ELSE
                  STR:=STR||','' '' AS P3';
                END IF;
                IF ISP4=1 THEN
                  STR:=STR||',P4';
                ELSE
                  STR:=STR||','' '' AS P4';
                END IF;

               STR:=STR||',
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
         NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3)  WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA,
               BATCHID,
               AREACODE,
         TMPLID,
         CHGRADE,
         MSGTYPE
               FROM GW_MT_TASK_BAK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||CURPROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
                 IF ISP1=1 THEN
                  STR:=STR||',P1';
                 END IF;
                IF ISP2=1 THEN
                  STR:=STR||',P2';
                 END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                 END IF;
                 IF ISP4=1 THEN
                  STR:=STR||',P4';
                 END IF;
               STR:=STR||',SENDTYPE,MOBILEAREA,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
        -- DBMS_OUTPUT.PUT_LINE(STR);

 EXECUTE IMMEDIATE STR;
       --SELECT MIN(),MAX() INTO  FROM TMEP_STATISTICS
 --插入或更新统计表
       STR:='DELETE FROM MT_DATAREPORT WHERE EXISTS (SELECT IYMD FROM '||TABLENAME||' A WHERE A.IYMD=MT_DATAREPORT.IYMD)';
      -- EXECUTE IMMEDIATE STR;

       --STR:='DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MT_DATAREPORT M
       (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RECFAIL,RNRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE,TMPLID,CHGRADE,MSGTYPE)
       SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,
       (T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.RECFAIL,T.NRET,T.SENDTYPE,T.MOBILEAREA,T.BATCHID,T.AREACODE,T.TMPLID,T.CHGRADE,T.MSGTYPE FROM '|| TABLENAME ||'  T';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;
END ;
/

CREATE OR REPLACE PROCEDURE GW_RTAILCTRL(OUT_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT OVERTAILFLAG,OTHERTAILFLAG,CORP_CODE FROM GW_TAILCTRL;
END;
/

CREATE OR REPLACE PROCEDURE GW_RBINDINFO(OUT_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT A.TAIL_ID,B.CONTENT,A.CORP_CODE,A.BUS_CODE,A.SPUSERID,A.TAIL_TYPE
      FROM GW_TAILBIND A INNER JOIN GW_MSGTAIL B ON A.TAIL_ID=B.TAIL_ID;
END;
/

CREATE OR REPLACE PROCEDURE GW_LFSPECBIND(OUT_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN OUT_CURSOR FOR
  'SELECT SPUSER,CORP_CODE FROM LF_SP_DEP_BIND WHERE IS_VALIDATE=1';
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE A_LOADUSRBIND
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADUSRBIND
(
 PIUSERID   IN VARCHAR2,
 PISPTYPE        IN NUMBER,
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT /*CORP.ECID*/0 AS ECID,USR."UID"/*TB1."UID"*/ AS "UID",USR."UID" AS UIDEX,USR.RISELEVEL AS RISELEVEL,TB2.DESTUID AS DESTUID,
  USR.USERID AS USERID,USR.USERID/*USR.LOGINID*/ AS LOGINID,GT.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,GT.SPGATE AS SPGATE,GT.ID AS CHANNELNO,
  GT.CPNO AS CPNO,GT.SPISUNCM AS SPISUNCM,GT.FEEFLAG AS FEEFLAG,GT.ROUTEFLAG AS ROUTEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,
  GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,GT.MULTILEN2 AS MULTILEN2,GT.SENDTIMEBEGIN AS TIMESTART,
  GT.SENDTIMEEND AS TIMEEND,GT.GATESEQ AS GATESEQ,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE,GATE.GATEPRIVILEGE AS GATEPRIVILEGE,
  GT.ENSIGNSTR AS ENSIGNSTR ,GT.ENSIGNLEN AS ENSIGNLEN ,GT.ENMAXWORDS AS ENMAXWORDS,
  GT.ENSINGLELEN AS ENSINGLELEN,GT.ENMULTILEN1 AS ENMULTILEN1,GT.ENMULTILEN2 AS ENMULTILEN2
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON USR.USERID=UPPER(GT.USERID) AND LENGTH(USR.USERID) <= 6
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE AND GATE.SPISUNCM=GT.SPISUNCM
  INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.SPGATE AS SPGATE,GATE2.SPISUNCM AS SPISUNCM FROM A_GWACCOUNT GWACC
         INNER JOIN A_GWSPBIND BIND ON BIND.PTACCUID=GWACC.PTACCUID
         INNER JOIN XT_GATE_QUEUE GATE2 ON GATE2.ID=BIND.GATEID WHERE GATE2.GATETYPE=PISPTYPE) TB2
         ON GT.SPGATE=TB2.SPGATE AND GT.SPISUNCM=TB2.SPISUNCM
  WHERE UPPER(USR.USERID)=UPPER(PIUSERID) AND USR.USERTYPE=0 AND USR.STATUS=0 AND GATE.STATUS=0 AND GT.STATUS=0
  AND GATE.GATETYPE=PISPTYPE
  AND USR.ACCOUNTTYPE=PISPTYPE
  AND GT.GATETYPE =PISPTYPE
  ORDER BY "UID";
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADALLBIND
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADALLBIND
(
 PISPTYPE IN NUMBER,
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT /*CORP.ECID*/ 0 AS ECID,USR."UID",USR."UID" AS UIDEX,USR.RISELEVEL AS RISELEVEL,TB2.DESTUID AS DESTUID,USR.USERID AS USERID,GT.ID AS CHANNELNO,
  /*USR.USERID*/USR.LOGINID AS LOGINID,GT.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,GT.SPGATE AS SPGATE,GT.CPNO AS CPNO,GT.SPISUNCM AS SPISUNCM,GT.FEEFLAG AS FEEFLAG,
  GT.ROUTEFLAG AS ROUTEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,
  GT.MULTILEN2 AS MULTILEN2,GT.SENDTIMEBEGIN AS TIMESTART,GT.SENDTIMEEND AS TIMEEND,GT.GATESEQ AS GATESEQ,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE,
  GATE.GATEPRIVILEGE AS GATEPRIVILEGE,GT.ENSIGNSTR AS ENSIGNSTR ,GT.ENSIGNLEN AS ENSIGNLEN ,GT.ENMAXWORDS AS ENMAXWORDS,
  GT.ENSINGLELEN AS ENSINGLELEN,GT.ENMULTILEN1 AS ENMULTILEN1,GT.ENMULTILEN2 AS ENMULTILEN2
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON USR.USERID=UPPER(GT.USERID) AND LENGTH(USR.USERID) <= 6
  --INNER JOIN KF_CORPBASE CORP ON UPPER(USR.CORPACCOUNT)=UPPER(CORP.CORPACCOUNT)
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE AND GATE.SPISUNCM=GT.SPISUNCM
  INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.SPGATE AS SPGATE,GATE2.SPISUNCM AS SPISUNCM FROM A_GWACCOUNT GWACC
         INNER JOIN A_GWSPBIND BIND ON BIND.PTACCUID=GWACC.PTACCUID
         INNER JOIN XT_GATE_QUEUE GATE2 ON GATE2.ID=BIND.GATEID WHERE GATE2.GATETYPE=PISPTYPE) TB2
         ON GT.SPGATE=TB2.SPGATE AND GT.SPISUNCM=TB2.SPISUNCM
  WHERE USR.USERTYPE=0 AND USR.STATUS=0 AND GATE.STATUS=0 AND GT.STATUS=0
  AND USR.ACCOUNTTYPE=PISPTYPE
  AND GT.GATETYPE = PISPTYPE
  AND GATE.GATETYPE = PISPTYPE
  ORDER BY "UID";
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETSPRULE
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETSPRULE
 (
  PIPTACCID       IN VARCHAR2,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  PIPTACCUID      PLS_INTEGER;
BEGIN
  PIPTACCUID := 0;
  SELECT "UID" INTO PIPTACCUID FROM USERDATA WHERE USERID=UPPER(PIPTACCID) AND USERTYPE=1 AND STATUS=0 AND ACCOUNTTYPE=PISPTYPE;
  OPEN OUT_CURSOR FOR
  SELECT ID,SPGATE,STATUS,SPISUNCM,GATETYPE,PORTTYPE,GATENAME,SINGLELEN,SIGNTYPE,SIGNFIXLEN,PREFIXLEN,ENDSPLIT,SIGNDROPTYPE,
  SIGNSTR,RISELEVEL,SPEED,LONGSMS,MAXWORDS,SUBLEN,FEEFLAG,SIGNLEN,SPLITRULE,MULTILEN1,MULTILEN2,MAXLONGMSGSEQ,GATESEQ,SPLITRULE,EACHSIGN,GATEPRIVILEGE,
  ENSIGNSTR,ENSIGNLEN,ENPREFIXLEN,ENMAXWORDS,ENSINGLELEN,ENMULTILEN1,ENMULTILEN2,ESPLITMAXWD,ESPLITENMAXWD
  FROM XT_GATE_QUEUE WHERE ID IN(SELECT GATEID FROM A_GWSPBIND WHERE PTACCUID=PIPTACCUID) AND STATUS=0 AND GATETYPE=PISPTYPE ORDER BY GATESEQ ASC;
END;
/

--加载网优路由绑定表
CREATE OR REPLACE PROCEDURE A_LOADGWROUTE(
PISPTYPE IN NUMBER,
OUT_CURSOR OUT SYS_REFCURSOR)
AS
BEGIN
OPEN OUT_CURSOR FOR
SELECT 0 AS ECID,
TB2.DESTUID AS DESTUID,TB2.RISELEVEL AS RISELEVEL,TB2.PORTTYPE AS PORTTYPE,0 AS ISEXCHANNEL,TB2.SPGATE AS SPGATE,
TB2.FEEFLAG AS FEEFLAG,TB2.SIGNSTR AS SIGNSTR,TB2.SIGNLEN AS SIGNLEN,TB2.MAXWORDS AS MAXWORDS,70 AS SINGLELEN,
TB2.MULTILEN1 AS MULTILEN1,TB2.MULTILEN2 AS MULTILEN2,TB2.AREATYPE AS AREATYPE,
RT.ID AS CHANNELNO, RT.TYPE AS ROUTEFLAG,RT.UNICOM AS SPISUNCM,RT.AREA AS GATEAREA,RT.GATESEQ AS GATESEQ,
RT.SENDTIMEBEGIN AS TIMESTART,RT.SENDTIMEEND AS TIMEEND,GATE.GATEPRIVILEGE AS GATEPRIVILEGE,
GATE.ENSIGNSTR AS ENSIGNSTR ,GATE.ENSIGNLEN AS ENSIGNLEN ,GATE.ENMAXWORDS AS ENMAXWORDS,
GATE.ENSINGLELEN AS ENSINGLELEN,GATE.ENMULTILEN1 AS ENMULTILEN1,GATE.ENMULTILEN2 AS ENMULTILEN2
FROM A_GWROUTE RT
INNER JOIN XT_GATE_QUEUE GATE
           ON GATE.ID=RT.GATEID AND GATE.SPISUNCM=RT.UNICOM
INNER JOIN (SELECT GWACC.PTACCUID AS DESTUID,GATE2.ID AS GATEID,GATE2.SPISUNCM AS SPISUNCM,GATE2.RISELEVEL,GATE2.PORTTYPE,
            GATE2.SPGATE,GATE2.FEEFLAG,GATE2.SIGNSTR,GATE2.SIGNLEN,GATE2.MAXWORDS,GATE2.MULTILEN1,GATE2.MULTILEN2,GATE2.AREATYPE
            FROM A_GWACCOUNT GWACC
            INNER JOIN A_GWSPBIND BIND
                       ON GWACC.PTACCUID=BIND.PTACCUID
            INNER JOIN XT_GATE_QUEUE GATE2
                       ON GATE2.ID=BIND.GATEID
            WHERE GATE2.GATETYPE=PISPTYPE)TB2
           ON TB2.GATEID=RT.GATEID AND TB2.SPISUNCM=RT.UNICOM
WHERE GATE.STATUS=0 AND RT.STATUS=0 AND GATE.GATETYPE=PISPTYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_RPTWAITA
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_RPTWAITA
(
  PIUSERUID       IN NUMBER,
  PILOGINUID      IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,ECID,PTMSGID,USERID,SPNUMBER,SUBMITTIME,DONETIME,PHONE,ERRORCODE,USERMSGID,MODULEID,
  TO_DATE(TO_CHAR(RECVTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVTIME
  FROM RPT_WAIT_A WHERE USERUID='||PIUSERUID||' AND LOGINUID='||PILOGINUID||' AND ROWNUM<='||PIMAXREADCNT|| '';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_RPTWAITA
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_RPTWAITA
 (
   PIECID       IN NUMBER,
   PIUSERUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPNUMBER   IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PISUBMITTIME IN VARCHAR2,
   PIDONETIME   IN VARCHAR2,
   PIERRORCODE  IN VARCHAR2,
   PIUSERMSGID  IN NUMBER DEFAULT 0,
   PIMODULEID   IN NUMBER DEFAULT 0,
   PIRECVTIME_P IN VARCHAR2

 )
AS
  PIUSERID2 VARCHAR2(11);
  PISPNUMBER2 VARCHAR2(21);
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  PIUSERID2:=PIUSERID;
  PISPNUMBER2:=PISPNUMBER;
  IF (PIUSERID2 IS NULL) THEN
    SELECT USERID,RTRIM(SPGATE)||RTRIM(CPNO) INTO PIUSERID2,PISPNUMBER2 FROM MT_TASK WHERE PTMSGID=PIPTMSGID;
  END IF;
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_A WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_A(ECID,USERUID,LOGINUID,PTMSGID,USERID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERMSGID,MODULEID,RECVTIME)
    VALUES(PIECID,PIUSERUID,PILOGINUID,PIPTMSGID,PIUSERID,PISPNUMBER2,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERMSGID,PIMODULEID,PIRECVTIME);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_RPTWAITB
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_RPTWAITB
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PIECID         IN NUMBER,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PIUSERID       IN VARCHAR2,
    PIORGUID       IN NUMBER,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRECVTIME_P   IN VARCHAR2
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_B("UID",PTMSGID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERID,ECID,ORGUID,USERMSGID,MODULEID,RECVTIME)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERID,PIECID,PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME);
  END IF;
END;
/

--写携号转网表
CREATE OR REPLACE PROCEDURE A_WR_MNP(
PIPHONE    IN VARCHAR2 DEFAULT 0,
PIUNICOM    IN NUMBER  DEFAULT 0,
PIPHONETYPE  IN NUMBER  DEFAULT 0,
PIADDTYPE  IN NUMBER  DEFAULT 0,
PIOPTTYPE  IN  NUMBER DEFAULT 0
)
AS
PICNT NUMBER;
BEGIN
SELECT COUNT(ID) INTO PICNT FROM A_MNP WHERE PHONE=PIPHONE AND OPTTYPE=0;
IF PICNT=0 THEN
    INSERT INTO A_MNP(PHONE,UNICOM,PHONETYPE,ADDTYPE,OPTTYPE )VALUES(PIPHONE,PIUNICOM,PIPHONETYPE,PIADDTYPE,PIOPTTYPE);
END IF;
END;
/

--携号转网表增量加载
CREATE OR REPLACE PROCEDURE A_LOADMNP(
PIID IN NUMBER DEFAULT 0,
PIMAXCNTID IN NUMBER DEFAULT 0,
OUT_CURSOR OUT SYS_REFCURSOR)
AS
BEGIN
OPEN OUT_CURSOR FOR
  SELECT MNP.ID,MNP.PHONE,MNP.UNICOM,MNP.PHONETYPE,MNP.ADDTYPE,MNP.OPTTYPE
  FROM (SELECT * FROM A_MNP WHERE ID>PIID ORDER BY ID ASC) MNP WHERE ROWNUM<=PIMAXCNTID ;
END;
/

CREATE OR REPLACE PROCEDURE A_LOADMNPERRCODE(OUT_CURSOR OUT SYS_REFCURSOR)
AS
BEGIN
OPEN OUT_CURSOR FOR
    SELECT TYPE,MNPTYPE,ERRORCODE,STATUS FROM A_MNPERRCODE;
END;
/

--特殊号码表增量加载
CREATE OR REPLACE PROCEDURE A_LOADSPEPHNO(
PIID IN NUMBER DEFAULT 0,
PIMAXCNTID IN NUMBER DEFAULT 0,
OUT_CURSOR OUT SYS_REFCURSOR)
AS
BEGIN
OPEN OUT_CURSOR FOR
    SELECT SP.ID,SP.PHONE,SP.CUSTID,SP.USERID,SP.SPECTYPE,SP.OPTTYPE,SP.UNICOM
    FROM (SELECT * FROM A_SPE_PHONE WHERE ID>PIID ORDER BY ID ASC) SP WHERE ROWNUM<=PIMAXCNTID ;
END;
/

--加载国际区号表
CREATE OR REPLACE PROCEDURE A_LOADAREACODE(OUT_CURSOR OUT SYS_REFCURSOR)
AS
BEGIN
OPEN OUT_CURSOR FOR
SELECT ID,AREACODE,AREANAME FROM A_AREACODE;
END;
/


CREATE OR REPLACE PROCEDURE A_LOADCMD_ROUTE(
OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE) AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,R.STATUS,R.MATCHMODE,R.CREATER,
  TO_CHAR(R.CREATTIME,'YYYY-MM-DD HH24:MI:SS') AS CREATTIME,U."UID",U.USERID,U.USERPASSWORD,R.PUSHURL,R.PUSHPROTOCOL,R.CMDPARAM FROM  A_CMD_ROUTE R
  INNER JOIN USERDATA U ON U."UID"=R.SP_ID WHERE U.ACCOUNTTYPE=1;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADCMD_ROUTE_G
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADCMD_ROUTE_G(OUT_CURSOR OUT SYS_REFCURSOR)--全局指令
AS
BEGIN
OPEN  OUT_CURSOR FOR
SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE)AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,U.USERID,R.STATUS,R.MATCHMODE,R.CREATER,
TO_CHAR(R.CREATTIME,'YYYY-MM-DD HH24:MI:SS') AS CREATTIME,U."UID",R.CMDTYPE,R.CMDPARAM,R.CMDATTRI,R.PUSHURL,R.PUSHPROTOCOL  FROM  A_CMD_ROUTE R
INNER JOIN USERDATA U ON U."UID"=R.SP_ID
WHERE U.ACCOUNTTYPE=1 AND U.USERTYPE=0 AND R.CMDTYPE=0;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADCMD_ROUTE_P
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADCMD_ROUTE_P(OUT_CURSOR OUT SYS_REFCURSOR)--通道指令
AS
BEGIN
OPEN  OUT_CURSOR FOR
SELECT R.ID,R.NAME,UPPER(R.STRUCTCODE)AS STRUCTCODE,R.TRUCTTYPE,R.BUSSYSNAME,U.USERID,R.STATUS,R.MATCHMODE,R.CREATER,
TO_CHAR(R.CREATTIME,'YYYY-MM-DD HH24:MI:SS') AS CREATTIME,U."UID",R.CMDTYPE,R.CMDPARAM,R.CMDATTRI,R.PUSHURL,R.PUSHPROTOCOL,P.GATEID,P.CMDID,P.STATUS,P.CPNO,P.FAILOPT,
P.DEFCMDID,P.SPNUMBER  FROM  A_CMD_ROUTE R
INNER JOIN USERDATA U ON U."UID"=R.SP_ID
INNER JOIN (SELECT CP.GATEID AS GATEID,CP.CMDID AS CMDID,CP.STATUS AS STATUS,CP.CPNO AS CPNO ,
CP.FAILOPT AS FAILOPT,CP.DEFCMDID AS DEFCMDID, TRIM(XT.SPGATE)||TRIM(CP.CPNO) AS SPNUMBER FROM A_CMD_PORT CP
            INNER JOIN XT_GATE_QUEUE XT ON XT.ID=CP.GATEID) P ON (R.ID=P.CMDID)
WHERE U.ACCOUNTTYPE=1 AND U.USERTYPE=0 AND P.STATUS=0 AND R.CMDTYPE=1;
END;
/

CREATE OR REPLACE PROCEDURE A_LOADPBLIST(
PIMAXID NUMBER, -- 最大ID
PIMAXCOLNUM NUMBER,-- 一次读取行数
PITYPE NUMBER,
OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT  PB.ID,PB.USERID,PB.SPGATE,PB.SPNUMBER,PB.PHONE,PB.OPTYPE,PB.SVRTYPE,PB.SPISUNCM,PB.CORPCODE,PB.BLTYPE
  FROM(SELECT * FROM  PB_LIST_BLACK WHERE BLTYPE=PITYPE AND ID>PIMAXID ORDER BY ID ASC )PB WHERE ROWNUM<= PIMAXCOLNUM ;
END;
/

CREATE OR REPLACE PROCEDURE A_LOADMOBILEAREA
 (PIID IN NUMBER ,
  PIMAXCOL IN NUMBER,
  OUT_CURSOR OUT SYS_REFCURSOR
 )
AS
BEGIN
    OPEN OUT_CURSOR FOR
    SELECT T.ID,T.MOBILE,T.AREACODE,P.PROVINCE,P.PROVINCECODE FROM (SELECT ID,MOBILE,AREACODE FROM (SELECT ID,MOBILE,AREACODE FROM A_MOBILEAREA  WHERE ID> PIID ORDER BY ID ASC) WHERE ROWNUM<= PIMAXCOL ) T
    LEFT JOIN  A_PROVINCECITY P  ON P.AREACODE=T.AREACODE;
END;
/

--PROMPT
--PROMPT CREATING FUNCTION BUILDINSERTSQL
--PROMPT ================================
--PROMPT
CREATE OR REPLACE FUNCTION BUILDINSERTSQL(STRTABLE VARCHAR2,FEILDS VARCHAR2,STRVALUES VARCHAR2)
RETURN VARCHAR2 IS
  STRSQL VARCHAR2(6000);
  STRVALUE VARCHAR(2048);
  STRVALUES1 VARCHAR(4096);
  INDEXNO NUMBER(10);
BEGIN
  STRVALUES1 := STRVALUES;

  STRSQL := 'INSERT INTO '||STRTABLE ||'(';
  STRSQL := STRSQL || REPLACE(FEILDS,'#',',');
  STRSQL := STRSQL || ') VALUES(';
  STRVALUES1 := STRVALUES1 || '#';
  INDEXNO := INSTR(STRVALUES1,'#');
  WHILE INDEXNO <> 0 LOOP
    STRVALUE := SUBSTR(STRVALUES1, 1, INDEXNO - 1);
    STRSQL := STRSQL || 'NVL(''' ||STRVALUE || ''','' ''),';
    STRVALUES1 := SUBSTR(STRVALUES1, INDEXNO+1, LENGTH(STRVALUES1));
    INDEXNO := INSTR(STRVALUES1,'#');
    --IF INDEXNO=0 THEN
       --STRVALUES1 := STRVALUES1||'#';
    --END IF;
    END LOOP;
  STRSQL := SUBSTR(STRSQL,1,LENGTH(STRSQL)-1);
  STRSQL :=STRSQL || ', SYSTIMESTAMP )';
  RETURN STRSQL;
END;
/

--PROMPT
--PROMPT CREATING FUNCTION BUILDUPDATESQL
--PROMPT ================================
--PROMPT
CREATE OR REPLACE FUNCTION BUILDUPDATESQL(STRTABLE VARCHAR2,FIELDS VARCHAR2,STRVALUES VARCHAR2,STRWHERE VARCHAR2)
RETURN VARCHAR2 IS
  STRVALUE VARCHAR2(2048);
  STRVALUES1 VARCHAR2(4096);
  FIELD VARCHAR2(2048);
  FIELDS1 VARCHAR2(2048);
  STRSQL VARCHAR2(6000);
  INDEXNO1 NUMBER(10);
  INDEXNO2 NUMBER(10);

  BEGIN
  STRVALUES1:=STRVALUES;
  STRVALUES1 := STRVALUES1 || '#';
  --STRVALUES1 := SUBSTR(STRVALUES1,2,LENGTH(STRVALUES1)-1);
  FIELDS1 := FIELDS;
  FIELDS1 := FIELDS1 || '#';
  STRSQL := 'UPDATE '||STRTABLE|| ' SET ';
  INDEXNO1:=INSTR(FIELDS1,'#');

  WHILE INDEXNO1 <> 0 LOOP
    INDEXNO2   := INSTR(STRVALUES1,'#');
    IF INDEXNO2 > 0 THEN
       STRVALUE   := SUBSTR(STRVALUES1, 1, INDEXNO2 - 1);
       STRVALUES1 := SUBSTR(STRVALUES1, INDEXNO2+1, LENGTH(STRVALUES1));
    ELSE
        STRVALUE := '';
    END IF;

    FIELD   := SUBSTR(FIELDS1, 1, INDEXNO1-1);
    FIELDS1 := SUBSTR(FIELDS1, INDEXNO1+1, LENGTH(FIELDS1));
    INDEXNO1:=INSTR(FIELDS1,'#');

    IF INDEXNO2 IS NULL THEN
      STRSQL := STRSQL || FIELD || '=SYSTIMESTAMP,';
    ELSE
        IF STRVALUE IS NULL THEN
      --STRSQL := STRSQL ||FIELD || '=''' ||STRVALUE ||''',';
               STRSQL := STRSQL ||FIELD || '=' || 'NVL(''' ||STRVALUE || ''','' ''),';
        ELSE
            STRSQL := STRSQL ||FIELD || '=' || '''' ||STRVALUE || ''',';
        END IF;
      END IF;
  END LOOP;

    STRSQL := SUBSTR(STRSQL,1,LENGTH(STRSQL)-1) ||' '||STRWHERE;

  RETURN STRSQL;
END BUILDUPDATESQL;
/

--PROMPT
--PROMPT CREATING FUNCTION GETARRAYLENGTH
--PROMPT ================================
--PROMPT
CREATE OR REPLACE FUNCTION GETARRAYLENGTH(
 STR VARCHAR2,    --(8000),  --要分割的字符串
 STRSPLIT VARCHAR2  --(10)  --分隔符号
)
RETURN NUMBER IS

 NLOCATION NUMBER(10);
 NSTART NUMBER(10);
 NLENGTH NUMBER(10);
 STR1 VARCHAR2(8000);

BEGIN
  STR1:=STR;
  STR1:=RTRIM(LTRIM(STR1));
  NLOCATION:=INSTR(STR1,STRSPLIT);
  NLENGTH:=1;
 WHILE NLOCATION<>0 LOOP
  NSTART:=NLOCATION+1;
  NLOCATION:=INSTR(STR1,STRSPLIT,NSTART);
  NLENGTH:=NLENGTH+1;
 END LOOP;
 RETURN NLENGTH;
END GETARRAYLENGTH;
/

--PROMPT
--PROMPT CREATING FUNCTION GETARRAYSTROFINDEX
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE FUNCTION GETARRAYSTROFINDEX
(
 STR VARCHAR2,       --(8000),  --要分割的字符串
 STRSPLIT VARCHAR2,   --(10),  --分隔符号
 INDEXNO NUMBER      --取第几个元素
)
RETURN VARCHAR2  IS  --(1024)

 NLOCATION NUMBER(10);
 NSTART    NUMBER(10);
 NNEXT     NUMBER(10);
 NSEED     NUMBER(10);
 STR1      VARCHAR2(8000);

BEGIN
 STR1:=STR;
 STR1:=LTRIM(RTRIM(STR1));
 NSTART:=1;
 NNEXT:=1;
 NSEED:=LENGTH(STRSPLIT);

 NLOCATION:=INSTR(STR1,STRSPLIT);   --CHARINDEX(@SPLIT,@STR)
 WHILE NLOCATION<>0 AND INDEXNO>NNEXT LOOP
   NSTART:=NLOCATION+NSEED;
   NLOCATION:=INSTR(STR1,STRSPLIT,NSTART);--CHARINDEX(@SPLIT,@STR,@START)
   NNEXT:=NNEXT+1;
 END LOOP;
 IF NLOCATION =0  THEN
    NLOCATION:=LENGTH(STR1)+1;
  END IF;
--这儿存在两种情况：1、字符串不存在分隔符号 2、字符串中存在分隔符号，跳出WHILE循环后，@LOCATION为0，那默认为字符串后边有一个分隔符号。

 RETURN SUBSTR(STR,NSTART,NLOCATION-NSTART);
END GETARRAYSTROFINDEX;
/

--PROMPT
--PROMPT CREATING FUNCTION SUBSTRINGPRIKEY
--PROMPT =================================
--PROMPT
CREATE OR REPLACE FUNCTION SUBSTRINGPRIKEY(INPSTR VARCHAR2,INDEXNO NUMBER)
RETURN VARCHAR2 IS

       STR VARCHAR2(2048);
       STRS VARCHAR2(2048);
       FLAGINDEX1 NUMBER(10);
       FLAGINDEX2 NUMBER(10);
BEGIN
  FLAGINDEX1:=0;
  FLAGINDEX2:=0;
  STRS:=INPSTR;

        IF INDEXNO=1 THEN
          FLAGINDEX1:=INSTR(STRS,'#',1,INDEXNO);
          STR:=SUBSTR(STRS,1,FLAGINDEX1-1);
          RETURN STR;
        ELSE
          FLAGINDEX1:=INSTR(STRS,'#',1,INDEXNO-1);
          FLAGINDEX2:=INSTR(STRS,'#',1,INDEXNO);
          STR:=SUBSTR(STRS,FLAGINDEX1+1,FLAGINDEX2-FLAGINDEX1-1);
          RETURN STR;
        END IF;
        RETURN STR;
END SUBSTRINGPRIKEY;
/

CREATE OR REPLACE PROCEDURE A_GETSGIPBIND
 (
  PIUID          IN  NUMBER,
  PITYPE         IN  NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIUID=0 THEN
    OPEN OUT_CURSOR FOR
    SELECT "UID",USERID,USERPASSWORD AS PWD,SPBINDURL
    FROM USERDATA WHERE USERTYPE=0 AND STATUS=0 AND NVL(TRIM(SPBINDURL),' ')<>' '
    AND TRANSMOTYPE=1 AND TRANSRPTYPE=1 AND ACCOUNTTYPE=PITYPE ORDER BY "UID";
  ELSE
    OPEN OUT_CURSOR FOR
    SELECT "UID",USERID,USERPASSWORD AS PWD,SPBINDURL
    FROM USERDATA WHERE USERTYPE=0 AND STATUS=0 AND NVL(TRIM(SPBINDURL),' ')<>' '
    AND TRANSMOTYPE=1 AND TRANSRPTYPE=1 AND "UID"=PIUID AND ACCOUNTTYPE=PITYPE ORDER BY "UID";
END IF;
END A_GETSGIPBIND;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETALLUSRINFO
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETALLUSRINFO
 (
  PISPTYPE   IN   NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT CASE WHEN B."UID" IS NULL THEN A."UID" ELSE B."UID" END AS SVRID,A."UID",A.USERID,A.USERTYPE,A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,
  A.STAFFNAME AS CORPNAME,A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,
  A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.ACCOUNTTYPE,A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE
  FROM USERDATA A LEFT JOIN (SELECT "UID",USERID FROM USERDATA WHERE BITAND(USERPRIVILEGE,2) = 2 AND USERDATA.ACCOUNTTYPE=PISPTYPE) B
  ON (A.LOGINID = B.USERID) OR B.USERID IS NULL
  WHERE A.STATUS=0 AND A.USERTYPE=0 AND A.ACCOUNTTYPE=PISPTYPE ;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETCHANNELMAP
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETCHANNELMAP
 (
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT SPNUMBER,CPNO FROM A_CHANNELMAP;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETCMDQUE
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETCMDQUE
 (
  PIGWNO          IN  NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  IGWNO PLS_INTEGER;
BEGIN
  IGWNO:=PIGWNO;
  OPEN OUT_CURSOR FOR
  SELECT ID,GWNO,GWTYPE,CMDTYPE,DEALSTATUS,CMDPARAM,RESULTCODE FROM A_CMDQUE WHERE GWNO=IGWNO AND DEALSTATUS=1;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETENDCHBINDB
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETENDCHBINDB
 (
  PIUSERID        IN  VARCHAR2,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  IPTACCUID       PLS_INTEGER;
BEGIN
  /*
  OPEN OUT_CURSOR FOR
  SELECT CORP.ECID AS ECID,GT.USERID AS USERID,GT.PORTTYPE AS PORTTYPE,
  GT.SPGATE AS SPGATE,GT.SPISUNCM AS SPISUNCM,GT.FEEFLAG AS FEEFLAG
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON UPPER(USR.USERID)=UPPER(GT.USERID)
  INNER JOIN KF_CORPBASE CORP ON UPPER(USR.CORPACCOUNT)=UPPER(CORP.CORPACCOUNT)
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE
  WHERE UPPER(USR.USERID)=UPPER(PIUSERID) AND USR.USERTYPE=1 AND GATE.STATUS=0 AND GT.STATUS=0;
  */
  IPTACCUID := 0;
  SELECT "UID" INTO IPTACCUID FROM USERDATA WHERE USERID=UPPER(PIUSERID) AND USERTYPE=1 AND STATUS=0 AND ACCOUNTTYPE=PISPTYPE;
  OPEN OUT_CURSOR FOR
  SELECT 0 AS ECID,PIUSERID AS USERID, 0 AS PORTTYPE,XTGATE.GATETYPE AS GATETYPE,XTGATE.SPGATE AS SPGATE,XTGATE.SPISUNCM AS SPISUNCM,
  XTGATE.FEEFLAG AS FEEFLAG,XTGATE.GATEAREA AS GATEAREA,XTGATE.AREATYPE AS AREATYPE,XTGATE.GATESEQ AS GATESEQ,
  XTGATE.ENSIGNSTR AS ENSIGNSTR ,XTGATE.ENSIGNLEN AS ENSIGNLEN ,XTGATE.ENPREFIXLEN AS ENPREFIXLEN,XTGATE.ENMAXWORDS AS ENMAXWORDS ,
  XTGATE.ENSINGLELEN AS ENSINGLELEN,XTGATE.ENMULTILEN1 AS ENMULTILEN1,XTGATE.ENMULTILEN2 AS ENMULTILEN2
  FROM XT_GATE_QUEUE XTGATE
  INNER JOIN A_GWSPBIND GWBIND ON XTGATE.ID=GWBIND.GATEID AND GWBIND.PTACCUID=IPTACCUID
  WHERE XTGATE.STATUS=0 AND XTGATE.GATETYPE=PISPTYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETGWACC
--PROMPT =============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETGWACC
 (
  PIGWNO          IN  NUMBER,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  IGWNO PLS_INTEGER;
BEGIN
  IGWNO:=PIGWNO;
  OPEN OUT_CURSOR FOR
  SELECT GWACC.GWNO AS GWNO,GWACC.PTACCUID AS PTACCUID,USR.USERID AS PTACCID,USR.USERPASSWORD AS PTACCPWD,
  GWACC.SPACCID AS SPACCID,GWACC.SPACCPWD AS SPACCPWD,GWACC.SPID AS SPID,GWACC.SERVICETYPE AS SERVICETYPE,
  GWACC.FEEUSERTYPE AS FEEUSERTYPE,GWACC.SPIP AS SPIP,GWACC.SPPORT AS SPPORT,GWACC.SPEEDLIMIT AS SPEEDLIMIT,
  GWACC.PROTOCOLCODE AS PROTOCOLCODE,GWACC.PROTOCOLPARAM AS PROTOCOLPARAM,GWACC.PTACCNAME AS PTACCNAME,
  GWACC.PTIP AS PTIP,GWACC.PTPORT AS PTPORT FROM A_GWACCOUNT GWACC
  INNER JOIN USERDATA USR ON PTACCUID=USR."UID" WHERE GWACC.GWNO=IGWNO AND USR.ACCOUNTTYPE=PISPTYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE GW_A_GETGWACCV1
--PROMPT =============================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_A_GETGWACCV1
 (
  PIGWNO          IN  NUMBER,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  IGWNO PLS_INTEGER;
BEGIN
  IGWNO:=PIGWNO;
  OPEN OUT_CURSOR FOR
  SELECT GWACC.GWNO AS GWNO,GWACC.PTACCUID AS PTACCUID,USR.USERID AS PTACCID,USR.USERPASSWORD AS PTACCPWD,
  GWACC.SPACCID AS SPACCID,GWACC.SPACCPWD AS SPACCPWD,GWACC.SPID AS SPID,GWACC.SERVICETYPE AS SERVICETYPE,
  GWACC.FEEUSERTYPE AS FEEUSERTYPE,GWACC.SPIP AS SPIP,GWACC.SPPORT AS SPPORT,GWACC.SPEEDLIMIT AS SPEEDLIMIT,
  GWACC.PROTOCOLCODE AS PROTOCOLCODE,GWACC.PROTOCOLPARAM AS PROTOCOLPARAM,GWACC.PTACCNAME AS PTACCNAME,
  GWACC.PTIP AS PTIP,GWACC.PTPORT AS PTPORT,GWACC.PTNODE FROM A_GWACCOUNT GWACC
  INNER JOIN USERDATA USR ON PTACCUID=USR."UID"
  WHERE GWACC.GWNO=(SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWNO=PIGWNO) AND USR.ACCOUNTTYPE=PISPTYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETGWCFG
--PROMPT =============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETGWCFG
 (
  PIGWNO          IN  NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
  IGWNO PLS_INTEGER;
BEGIN
  IGWNO := PIGWNO;
  OPEN OUT_CURSOR FOR
  SELECT GWNO,GWTYPE,PARAMITEM,PARAMVALUE FROM A_GWPARAMVALUE WHERE GWNO=IGWNO;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETKFPARAMS
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETKFPARAMS
 (
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT PARACODE,PARAVAL1,PARAVAL2 FROM KF_PARAMS;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETMSGIDMAP
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETMSGIDMAP(
PIMSGID IN VARCHAR2,
OUT_CURSOR OUT SYS_REFCURSOR)
IS
PISQL VARCHAR2(3000);
BEGIN
PISQL:='SELECT ID,PTMSGID,USERMSGID FROM A_SMSMSGIDMAP WHERE PTMSGID '||' IN('||PIMSGID||')';
OPEN OUT_CURSOR FOR PISQL;
END A_GETMSGIDMAP;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETPBSVRTYPE
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETPBSVRTYPE
 (
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT SPISUNCM,SERVICENO,SERVICEINFO FROM PB_SERVICETYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETPRECHBINDA
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETPRECHBINDA
 (
  PIUSERID        IN VARCHAR2,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT GT.PORTTYPE AS PORTTYPE,GT.SPGATE AS SPGATE,GT.CPNO AS CPNO,
  GT.FEEFLAG AS FEEFLAG,GT.SIGNSTR AS SIGNSTR,GT.SIGNLEN AS SIGNLEN,GT.ROUTEFLAG AS ROUTEFLAG,
  GT.MAXWORDS AS MAXWORDS,/*GT.SINGLELEN*/70 AS SINGLELEN,GT.MULTILEN1 AS MULTILEN1,
  GT.MULTILEN2 AS MULTILEN2,GT.SPISUNCM AS SPISUNCM,GT.MOBIAREA AS GATEAREA,GATE.AREATYPE AS AREATYPE,
  GT.ENSIGNSTR,GT.ENSIGNLEN,GT.ENMAXWORDS,GT.ENSINGLELEN,GT.ENMULTILEN1,GT.ENMULTILEN2
  FROM GT_PORT_USED GT
  INNER JOIN USERDATA USR ON USR.USERID=GT.USERID
  INNER JOIN XT_GATE_QUEUE GATE ON GATE.SPGATE=GT.SPGATE
  WHERE GT.USERID=UPPER(PIUSERID) AND USR.USERTYPE=0 AND GATE.STATUS=0 AND GT.STATUS=0
  AND GT.GATETYPE=PISPTYPE
  AND USR.ACCOUNTTYPE=PISPTYPE
  AND GATE.GATETYPE=PISPTYPE;
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE A_GETURLBIND
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETURLBIND
 (
  PIUID           IN NUMBER,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF (PIUID=0) THEN
     OPEN OUT_CURSOR FOR
     SELECT "UID",USERID,USERPASSWORD AS PWD,MTURL,
     CASE WHEN ((RTRIM(MOURL) IS NOT NULL) AND TRANSMOTYPE=2) THEN MOURL ELSE ' ' END AS MOURL,
     CASE WHEN ((RTRIM(RPTURL) IS NOT NULL) AND TRANSRPTYPE=2) THEN RPTURL ELSE ' ' END AS RPTURL
     FROM USERDATA WHERE USERTYPE=0 AND STATUS=0
     AND (((RTRIM(MOURL) IS NOT NULL) AND TRANSMOTYPE=2) OR ((RTRIM(RPTURL) IS NOT NULL) AND TRANSRPTYPE=2))
     AND ACCOUNTTYPE=PISPTYPE ORDER BY "UID";

  ELSE
     OPEN OUT_CURSOR FOR
     SELECT "UID",USERID,USERPASSWORD AS PWD,MTURL,
     CASE WHEN ((RTRIM(MOURL) IS NOT NULL) AND TRANSMOTYPE=2) THEN MOURL ELSE ' ' END AS MOURL,
     CASE WHEN ((RTRIM(RPTURL) IS NOT NULL) AND TRANSRPTYPE=2) THEN RPTURL ELSE ' ' END AS RPTURL
     FROM USERDATA WHERE "UID"=PIUID AND USERTYPE=0 AND STATUS=0
     AND (((RTRIM(MOURL) IS NOT NULL) AND TRANSMOTYPE=2) OR ((RTRIM(RPTURL) IS NOT NULL) AND TRANSRPTYPE=2))
     AND ACCOUNTTYPE=PISPTYPE ORDER BY "UID";
  END IF;
END;
/
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETUSRFEE
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE "A_GETUSRFEE"
 (
  PIUSERID        IN VARCHAR2,
  PIUID           IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT "UID",SENDNUM,USERID FROM USERFEE
  WHERE USERID=UPPER(PIUSERID) OR "UID"=PIUID;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETUSRINFO
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETUSRINFO
 (
  PIUSERID        IN VARCHAR2,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
    OPEN OUT_CURSOR FOR
    SELECT CASE WHEN B."UID" IS NULL THEN A."UID" ELSE B."UID" END AS SVRID,A."UID",A.USERID,A.USERTYPE,
    A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,A.STAFFNAME AS CORPNAME,
    A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.ACCOUNTTYPE,
    A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE
    FROM USERDATA A LEFT JOIN
    (SELECT "UID",USERID FROM USERDATA WHERE BITAND(USERPRIVILEGE,2) = 2
    AND USERDATA.ACCOUNTTYPE=PISPTYPE AND USERDATA.USERID=UPPER(PIUSERID)) B
    ON (A.LOGINID = B.USERID) OR B.USERID IS NULL
    WHERE A.USERID=UPPER(PIUSERID) AND A.STATUS=0 AND A.ACCOUNTTYPE=PISPTYPE AND ROWNUM<=1 ;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_GETUSRUID
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_GETUSRUID
 (
  PIUSERID        IN VARCHAR2,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT "UID" FROM USERDATA WHERE USERID=UPPER(PIUSERID);
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE A_LOADFEEINFOA
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADFEEINFOA
 (
  OUT_CURSOR OUT SYS_REFCURSOR
 )
 AS
 BEGIN
  OPEN OUT_CURSOR FOR
  SELECT "UID",USERID,SENDNUM FROM USERFEE ORDER BY "UID";
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADFORWARDBIND
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADFORWARDBIND
(
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT * FROM A_SMSFWDCONF;
END A_LOADFORWARDBIND;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADKEYWORDS
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADKEYWORDS
(
 PIID IN NUMBER,
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT ID,OPTTYPE,KEYWORD,0 AS KEYTYPE,0 AS KEYLEVEL FROM KEYWORD_BLACK WHERE ID>PIID AND KEYWORD<>' ';
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_LOADMTROUTE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADMTROUTE
 (
  PISPTYPE  IN NUMBER,
  OUT_CURSOR OUT SYS_REFCURSOR
 )
AS
BEGIN
    /*
  ENUM
  {
    ROUTE_FORCE=0,
    ROUTE_SUPPSEND,
    ROUTE_RESEND,
    ROUTE_SECTIONNO,
    ROUTE_PROPORTION
  };
  */

  OPEN OUT_CURSOR FOR
  SELECT USRSRC."UID" AS SRCUID,USRDEST."UID" AS DESTUID,NVL(GTDEST.FEEFLAG,1) AS FEEFLAG,
  ROUTE.EXNOHOLD AS EXNOHOLD,ROUTE.EXPIREDTM AS EXPIREDTM,/*USR3.ENDUID AS ENDUID,*/ ROUTE.SRCUSERID AS SRCUSERID,
  ROUTE.DESTUSERID AS DESTUSERID,ROUTE.ROUTETYPE AS ROUTETYPE,GTSRC.SPISUNCM AS GATETYPE,
  GTSRC.SPGATE AS SRCSPGATE,NVL(GTDEST.SPGATE,' ') AS DESTSPGATE,
  NVL(LTRIM(RTRIM(GTSRC.SPGATE))||LTRIM(RTRIM(GTSRC.CPNO)),' ') AS SRCSPNUMBER,
  NVL(LTRIM(RTRIM(GTDEST.SPGATE))||LTRIM(RTRIM(GTDEST.CPNO)),' ') AS DESTSPNUMBER,
  NVL(LTRIM(RTRIM(ROUTE.PARAMS)),' ') AS PARAMS,GTSRC.ID AS SRCCHANNELNO,GTDEST.ID AS DESTCHANNELNO
  FROM MT_ROUTETABLE ROUTE
  INNER JOIN USERDATA USRSRC ON USRSRC.USERID=ROUTE.SRCUSERID
  INNER JOIN USERDATA USRDEST ON USRDEST.USERID=ROUTE.DESTUSERID
  INNER JOIN GT_PORT_USED GTSRC ON ROUTE.SRCBINDID=GTSRC.ID AND GTSRC.STATUS=0
  INNER JOIN GT_PORT_USED GTDEST ON ROUTE.DESTBINDID=GTDEST.ID AND GTDEST.STATUS=0
  INNER JOIN XT_GATE_QUEUE GATEQUESRC ON GTSRC.SPGATE=GATEQUESRC.SPGATE AND GTSRC.SPISUNCM=GATEQUESRC.SPISUNCM
  INNER JOIN XT_GATE_QUEUE GATEQUEDEST ON GTDEST.SPGATE=GATEQUEDEST.SPGATE AND GTDEST.SPISUNCM=GATEQUEDEST.SPISUNCM
  WHERE GATEQUESRC.STATUS=0 AND GATEQUEDEST.STATUS=0
  AND USRSRC.ACCOUNTTYPE=PISPTYPE
  AND USRDEST.ACCOUNTTYPE=PISPTYPE
  AND GTSRC.GATETYPE=PISPTYPE
  AND GTDEST.GATETYPE=PISPTYPE
  AND GATEQUESRC.GATETYPE=PISPTYPE
  AND GATEQUEDEST.GATETYPE=PISPTYPE
  ORDER BY ROUTETYPE;
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE A_LOADPUSHBIND
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_LOADPUSHBIND
(
PISPTYPE IN NUMBER,
OUT_CURSOR OUT SYS_REFCURSOR
) IS
BEGIN
  OPEN OUT_CURSOR FOR SELECT PROBIND.USERUID AS USERUID, USERDATA.USERID AS USERID, PROCONF.PROTOCOLCODE AS PROTOCOLCODE,
  PROCONF.PROTOCOLNAME AS PROTOCOLNAME, PROCONF.PUSHURL AS PUSHURL, PROCONF.PUSHACCOUNT AS PUSHACCOUNT,
  PROCONF.PUSHPASSWD AS PUSHPASSWD, PROCONF.PUSHKEY AS PUSHKEY ,PROCONF.PUSHFLAG AS PUSHFLAG
  FROM  A_SMSPUSHBIND PROBIND
  INNER JOIN A_SMSPUSHCONF PROCONF  ON UPPER(PROBIND.PROTOCOLCODE)=UPPER(PROCONF.PROTOCOLCODE)
  INNER JOIN USERDATA ON USERDATA."UID" = PROBIND.USERUID AND USERDATA.ACCOUNTTYPE=PISPTYPE;
END A_LOADPUSHBIND;
/


--PROMPT
--PROMPT CREATING PROCEDURE A_RD_PROINFO
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_RD_PROINFO
 (
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT SERIALNUM,PROTYPE,PROSTATUS,STATUSINFO,VALIDDAYS,CORPNAME,SENDSPEED FROM A_PROINFO;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_SYNCUSRFEEA
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_SYNCUSRFEEA
 (
   PIUID      IN NUMBER,
   OUT_CURSOR OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIUID<=0 THEN
    OPEN OUT_CURSOR FOR
    SELECT 0 AS SENDNUM FROM DUAL;
  ELSE
    OPEN OUT_CURSOR FOR
    SELECT SENDNUM FROM USERFEE WHERE "UID" = PIUID;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_SYNCUSRFEEB
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_SYNCUSRFEEB
 (
  PIUID                   IN NUMBER,
  PILASTDBREMAINED        IN NUMBER,
  PIREMAINED              IN NUMBER,
  PIPREPAYUSED            IN NUMBER,
  PIPOSTPAYUSED           IN NUMBER,
  OUT_CURSOR              OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIUID>0 THEN
     IF PIPREPAYUSED <>0 OR PIPOSTPAYUSED <>0 THEN
       UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(USERFEE)*/ USERFEE NOLOGGING
       SET SENDNUM=SENDNUM-PIPREPAYUSED,SENDEDNUM=SENDEDNUM+PIPREPAYUSED,POSTPAYUSED=POSTPAYUSED+PIPOSTPAYUSED WHERE "UID" = PIUID;
     END IF;
     OPEN OUT_CURSOR FOR
     SELECT SENDNUM  FROM USERFEE WHERE "UID"=PIUID;
  ELSE
    OPEN OUT_CURSOR FOR
    SELECT 0 AS SENDNUM FROM DUAL;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_SYNCUSRFEEB
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_SYNCUSRFEEBV1
 (
  PIUID                   IN NUMBER,
  PILASTDBREMAINED        IN NUMBER,
  PIREMAINED              IN NUMBER,
  PIPREPAYUSED            IN NUMBER,
  PIPOSTPAYUSED           IN NUMBER,
  OUT_CURSOR              OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIUID>0 THEN
     IF PIPREPAYUSED <>0 OR PIPOSTPAYUSED <>0 THEN
       UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(USERFEE)*/ USERFEE NOLOGGING
       SET SENDNUM=SENDNUM-PIPREPAYUSED,SENDEDNUM=SENDEDNUM+PIPREPAYUSED,POSTPAYUSED=POSTPAYUSED+PIPOSTPAYUSED WHERE "UID" = PIUID;
     END IF;
     OPEN OUT_CURSOR FOR
     SELECT SENDNUM  FROM USERFEE WHERE "UID"=PIUID;
  ELSE
    OPEN OUT_CURSOR FOR
    SELECT 0 AS SENDNUM FROM DUAL;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_UPDCMDQUE
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_UPDCMDQUE
 (
  PIID            IN NUMBER,
  PIDEALSTATUS    IN NUMBER,
  PIRESULTCODE    IN VARCHAR2
 )
AS
BEGIN
  --正在处理中
  IF PIDEALSTATUS=2 THEN
    UPDATE A_CMDQUE SET DEALSTATUS=2 WHERE ID=PIID AND DEALSTATUS=1;
  --网关服务一分钟后未启动，命令写库，置状态为1(未处理)稍后再处理
  ELSIF PIDEALSTATUS=1 THEN
    UPDATE A_CMDQUE SET DEALSTATUS=1 WHERE ID=PIID AND DEALSTATUS=2;
  --处理完毕
  ELSIF PIDEALSTATUS=0 THEN
    INSERT INTO A_CMDQUE_HIS (ID,GWNO,GWTYPE,CMDTYPE,CMDINFO,CMDPARAM,DEALSTATUS,RESULTCODE,REQTIME)
    SELECT ID,GWNO,GWTYPE,CMDTYPE,CMDINFO,CMDPARAM,0 AS DEALSTATUS,PIRESULTCODE AS RESULTCODE,REQTIME
    FROM A_CMDQUE WHERE ID=PIID;
    DELETE FROM A_CMDQUE WHERE ID=PIID;
    --清除60天前的历史
    DELETE FROM A_CMDQUE_HIS WHERE DONETIME<SYSDATE-60;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_UPDNUMSECTION
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_UPDNUMSECTION
 (
  PINUMSECTION_IN   IN VARCHAR2
 )
AS
  PINUM0  VARCHAR2(2048); --移动
  PINUM1  VARCHAR2(2048); --联通
  PINUM21 VARCHAR2(2048); --电信
  PITMP1  VARCHAR2(2048); --临时
  PITMP2  VARCHAR2(2048); --临时
  PINUMSECTION VARCHAR2(2048);
  PISPLITSTR VARCHAR2(8); --分隔符
  PILOCATION PLS_INTEGER; --位置
  PISTART    PLS_INTEGER; --起始
  PITMPPOS   PLS_INTEGER; --临时位置
  PICOUNT    PLS_INTEGER; --计数
  PILEN      PLS_INTEGER; --长度
  PITMPLEN   PLS_INTEGER; --临时长度
BEGIN
  PISPLITSTR := ';';
  PILOCATION := 0;
  PISTART    := 0;
  PINUMSECTION := PISPLITSTR||PINUMSECTION_IN||PISPLITSTR;
  PILEN      := LENGTH(PINUMSECTION);
  PILOCATION := INSTR(PINUMSECTION,PISPLITSTR);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PINUMSECTION,PISPLITSTR,PISTART+1);
    IF PILOCATION > 0 THEN
      PITMP1 := SUBSTR(PINUMSECTION,PISTART+1,PILOCATION-PISTART-1);
      --DBMS_OUTPUT.PUT_LINE(PITMP1);
      IF (PITMP1 IS NOT NULL) THEN
        PITMPLEN := LENGTH(PITMP1);
        PITMPPOS := INSTR(PITMP1,',');
        IF (PITMPPOS > 0) THEN
          PITMP2 := SUBSTR(PITMP1,1,PITMPPOS-1);
          IF PITMP2='0' THEN
            PINUM0 := SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
            --DBMS_OUTPUT.PUT_LINE(PINUM0);
          ELSIF PITMP2='1' THEN
            PINUM1 := SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
            --DBMS_OUTPUT.PUT_LINE(PINUM1);
          ELSIF PITMP2='21'THEN
            PINUM21 := SUBSTR(PITMP1,PITMPPOS+1,PITMPLEN-PITMPPOS);
            --DBMS_OUTPUT.PUT_LINE(PINUM21);
          END IF;
        END IF;
      END IF;
    END IF;
  END LOOP;
  PICOUNT := 0;
  IF (PINUM0 IS NOT NULL) THEN
    SELECT COUNT(*) INTO PICOUNT FROM PB_SERVICETYPE WHERE SPISUNCM=0;
    IF PICOUNT > 0 THEN
      UPDATE PB_SERVICETYPE SET SERVICENO = PINUM0 WHERE SPISUNCM=0;
    ELSE
      INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (0,PINUM0,'移动号段');
    END IF;
  END IF;
  PICOUNT := 0;
  IF (PINUM1 IS NOT NULL) THEN
    SELECT COUNT(*) INTO PICOUNT FROM PB_SERVICETYPE WHERE SPISUNCM=1;
    IF PICOUNT > 0 THEN
      UPDATE PB_SERVICETYPE SET SERVICENO = PINUM1 WHERE SPISUNCM=1;
    ELSE
      INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (1,PINUM1,'联通号段');
    END IF;
  END IF;
  PICOUNT := 0;
  IF (PINUM21 IS NOT NULL) THEN
    SELECT COUNT(*) INTO PICOUNT FROM PB_SERVICETYPE WHERE SPISUNCM=21;
    IF PICOUNT > 0 THEN
      UPDATE PB_SERVICETYPE SET SERVICENO = PINUM21 WHERE SPISUNCM=21;
    ELSE
      INSERT INTO PB_SERVICETYPE (SPISUNCM,SERVICENO,SERVICEINFO) VALUES (21,PINUM21,'电信C网号段');
    END IF;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_WR_MSGIDMAP
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE A_WR_MSGIDMAP(
  PIPTMSGID IN NUMBER,
  PIUSERMSGID IN VARCHAR2)
  AS
PICNT NUMBER(11);
BEGIN
SELECT COUNT(PTMSGID)INTO PICNT FROM A_SMSMSGIDMAP WHERE PTMSGID=PIPTMSGID;
  IF (PICNT=0) THEN
  INSERT INTO A_SMSMSGIDMAP(PTMSGID, USERMSGID) VALUES(PIPTMSGID,PIUSERMSGID);
  END IF;
END A_WR_MSGIDMAP;
/

--PROMPT
--PROMPT CREATING PROCEDURE A_WR_PROINFO
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE A_WR_PROINFO
 (
  PISERIALNUM     IN VARCHAR2,
  PIPROTYPE       IN NUMBER,
  PIPROSTATUS     IN NUMBER,
  PIVALIDDAYS     IN NUMBER,
  PICORPNAME      IN VARCHAR2,
  PISTATUSINFO    IN VARCHAR2,
  PISENDSPEED     IN NUMBER
 )
AS
  ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT := 0;

  IF PISERIALNUM IS NULL THEN
    RETURN;
  END IF;

  DELETE FROM A_PROINFO WHERE SERIALNUM<>PISERIALNUM;
  SELECT COUNT(*) INTO ICOUNT FROM A_PROINFO WHERE SERIALNUM=PISERIALNUM;
  IF ICOUNT<=0 THEN
    INSERT INTO A_PROINFO(SERIALNUM,PROTYPE,PROSTATUS,VALIDDAYS,STATUSINFO,CORPNAME,SENDSPEED) VALUES(PISERIALNUM,PIPROTYPE,PIPROSTATUS,PIVALIDDAYS,PISTATUSINFO,PICORPNAME,PISENDSPEED);
  ELSE
    UPDATE A_PROINFO SET PROTYPE=PIPROTYPE,PROSTATUS=PIPROSTATUS,VALIDDAYS=PIVALIDDAYS,STATUSINFO=PISTATUSINFO,CORPNAME=PICORPNAME,SENDSPEED=PISENDSPEED;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE COMPILE_PROCEDURE
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE PROCEDURE COMPILE_PROCEDURE
AS
V_SQL VARCHAR2(2000);
BEGIN

  FOR V IN (SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE IN ('PROCEDURE','TRIGGER') AND STATUS='INVALID' AND OBJECT_NAME NOT LIKE '%BIN$%')
    LOOP
      V_SQL:= 'ALTER  '||V.OBJECT_TYPE||' '|| V.OBJECT_NAME||' COMPILE';
      EXECUTE IMMEDIATE V_SQL;
      DBMS_OUTPUT.PUT_LINE(V_SQL);
    END LOOP;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE H_DELETETASK
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE H_DELETETASK(MININDEX IN NUMBER,MAXINDEX IN NUMBER,PROCESSFLAG IN NUMBER,LOTSIZE IN NUMBER) IS
BEGIN
  --------------------VER 3.0-------------------------------------
        --DELETE /*+RULE*/  FROM MT_TASK M  WHERE (M.ID BETWEEN MININDEX AND MAXINDEX);
        DELETE /*+RULE*/  FROM MT_TASK M  WHERE (M.ID <= MAXINDEX) ;
END H_DELETETASK;
/

--PROMPT
--PROMPT CREATING PROCEDURE H_PROCESSSTATUS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE H_PROCESSSTATUS(CUSEID          IN NUMBER,
                                                  CUR       IN NUMBER,
                                                  MAXI       IN NUMBER,
                                                  COUNTS    IN NUMBER,
                                                  DISTRACTS IN NUMBER,
                                                  DELETES   IN NUMBER) IS
ISEXIT NUMBER;
BEGIN
     ISEXIT := 0;
     SELECT COUNT(USEID) INTO ISEXIT FROM PROCESSINGSTATUS WHERE USEID=CUSEID;
     IF(ISEXIT = 0) THEN
               INSERT INTO PROCESSINGSTATUS(USEID,CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS ,DELETESTATUS)
                VALUES(CUSEID,CUR,MAXI,COUNTS,DISTRACTS,DELETES);
      ELSE
                UPDATE PROCESSINGSTATUS SET CURRINDEX=CUR, MAXINDEX=MAXI,COUNTSTATUS=COUNTS,DISTRACTSTATUS=DISTRACTS ,DELETESTATUS=DELETES
                WHERE USEID=CUSEID;
      END IF;
END H_PROCESSSTATUS;
/

CREATE OR REPLACE PROCEDURE H_STATISTICS(PROCESSFLAG IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11),
        BATCHID NUMBER(22),
        AREACODE NUMBER(11)

 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计

 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA,
               BATCHID,
               AREACODE
               FROM MT_TASK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,SENDTYPE,MOBILEAREA,BATCHID,AREACODE,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
          --DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --插入或更新统计表
       STR:='DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MT_DATAREPORT M
       (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
       SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,
       (T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA,T.BATCHID,T.AREACODE FROM '|| TABLENAME ||'  T';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;

END H_STATISTICS;
/

CREATE OR REPLACE PROCEDURE H_MMSSTATISTICS(PROCESSFLAG IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11)
 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计
 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
              NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA
               FROM MMS_TASK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,SENDTYPE,MOBILEAREA,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
            --DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
--插入或更新统计表

       STR:= 'DELETE FROM MMS_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MMS_DATAREPORT
         (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA)
         SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA FROM '||TABLENAME||' T' ;

 --DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;

END H_MMSSTATISTICS;
/


--PROMPT
--PROMPT CREATING PROCEDURE PRO_INDEX_REBUILD
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE PROCEDURE PRO_INDEX_REBUILD
AS

INDEX_USAGE NUMBER;--索引的使用，值大于20时，需要重整索引
STR VARCHAR2(200);
EXCEPTION_NUMBER  NUMBER;--允许的异常数量
BEGIN

     EXCEPTION_NUMBER:=10;

     FOR EC IN
      (SELECT INDEX_NAME,TABLE_NAME FROM USER_INDEXES)
      LOOP
      --错误后重复尝试
     <<LABEL_PRE_ERROR>>
        BEGIN

        --分析索引的数据库是否有坏块，分析并且得到数据
        STR:='ANALYZE INDEX '|| EC.INDEX_NAME ||'  VALIDATE STRUCTURE';
        EXECUTE IMMEDIATE STR;

        --获取索引的使用信息
        SELECT NVL(MAX((DEL_LF_ROWS_LEN/LF_ROWS_LEN)*100),0) INTO INDEX_USAGE  FROM INDEX_STATS ;

        IF INDEX_USAGE >=2 THEN--判断是否需要重整索引

          --当索引的使用率大于2%时，需要重整索引
          STR:=' ALTER INDEX ' || EC.INDEX_NAME||'  REBUILD';
          EXECUTE IMMEDIATE STR;

          --分析索引
          STR:='ANALYZE INDEX '|| EC.INDEX_NAME ||' COMPUTE STATISTICS';
          EXECUTE IMMEDIATE STR;--分析索引

          --分析表
          STR:= 'ANALYZE TABLE '||EC.TABLE_NAME||'  ESTIMATE STATISTICS SAMPLE 40 PERCENT FOR ALL INDEXES ';
          EXECUTE IMMEDIATE STR;

          END IF;

           EXCEPTION WHEN OTHERS THEN
         EXCEPTION_NUMBER      := EXCEPTION_NUMBER - 1;
                                  DBMS_OUTPUT.PUT_LINE('您还有'||EXCEPTION_NUMBER||'次(重整索引统计数据信息的)机会,共'||EXCEPTION_NUMBER||'次机会');
                                  IF(EXCEPTION_NUMBER <=0 ) THEN
                                     RETURN;
                                  ELSE
                                      GOTO LABEL_PRE_ERROR;
                                  END IF;
         END;
    END LOOP;

END;
/



CREATE OR REPLACE PROCEDURE H_MMSDELETETASK(MININDEX IN NUMBER,MAXINDEX IN NUMBER,PROCESSFLAG IN NUMBER,LOTSIZE IN NUMBER) IS
BEGIN
  --------------------VER 3.0-------------------------------------
        DELETE /*+RULE*/  FROM MMS_TASK M  WHERE (M.ID <= MAXINDEX) ;
END H_MMSDELETETASK;
/

--PROMPT
--PROMPT CREATING PROCEDURE H_RESTATISTICS
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE H_RESTATISTICS
  (
    PIYEAR  IN NUMBER,
    PIMONTH IN NUMBER,
    PIDAY   IN NUMBER
    )
AUTHID CURRENT_USER
IS
  STR VARCHAR2(4000);
  PITABLENAME VARCHAR2(64);
  TABLENAME VARCHAR2(20);
  ISEXIST NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表
  IF PIMONTH>9 THEN
    PITABLENAME :='MTTASK'||TO_CHAR(PIYEAR)||TO_CHAR(PIMONTH);
  ELSE
    PITABLENAME :='MTTASK'||TO_CHAR(PIYEAR)||'0'||TO_CHAR(PIMONTH);
  END IF;

  STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11),
        BATCHID NUMBER(22),
        AREACODE NUMBER(11)
     )';
  EXECUTE IMMEDIATE STR;

  STR :='INSERT INTO  '|| TABLENAME ||' SELECT USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,
           TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
           TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
           TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
           TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
           COUNT(ID),
           NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
           NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
           NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
           SENDTYPE,
           MOBILEAREA,
           BATCHID,
           AREACODE
           FROM '|| PITABLENAME ||
           ' WHERE TO_NUMBER(TO_CHAR(SENDTIME,''DD''))='||PIDAY||' OR 0='||PIDAY||
           ' GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE,P1,P2,P3,P4,SENDTYPE,MOBILEAREA,BATCHID,AREACODE,
           TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
           TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
           TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
           TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';

  EXECUTE IMMEDIATE STR;

  --插入或更新统计表
       STR:='MERGE INTO MT_DATAREPORT M
          USING  '|| TABLENAME ||'  T
          ON(M.USERID   = T.USERID AND
             M.TASKID   = T.TASKID AND
             M.IYMD     = T.IYMD AND
             M.SPGATE   = T.SPGATE AND
             M.SPISUNCM = T.SPISUNCM AND
             M.SPID     = T.SPID AND
             M.SVRTYPE  = T.SVRTYPE AND
             M.P1       = T.P1 AND
             M.P2       = T.P2 AND
             M.P3       = T.P3 AND
             M.P4       = T.P4 AND
             M.IHOUR    = T.IHOUR AND
             M.Y        = T.IYEAR AND
             M.IMONTH   = T.IMONTH AND
             M.SENDTYPE = T.SENDTYPE AND
             M.MOBILEAREA = T.MOBILEAREA AND
             M.BATCHID    = T.BATCHID AND
             M.AREACODE = T.AREACODE
             )
          WHEN MATCHED THEN
               UPDATE SET M.ICOUNT=T.ICOUNT,M.RSUCC=T.SUCC,M.RFAIL1=T.FAIL,M.RFAIL2=(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),M.RNRET=T.NRET
          WHEN NOT MATCHED THEN
               INSERT (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,
               RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
               VALUES(T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,
               T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA,T.BATCHID,T.AREACODE)';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE INSERTMTREPORT_SP
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE PROCEDURE INSERTMTREPORT_SP(USERID_ IN VARCHAR2,
                                       RPTSTR IN VARCHAR2) IS

   IYMD_     NUMBER;                   --月份
   SPGATE_   VARCHAR2(21);             --通道号
   SPISUNCM_ NUMBER;                   --运营商
   ICOUNT_   NUMBER;                   --发送总数
   ISUCC_    NUMBER;                   --成功数
   IFAIL_    NUMBER;                   --失败数
   ISFIND    NUMBER;                   --存在状态: >0存在
BEGIN
    --初始化
    ISFIND := 0;
    IF (LENGTH(USERID_)>0) AND (LENGTH(RPTSTR)>0) THEN
    BEGIN
          --先拆分数据
          IYMD_      := TO_NUMBER(SUBSTR(RPTSTR,0,8));
          SPGATE_    := SUBSTR(RPTSTR,10,INSTR(RPTSTR,',',1,2)-10);
          SPISUNCM_  := TO_NUMBER(SUBSTR(RPTSTR,INSTR(RPTSTR,',',1,2)+1,1));
          ICOUNT_    := TO_NUMBER(SUBSTR(RPTSTR,INSTR(RPTSTR,',',1,3)+1,INSTR(RPTSTR,',',1,4)-INSTR(RPTSTR,',',1,3)-1));
          ISUCC_     := TO_NUMBER(SUBSTR(RPTSTR,INSTR(RPTSTR,',',1,4)+1,INSTR(RPTSTR,',',1,5)-INSTR(RPTSTR,',',1,4)-1));
          IFAIL_     := TO_NUMBER(SUBSTR(RPTSTR,INSTR(RPTSTR,',',1,5)+1,LENGTH(RPTSTR)-INSTR(RPTSTR,',',1,5)));

          --先判断是否存在
          SELECT COUNT(*) INTO ISFIND FROM MT_DATAREPORT_SP M WHERE M.IYMD = IYMD_  AND M.USERID = USERID_ AND  M.SPGATE = SPGATE_ AND M.SPISUNCM = SPISUNCM_ ;
          IF (ISFIND = 0) THEN
            INSERT INTO  MT_DATAREPORT_SP(IYMD,USERID,SPGATE,SPISUNCM,ICOUNT,ISUCC,IFAIL,UPDATETIME) VALUES(IYMD_,USERID_,SPGATE_,SPISUNCM_,ICOUNT_,ISUCC_,IFAIL_,SYSDATE);
          ELSE
             UPDATE MT_DATAREPORT_SP SET  ICOUNT = ICOUNT_,  ISUCC = ISUCC_,  IFAIL = IFAIL_, UPDATETIME = SYSDATE WHERE  IYMD   = IYMD_   AND  USERID = USERID_ AND  SPGATE = SPGATE_ AND SPISUNCM = SPISUNCM_;
          END IF;

    END;
    END IF;
END INSERTMTREPORT_SP;
/

--PROMPT
--PROMPT CREATING PROCEDURE LOADPROCERRCODE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE LOADPROCERRCODE
(
PIPROTOCOLTYPE IN VARCHAR2,
OUT_CURSOR OUT SYS_REFCURSOR
)
AS
PICNT NUMBER;
BEGIN
PICNT:=0;
SELECT COUNT(*) INTO PICNT FROM HTTPERRCODE WHERE PROTOCOLTYPE = PIPROTOCOLTYPE ;
  IF(PICNT=0)THEN
  OPEN OUT_CURSOR FOR SELECT ERRSTATUS,PROTOCOLTYPE,ERRCODE,DESCRPTINFO FROM HTTPERRCODE ;
  ELSE
  OPEN OUT_CURSOR FOR SELECT ERRSTATUS,PROTOCOLTYPE,ERRCODE,DESCRPTINFO FROM HTTPERRCODE WHERE PROTOCOLTYPE = PIPROTOCOLTYPE ;
  END IF;
END ;
/

--PROMPT
--PROMPT CREATING PROCEDURE MMS_RD_BMTREQ
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE MMS_RD_BMTREQ
  (
     PIMAXREADCNT IN NUMBER,
     OUT_CURSOR   OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(5000);
BEGIN
  PISQLSTR := 'SELECT ID,MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,TASKID,TITLE,TMPLID,MSG,
    MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SENDSTATUS,ERRORCODE,TO_CHAR(RECVTIME,''YYYY-MM-DD HH24:MI:SS'') AS RECVTIME,
    TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS'') AS SENDTIME,SENDTYPE,ATTIMEFLAG,SA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG
  FROM MMS_BMTREQ WHERE SENDSTATUS=1 AND ROWNUM<='||PIMAXREADCNT||' ORDER BY SENDLEVEL';
  OPEN OUT_CURSOR FOR PISQLSTR;
END MMS_RD_BMTREQ;
/

--PROMPT
--PROMPT CREATING PROCEDURE MMS_UPD_BMTREQ
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE MMS_UPD_BMTREQ(
  PIID IN NUMBER,
  PISENDSTATUS IN NUMBER,
  PITASKID IN NUMBER,
  PIMSGID IN NUMBER,
  PIERRORCODE IN VARCHAR2,
  PIBMTMSGID IN NUMBER:=0,
  PIPTMSGIDSTR IN VARCHAR2:='',
  PIPTMSGID IN NUMBER:=0
  )
AS
BEGIN
  IF PISENDSTATUS=1 THEN
    UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,MSGID=0,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
    -- 已读取待处理
  ELSIF PISENDSTATUS=2 THEN
    UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,MSGID=PIMSGID,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
    -- 请求有误,停止该处理该请求
  ELSIF PISENDSTATUS=3 THEN
    UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
    -- 该请求所对应的文件已下载完毕，正在发送中
  ELSIF PISENDSTATUS=4 THEN
    UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
  -- 请求有误,停止该处理该请求
  ELSIF PISENDSTATUS=5 THEN
    UPDATE MMS_BMTREQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
  --
  ELSIF PISENDSTATUS=6 THEN
  BEGIN
    UPDATE MMS_BMTREQ SET MSGID=PIPTMSGID,SENDSTATUS=PISENDSTATUS,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
        UPDATE MMS_LEVEL_QUEUE SET SENDSTATUS=1
               WHERE SENDSTATUS=10 AND INSTR(PIPTMSGIDSTR, CAST(PTMSGID AS VARCHAR2(30)))>0;
  END;
  ELSIF PISENDSTATUS=0 THEN
  BEGIN
    UPDATE MMS_BMTREQ SET MSGID=PIPTMSGID,SENDSTATUS=PISENDSTATUS,SENDTIME=SYSTIMESTAMP
    WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
        UPDATE MMS_LEVEL_QUEUE SET SENDSTATUS=1
               WHERE SENDSTATUS=10 AND INSTR(PIPTMSGIDSTR, CAST(PTMSGID AS VARCHAR2(30)))>0;
    INSERT INTO MMS_BMTREQHIS(MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,
                    TASKID,TITLE,TMPLID,MSG,MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,
                    SENDSTATUS,ERRORCODE,RECVTIME,SENDTIME,SENDTYPE,ATTIMEFLAG,SA,
                    SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG)
        SELECT MSGID,BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,MSGTYPE,TASKID,TITLE,TMPLID,MSG,
               MSGFMT,REMOTEURL,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,SENDSTATUS,ERRORCODE,RECVTIME,
               SENDTIME,SENDTYPE,ATTIMEFLAG,SA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG
        FROM MMS_BMTREQ WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
    DELETE FROM MMS_BMTREQ WHERE ID=PIID AND BMTMSGID=PIBMTMSGID;
  END;
  END IF;
END MMS_UPD_BMTREQ;
/

--PROMPT
--PROMPT CREATING PROCEDURE MMS_WR_LVLQUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE MMS_WR_LVLQUE
(
  PIPTMSGID     IN   NUMBER,
  PIUID         IN    NUMBER,
  PILOGINID     IN   VARCHAR2,
  PIDEALSTATUS  IN   NUMBER,
  PIUSERID      IN   VARCHAR2 ,
  PISA          IN   VARCHAR2,
  PIRETFLAG     IN  NUMBER,
  PIPHONECOUNT  IN  NUMBER,
  PIUNICOM      IN  NUMBER,
  PISENDSTATUS  IN  NUMBER,
  PISENDLEVEL   IN   NUMBER,
  PISENDTIME_P  IN   VARCHAR2,
  PIMSGFMT      IN   NUMBER,
  PIMSGTYPE     IN   NUMBER,
  PITASKID      IN   NUMBER,
  PIMSGTITLE    IN   VARCHAR2 ,
  PITMPLID      IN  NUMBER,
  PIMESSAGE     IN   VARCHAR2 ,
  PIPHONE       IN  VARCHAR2 ,
  PISVRTYPE     IN   VARCHAR2 :='',
  PIP1          IN  VARCHAR2 :='',
  PIP2          IN    VARCHAR2 :='',
  PIP3          IN   VARCHAR2 :='',
  PIP4          IN   VARCHAR2 :='',
  PIUSERMSGID   IN   NUMBER :=0,
  PIMODULEID    IN   NUMBER :=0,
  PIATTIME      IN   NUMBER :=0,
  PIVALIDTIME   IN   NUMBER :=0
)
AS
  PILOGINUID INT;
  PICOUNTSP1 PLS_INTEGER;
  PICOUNTSP2 PLS_INTEGER;
  PICOUNTSP3 PLS_INTEGER;
  PICOUNTPT  PLS_INTEGER;
  PISENDTIME TIMESTAMP(6);
BEGIN
   IF PISENDTIME_P IS NULL THEN
      PISENDTIME:=SYSTIMESTAMP;
   ELSE
      PISENDTIME:=TO_TIMESTAMP(PISENDTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
   END IF;

   SELECT COUNT(SPGATE) INTO PICOUNTSP1 FROM  GT_PORT_USED WHERE USERID=PIUSERID AND SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2;
   SELECT COUNT(SPGATE) INTO PICOUNTSP2 FROM XT_GATE_QUEUE WHERE SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2;
   SELECT COUNT(SPGATE) INTO PICOUNTSP3 FROM  GT_PORT_USED WHERE USERID=PIUSERID AND STATUS=0 AND GATETYPE=2;
   --SELECT COUNT(SPGATE) INTO PICOUNTSP2 FROM  GT_PORT_USED WHERE USERID=PIUSERID AND STATUS=0 AND GATETYPE=2;
  -- 该用户存绑定了对应通道且是激活状态
  IF PICOUNTSP1>0 THEN
  BEGIN
    SELECT COUNT(PTMSGID) INTO PICOUNTPT FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID;
    IF PICOUNTPT=0 THEN
       INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,"UID",DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
       UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
       SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
       SELECT PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,CPNO,PISA,PIRETFLAG,
       PIPHONECOUNT,PIUNICOM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
       PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
       PIMODULEID,PIATTIME,PIVALIDTIME
       FROM GT_PORT_USED WHERE USERID=PIUSERID AND SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2 AND ROWNUM<=1 ORDER BY ID DESC;
    END IF;
  END;
    -- 绑定了彩信通道，但没有对应运营商类型的 先随意取对应运营商通道

    ELSIF PICOUNTSP2>0 THEN
    BEGIN
      SELECT COUNT(PTMSGID) INTO PICOUNTPT FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID;
      IF PICOUNTPT=0 THEN
         INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,"UID",DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
         UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
         SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
         SELECT  PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,' ',PISA,PIRETFLAG,
         PIPHONECOUNT,PIUNICOM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
         PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
         PIMODULEID,PIATTIME,PIVALIDTIME
         FROM XT_GATE_QUEUE WHERE SPISUNCM=PIUNICOM AND STATUS=0 AND GATETYPE=2 AND ROWNUM<=1 ORDER BY ID DESC;
      END IF;
    END;
  -- 绑定了彩信通道，但没有对应运营商类型的
  ELSIF PICOUNTSP3>0 THEN
  BEGIN
    SELECT COUNT(PTMSGID) INTO PICOUNTPT FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID;
    IF PICOUNTPT=0 THEN
       INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,"UID",DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
       UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
       SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
       SELECT   PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,SPGATE,CPNO,PISA,PIRETFLAG,
       PIPHONECOUNT,SPISUNCM,PISENDSTATUS,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
       PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
       PIMODULEID,PIATTIME,PIVALIDTIME
       FROM GT_PORT_USED WHERE USERID=PIUSERID AND STATUS=0 AND GATETYPE=2 AND ROWNUM<=1 ORDER BY ID DESC;
    END IF;
  END;
  --该用户没有绑相应运营商类型的通道，设置发送状态为9
  ELSE
  BEGIN
    SELECT COUNT(PTMSGID) INTO  PICOUNTPT FROM MMS_LEVEL_QUEUE WHERE PTMSGID=PIPTMSGID;
    IF PICOUNTPT=0 THEN
    INSERT INTO MMS_LEVEL_QUEUE(PTMSGID,"UID",DEALSTATUS,USERID,SPGATE,CPNO,SA,RETFLAG,PHONECOUNT,
    UNICOM,SENDSTATUS,SENDLEVEL,SENDTIME,MSGFMT,MSGTYPE,TASKID,MSGTITLE,TMPLID,MESSAGE,PHONE,
    SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME)
    VALUES(PIPTMSGID,PIUID,PIDEALSTATUS,PIUSERID,' ',' ',PISA,PIRETFLAG,
    PIPHONECOUNT,PIUNICOM,9,PISENDLEVEL,PISENDTIME,PIMSGFMT,PIMSGTYPE,PITASKID,
    PIMSGTITLE,PITMPLID,PIMESSAGE,PIPHONE,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,
    PIMODULEID,PIATTIME,PIVALIDTIME);
    END IF;
  END;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE M_WR_MONINFO
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE M_WR_MONINFO
( INFOTYPE IN NUMBER,       --编号
  MONINFO IN VARCHAR2       --(5120) --传入的值--RETURNSTR OUT VARCHAR2
 )  IS
 PISTRSQL  VARCHAR2(5120);         --返回的SQL语句
 PIMONSTR       VARCHAR2(5120); --传人的字符串
 PISUBSTR    VARCHAR2(5120); --截取的字符串
 NCOUNT1    NUMBER(11);
 NCOUNT2    NUMBER(11);

BEGIN
 -----------------------------------维护表M_MON_USERINFO,帐号为主键,存在更新/不存在插入--------------------------------------
  --SET FEEDBACK OFF;
  IF INFOTYPE=130 THEN
     PIMONSTR:=MONINFO ;
     PISUBSTR:=SUBSTRINGPRIKEY(PIMONSTR,2);
    SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_USERINFO WHERE USERID=PISUBSTR;

     IF NCOUNT1>0  THEN   --判断主键是否存在
      PISTRSQL:=BUILDUPDATESQL('M_MON_USERINFO',
      'PTCODE#USERID#USERUID#USERNAME#USERPRIVILEGE#JTYPE#LINKNUM#LOGINIP#ONLINESTATUS#USERFEE#FIXFAILURERATE#FAILURENUM#FAILURERATE#BINDINFO#MTTOTALSND#MTHAVESND#MTREMAINED#MTSNDINFO#MTSNDSPD#MOTOTALRECV#MOREMAINED#MORPTRECVSPD#MOTMOUTCNT#RPTTOTALRECV#RPTREMAINED#RPTTMOUTCNT#LOGININTM#LOGINOUTTM#UPDATETIME'
      ,PIMONSTR,'WHERE USERID='''||PISUBSTR||'''');

      ELSE
          PISTRSQL:= BUILDINSERTSQL('M_MON_USERINFO',
          'PTCODE#USERID#USERUID#USERNAME#USERPRIVILEGE#JTYPE#LINKNUM#LOGINIP#ONLINESTATUS#USERFEE#FIXFAILURERATE#FAILURENUM#FAILURERATE#BINDINFO#MTTOTALSND#MTHAVESND#MTREMAINED#MTSNDINFO#MTSNDSPD#MOTOTALRECV#MOREMAINED#MORPTRECVSPD#MOTMOUTCNT#RPTTOTALRECV#RPTREMAINED#RPTTMOUTCNT#LOGININTM#LOGINOUTTM#UPDATETIME'
         ,PIMONSTR);
      END IF;
  --BEGIN
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;
----------------------------------维护表M_MON_SPGATEINFO,帐号为主键,存在更新/不存在插入 -----------------------------
 ELSIF INFOTYPE=131 THEN

     PIMONSTR:=MONINFO;
     PISUBSTR:=SUBSTRINGPRIKEY(PIMONSTR,2);
     SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_SPGATEINFO WHERE USERID=PISUBSTR;

     IF NCOUNT1 >0  THEN  --判断主键是否存在
      PISTRSQL:=BUILDUPDATESQL('M_MON_SPGATEINFO',
      'PTCODE#USERID#USERUID#USERNAME#JTYPE#LINKNUM#LOGINIP#ONLINESTATUS#MTHAVESND#MTREMAINED#MTRECVSPD#MOTOTALRECV#MOHAVESND#MOREMAINED#MOSNDSPD#RPTTOTALRECV#RPTHAVESND#RPTREMAINED#RPTSNDSPD#SNDERCNT#LASTSNDERTM#LOGININTM#LOGINOUTTM#UPDATETIME'
      ,PIMONSTR,'WHERE USERID='''||SUBSTRINGPRIKEY(PIMONSTR,2)||'''');

    ELSE

         PISTRSQL:=BUILDINSERTSQL('M_MON_SPGATEINFO',
          'PTCODE#USERID#USERUID#USERNAME#JTYPE#LINKNUM#LOGINIP#ONLINESTATUS#MTHAVESND#MTREMAINED#MTRECVSPD#MOTOTALRECV#MOHAVESND#MOREMAINED#MOSNDSPD#RPTTOTALRECV#RPTHAVESND#RPTREMAINED#RPTSNDSPD#SNDERCNT#LASTSNDERTM#LOGININTM#LOGINOUTTM#UPDATETIME'
          ,PIMONSTR);
     END IF;
  --BEGIN
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;
----------------------------------维护表DBO.M_MON_THREADINFO,THRID为主键,存在更新/不存在插入 -----------------------------
 ELSIF INFOTYPE=132 THEN

     PIMONSTR:=MONINFO;
     PISUBSTR:=SUBSTRINGPRIKEY(PIMONSTR,2);
     SELECT COUNT(*) INTO NCOUNT1  FROM M_MON_THREADINFO WHERE THRID=PISUBSTR;

     IF NCOUNT1 >0  THEN  --判断主键是否存在
      PISTRSQL:=BUILDUPDATESQL('M_MON_THREADINFO',
      'PTCODE#THRID#THRNAME#THRSTATUS#ERRORCNT#LASTERRORTM#THRLOGS#LASTRUNTM#THISRUNTM#UPDATETIME'
      ,PIMONSTR,'WHERE THRID='''||SUBSTRINGPRIKEY(PIMONSTR,2)||'''');
      ELSE
         PISTRSQL:=BUILDINSERTSQL('M_MON_THREADINFO',
         'PTCODE#THRID#THRNAME#THRSTATUS#ERRORCNT#LASTERRORTM#THRLOGS#LASTRUNTM#THISRUNTM#UPDATETIME'
          ,PIMONSTR);
      END IF;

  --BEGIN
  DBMS_OUTPUT.PUT_LINE(PISTRSQL);
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;
------------------------------------维护表M_MON_BUFINFO,原则上只有一条记录，存在更新，不存在插入 -----------------------------
 ELSIF INFOTYPE=133 THEN

     PIMONSTR:=MONINFO;
     SELECT COUNT(*) INTO NCOUNT2 FROM M_MON_BUFINFO;

     IF NCOUNT2>0 THEN   --有记录更新,无记录插入
      PISTRSQL:=BUILDUPDATESQL('M_MON_BUFINFO',
      'PTCODE#ENDCNT#MOTOTALRECV#MTTOTALSND#WRMOBUF#UPDMOBUF#UPDRPTBUF#WRRPTBUF#ENDRSPBUF#SMTSNDBUF#NMTSNDBUF#MTWAITBUF#PRECNT#MTTOTALRECV#MOTOTALSND#WRMTTASKBUF#WRMTTMBUF#WRMTVFYBUF#WRMTLVLBUF#PRERSPBUF#PRERSPTMPBUF#MOSNDBUF#RPTSNDBUF#MORPTWAITBUF#LOGFILENUM#LOGBUF#RECVBUF#RESNDBUF#SUPPSNDBUF#MONLOGBUF#UPDATETIME'
      ,PIMONSTR,'WHERE 1=1');
      ELSE
         PISTRSQL:=BUILDINSERTSQL('M_MON_BUFINFO',
         'PTCODE#ENDCNT#MOTOTALRECV#MTTOTALSND#WRMOBUF#UPDMOBUF#UPDRPTBUF#WRRPTBUF#ENDRSPBUF#SMTSNDBUF#NMTSNDBUF#MTWAITBUF#PRECNT#MTTOTALRECV#MOTOTALSND#WRMTTASKBUF#WRMTTMBUF#WRMTVFYBUF#WRMTLVLBUF#PRERSPBUF#PRERSPTMPBUF#MOSNDBUF#RPTSNDBUF#MORPTWAITBUF#LOGFILENUM#LOGBUF#RECVBUF#RESNDBUF#SUPPSNDBUF#MONLOGBUF#UPDATETIME'
          ,PIMONSTR);
     END IF;
  --BEGIN
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;
------------------------------------维护表M_MON_SYSINFO,原则上只有一条记录，存在更新，不存在插入 -----------------------------
 ELSIF INFOTYPE=134 THEN

    PIMONSTR:=MONINFO;
    SELECT COUNT(*) INTO NCOUNT2 FROM M_MON_SYSINFO;

     IF NCOUNT2>0 THEN    --有记录更新,无记录插入
      PISTRSQL:=BUILDUPDATESQL('M_MON_SYSINFO',
      'PTCODE#CPUUSAGE#MEMUSAGE#VMEMUSAGE#DISKFREESPACE#UPDATETIME'
      ,PIMONSTR,'WHERE 1=1');

     ELSE
         PISTRSQL:=BUILDINSERTSQL('M_MON_SYSINFO',
         'PTCODE#CPUUSAGE#MEMUSAGE#VMEMUSAGE#DISKFREESPACE#UPDATETIME'
          ,PIMONSTR);
     END IF;
  --BEGIN
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;

--------------------------------------维护表M_MON_LOGINFO,持续插入,一小时清空一次(清空动作由上层页面完成) -----------------------------
  ELSIF INFOTYPE=135 THEN

     PIMONSTR:=MONINFO;
         PISTRSQL:=BUILDINSERTSQL('M_MON_LOGINFO','PTCODE#LOGTYPE#LOGS',PIMONSTR);
  --BEGIN
  EXECUTE   IMMEDIATE PISTRSQL;   --EXEC (PISTRSQL);
  --END;
------------------------------监控信息转移到监控历史表中---------------------
ELSIF INFOTYPE=254 THEN
      INSERT INTO  M_MON_USER_HIS( PTCODE,USERID,USERUID,USERNAME,USERPRIVILEGE,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,USERFEE,FIXFAILURERATE,
                               FAILURENUM,FAILURERATE,BINDINFO,MTTOTALSND,MTHAVESND,MTREMAINED,MTSNDINFO,MTSNDSPD,MOTOTALRECV,MOREMAINED,
                 MORPTRECVSPD,MOTMOUTCNT,RPTTOTALRECV,RPTREMAINED,RPTTMOUTCNT,LOGININTM ,LOGINOUTTM,UPDATETIME)
                 SELECT PTCODE,USERID,USERUID,USERNAME,USERPRIVILEGE,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,USERFEE,
                 FIXFAILURERATE,FAILURENUM,FAILURERATE,BINDINFO,MTTOTALSND,MTHAVESND,MTREMAINED,MTSNDINFO,MTSNDSPD,
                 MOTOTALRECV,MOREMAINED,MORPTRECVSPD,MOTMOUTCNT,RPTTOTALRECV,RPTREMAINED,RPTTMOUTCNT,LOGININTM ,LOGINOUTTM,UPDATETIME
                 FROM  M_MON_USERINFO;

      INSERT INTO  M_MON_SPGATE_HIS(PTCODE,USERID,USERUID,USERNAME,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,MTHAVESND,MTREMAINED,MTRECVSPD,MOTOTALRECV,
                                MOHAVESND,MOREMAINED,MOSNDSPD,RPTTOTALRECV,RPTHAVESND,RPTREMAINED,RPTSNDSPD,SNDERCNT,LASTSNDERTM,LOGININTM,LOGINOUTTM,UPDATETIME)
                  SELECT PTCODE,USERID,USERUID,USERNAME,JTYPE,LINKNUM,LOGINIP,ONLINESTATUS,MTHAVESND,MTREMAINED,MTRECVSPD,MOTOTALRECV,MOHAVESND,
                  MOREMAINED,MOSNDSPD,RPTTOTALRECV,RPTHAVESND,RPTREMAINED,RPTSNDSPD,SNDERCNT,LASTSNDERTM,LOGININTM,LOGINOUTTM,UPDATETIME
                  FROM  M_MON_SPGATEINFO;


      INSERT INTO M_MON_SYS_HIS(PTCODE,CPUUSAGE,MEMUSAGE,VMEMUSAGE,DISKFREESPACE,UPDATETIME) SELECT PTCODE,CPUUSAGE,MEMUSAGE,VMEMUSAGE,DISKFREESPACE,UPDATETIME FROM M_MON_SYSINFO;


      INSERT INTO M_MON_BUF_HIS(PTCODE,ENDCNT,MOTOTALRECV,MTTOTALSND,WRMOBUF,UPDMOBUF,UPDRPTBUF,WRRPTBUF,ENDRSPBUF,SMTSNDBUF,NMTSNDBUF,MTWAITBUF,PRECNT,
                            MTTOTALRECV,MOTOTALSND,WRMTTASKBUF,WRMTTMBUF,WRMTVFYBUF,WRMTLVLBUF,PRERSPBUF,PRERSPTMPBUF,MOSNDBUF,RPTSNDBUF,
                MORPTWAITBUF,LOGFILENUM,LOGBUF,RECVBUF,RESNDBUF,SUPPSNDBUF,MONLOGBUF,UPDATETIME)
                SELECT PTCODE,ENDCNT,MOTOTALRECV,MTTOTALSND,WRMOBUF,UPDMOBUF,UPDRPTBUF,WRRPTBUF,ENDRSPBUF,SMTSNDBUF,NMTSNDBUF,MTWAITBUF,
                PRECNT,MTTOTALRECV,MOTOTALSND,WRMTTASKBUF,WRMTTMBUF,WRMTVFYBUF,WRMTLVLBUF,PRERSPBUF,PRERSPTMPBUF,MOSNDBUF,RPTSNDBUF,
                MORPTWAITBUF,LOGFILENUM,LOGBUF,RECVBUF,RESNDBUF,SUPPSNDBUF,MONLOGBUF,UPDATETIME FROM M_MON_BUFINFO;

      INSERT INTO M_MON_THREAD_HIS(PTCODE,THRID,THRNAME,THRSTATUS,ERRORCNT,LASTERRORTM,THRLOGS,LASTRUNTM,THISRUNTM,UPDATETIME)
                               SELECT PTCODE,THRID,THRNAME,THRSTATUS,ERRORCNT,LASTERRORTM,THRLOGS,LASTRUNTM,THISRUNTM,UPDATETIME FROM M_MON_THREADINFO;


      INSERT INTO M_MON_LOG_HIS(PTCODE,LOGTYPE,LOGS,CREATETIME) SELECT PTCODE,LOGTYPE,LOGS,CREATETIME FROM M_MON_LOGINFO;
--------------------------------------清空所有表 -----------------------------
  ELSE                                    --INFOTYPE=255   THEN
    BEGIN
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_USERINFO';
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_SPGATEINFO';
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_THREADINFO';
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_BUFINFO';
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_SYSINFO';
    EXECUTE   IMMEDIATE 'TRUNCATE TABLE M_MON_LOGINFO';
    END;
  END IF;
  --DBMS_OUTPUT.PUT_LINE(PISTRSQL);
  NULL;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_ATTMRTASK
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_ATTMRTASK
 (
   PILOGINID    IN VARCHAR2,
   PIATTIME     NUMBER,
   OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT A.ID,A.LOGINID,A.TASKID,A.BMTMSGID,A.ATTIME,A.VALIDTIME
	FROM ATTIME_TASK A
	INNER JOIN BATCH_MT_REQ B ON A.BMTMSGID=B.BMTMSGID
	WHERE UPPER(A.LOGINID)=UPPER(PILOGINID) AND A.ATTIME<=PIATTIME  AND B.ERRORCODE='ACCEPTD';
END;
/



--PROMPT
--PROMPT CREATING PROCEDURE S_RD_BATMTREQ
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_BATMTREQ
 (
  PILOGINID    IN VARCHAR2,
  PIDOWNLOADFLAG IN NUMBER,
  OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIDOWNLOADFLAG=0 THEN
  OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,
    PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,
    PB.TASKTYPE,PB.BATCHID FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS>2 AND  ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH) IS NULL
    ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
  ELSE
  OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,
    PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,
    PB.TASKTYPE,PB.BATCHID FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS>2 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH) IS NOT NULL
    ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE S_RD_MMS_QUEUE(
  PISPGATE VARCHAR2,
  PIUNICOM NUMBER :=0,
  OUT_CURSOR OUT SYS_REFCURSOR
 )
AS
  PIATTIME NUMBER(22);
BEGIN
  PIATTIME:=CAST(TO_CHAR(SYSDATE,'YYYYMMDDHH24MISS') AS INT);
  OPEN OUT_CURSOR FOR
  SELECT ID,PTMSGID,USERMSGID,TMPLID,"UID",DESTUID,LOGINUID,ECID,TASKID
  ,PHONECOUNT,TOTALCOUNT,DEALSTATUS,JTYPE,FEEFLAG,RETFLAG,SPLITFLAG,SENDLEVEL
  ,MSGFMT,MSGTYPE,TPPID,TPUDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PASSTHROUGH,SENDSTATUS
  ,USERID,SVRTYPE,SPGATE,CPNO,ORDERCPNO,PHONE,MSGTITLE,MESSAGE,TO_DATE(TO_CHAR(SENDTIME, 'YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DD HH24:MI:SS') AS SENDTIME,UNICOM
  ,ATTIME,VALIDTIME,MODULEID,SA,P1,P2,P3,P4
   FROM MMS_LEVEL_QUEUE
   WHERE SPGATE=PISPGATE AND (SENDSTATUS=1 OR SENDSTATUS=2) AND UNICOM=PIUNICOM AND ATTIME<PIATTIME AND ROWNUM<=100 ORDER BY SENDLEVEL,ID  ;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MOTASK
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MOTASK
(
  PIUID           IN NUMBER,
  PIMAXRESNDCNT   IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR := 'SELECT /*+RULE*/ ID,"UID",ORGUID,ECID,PTMSGID,SPNUMBER,USERID,SERVICEID,MSGFMT,'
  ||'TP_PID,TP_UDHI,PHONE,MSGCONTENT,TP_PID,TP_UDHI,RESENDCNT,PKNUMBER,PKTOTAL,LONGMSGSEQ,PTNOTICE,CMDID,
  TO_DATE(TO_CHAR(DELIVERTIME,''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS DELIVERTIME
   FROM MO_TASK '
  ||'WHERE "UID"='||PIUID||' AND SENDSTATUS=1 AND RESENDCNT<='||PIMAXRESNDCNT||' AND ROWNUM<='||PIMAXREADCNT||'';
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MOWAITA
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MOWAITA
(
  PIUSERUID       IN NUMBER,
  PILOGINUID      IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :='SELECT /*+RULE*/ ID,ECID,PTMSGID,USERID,SPNUMBER,MESSAGE,PHONE,SPGATE,CPNO,UNICOM,'
  ||'TO_DATE(TO_CHAR(DELIVERTIME,''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS DELIVERTIME,CMDID '
  ||'FROM MO_WAIT_A WHERE USERUID='||PIUSERUID||' AND LOGINUID='||PILOGINUID||' AND ROWNUM<='||PIMAXREADCNT|| '';
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MOWAITA_PUSH
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MOWAITA_PUSH(
PIUSERUID IN NUMBER,
PIMAXREADCNT IN NUMBER,
PISPTYPE IN NUMBER,
OUT_CURSOR OUT SYS_REFCURSOR
)
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR := 'SELECT MO.ID AS ID,MO.ECID AS ECID,MO.PTMSGID AS PTMSGID,MO.USERID AS USERID,'||
  '(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO)) AS SPNUMBER,NVL(SUBSTR(MO.SPNUMBER,LENGTH(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO))+1,LENGTH(MO.SPNUMBER)-LENGTH(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO))),'' '') AS CPNO,MO.MESSAGE AS MESSAGE,'||
  'MO.PHONE AS PHONE,TO_DATE(TO_CHAR(MO.DELIVERTIME,''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'')AS DELIVERTIME ,MO.SPGATE AS SPGATE,MO.SPNUMBER AS SPNUMBER1,MO.UNICOM AS UNICOM,MO.CMDID AS CMDID FROM MO_WAIT_A MO '||
  'INNER JOIN GT_PORT_USED TB ON TB.USERID=MO.USERID AND INSTR(RTRIM(TB.SPGATE)||RTRIM(TB.CPNO),RTRIM(MO.SPNUMBER),1)=1 AND (TB.ROUTEFLAG=2 OR TB.ROUTEFLAG=0)AND TB.SPISUNCM=MO.UNICOM '||
  'WHERE MO.USERUID='||PIUSERUID ||' AND ROWNUM <='||PIMAXREADCNT|| ' AND TB.GATETYPE='||PISPTYPE||' ORDER BY ROWNUM ASC';
  OPEN OUT_CURSOR FOR PISQLSTR;
END S_RD_MOWAITA_PUSH;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTLVLQUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTLVLQUE
(
  PIDESTUID      IN NUMBER,
  PISENDLEVEL    IN NUMBER,
  PIMAXREADCNT   IN NUMBER,
  PISTRUID       IN VARCHAR2,
  SPCURTIME      IN NUMBER DEFAULT 0,
  OUT_CURSOR     OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,'
  ||'RETFLAG,TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,'
  ||'TO_DATE(TO_CHAR(SENDTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA '
  ||'FROM MT_LEVEL0_QUEUE WHERE DESTUID='||PIDESTUID||' AND "UID" NOT IN('||PISTRUID||')
  AND SENDLEVEL='||PISENDLEVEL ||'AND (ATTIME<='||SPCURTIME||'OR ATTIME<0) AND ROWNUM<='||PIMAXREADCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTTASKRESD
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTTASKRESD
(
  PIMAXRESNDCNT   IN NUMBER,
  PISTRMSGID     IN VARCHAR2,
  OUT_CURSOR     OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,'
  ||'RETFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDLEVEL,TPUDHI,LONGMSGSEQ,MSGFMT,MESSAGE,'
  ||'TO_DATE(TO_CHAR(RECVMTTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE '
  ||'FROM MT_TASK WHERE PTMSGID IN('||PISTRMSGID||') AND RESENDCNT<'||PIMAXRESNDCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

CREATE OR REPLACE PROCEDURE S_RD_MTTASKRPT
(
  PIPTMSGID       IN NUMBER,
  PIUID           IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
  AUTHID CURRENT_USER
AS
PICOUNT NUMBER(11);
PICNT NUMBER(11);
PISQLSTR VARCHAR(256);
PIDBNAME VARCHAR(32);
PIMONTH NUMBER(11);
PICURYM NUMBER(11);

BEGIN
  PICOUNT := 0;
  PIDBNAME := 'MTTASK';
  select count(*) into PICOUNT from tab where tname ='TEMP';
  if PICOUNT=0 then
  PISQLSTR:='CREATE GLOBAL TEMPORARY TABLE TEMP(SPNUMBER VARCHAR2(21),PHONE VARCHAR2(21),
  DONEDATE CHAR(10),ERRORCODE CHAR(7),RECVRPTTIME VARCHAR2(22))ON COMMIT DELETE ROWS';
  execute immediate PISQLSTR; ----使用动态SQL语句来执行
  end if;
  SELECT COUNT(*) INTO PICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
  IF PICOUNT > 0 THEN
     OPEN OUT_CURSOR FOR
     SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
     TO_CHAR(SENDTIME,'YYYY-MM-DD HH24:MI:SS') AS RECVRPTTIME FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
  ELSE
     --在当月历史中查询
     SELECT CAST(to_char(sysdate,'YYYYMM') AS INT) INTO PICURYM FROM DUAL;
     PIDBNAME := 'MTTASK'||TO_CHAR(PICURYM);
     PICOUNT := 0;
     PISQLSTR := 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';--=:绑定变量
     EXECUTE IMMEDIATE PISQLSTR INTO PICOUNT USING PIPTMSGID;
     IF PICOUNT > 0 THEN
       PISQLSTR := 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
       TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS'') AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
       OPEN OUT_CURSOR FOR PISQLSTR USING PIPTMSGID;
       RETURN;
     ELSE
       ----若当月历史表中没有,则遍历近三个月的历史表，如果查询到需要的记录，直接RETURN返回
       PIMONTH := 1;
       WHILE PIMONTH<3 LOOP
         --格式化数据库名称
         PIDBNAME := 'MTTASK'||TO_CHAR(ADD_MONTHS(SYSDATE,-PIMONTH),'YYYYMM');
         PICOUNT := 0;
         --判断表名是否存在
         SELECT COUNT(1) INTO PICNT FROM USER_TABLES T WHERE T.TABLE_NAME=PIDBNAME;
         IF PICNT>0 THEN
         PISQLSTR := 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
         EXECUTE IMMEDIATE PISQLSTR INTO PICOUNT USING PIPTMSGID;
         IF PICOUNT > 0 THEN
           PISQLSTR := 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
           TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS'') AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
           OPEN OUT_CURSOR FOR PISQLSTR USING PIPTMSGID;
           RETURN;
         END IF;
         END IF;
         PIMONTH := PIMONTH+1;
       END LOOP;
     END IF;
     --当在历史表中没有查询到需要的数据时候，返回空的记录集(最后一次遍历的表可能不存在)
     PISQLSTR:='SELECT SPNUMBER, PHONE, DONEDATE, ERRORCODE, RECVRPTTIME FROM TEMP';
     open OUT_CURSOR for PISQLSTR; ----使用动态SQL语句来执行
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTTASK
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTTASK
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PISPLITLEN_P   IN NUMBER,
    PIMULTILEN1_P  IN NUMBER,
    PIMULTILEN2_P  IN NUMBER,
    PISIGNLEN_P    IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1      IN VARCHAR2,
    PIP2      IN VARCHAR2,
    PIP3      IN VARCHAR2,
    PIP4      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0
 )
AS
--临时变量
PITMPMSGID NUMBER(22,0);
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR(21);
PISTRSPLIT VARCHAR(2);
PILEN PLS_INTEGER;
PIRESULTMSG VARCHAR(720);
PIPKNUM PLS_INTEGER;
PITMPNUM PLS_INTEGER;
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIRECVMTTIME_P TIMESTAMP(6);
PIPTMSGID_P NUMBER(22,0);

PISPLITLEN PLS_INTEGER;
PIMULTILEN1 PLS_INTEGER;
PIMULTILEN2 PLS_INTEGER;
PISIGNLEN PLS_INTEGER;

BEGIN
--变量赋值
PILEN := LENGTH(PIMESSAGE)-PISIGNLEN_P;
PITMPNUM := 0;
PIPKNUM := 1;
PISTRSPLIT := ',';
PISHOUJI_P :=PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;


IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
--清空临时表,如果临时表不存在直接返回不处理
/*SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASK');
IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASK';
ELSE
  RETURN;
END IF;
*/
--验证手机号合法性
IF (PISHOUJI_P IS NULL) THEN
  PISHOUJI_P := ' ';
END IF;
IF /*(PISHOUJI_P IS NULL) OR */(PIPHONECOUNT < 1) THEN
   RETURN;
END IF;

--变量赋值
IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
  PISPLITLEN:=140;
  PIMULTILEN1:=134;
  PIMULTILEN2:=134;
  PISIGNLEN:=0;
ELSE
  PISPLITLEN  :=PISPLITLEN_P;
  PIMULTILEN1 :=PIMULTILEN1_P;
  PIMULTILEN2 :=PIMULTILEN2_P;
  PISIGNLEN   :=PISIGNLEN_P;
END IF;
IF PIMSGFMT=25 THEN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO MT_TASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
    RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
    UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
    PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
    PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
  RETURN;
END IF;
IF PIPHONECOUNT = 1 --单发
THEN
 SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID_P;
  --IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
  IF ICOUNT<1 THEN
    IF PIPKTOTAL = 1 THEN
      INSERT INTO MT_TASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
      PIRETFLAG,PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
      PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
    ELSE
      PIPKNUM := 1;
      PITMPMSGID := PIPTMSGID_P;
      IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
        PIRESULTMSG := SUBSTR(PIMESSAGE,1,PISPLITLEN);
        PITMPMSGID := PITMPMSGID;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID=PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID, PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
        PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
        PITMPMSGID := PITMPMSGID+17179869184;
        PIPKNUM := PIPKNUM+1;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
      ELSE
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          IF PIPKNUM = PIPKTOTAL THEN
             PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
             PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSIF PIPKNUM = PIPKTOTAL-1 THEN
            IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
               PITMPNUM := PILEN-1;
               --DBMS_OUTPUT.PUT_LINE('123');
            ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
               PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
               --DBMS_OUTPUT.PUT_LINE('456');
            END IF;
            PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
               --DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
          END IF;
          ICOUNT:=0;
          SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
          IF ICOUNT<1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
            PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
          --EXECUTE IMMEDIATE STR;
          PIPKNUM := PIPKNUM+1;
        END LOOP;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
      END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;
      INSERT INTO MT_TASK ("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
      A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASK A;
      COMMIT;
    END IF;--END IF OF IF PIPKTOTAL = 1
  --ELSE  --MSGID存在是写入MSGIDTEST表
  --  INSERT INTO MSGIDTEST(MSGID) VALUES(PIPTMSGID);
  END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
ELSE --群发
    PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  IF PIPKTOTAL < 1 THEN--没有短信内容
    RETURN;
  END IF;

  IF PIPKTOTAL >= 1 --需要拆分长短信
  THEN
    WHILE PILOCATION <> 0 LOOP--拆分手机号码
        PISTART := PILOCATION;
        PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
      IF PILOCATION > 0 THEN
        PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);--拆分后的字符
        IF (PIRESULTPHONE IS NULL) THEN
          PIRESULTPHONE := ' ';
        END IF;
        PITMPMSGID := PIPTMSGID_P;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          IF PIPKTOTAL = 1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIMESSAGE,PISENDSTATUS,
            PIRETFLAG, PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          ELSE
            PIPKNUM := 1;
            IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
              PIRESULTMSG := SUBSTR(PIMESSAGE,1, PISPLITLEN);--拆分后的字符
              PITMPMSGID := PITMPMSGID;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID, PISPGATE,PICPNO,PIRESULTPHONE, PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG, PIPKNUM, PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF;
              PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
              PITMPMSGID := PITMPMSGID+17179869184;
              PIPKNUM := PIPKNUM+1;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
            ELSE
              WHILE PIPKNUM <= PIPKTOTAL LOOP--PIPKNUM:1    PIPKTOTAL 2
                IF PIPKNUM = PIPKTOTAL THEN
                  PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSIF PIPKNUM = PIPKTOTAL-1 THEN
                  IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
                    PITMPNUM := PILEN-1;
                  ELSE
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                    PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
                     ----第一条
                  END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSE
                  PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
                ICOUNT:=0;
                SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK WHERE PTMSGID = PITMPMSGID;
                IF ICOUNT<1 THEN
                  INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                  RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                  PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                  PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
                END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
                PIPKNUM := PIPKNUM+1;
              END LOOP;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
            END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
          END  IF;--END IF OF IF PIPKTOTAL = 1
        END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
        PIPTMSGID_P := PIPTMSGID_P+1;
      END  IF; --END IF OF IF PILOCATION > 0
    END LOOP; --END WHILE OF WHILE PILOCATION <> 0
      INSERT INTO MT_TASK ("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
      A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASK A;
      COMMIT;
   END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --单发
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTTASKSR
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTTASKSR
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1           IN VARCHAR2,
    PIP2           IN VARCHAR2,
    PIP3           IN VARCHAR2,
    PIP4           IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0
 )
AS
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR2(21);
PISTRSPLIT VARCHAR2(2);
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIPTMSGID_P NUMBER(22,0);

BEGIN

PISTRSPLIT := ',';
PISHOUJI_P := PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;

IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
/*
SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASKSR');
IF ICOUNT>0 THEN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
ELSE
  RETURN;
END IF;
*/
IF (PISHOUJI_P IS NULL) THEN
   PISHOUJI_P := ' ';
END IF;
IF (PIPHONECOUNT < 1) THEN--手机号码为空
  RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--单发
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
    RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
    MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI_P, PIPTMSGID_P, PIMESSAGE,PISENDSTATUS,
    PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
    PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,
    PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
ELSE --群发
  PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
  PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
    IF PILOCATION > 0 THEN
      PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);
      IF (PIRESULTPHONE IS NULL) THEN
        PIRESULTPHONE := ' ';
      END IF;
      ICOUNT:=0;
      SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;

      IF ICOUNT<1 THEN
        INSERT INTO TMP_MTTASKSR("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
        RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
        MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
        VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PIPTMSGID_P,PIMESSAGE,PISENDSTATUS,PIRETFLAG,
        PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,
        PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
      END IF;
      PIPTMSGID_P := PIPTMSGID_P+1;
    END IF;
  END LOOP;
  INSERT INTO GW_MT_TASK_BAK ("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS, RETFLAG,
  PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
  SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
  A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
  A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASKSR A;
  COMMIT;
END IF;
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTTASKSUPP
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTTASKSUPP
(
  PIOLDMSGID IN NUMBER,
  PINEWMSGID  IN NUMBER,
  PISRCUID  IN NUMBER,
  PISRCUSRID  IN VARCHAR2,
  PISRCSPGATE  IN VARCHAR2,
  PISRCSPNUMBER IN  VARCHAR2,
  PIDESTUID  IN NUMBER,
  PIDESTUSRID  IN VARCHAR2,
  PIDESTSPGATE  IN VARCHAR2,
  PIDESTSPNUMBER  IN VARCHAR2,
  PIDESTFEEFLAG  IN NUMBER,
  PISPLITLEN  IN NUMBER,
  PIMULTILEN1  IN NUMBER,
  PIMULTILEN2  IN NUMBER,
  PINEWSIGNLEN  IN NUMBER,
  PIOLDSIGNLEN  IN NUMBER,
  PISIGNATURE  IN VARCHAR2,
  PINEWSIGNPOS IN NUMBER,
  PIOLDSIGNPOS IN NUMBER,
  PIENSPLITLEN IN NUMBER, --英文短信单条长度，小于等于0标识不支持英文短信
  PIENMULTILEN1  IN NUMBER, --英文长短信拆分长度
  PIENMULTILEN2  IN NUMBER, --英文长短信最后一条长度
  PINEWENSIGNLEN  IN NUMBER, --补发英文签名长度
  PIOLDENSIGNLEN  IN NUMBER, --原英文签名长度
  PIENSIGNATURE  IN VARCHAR2, --英文签名
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISENDNUM NUMBER(11);
  PIPKTOTAL NUMBER(11);
  PIPKNUM   NUMBER(11);
  PIINITMSGID NUMBER(22);
  PISINGLEMSG VARCHAR2(720);
  PILONGMSG VARCHAR2(3000);
  PITOTALCNT NUMBER(11);
  PILONGMSGLEN NUMBER(11);
  PIECID NUMBER(11);
  PIPHONE VARCHAR2(21);
  PISENDLEVEL NUMBER(11);
  PITASKID NUMBER(11);
  PIRECVMTTIME TIMESTAMP;
  PISRCCPNO  VARCHAR2(21);
  PIDESTCPNO VARCHAR2(21);
  PITPUDHI NUMBER(11);
  PITPPID NUMBER(11);
  PILONGMSGSEQ NUMBER(11);
  PIMSGFMT NUMBER(11);
  PIUNICOM NUMBER(11);
  PIMOBILEAREA NUMBER(11);
  PISVRTYPE VARCHAR2(64);
  PIUSERMSGID NUMBER(22);
  PISENDTYPE NUMBER(11);
  PIP1 VARCHAR2(64);
  PIP2 VARCHAR2(64);
  PIP3 VARCHAR2(64);
  PIP4 VARCHAR2(64);
  PIMODULEID NUMBER(11);
  PIATTIME NUMBER(22);
  PIVALIDTIME NUMBER(22);
  PIBATCHID NUMBER(22);
  PIAREACODE NUMBER(11);
  ICOUNT NUMBER(11);
  PITEMPCNT1 NUMBER(11);
  PITEMPCNT2 NUMBER(11);

  PISPLITLEN_V NUMBER(11);
  PIMULTILEN1_V  NUMBER(11);
  PIMULTILEN2_V  NUMBER(11);
  PINEWSIGNLEN_V  NUMBER(11);
  PIOLDSIGNLEN_V  NUMBER(11);
  PISIGNATURE_V  VARCHAR2(22);
BEGIN

  /*--检查查临时表是否存在,如果存在则清空,不存在直接返回
  SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_RDMTTASK');
  IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';
  ELSE
    RETURN;
  END IF;
  */
  PILONGMSG:='';
  PIRECVMTTIME:= SYSTIMESTAMP;
  PISRCCPNO:= SUBSTR(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE));
  PIDESTCPNO:= SUBSTR(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE));
   --取补发帐号的费用
  SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=PIDESTUSRID;

  --每次调用存储过程时候，先清空TMP_RDMTTASK会话级别的临时表
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';

  --该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=SQL%ROWCOUNT;

  DELETE FROM TMP_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
  PITEMPCNT2:=SQL%ROWCOUNT;

  IF PITEMPCNT1 - PITEMPCNT2>0 THEN
    SELECT PKTOTAL,PKNUMBER,ECID,PHONE,SENDLEVEL,
        TASKID,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
        MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
        SENDTYPE,P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE  INTO
        PIPKTOTAL,PIPKNUM,PIECID,PIPHONE,PISENDLEVEL,
        PITASKID,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
        PIMOBILEAREA,PISVRTYPE,PITPPID,PIUSERMSGID,
        PISENDTYPE,PIP1,PIP2,PIP3,PIP4,PIMODULEID,PIATTIME,PIVALIDTIME,PIBATCHID,PIAREACODE
    FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       PIOLDSIGNLEN_V:=PIOLDENSIGNLEN;
     ELSE
       PIOLDSIGNLEN_V:=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       PISPLITLEN_V:=PIENSPLITLEN;
       PIMULTILEN1_V:=PIENMULTILEN1;
       PIMULTILEN2_V:=PIENMULTILEN2;
       PINEWSIGNLEN_V:=PINEWENSIGNLEN;
       PISIGNATURE_V:=PIENSIGNATURE;
     ELSE
       PISPLITLEN_V:=PISPLITLEN;
       PIMULTILEN1_V:=PIMULTILEN1;
       PIMULTILEN2_V:=PIMULTILEN2;
       PINEWSIGNLEN_V:=PINEWSIGNLEN;
       PISIGNATURE_V:=PISIGNATURE;
     END IF;

     IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN--对于非长短信补发的处理
        PILONGMSG:='';
        --取短信内容
        SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
        --更新替换MSGID
        UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V; --减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := PILONGMSG||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||PILONGMSG;
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
        PIPKNUM:=1;
    /*
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN--对标准协议长短信的补发
      PILONGMSG:='';
      --取短信内容
      SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
      --更新替换MSGID
      UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
      IF (PIPKTOTAL=PIPKNUM)THEN ---如果是最后一条，去掉旧签名，加上新签名
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN; --减去签名的净长度
        PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        PILONGMSG := PILONGMSG||PISIGNATURE;
      END IF;
      PILONGMSGLEN := LENGTH(PILONGMSG);
      IF PILONGMSGLEN > 0 THEN
        --调用插入存储过程
        S_WR_MTTASKSR(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
                PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
                PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
      ELSE
        PILONGMSG:='';
      END IF;--END OF IF PILONGMSGLEN > 0
    */
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0)THEN--对非标准长短信协议的处理
      PILONGMSG:='';
      --没有补发过且通道号跟源通道号相等
      SELECT COUNT(*) INTO ICOUNT FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND TRIM(SPGATE)=PISRCSPGATE;
      IF ICOUNT>0 THEN
        --循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
        --计算起始MSGID
        PIINITMSGID := PIOLDMSGID-(PIPKNUM-1)*17179869184;
        PIPKNUM := 1;
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          --取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
           SELECT MESSAGE INTO PISINGLEMSG FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          IF (PISINGLEMSG IS NOT NULL) THEN
            --更新替换MSGID
            UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            --拼接短信内容
            PILONGMSG := PILONGMSG||PISINGLEMSG;
            PIPKNUM := PIPKNUM+1;
          ELSE
            PILONGMSG:='';
            PIPKNUM:=PIPKTOTAL;--用来跳出WHILE
          END IF;
        END LOOP;--END OF WHILE PIPKNUM <= PIPKTOTAL
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V ;--减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := PILONGMSG||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||PILONGMSG;
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
          PIPKNUM:=1;
      END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM PITMP WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND (TRIM(SPGATE)+TRIM(CPNO))=PISRCSPNUMBER)
    END  IF;--END OF IF PIPKTOTAL > 1
  END IF;--END OF IF PIPIROWCOUNT<>0
  --返回给上层数据
  OPEN OUT_CURSOR FOR
  SELECT PIDESTUID AS "UID",PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
  PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,1 AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
  SENDSTATUS,1 AS SENDLEVEL,TO_DATE(TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),'YYYY-MM-DD HH24:MI:SS') AS RECVMTTIME,
  PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
  PISVRTYPE AS SVRTYPE,PIP1 AS P1,PIP2 AS P2,PIP3 AS P3,PIP4 AS P4,PIUSERMSGID AS USERMSGID,PIMODULEID AS MODULEID,
  PIATTIME AS ATTIME,PIVALIDTIME AS VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM TMP_RDMTTASK WHERE (PILONGMSG IS NOT NULL);
END;
/



--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTTMRQUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTTMRQUE
(
  PIUID          IN NUMBER,
  PIDESTUID      IN NUMBER,
  PISENDLEVEL    IN NUMBER,
  PIMAXREADCNT   IN NUMBER,
  SPCURTIME      IN NUMBER DEFAULT 0,
  OUT_CURSOR     OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :='SELECT /*+RULE*/ ID,"UID",DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,'
  ||'TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,'
  ||'TO_DATE(TO_CHAR(SENDTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME,LONGMSGSEQ, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID '
  ||'FROM MT_TIMER_QUEUE WHERE "UID"='||PIUID||' AND DESTUID='||PIDESTUID||' AND SENDLEVEL='||PISENDLEVEL||'AND (ATTIME<='||SPCURTIME||'OR ATTIME<0) AND ROWNUM<='||PIMAXREADCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTVFYTASK
--PROMPT =================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTVFYTASK
(
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
BEGIN
  --返回给上层数据
  OPEN OUT_CURSOR FOR
  SELECT ID,VERIFYSTATUS,CMDTEXT,PARAMS FROM MT_VERIFY_TASK WHERE DEALSTATUS=1 ORDER BY ID ASC;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTWAITA
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_MTWAITA
(
  PILOGINUID      IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :='SELECT /*+RULE*/ ID,USERUID,USERID,PTMSGID,SPNUMBER,PHONECOUNT,MESSAGE,PHONE,MSGFMT,'
  ||'TO_DATE(TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME,TASKID,SENDLEVEL, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,ATTIME,VALIDTIME,SENDTYPE,BATCHID,TOTALCOUNT '
  ||'FROM MT_WAIT_A WHERE SENDSTATUS IN (1,255,8) AND LOGINUID='||PILOGINUID||' AND ROWNUM<='||PIMAXREADCNT|| '';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE S_RD_RPTWAITA_PUSH
--PROMPT =====================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_RPTWAITA_PUSH(
  PIUSERUID IN INTEGER,
  PIMAXREADCNT IN INTEGER,
  OUT_CURSOR OUT SYS_REFCURSOR)
AS
 PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR := 'SELECT ID,ECID,PTMSGID,USERID,SPNUMBER,SUBMITTIME,DONETIME,PHONE,ERRORCODE,USERMSGID,MODULEID,
  TO_DATE(TO_CHAR(RECVTIME,''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVTIME
  FROM RPT_WAIT_A WHERE USERUID='||PIUSERUID||' AND ROWNUM<='||PIMAXREADCNT||' ORDER BY ROWNUM ASC';
  OPEN OUT_CURSOR FOR PISQLSTR;
END S_RD_RPTWAITA_PUSH;
/

--统计所有的MT_LEVEL0-MT_LEVEL9滞留表
CREATE OR REPLACE PROCEDURE S_STATREMAIN
 (
   PICMD          IN NUMBER,
   OUT_CURSOR     OUT SYS_REFCURSOR
 )
AS
PI_TBNUM NUMBER(4);
PI_STR VARCHAR2(2048);
PI_STR1 VARCHAR2(128);
PI_STR2 VARCHAR2(2048);
BEGIN
  PI_TBNUM:=0;
  WHILE PI_TBNUM<=9 LOOP
    IF PI_TBNUM<9 THEN
      PI_STR1:='SELECT TOTALCOUNT,SENDLEVEL,"UID",DESTUID FROM '||'MT_LEVEL'||CAST(PI_TBNUM AS CHAR)||'_QUEUE UNION ALL ';
    ELSE
      PI_STR1:='SELECT TOTALCOUNT,SENDLEVEL,"UID",DESTUID FROM '||'MT_LEVEL'||CAST(PI_TBNUM AS CHAR)||'_QUEUE';
    END IF;
    PI_STR:=PI_STR||PI_STR1;
    PI_TBNUM:=PI_TBNUM+1;
  END LOOP;

  IF PICMD=100 THEN
  --汇总MT_LEVEL0_QUEUE中各帐号数据
    --前端滞留
    PI_STR2:='SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", "UID" FROM ('||PI_STR||') WHERE "UID">0 GROUP BY "UID",SENDLEVEL';
    OPEN OUT_CURSOR FOR PI_STR2;
    --后端滞留
  ELSIF PICMD=110 THEN
    PI_STR2:='SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", DESTUID AS "UID" FROM ('||PI_STR||') WHERE DESTUID>0 GROUP BY DESTUID,SENDLEVEL';
    OPEN OUT_CURSOR FOR PI_STR2;

     --代理滞留
  --ELSIF PICMD=120 THEN
  --  OPEN OUT_CURSOR FOR
  --  SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", LOGINUID AS "UID" FROM MT_LEVEL0_QUEUE WHERE LOGINUID>0 AND "UID"<>LOGINUID GROUP BY LOGINUID,SENDLEVEL;

  --汇总MT_TIMER_QUEUE中各帐号数据
    --前端滞留
  ELSIF PICMD=200 THEN
    OPEN OUT_CURSOR FOR
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", "UID" FROM MT_TIMER_QUEUE WHERE "UID">0 GROUP BY "UID",SENDLEVEL;
  --后端滞留
  ELSIF PICMD=210 THEN
    OPEN OUT_CURSOR FOR
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", DESTUID AS "UID" FROM MT_TIMER_QUEUE WHERE DESTUID>0 GROUP BY DESTUID,SENDLEVEL;
    --代理滞留
  --ELSIF PICMD=220 THEN
  -- OPEN OUT_CURSOR FOR
  -- SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS "LEVEL", LOGINUID AS "UID" FROM MT_TIMER_QUEUE WHERE LOGINUID>0 AND "UID"<>LOGINUID GROUP BY LOGINUID,SENDLEVEL;

  --汇总MO_TASK中各帐号数据
    --前端滞留
  ELSIF PICMD=300 THEN
   OPEN OUT_CURSOR FOR
   SELECT COUNT("UID") AS REMAINEDNUM, 0 AS "LEVEL", "UID" FROM MO_TASK WHERE SENDSTATUS=1 AND "UID">0 AND ORGUID>0 GROUP BY "UID";
    --后端滞留
  ELSIF PICMD=310 THEN
   OPEN OUT_CURSOR FOR
   SELECT COUNT("UID") AS REMAINEDNUM, 0 AS "LEVEL", ORGUID AS "UID" FROM MO_TASK WHERE SENDSTATUS=1 AND ORGUID>0 GROUP BY ORGUID;

  --汇总RPT_WAIT_B中各帐号数据
    --前端滞留
  ELSIF PICMD=401 THEN
   OPEN OUT_CURSOR FOR
   SELECT COUNT("UID") AS REMAINEDNUM, 1 AS "LEVEL", "UID" FROM RPT_WAIT_B WHERE "UID">0 AND ORGUID>0 GROUP BY "UID";

    --后端滞留
  ELSIF PICMD=411 THEN
   OPEN OUT_CURSOR FOR
   SELECT COUNT("UID") AS REMAINEDNUM, 1 AS "LEVEL", ORGUID AS "UID" FROM RPT_WAIT_B WHERE ORGUID>0 GROUP BY ORGUID;

   --CMD 501统计MT_WAIT_A
  ELSIF PICMD=501 THEN
   OPEN OUT_CURSOR FOR
   SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, 0 AS "LEVEL",USERUID AS "UID" FROM MT_WAIT_A WHERE USERUID>0 GROUP BY USERUID;

   --502统计BATCH_MT_REQ(统计滞留为TOTALNUM-SENDNUM)
  ELSIF PICMD=502 THEN
   OPEN OUT_CURSOR FOR
   SELECT SUM(TOTALNUM-SENDNUM) AS REMAINEDNUM,0 AS "LEVEL", USERUID AS "UID" FROM BATCH_MT_REQ WHERE USERUID>0 GROUP BY USERUID;

  ELSE
   OPEN OUT_CURSOR FOR
   SELECT 0 AS REMAINEDNUM, 0 AS "LEVEL", 0 AS "UID" FROM DUAL;
  END IF;
END;
/

--增加参数PITABLENO（滞留表MT_LEVEL0-9）
CREATE OR REPLACE PROCEDURE GW_WR_MTLVLQUEV2
 (
   PIUID        IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIRETFLAG    IN NUMBER,
   PIPKTOTAL    IN NUMBER,
   PIPHONECOUNT IN NUMBER,
   PISENDSTATUS IN NUMBER,
   PISPLITFLAG  IN NUMBER,
   PIECID       IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPGATE     IN VARCHAR2,
   PICPNO       IN VARCHAR2,
   PIRECVMTTIME IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PIMESSAGE    IN VARCHAR2,
   PIFEEFLAG    IN NUMBER,
   PIDESTUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPKNUMBER   IN NUMBER,
   PISENDLEVEL  IN NUMBER,
   PITPUDHI     IN NUMBER,
   PITASKID     IN NUMBER,
   PILONGMSGSEQ IN NUMBER,
   PIMSGFMT     IN NUMBER,
   PITOTALCOUNT IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME       IN NUMBER DEFAULT 0,
   PIVALIDTIME    IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0,
   PIAREACODE     IN NUMBER DEFAULT 0,
   PICUSTID     IN MT_LEVEL0_QUEUE.CUSTID%TYPE,
   PIEXDATA    IN MT_LEVEL0_QUEUE.EXDATA%TYPE,
   PITABLENO   IN NUMBER
 )
AS
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
BEGIN
  IF PITABLENO = 0 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL0_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 1 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL1_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL1_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 2 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL2_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL2_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 3 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL3_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL3_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 4 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL4_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL4_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 5 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL5_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL5_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 6 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL6_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL6_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 7 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL7_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL7_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 8 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL8_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL8_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  ELSIF PITABLENO = 9 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL9_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL9_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
END IF;
END;
/

--增加参数PITABLENO（滞留表MT_LEVEL0-9）
CREATE OR REPLACE PROCEDURE GW_RD_MTLVLQUEV1
(
  PIDESTUID      IN NUMBER,
  PISENDLEVEL    IN NUMBER,
  PIMAXREADCNT   IN NUMBER,
  PISTRUID       IN VARCHAR2,
  SPCURTIME      IN NUMBER DEFAULT 0,
  PITABLENO      IN NUMBER,
  OUT_CURSOR     OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,'
  ||'RETFLAG,TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,'
  ||'TO_DATE(TO_CHAR(SENDTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1 '
  ||'FROM MT_LEVEL'||PITABLENO||'_QUEUE WHERE DESTUID='||PIDESTUID||' AND "UID" NOT IN('||PISTRUID||')
  AND SENDLEVEL='||PISENDLEVEL ||'AND (ATTIME<='||SPCURTIME||'OR ATTIME<0) AND ROWNUM<='||PIMAXREADCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_ATTMRFLAG
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_ATTMRFLAG
 (
   PITASKID     IN PLS_INTEGER,
   PIID         IN PLS_INTEGER,
   PILOGINID    IN VARCHAR2,
   PIBMTMSGID   NUMBER
 )
AS
  RCOUNT PLS_INTEGER;
BEGIN
  UPDATE BATCH_MT_REQ SET ATTIMEFLAG=0 WHERE BMTMSGID=PIBMTMSGID AND UPPER(LOGINID)=UPPER(PILOGINID);
  RCOUNT:=SQL%ROWCOUNT;
  IF RCOUNT>0 THEN
    DELETE FROM ATTIME_TASK WHERE ID=PIID;
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE S_RD_BATMTREQ
 (
  PILOGINID    IN VARCHAR2,
  PIDOWNLOADFLAG IN NUMBER,
  OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIDOWNLOADFLAG=0 THEN
  OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,PB.TASKTYPE,PB.BATCHID FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS=3 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH) IS NULL ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
  ELSE
  OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,PB.TASKTYPE,PB.BATCHID FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND (SENDSTATUS=4 OR SENDSTATUS=5) AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH) IS NOT NULL ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE S_UPD_BATMTREQ
 (
   PIUSERID     IN BATCH_MT_REQ.USERID%TYPE,
   PIUSERUID    IN BATCH_MT_REQ.USERUID%TYPE,
   PILOGINID    IN BATCH_MT_REQ.LOGINID%TYPE,
   PISENDSTATUS IN BATCH_MT_REQ.SENDSTATUS%TYPE,
   PITASKID     IN BATCH_MT_REQ.TASKID%TYPE,
   PIMSGID      IN BATCH_MT_REQ.MSGID%TYPE,
   PILOCALPATH  IN BATCH_MT_REQ.LOCALPATH%TYPE,
   PIERRORCODE  IN BATCH_MT_REQ.ERRORCODE%TYPE,
   PIBMTMSGID   IN BATCH_MT_REQ.BMTMSGID%TYPE,
   PITOTALNUM   IN BATCH_MT_REQ.TOTALNUM%TYPE:=0,
   PISENDNUM    IN BATCH_MT_REQ.SENDNUM%TYPE:=0,
   OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
  PIROWCOUNT NUMBER;
  BEGIN
  IF PISENDSTATUS=0 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       PIROWCOUNT:= SQL%ROWCOUNT;
       BEGIN
       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID);
       DELETE FROM BATCH_MT_REQ WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       DELETE FROM ATTIME_TASK WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       EXCEPTION WHEN OTHERS THEN
         ROLLBACK;
       END;
       COMMIT;
  ELSIF PISENDSTATUS=2 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=3 THEN
       UPDATE BATCH_MT_REQ SET USERUID=PIUSERUID,SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,MSGID=PIMSGID,SENDTIME=SYSTIMESTAMP
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=4 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,LOCALPATH=PILOCALPATH,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP,TOTALNUM=PITOTALNUM
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID AND SENDSTATUS=3;
       PIROWCOUNT:= SQL%ROWCOUNT;
       IF PIROWCOUNT<>1 THEN
         BEGIN
           UPDATE BATCH_MT_REQ SET SENDSTATUS=0,ERRORCODE='UPDFAIL',SENDTIME=SYSTIMESTAMP WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
           INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID);
           DELETE FROM BATCH_MT_REQ WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
           DELETE FROM ATTIME_TASK WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
           EXCEPTION WHEN OTHERS THEN
             ROLLBACK;
         END;
         COMMIT;
       END IF;
  ELSIF PISENDSTATUS=5 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=6 THEN
       UPDATE BATCH_MT_REQ SET ERRORCODE=PIERRORCODE,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP
       WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSE
    PIROWCOUNT:= 0;
  END IF;
  OPEN OUT_CURSOR FOR SELECT PIROWCOUNT AS UPDROWCOUNT FROM DUAL;
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MMS_MTRPT
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MMS_MTRPT(
  -- ADD THE PARAMETERS FOR THE STORED PROCEDURE HERE --OPTYPE INT,
  --1-第一次更新为成功，2第一更新为失败，3，非第一次更新为失败，非第一次更新为成功
  PISENDSTATUS IN NUMBER,
  PIPTMSGID  IN NUMBER,
  PISPMSGID  IN NUMBER,
  PIRECVFLAG  IN NUMBER,
  PIERRORCODE  IN VARCHAR2,
  PISUBMITDATE  IN VARCHAR2,
  PIDONEDATE  IN VARCHAR2,
  PIRECVTIME  IN TIMESTAMP:=''
  )
AS
BEGIN
  UPDATE MMS_TASK SET SENDSTATUS = PISENDSTATUS, RECVFLAG = PIRECVFLAG, ERRORCODE = PIERRORCODE, DONEDATE = PIDONEDATE, RECVTIME = PIRECVTIME
  WHERE PTMSGID = PIPTMSGID AND SENDSTATUS<>0;
END S_UPD_MMS_MTRPT;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MONINFO
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MONINFO
 (
    PIGATEID       IN PLS_INTEGER,
    PISPGATE       IN VARCHAR2,
    PIUSRID        IN VARCHAR2,
    PIONLINESTATUS IN PLS_INTEGER,
    PITOTALRPTSEND IN PLS_INTEGER,
    PITOTALMOSEND  IN PLS_INTEGER,
    PIHAVESENDMO   IN PLS_INTEGER,
    PIHAVESENDRPT  IN PLS_INTEGER,
    PIRECVMT       IN PLS_INTEGER,
    PIREMAINEDMT   IN PLS_INTEGER,
    PITIMERSENDMT  IN PLS_INTEGER,
    PIREMAINEDRPT  IN PLS_INTEGER,
    PIREMAINEDMO   IN PLS_INTEGER,
    PIRECVSPEED    IN PLS_INTEGER
 )
AS
  ICOUNT PLS_INTEGER;
BEGIN
  SELECT COUNT(GATEID) INTO ICOUNT FROM MR_SPGATE_WATCH WHERE UPPER(USRID)=UPPER(PIUSRID) AND SPGATE=PISPGATE;
  IF ICOUNT<1 THEN
    INSERT INTO MR_SPGATE_WATCH(GATEID,SPGATE,USRID,ONLINESTATUS,TOTALRPTSEND,NUMRPT,
    TOTALMOSEND,NUMMO,HAVESENDMO,HAVESENDRPT,RECVMT,NUMMT,REMAINEDMT,TIMERSENDMT,
    REMAINEDRPT,REMAINEDMO,RECVSPEED)
    VALUES(PIGATEID,PISPGATE,PIUSRID,PIONLINESTATUS,PITOTALRPTSEND,PITOTALRPTSEND,
    PITOTALMOSEND,PITOTALMOSEND,PIHAVESENDMO,PIHAVESENDRPT,PIRECVMT,PIRECVMT,
    PIREMAINEDMT,PITIMERSENDMT,PIREMAINEDRPT,PIREMAINEDMO,PIRECVSPEED);
  ELSE
    UPDATE MR_SPGATE_WATCH SET SPGATE=PISPGATE,USRID=PIUSRID,ONLINESTATUS=PIONLINESTATUS,
    TOTALRPTSEND=PITOTALRPTSEND,NUMRPT=PITOTALRPTSEND,TOTALMOSEND=PITOTALMOSEND,NUMMO=PITOTALMOSEND,
    HAVESENDMO=PIHAVESENDMO,HAVESENDRPT=PIHAVESENDRPT,RECVMT=PIRECVMT,NUMMT=PIRECVMT,REMAINEDMT=PIREMAINEDMT,
    TIMERSENDMT=PITIMERSENDMT,REMAINEDRPT=PIREMAINEDRPT,REMAINEDMO=PIREMAINEDMO,RECVSPEED=PIRECVSPEED
    WHERE UPPER(USRID)=UPPER(PIUSRID) AND SPGATE=PISPGATE;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MOTASK
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MOTASK
 (
    PIPTMSGID     IN NUMBER,
    PISENDSTATUS  IN PLS_INTEGER,
    PIUID         IN PLS_INTEGER,
    PIECID        IN PLS_INTEGER,
    PIUSERID      IN VARCHAR2
 )
AS
  PIRESENDCNT PLS_INTEGER;
BEGIN
  PIRESENDCNT:=0;
  IF PISENDSTATUS=1 THEN
    PIRESENDCNT:=0;
  ELSE
    PIRESENDCNT:=0;
  END IF;

  IF PIUID=0 AND PIECID=0 AND (PIUSERID IS NULL) THEN
    UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,RESENDCNT=RESENDCNT+PIRESENDCNT WHERE PTMSGID = PIPTMSGID;
  ELSE
    UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,"UID"=PIUID,ECID=PIECID,
    USERID=PIUSERID,RESENDCNT=RESENDCNT+PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MTRPT
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MTRPT
 (
    PISENDSTATUS IN PLS_INTEGER,
    PIPTMSGID    IN NUMBER,
    PISPMSGID    IN NUMBER,
    PIRECVFLAG   IN PLS_INTEGER,
    PIERRORCODE  IN VARCHAR2,
    PISUBMITDATE IN VARCHAR2,
    PIDONEDATE   IN VARCHAR2,
    PIRECVTIME   IN VARCHAR2,
    PISPID       IN VARCHAR2 DEFAULT(' ')
 )
AS
BEGIN
  IF PISENDSTATUS=3 THEN
     UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDSTATUS=PISENDSTATUS,RECVFLAG=PIRECVFLAG,
     ERRORCODE=PIERRORCODE,DONEDATE=PIDONEDATE,RECVTIME=SYSTIMESTAMP,SPID=PISPID WHERE PTMSGID=PIPTMSGID AND SENDSTATUS=2;
  ELSIF PISENDSTATUS=5 THEN
    UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDSTATUS=PISENDSTATUS,RECVFLAG=PIRECVFLAG,
    ERRORCODE=PIERRORCODE,DONEDATE=PIDONEDATE,RECVTIME=SYSTIMESTAMP,SPID=PISPID WHERE PTMSGID=PIPTMSGID AND SENDSTATUS<>0;
  ELSE
     UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDSTATUS=PISENDSTATUS,RECVFLAG=PIRECVFLAG,
     ERRORCODE=PIERRORCODE,DONEDATE=PIDONEDATE,RECVTIME=SYSTIMESTAMP,SPID=PISPID WHERE PTMSGID=PIPTMSGID AND SENDSTATUS<>0;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MTTASK
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MTTASK
 (
    PIPTMSGID      IN NUMBER,
    PISPMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PISENDFLAG     IN NUMBER,
    PISENDRPTTM    IN VARCHAR2 DEFAULT (' ')
 )
AS
    PISENDRPTTIME TIMESTAMP(6);
BEGIN
  IF RTRIM(PISENDRPTTM) IS NULL THEN
     PISENDRPTTIME:=SYSTIMESTAMP;
  ELSE
     PISENDRPTTIME:=TO_TIMESTAMP(PISENDRPTTM,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;
  IF PISENDSTATUS=8 THEN
  --10:表示该条短信的状态报告没有返回给用户
    UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDFLAG=10,SENDRPTTIME=PISENDRPTTIME WHERE PTMSGID=PIPTMSGID;
  ELSIF PISENDSTATUS=9 THEN
  --11:表示该条短信的状态报告被强制修改为DELIVRD后返回给用户
    UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDFLAG=11,SENDRPTTIME=PISENDRPTTIME WHERE PTMSGID=PIPTMSGID;
  --MT成功发级行业网关
  ELSIF PISENDSTATUS=3 THEN
    UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDSTATUS=PISENDSTATUS,SENDTIME=PISENDRPTTIME WHERE PTMSGID=PIPTMSGID;
  ELSE --RPT已产生或RPT成功送至用户
    UPDATE /*+NO_PARALLEL NO_PARALLEL_INDEX FULL(MT_TASK)*/ MT_TASK NOLOGGING SET SENDSTATUS=PISENDSTATUS,SENDRPTTIME=PISENDRPTTIME WHERE PTMSGID=PIPTMSGID;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_UPD_MTVFYTASK
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_UPD_MTVFYTASK
(
  PIID IN NUMBER
  )
AS
BEGIN
  UPDATE MT_VERIFY_TASK SET DEALSTATUS=0 WHERE ID=PIID;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_BATMTREQ
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_BATMTREQ
 ( PIUSERID       IN VARCHAR2,
   PILOGINID      IN VARCHAR2,
   PIUSERUID      IN NUMBER,
   PISERVICETYPE  IN VARCHAR2,
   PISENDTYPE     IN NUMBER,
   PIMSGFMT       IN NUMBER,
   PIREMOTEURL    IN VARCHAR2,
   PISENDSTATUS   IN NUMBER,
   PIRECVTIMEIN   IN VARCHAR2,
   PIMSG          IN VARCHAR2,
   PITASKID       IN NUMBER,
   PITITLE        IN VARCHAR2,
   PISENDLEVEL    IN NUMBER,
   PIATTIME       IN VARCHAR2,
   PIVALIDTIME    IN VARCHAR2,
   PIMSGID        IN NUMBER,
   PILOCALPATH    IN VARCHAR2,
   PIERRORCODE    IN VARCHAR2,
   PIICURTIME     IN NUMBER,
   PII64ATTIME    IN NUMBER,
   PIBMTMSGID     IN NUMBER,
   PISA           IN VARCHAR2,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIRETFLAG      IN NUMBER DEFAULT 1,
   PITASKTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0
 )
AS
  PIATTIMEFLAG PLS_INTEGER;
  IDCOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  PIRECVTIME := SYSTIMESTAMP;
  IDCOUNT:=0;
  PIATTIMEFLAG:=0;
  IF PIICURTIME < PII64ATTIME THEN
    PIATTIMEFLAG:=1;
  END IF;
  SELECT COUNT(ID) INTO IDCOUNT FROM BATCH_MT_REQ WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
  IF IDCOUNT = 0 THEN
    INSERT INTO BATCH_MT_REQ(BMTMSGID,USERID,LOGINID,USERUID,SERVICETYPE,SENDTYPE,MSGFMT,REMOTEURL,SENDSTATUS,
    MSGID,TASKID,TITLE,MSG,LOCALPATH,SENDLEVEL,ATTIME,VALIDTIME,ERRORCODE,RECVTIME,ATTIMEFLAG,SA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,TASKTYPE,BATCHID)
    VALUES(PIBMTMSGID,PIUSERID,PILOGINID,PIUSERUID,PISERVICETYPE,PISENDTYPE,PIMSGFMT,PIREMOTEURL,PISENDSTATUS,
    PIMSGID,PITASKID,PITITLE,PIMSG,PILOCALPATH,PISENDLEVEL,PIATTIME,PIVALIDTIME,PIERRORCODE,PIRECVTIME,PIATTIMEFLAG,PISA,
    PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIRETFLAG,PITASKTYPE,PIBATCHID);
  END IF;
  IF PIATTIMEFLAG=1 THEN
    IDCOUNT:=0;
    SELECT COUNT(*) INTO IDCOUNT FROM ATTIME_TASK WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
    IF IDCOUNT = 0 THEN
      INSERT INTO ATTIME_TASK(LOGINID,BMTMSGID,TASKID,ATTIME,VALIDTIME) VALUES (PILOGINID,PIBMTMSGID,PITASKID,PII64ATTIME,PIICURTIME);
    ELSE
      UPDATE ATTIME_TASK SET ATTIME=PII64ATTIME,VALIDTIME=PIICURTIME WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND BMTMSGID=PIBMTMSGID;
    END IF;
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MMS_MO
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MMS_MO(
PIPTMSGID IN  NUMBER,
PIUID IN NUMBER,
PIORGUID  IN NUMBER,
PIECID  IN NUMBER,

PIUNICOM  IN NUMBER,
PIPTNOTICE IN  NUMBER,
PIRESENDCNT  IN NUMBER,
PISENDSTATUS  IN NUMBER,

PIMSGFMT  IN NUMBER,
PIMSGTYPE  IN NUMBER,
PITP_PID  IN NUMBER,
PITP_UDHI  IN NUMBER,
PIPKNUMBER  IN NUMBER,
PIPKTOTAL  IN NUMBER,
PILONGMSGSEQ  IN NUMBER,
PIPASSTHROUGH  IN NUMBER,

PIUSERID   IN VARCHAR2,
PISERVICEID  IN VARCHAR2,
PISPGATE  IN VARCHAR2,
PISPNUMBER  IN VARCHAR2,
PIPHONE  IN VARCHAR2,
PIMSGTITLE  IN VARCHAR2,
PIMSGCONTENT  IN VARCHAR2,
PIDELIVERTIME  IN TIMESTAMP
)
AS
PIUSERID2 VARCHAR2(11);
PIUID2    INT ;
BEGIN
SELECT NVL(USERID,'') INTO PIUSERID2 FROM GT_PORT_USED WHERE SPISUNCM=PIUNICOM AND INSTR(RTRIM(SPGATE)+RTRIM(CPNO), PISPNUMBER, 1)>0;
SELECT NVL("UID",0) INTO PIUID2 FROM USERDATA WHERE USERID=PIUSERID2;
INSERT INTO MMS_MO(
PTMSGID,"UID",ORGUID,ECID,UNICOM,PTNOTICE,RESENDCNT,SENDSTATUS,
MSGFMT,MSGTYPE,TP_PID,TP_UDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PASSTHROUGH,
USERID,SERVICEID,SPGATE,SPNUMBER,PHONE,MSGTITLE,MSGCONTENT,DELIVERTIME)
VALUES(
PIPTMSGID,PIUID2,PIORGUID,PIECID,PIUNICOM,PIPTNOTICE,PIRESENDCNT,PISENDSTATUS,
PIMSGFMT,PIMSGTYPE,PITP_PID,PITP_UDHI,PIPKNUMBER,PIPKTOTAL,PILONGMSGSEQ,PIPASSTHROUGH,
PIUSERID2,PISERVICEID,PISPGATE,PISPNUMBER,PIPHONE,PIMSGTITLE,PIMSGCONTENT,PIDELIVERTIME);

END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MMS_RPT
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MMS_RPT(
PIPTMSGID IN NUMBER,
PISPMSGID IN  NUMBER,
PIUSERMSGID IN  NUMBER,

PIUID  IN NUMBER,
PIORGUID  IN NUMBER,
PIECID  IN NUMBER,

PISENDLEVEL IN  NUMBER,
PIRESENDCNT  IN NUMBER,

PIUSERID  IN VARCHAR2,
PISPNUMBER  IN VARCHAR2,
PIPHONE  IN VARCHAR2,
PISPMSGID2 IN  VARCHAR2,
PIERRORCODE IN  VARCHAR2,
PIERRORMSG  IN VARCHAR2,
PISUBMITTIME  IN VARCHAR2,
PIDONEDATE  IN VARCHAR2,
PIRECVTIME  IN TIMESTAMP
)
AS
PICOUNT INT;
PISPNUMBER2 VARCHAR2(21);
BEGIN
  SELECT COUNT(PTMSGID) INTO PICOUNT FROM MMS_RPT WHERE PTMSGID=PIPTMSGID;
IF PICOUNT=0 THEN
BEGIN
IF PISPNUMBER='' THEN
  BEGIN
    SELECT (RTRIM(SPGATE)+RTRIM(CPNO)) INTO PISPNUMBER2 FROM MMS_TASK WHERE PTMSGID=PIPTMSGID;
    INSERT INTO MMS_RPT(
           PTMSGID,SPMSGID,USERMSGID,"UID",ORGUID,ECID,SENDLEVEL,RESENDCNT,
           USERID,SPNUMBER,PHONE,SPMSGID2,ERRORCODE,ERRORMSG,SUBMITTIME,DONEDATE,RECVTIME)
           VALUES(
           PIPTMSGID,PISPMSGID,PIUSERMSGID,PIUID,PIORGUID,PIECID,PISENDLEVEL,PIRESENDCNT,
           PIUSERID,PISPNUMBER2,PIPHONE,PISPMSGID2,PIERRORCODE,PIERRORMSG,PISUBMITTIME,PIDONEDATE,PIRECVTIME);
  END;
  END IF;
END;
END IF;
END S_WR_MMS_RPT;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MMS_TASK
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MMS_TASK(
PIPTMSGID IN NUMBER,
PISPMSGID  IN NUMBER,
PIUSERMSGID  IN NUMBER,
PITMPLID  IN NUMBER,
PIATTIME  IN NUMBER,
PIVALIDTIME  IN NUMBER,

PIUID  IN NUMBER,
PIECID  IN NUMBER,
PITASKID  IN NUMBER,
PIMOBILEAREA  IN NUMBER,
PIMODULEID  IN NUMBER,

PIJTYPE  IN NUMBER,
PIFEEFLAG  IN NUMBER,
PIUNICOM  IN NUMBER,
PIRETFLAG  IN NUMBER,
PISENDTYPE  IN NUMBER,
PISENDLEVEL  IN NUMBER,
PISENDFLAG  IN NUMBER,
PIRECVFLAG  IN NUMBER,
PIRESENDCNT  IN NUMBER,
PISENDSTATUS  IN NUMBER,

PIMSGFMT  IN NUMBER,
PIMSGTYPE  IN NUMBER,
PITPPID  IN NUMBER,
PITPUDHI  IN NUMBER,
PIPKNUMBER IN NUMBER,
PIPKTOTAL  IN NUMBER,
PILONGMSGSEQ  IN NUMBER,
PIPASSTHROUGH  IN NUMBER,

PIUSERID  IN VARCHAR2,
PISVRTYPE  IN VARCHAR2,
PISPGATE  IN VARCHAR2,
PICPNO  IN VARCHAR2,
PIORDERCPNO  IN VARCHAR2,

PIPHONE  IN VARCHAR2,
PIMSGTITLE  IN VARCHAR2,
PIMESSAGE  IN VARCHAR2,
PISPMSGID2  IN VARCHAR2,
PIERRORCODE  IN VARCHAR2,
PIDONEDATE IN  VARCHAR2,

PIP1  IN VARCHAR2,
PIP2  IN VARCHAR2,
PIP3  IN VARCHAR2,
PIP4  IN VARCHAR2,

PIRECVMTTIME  IN TIMESTAMP,
PITRANSMTTIME  IN TIMESTAMP,
PISENDTIME  IN TIMESTAMP,
PIRECVTIME  IN TIMESTAMP,
PITRANSRPTTIME  IN TIMESTAMP,
PISENDRPTTIME  IN TIMESTAMP,
PISPID  IN VARCHAR2:=''
)
AS
PICOUNT INT;
BEGIN
  SELECT COUNT(PTMSGID) INTO PICOUNT FROM MMS_TASK WHERE PTMSGID=PIPTMSGID;
IF PICOUNT=0 THEN
INSERT INTO MMS_TASK(
PTMSGID,SPMSGID,USERMSGID,TMPLID,ATTIME,VALIDTIME,
"UID",ECID,TASKID,MOBILEAREA,MODULEID,
JTYPE,FEEFLAG,UNICOM,RETFLAG,SENDTYPE,SENDLEVEL,SENDFLAG,RECVFLAG,RESENDCNT,SENDSTATUS,
MSGFMT,MSGTYPE,TPPID,TPUDHI,PKNUMBER,PKTOTAL,LONGMSGSEQ,PASSTHROUGH,
USERID,SVRTYPE,SPGATE,CPNO,ORDERCPNO,
PHONE,MSGTITLE,MESSAGE,SPMSGID2,ERRORCODE,DONEDATE,
P1,P2,P3,P4,
RECVMTTIME,TRANSMTTIME,SENDTIME,RECVTIME,TRANSRPTTIME,SENDRPTTIME,SPID)
VALUES(
PIPTMSGID,PISPMSGID,PIUSERMSGID,PITMPLID,PIATTIME,PIVALIDTIME,
PIUID,PIECID,PITASKID,PIMOBILEAREA,PIMODULEID,
PIJTYPE,PIFEEFLAG,PIUNICOM,PIRETFLAG,PISENDTYPE,PISENDLEVEL,PISENDFLAG,PIRECVFLAG,PIRESENDCNT,PISENDSTATUS,
PIMSGFMT,PIMSGTYPE,PITPPID,PITPUDHI,PIPKNUMBER,PIPKTOTAL,PILONGMSGSEQ,PIPASSTHROUGH,
PIUSERID,PISVRTYPE,PISPGATE,PICPNO,PIORDERCPNO,
PIPHONE,PIMSGTITLE,PIMESSAGE,PISPMSGID2,PIERRORCODE,PIDONEDATE,
PIP1,PIP2,PIP3,PIP4,
PIRECVMTTIME,PITRANSMTTIME,PISENDTIME,PIRECVTIME,PITRANSRPTTIME,PISENDRPTTIME,PISPID);
END IF;
END S_WR_MMS_TASK;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MOTASK
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MOTASK
 (
  PIUID           IN NUMBER,
  PIPTMSGID       IN NUMBER,
  PISENDSTATUS    IN NUMBER,
  PIMSGFMT        IN NUMBER,
  PIECID          IN NUMBER,
  PIUSERID        IN VARCHAR2,
  PISPNUMBER      IN VARCHAR2,
  PISERVICEID     IN VARCHAR2,
  PIDELIVERTIME   IN VARCHAR2,
  PIPHONE         IN VARCHAR2,
  PIMSGCONTENT    IN VARCHAR2,
  PIORGUID        IN NUMBER,
  PISPGATE        IN VARCHAR2,
  PITPUDHI        IN NUMBER,
  PITPPID         IN NUMBER,
  PIPKNUMBER      IN NUMBER,
  PIPKTOTAL       IN NUMBER,
  PILONGMSGSEQ    IN NUMBER,
  PIPTNOTICE      IN NUMBER,
  PIUNICOM        IN NUMBER DEFAULT 0,
  PICMDID         IN NUMBER
 )
AS
  ICOUNT PLS_INTEGER;
  --TO_DATE(PIDELIVERTIME,'YYYY-MM-DD HH24:MI:SS.FF')
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MO_TASK WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO MO_TASK("UID",PTMSGID,SPNUMBER,SERVICEID,SENDSTATUS,MSGFMT,DELIVERTIME,PHONE,
    MSGCONTENT,ECID,USERID,ORGUID,SPGATE,TP_UDHI,TP_PID,PKNUMBER,PKTOTAL,LONGMSGSEQ,PTNOTICE,UNICOM,CMDID)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PISERVICEID,PISENDSTATUS,PIMSGFMT,SYSTIMESTAMP,PIPHONE,PIMSGCONTENT,
    PIECID,PIUSERID,PIORGUID,PISPGATE,PITPUDHI,PITPPID,PIPKNUMBER,PIPKTOTAL,PILONGMSGSEQ,PIPTNOTICE,PIUNICOM,PICMDID);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MOWAITA
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MOWAITA
 (
   PIECID        IN NUMBER,
   PIUSERUID     IN NUMBER,
   PILOGINUID    IN NUMBER,
   PIPTMSGID     IN NUMBER,
   PIUSERID      IN VARCHAR2,
   PIPHONE       IN VARCHAR2,
   PISPNUMBER    IN VARCHAR2,
   PIDELIVERTIME IN VARCHAR2,
   PIMESSAGE     IN VARCHAR2,
   PISPGATE      IN VARCHAR2,
   PICPNO        IN VARCHAR2,
   PIUNICOM      IN NUMBER,
   PICMDID       IN NUMBER
 )
AS
  PIUSERID2 VARCHAR2(11);
  PISPNUMBER2 VARCHAR2(21);
  ICOUNT PLS_INTEGER;
  --TO_DATE(PIDELIVERTIME,'YYYY-MM-DD HH24:MI:SS.FF')
BEGIN
  PIUSERID2:=PIUSERID;
  PISPNUMBER2:=PISPNUMBER;
  IF (PIUSERID2 IS NULL) THEN
    SELECT USERID,RTRIM(SPNUMBER) INTO PIUSERID2,PISPNUMBER2 FROM MO_TASK WHERE PTMSGID=PIPTMSGID;
  END IF;
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM  MO_WAIT_A WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO MO_WAIT_A(ECID,USERUID,LOGINUID,PTMSGID,USERID,SPNUMBER,PHONE,DELIVERTIME,MESSAGE,SPGATE,CPNO,UNICOM,CMDID)
    VALUES(PIECID,PIUSERUID,PILOGINUID,PIPTMSGID,PIUSERID2,PISPNUMBER2,PIPHONE,SYSTIMESTAMP,PIMESSAGE,PISPGATE,PICPNO,PIUNICOM,PICMDID);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MOWAITC
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MOWAITC
 (
   PIUID           IN NUMBER,
   PIPTMSGID       IN NUMBER,
   PISENDSTATUS    IN NUMBER,
   PIMSGFMT        IN NUMBER,
   PISPNUMBER      IN VARCHAR2,
   PISERVICEID     IN VARCHAR2,
   PIDELIVERTIME   IN VARCHAR2,
   PIPHONE         IN VARCHAR2,
   PIMSGCONTENT    IN VARCHAR2,
   PILOGINID       IN VARCHAR2,
   PITPPID         IN NUMBER,
   PITPUDHI        IN NUMBER,
   PIPKNUMBER      IN NUMBER,
   PIPKTOTAL       IN NUMBER,
   PIPTNOTICE      IN NUMBER
 )
AS
  --TO_DATE(NVL(PIDELIVERTIME,' '),'YYYY-MM-DD HH24:MI:SS.FF')
  ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MO_WAIT_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO MO_WAIT_C("UID", PTMSGID, SPNUMBER, SERVICEID, SENDSTATUS, MSGFMT, DELIVERTIME, PHONE, MSGCONTENT,LOGINID,TP_UDHI,TP_PID,PKNUMBER,PKTOTAL,PTNOTICE)
    VALUES(PIUID, PIPTMSGID, PISPNUMBER, PISERVICEID, PISENDSTATUS, PIMSGFMT, SYSTIMESTAMP, PIPHONE, PIMSGCONTENT,PILOGINID,PITPUDHI,PITPPID,PIPKNUMBER,PIPKTOTAL,PIPTNOTICE);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTLVLQUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTLVLQUE
 (
   PIUID        IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIRETFLAG    IN NUMBER,
   PIPKTOTAL    IN NUMBER,
   PIPHONECOUNT IN NUMBER,
   PISENDSTATUS IN NUMBER,
   PISPLITFLAG  IN NUMBER,
   PIECID       IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPGATE     IN VARCHAR2,
   PICPNO       IN VARCHAR2,
   PIRECVMTTIME IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PIMESSAGE    IN VARCHAR2,
   PIFEEFLAG    IN NUMBER,
   PIDESTUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPKNUMBER   IN NUMBER,
   PISENDLEVEL  IN NUMBER,
   PITPUDHI     IN NUMBER,
   PITASKID     IN NUMBER,
   PILONGMSGSEQ IN NUMBER,
   PIMSGFMT     IN NUMBER,
   PITOTALCOUNT IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME       IN NUMBER DEFAULT 0,
   PIVALIDTIME    IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0,
   PIAREACODE     IN NUMBER DEFAULT 0
 )
AS
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL0_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
END;
/
CREATE OR REPLACE PROCEDURE GW_WR_MTLVLQUEV1
 (
   PIUID        IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIRETFLAG    IN NUMBER,
   PIPKTOTAL    IN NUMBER,
   PIPHONECOUNT IN NUMBER,
   PISENDSTATUS IN NUMBER,
   PISPLITFLAG  IN NUMBER,
   PIECID       IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPGATE     IN VARCHAR2,
   PICPNO       IN VARCHAR2,
   PIRECVMTTIME IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PIMESSAGE    IN VARCHAR2,
   PIFEEFLAG    IN NUMBER,
   PIDESTUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPKNUMBER   IN NUMBER,
   PISENDLEVEL  IN NUMBER,
   PITPUDHI     IN NUMBER,
   PITASKID     IN NUMBER,
   PILONGMSGSEQ IN NUMBER,
   PIMSGFMT     IN NUMBER,
   PITOTALCOUNT IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME       IN NUMBER DEFAULT 0,
   PIVALIDTIME    IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0,
   PIAREACODE     IN NUMBER DEFAULT 0,
   PICUSTID     IN MT_LEVEL0_QUEUE.CUSTID%TYPE,
   PIEXDATA    IN MT_LEVEL0_QUEUE.EXDATA%TYPE
 )
AS
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL0_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTTASKC
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTTASKC
 (
  PIUID          IN NUMBER,
  PIPTMSGID      IN NUMBER,
  PISENDSTATUS   IN NUMBER,
  PIRETFLAG      IN NUMBER,
  PIPKNUMBER     IN NUMBER,
  PIPKTOTAL      IN NUMBER,
  PIPHONECOUNT   IN NUMBER,
  PIUSERID       IN VARCHAR2,
  PISPGATE       IN VARCHAR2,
  PICPNO         IN VARCHAR2,
  PIRECVMTTIME   IN VARCHAR2,
  PIPHONE        IN VARCHAR2,
  PIMESSAGE      IN VARCHAR2,
  PITPUDHI       IN NUMBER,
  PILOGINID      IN VARCHAR2,
  PIMSGFMT       IN NUMBER,
  PILONGMSGSEQ   IN NUMBER,
  PIUSERMSGID    IN NUMBER DEFAULT 0,
  PIMODULEID     IN NUMBER DEFAULT 0,
  PISENDLEVEL    IN NUMBER DEFAULT 5,
  PIVALIDTIME    IN NUMBER DEFAULT 0,
  PIUNICOM       IN NUMBER DEFAULT 0,
  PITASKID       IN NUMBER DEFAULT 0,
  PIMOBILEAREA   IN NUMBER DEFAULT 0
 )
AS
--TO_DATE(NVL(PISENDTIME,' '),'YYYY-MM-DD HH24:MI:SS.FF')
ICOUNT PLS_INTEGER;
PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
    INSERT INTO MT_TASK_C("UID", LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
    SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME, TPUDHI, LONGMSGSEQ, MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA )
    VALUES(PIUID, PILOGINID,PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
    PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PITPUDHI, PILONGMSGSEQ, PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA );
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTTMRQUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTTMRQUE
 (
   PIUID          IN NUMBER,
   PIPTMSGID      IN NUMBER,
   PIRETFLAG      IN NUMBER,
   PIPKTOTAL      IN NUMBER,
   PIPHONECOUNT   IN NUMBER,
   PISENDSTATUS   IN NUMBER,
   PISPLITFLAG    IN NUMBER,
   PIECID         IN NUMBER,
   PIUSERID       IN VARCHAR2,
   PISPGATE       IN VARCHAR2,
   PICPNO         IN VARCHAR2,
   PIRECVMTTIME   IN VARCHAR2,
   PIPHONE        IN VARCHAR2,
   PIMESSAGE      IN VARCHAR2,
   PIFEEFLAG      IN NUMBER,
   PIDESTUID      IN NUMBER,
   PILOGINUID     IN NUMBER,
   PIPKNUMBER     IN NUMBER,
   PISENDLEVEL    IN NUMBER,
   PITPUDHI       IN NUMBER,
   PITASKID       IN NUMBER,
   PILONGMSGSEQ   IN NUMBER,
   PIMSGFMT       IN NUMBER,
   PITOTALCOUNT   IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME         IN NUMBER DEFAULT 0,
   PIVALIDTIME      IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0
 )
AS
  PIRECVMTTIME_P TIMESTAMP(6);
  ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TIMER_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF PIRECVMTTIME IS NULL THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
    INSERT INTO MT_TIMER_QUEUE("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,RETFLAG,PKTOTAL,TOTALCOUNT,PHONECOUNT,
    SENDTIME,SENDSTATUS,SPLITFLAG,ECID,FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIPHONE,PIPTMSGID,PIMESSAGE,PIRETFLAG,PIPKTOTAL,PITOTALCOUNT,PIPHONECOUNT,PIRECVMTTIME_P,
   PISENDSTATUS,PISPLITFLAG,PIECID,PIFEEFLAG,PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTVRFYWAIT
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTVRFYWAIT
 (
   PIUID        IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIRETFLAG    IN NUMBER,
   PIPKTOTAL    IN NUMBER,
   PIPHONECOUNT IN NUMBER,
   PISENDSTATUS IN NUMBER,
   PISPLITFLAG  IN NUMBER,
   PIECID       IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPGATE     IN VARCHAR2,
   PICPNO       IN VARCHAR2,
   PIRECVMTTIME IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PIMESSAGE    IN VARCHAR2,
   PIFEEFLAG    IN NUMBER,
   PIDESTUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPKNUMBER   IN NUMBER,
   PISENDLEVEL  IN NUMBER,
   PITPUDHI     IN NUMBER,
   PITASKID     IN NUMBER,
   PILONGMSGSEQ IN NUMBER,
   PIMSGFMT     IN NUMBER,
   PITOTALCOUNT IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME       IN NUMBER DEFAULT 0,
   PIVALIDTIME    IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0
 )
AS
ICOUNT PLS_INTEGER;
PIDEALSTATUS PLS_INTEGER;
PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  IF PISENDSTATUS>=10 THEN
    PIDEALSTATUS:=0;
  ELSE
    PIDEALSTATUS:=1;
  END IF;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
  IF PIRECVMTTIME IS NULL THEN
     PIRECVMTTIME_P:=SYSTIMESTAMP;
  ELSE
     PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;
  INSERT INTO /*+APPEND*/ MT_VERIFY_WAIT("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,RETFLAG,PKTOTAL,TOTALCOUNT,PHONECOUNT,
  SENDTIME,SENDSTATUS,DEALSTATUS,SPLITFLAG,ECID,FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,
  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID)
  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIPHONE,PIPTMSGID,PIMESSAGE,PIRETFLAG,PIPKTOTAL,PITOTALCOUNT,PIPHONECOUNT,PIRECVMTTIME_P,
  PISENDSTATUS,PIDEALSTATUS,PISPLITFLAG,PIECID,PIFEEFLAG,PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,PILONGMSGSEQ,
  PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID);
  END IF;
END;
/



--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTWAITA
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_MTWAITA
 (
  PILOGINUID    IN NUMBER,
  PIUSERUID     IN NUMBER,
  PIUSERID      IN VARCHAR2,
  PIPTMSGID     IN NUMBER,
  PISPNUMBER    IN VARCHAR2,
  PISENDSTATUS  IN NUMBER,
  PIPHONECOUNT  IN NUMBER,
  PIRECVMTTIME  IN VARCHAR2,
  PIMESSAGE     IN VARCHAR2,
  PIPHONE       IN VARCHAR2,
  PITASKID      IN NUMBER,
  PISENDLEVEL   IN NUMBER,
  PIMSGFMT      IN NUMBER,
  PISVRTYPE   IN VARCHAR2,
  PIP1     IN VARCHAR2,
  PIP2     IN VARCHAR2,
  PIP3     IN VARCHAR2,
  PIP4     IN VARCHAR2,
  PIUSERMSGID   IN NUMBER DEFAULT 0,
  PIMODULEID    IN NUMBER DEFAULT 0,
  PIRETFLAG     IN NUMBER DEFAULT 1,
  ATTIME        IN NUMBER DEFAULT 0,
  VALIDTIME     IN NUMBER DEFAULT 0,
  PISENDTYPE    IN NUMBER DEFAULT 1,
  PIBATCHID     IN NUMBER DEFAULT 0,
  PITOTALCOUNT  IN NUMBER DEFAULT 0
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_WAIT_A WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
  IF PIRECVMTTIME IS NULL THEN
     PIRECVMTTIME_P:=SYSTIMESTAMP;
  ELSE
     PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;
    INSERT INTO MT_WAIT_A (PTMSGID,LOGINUID,ECID,USERUID,USERID,SPNUMBER,SENDSTATUS,SENDLEVEL,SENDTIME,PHONECOUNT,MESSAGE,PHONE,TASKID,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,RETFLAG,ATTIME,VALIDTIME,SENDTYPE,BATCHID,TOTALCOUNT)
    VALUES(PIPTMSGID,PILOGINUID,0,PIUSERUID,PIUSERID,PISPNUMBER,PISENDSTATUS,PISENDLEVEL,PIRECVMTTIME_P,PIPHONECOUNT,PIMESSAGE,PIPHONE,PITASKID,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIRETFLAG,ATTIME,VALIDTIME,PISENDTYPE,PIBATCHID,PITOTALCOUNT);
  END IF;
END;
/



--PROMPT
--PROMPT CREATING PROCEDURE S_WR_RPTWAITC
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_WR_RPTWAITC
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISPGATE       IN VARCHAR2,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PILOGINID      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0
 )
AS
BEGIN
    INSERT INTO RPT_WAIT_C("UID", PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME, ERRORCODE,LOGINID,USERMSGID,MODULEID)
    VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME, PIERRORCODE,PILOGINID,PIUSERMSGID,PIMODULEID);
END;
/
CREATE OR REPLACE PROCEDURE CREATETABLE(PITYPE NUMBER,PIYM NUMBER)
AUTHID CURRENT_USER
IS
PISTR VARCHAR2(4000);
PISTR_1 VARCHAR2(256);
PITABLENAME VARCHAR2(20);
BEGIN
  IF PITYPE=1 THEN
    PITABLENAME:='MTTASK'||CAST(PIYM AS CHAR);
    PISTR:='CREATE TABLE '||PITABLENAME||
    '(
    ID         NUMBER(22) NOT NULL,
    MDAY       NUMBER(11) NOT NULL,
    USERID     VARCHAR2(11) NOT NULL,
    SPID       VARCHAR2(32) DEFAULT ('' '') NOT NULL,
    SPGATE     VARCHAR2(21) NOT NULL,
    CPNO       VARCHAR2(21) NOT NULL,
    PHONE      VARCHAR2(21) NOT NULL,
    SPMSGID    NUMBER(22) NOT NULL,
    RETFLAG    NUMBER(11) NOT NULL,
    FEEFLAG    NUMBER(11) NOT NULL,
    PKNUMBER   NUMBER(11) NOT NULL,
    PKTOTAL    NUMBER(11) NOT NULL,
    SENDSTATUS NUMBER(11) NOT NULL,
    SENDFLAG   NUMBER(11) NOT NULL,
    RECVFLAG   NUMBER(11) NOT NULL,
    DONEDATE   CHAR(10) NOT NULL,
    ERRORCODE  CHAR(7) NOT NULL,
    SENDLEVEL  NUMBER(11) NOT NULL,
    SENDTYPE   NUMBER(11) NOT NULL,
    UNICOM     NUMBER(11) NOT NULL,
    MOBILEAREA NUMBER(11) DEFAULT 0 NOT NULL,
    SENDTIME   TIMESTAMP(6) NOT NULL,
    RECVTIME   TIMESTAMP(6) NOT NULL,
    MESSAGE    VARCHAR2(3000) NOT NULL,
    TASKID     NUMBER(11) NOT NULL,
    ECID       NUMBER(11) NOT NULL,
    PTMSGID    NUMBER(22) NOT NULL,
    USERMSGID  NUMBER(22) DEFAULT 0 NOT NULL,
    MODULEID   NUMBER(11) DEFAULT 0 NOT NULL,
    SVRTYPE    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P1         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P2         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P3         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P4         VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    ATTIME     NUMBER(22) DEFAULT 0 NOT NULL,
    VALIDTIME  NUMBER(22) DEFAULT 0 NOT NULL,
    BATCHID    NUMBER(22) DEFAULT 0 NOT NULL,
    AREACODE   NUMBER(11) DEFAULT 0 NOT NULL,
    CUSTID     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    EXDATA     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
	LONGMSG	 VARCHAR2(4000) DEFAULT ('' '') NOT NULL,
	TMPLID 	 NUMBER(22) DEFAULT 0 NOT NULL,
	CHGRADE 	 NUMBER(11) DEFAULT 0 NOT NULL,
	MSGTYPE 	 NUMBER(11) DEFAULT 0 NOT NULL,
	RMSVALIDTM NUMBER(11) DEFAULT 0 NOT NULL,
	ERRORCODE2 CHAR(7) DEFAULT ('' '') NOT NULL,
	DOWNTM TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
	RMSRPTFLAG NUMBER(11) DEFAULT 1 NOT NULL,
    PROTOCOLVER	NUMBER(11) DEFAULT 0 NOT NULL,
    TMPLTYPE	NUMBER(11) DEFAULT 0 NOT NULL,
    TITLE	 VARCHAR2(40) DEFAULT ('' '') NOT NULL,
    SHOWAY	 VARCHAR2(16) DEFAULT ('' '') NOT NULL,
    DLDWAY	NUMBER(11) DEFAULT 0 NOT NULL,
    DLDNEY	NUMBER(11) DEFAULT 0 NOT NULL,
    ISFREE	NUMBER(11) DEFAULT 0 NOT NULL,
    SHOWTIME 	 NUMBER(22) DEFAULT 0 NOT NULL,
	SUID1 VARCHAR2(64) DEFAULT ('' '') NOT NULL,
	LUID1 VARCHAR2(64) DEFAULT ('' '') NOT NULL
    )
    TABLESPACE TBSHISDATA
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_P1 ON '||PITABLENAME||'(P1)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE UNIQUE INDEX IX_'||PITABLENAME||'_PTID ON '||PITABLENAME||'(PTMSGID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_SVRTYPE ON '||PITABLENAME||'(SVRTYPE)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||'(TASKID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_SENDTIME ON '||PITABLENAME||'(SENDTIME)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_UID ON '||PITABLENAME||'(USERID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_BATCHID ON '||PITABLENAME||'(BATCHID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_AREACODE ON '||PITABLENAME||'(AREACODE)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_PHONE ON '||PITABLENAME||'(PHONE)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;

  ELSIF PITYPE=2 THEN
    PITABLENAME:='MMSTASK'||CAST(PIYM AS CHAR);
    PISTR:='CREATE TABLE '||PITABLENAME||
    '(
    ID          NUMBER(22) NOT NULL,
    MDAY        NUMBER(11) DEFAULT 0 NOT NULL,
    USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
    SPGATE      VARCHAR2(21) DEFAULT ('' '') NOT NULL,
    CPNO        VARCHAR2(21) DEFAULT ('' '') NOT NULL,
    PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
    SPMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
    RETFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
    FEEFLAG     NUMBER(11) DEFAULT 0 NOT NULL,
    PKNUMBER    NUMBER(11) DEFAULT 0 NOT NULL,
    PKTOTAL     NUMBER(11) DEFAULT 0 NOT NULL,
    SENDSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
    SENDFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
    RECVFLAG    NUMBER(11) DEFAULT 0 NOT NULL,
    DONEDATE    VARCHAR2(10) DEFAULT ('' '') NOT NULL,
    ERRORCODE   VARCHAR2(7) DEFAULT ('' '') NOT NULL,
    SENDLEVEL   NUMBER(11) DEFAULT 0 NOT NULL,
    SENDTYPE    NUMBER(11) DEFAULT 0 NOT NULL,
    UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
    SENDTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
    RECVTIME    TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
    MESSAGE     VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
    TASKID      NUMBER(11) DEFAULT 0 NOT NULL,
    ECID        NUMBER(11) DEFAULT 0 NOT NULL,
    PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
    SPID        VARCHAR2(32) DEFAULT ('' '') NOT NULL,
    MOBILEAREA  NUMBER(11) DEFAULT 0 NOT NULL,
    SVRTYPE     VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P1          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P2          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P3          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    P4          VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    USERMSGID   NUMBER(22) DEFAULT 0 NOT NULL,
    MODULEID    NUMBER(11) DEFAULT 0 NOT NULL,
    ATTIME      NUMBER(22) DEFAULT 0 NOT NULL,
    VALIDTIME   NUMBER(22) DEFAULT 0 NOT NULL,
    SPMSGID2    VARCHAR2(64) DEFAULT ('' '') NOT NULL,
    JTYPE       NUMBER(11) DEFAULT 0 NOT NULL,
    ORDERCPNO   VARCHAR2(21) DEFAULT ('' '') NOT NULL,
    PASSTHROUGH NUMBER(11) DEFAULT 0 NOT NULL,
    MSGTITLE    VARCHAR2(720) DEFAULT ('' '') NOT NULL,
    TMPLID      NUMBER(22) DEFAULT 0 NOT NULL,
    MSGTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
    ERRORMSG    VARCHAR2(256) DEFAULT ('' '') NOT NULL
    )
    TABLESPACE TBSHISDATA
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR;
    PISTR_1:='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT PK_'||PITABLENAME||' PRIMARY KEY (ID)'||'
    USING INDEX
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_P1 ON '||PITABLENAME||' (P1)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE UNIQUE INDEX IX_'||PITABLENAME||'_PTMSGID ON '||PITABLENAME||' (PTMSGID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_SENDTIME ON '||PITABLENAME||' (SENDTIME)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_SVRTYPE ON '||PITABLENAME||' (SVRTYPE)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_TASKID ON '||PITABLENAME||' (TASKID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
    PISTR_1:='CREATE INDEX IX_'||PITABLENAME||'_USERID ON '||PITABLENAME||' (USERID)'||'
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;

  ELSIF PITYPE=3 THEN
    PITABLENAME:='MOTASK'||CAST(PIYM AS CHAR);
    PISTR:='CREATE TABLE '||PITABLENAME||
    '(
    ID          NUMBER(22) NOT NULL,
    "UID"         NUMBER(11) NOT NULL,
    USERID      VARCHAR2(11) NOT NULL,
    SPNUMBER    VARCHAR2(21) NOT NULL,
    SERVICEID   VARCHAR2(10) NOT NULL,
    SENDSTATUS  NUMBER(11) NOT NULL,
    DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
    PHONE       VARCHAR2(21) NOT NULL,
    MSGCONTENT  VARCHAR2(3000) NOT NULL,
    ECID        NUMBER(11) NOT NULL,
    ORGUID      NUMBER(11) NOT NULL,
    PTMSGID     NUMBER(22) NOT NULL,
    TP_PID      NUMBER(11) NOT NULL,
    TP_UDHI     NUMBER(11) NOT NULL,
    MSGFMT      NUMBER(11) NOT NULL,
    UNICOM      NUMBER(11) DEFAULT 0 NOT NULL
    )
    TABLESPACE TBSHISDATA
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR;
    PISTR_1:='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT '||PITABLENAME||'_PRIMARY PRIMARY KEY (ID)'||'
    USING INDEX
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
  ELSE
     PITABLENAME:='MMSMOTASK'||CAST(PIYM AS CHAR);
     PISTR:='CREATE TABLE '||PITABLENAME||
     '(
      ID          NUMBER(22) NOT NULL,
      "UID"         NUMBER(11) DEFAULT 0 NOT NULL,
      USERID      VARCHAR2(11) DEFAULT ('' '') NOT NULL,
      SPNUMBER    VARCHAR2(11) DEFAULT ('' '') NOT NULL,
      SERVICEID   VARCHAR2(10) DEFAULT ('' '') NOT NULL,
      SENDSTATUS  NUMBER(11) DEFAULT 0 NOT NULL,
      DELIVERTIME TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
      PHONE       VARCHAR2(21) DEFAULT ('' '') NOT NULL,
      MSGCONTENT  VARCHAR2(3000) DEFAULT ('' '') NOT NULL,
      ECID        NUMBER(11) DEFAULT 0 NOT NULL,
      ORGUID      NUMBER(11) DEFAULT 0 NOT NULL,
      PTMSGID     NUMBER(22) DEFAULT 0 NOT NULL,
      TP_PID      NUMBER(11) DEFAULT 0 NOT NULL,
      TP_UDHI     NUMBER(11) DEFAULT 0 NOT NULL,
      MSGFMT      NUMBER(11) DEFAULT 15 NOT NULL,
      UNICOM      NUMBER(11) DEFAULT 0 NOT NULL,
      MSGTYPE     NUMBER(11) DEFAULT 0 NOT NULL,
      MSGTITLE    VARCHAR2(200) DEFAULT ('' '') NOT NULL,
      PASSTHROUGH NUMBER(11) DEFAULT 0 NOT NULL
    )
    TABLESPACE TBSHISDATA
    PCTFREE 10
    INITRANS 1
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR;
    PISTR_1:='ALTER TABLE '||PITABLENAME||' ADD CONSTRAINT PK_'||PITABLENAME||' PRIMARY KEY (ID)'||'
    USING INDEX
    TABLESPACE TBSHISINDEX
    PCTFREE 10
    INITRANS 2
    MAXTRANS 255
    STORAGE
    (
      INITIAL 64K
      MINEXTENTS 1
      MAXEXTENTS UNLIMITED
    )';
    EXECUTE IMMEDIATE PISTR_1;
  END IF;
  END;
/


CREATE OR REPLACE PROCEDURE H_TRANSFER(MININDEX IN NUMBER,
                                     MAXINDEX IN NUMBER,
                                     PROCESSFLAG IN NUMBER,
                                     LOTSIZE IN NUMBER) IS
PISTR VARCHAR2(4000);
PITABLENAME VARCHAR2(20);
MINYM NUMBER;
MAXYM NUMBER;
CURYM NUMBER;
BEGIN
  --------------------VER 3.1-------------------------------------
   SELECT CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT) INTO MAXYM,MINYM FROM MT_TASK WHERE ID BETWEEN MININDEX AND MAXINDEX;

   CURYM := MINYM;
   WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);

      PISTR:= 'INSERT INTO '||PITABLENAME||' NOLOGGING (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,
      PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,
      ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
      SELECT ID,TO_NUMBER(TO_CHAR(M.SENDTIME,''DD'')),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,
      SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,
      PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
      FROM MT_TASK M
      WHERE CAST(TO_CHAR(SENDTIME,''YYYYMM'')AS INT) ='||CURYM||' AND (M.ID <='||MAXINDEX||') ';
      --DBMS_OUTPUT.PUT_LINE(PISTR);
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
   END LOOP;
END H_TRANSFER;
/


CREATE OR REPLACE PROCEDURE H_MMSTRANSFER(MININDEX IN NUMBER,
                                     MAXINDEX IN NUMBER,
                                     PROCESSFLAG IN NUMBER,
                                     LOTSIZE IN NUMBER) IS
PISTR VARCHAR2(4000);
PITABLENAME VARCHAR2(20);
MINYM NUMBER;
MAXYM NUMBER;
CURYM NUMBER;
BEGIN
  --------------------VER 3.1-------------------------------------

   SELECT CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT) INTO MAXYM,MINYM FROM MMS_TASK WHERE ID BETWEEN MININDEX AND MAXINDEX;

   CURYM := MINYM;
   WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MMSTASK'||CAST(CURYM AS CHAR);

      PISTR:=  'INSERT INTO '||PITABLENAME||' NOLOGGING (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SPMSGID2,JTYPE,ORDERCPNO,PASSTHROUGH,MSGTITLE,TMPLID,MSGTYPE,ERRORMSG)
                SELECT ID,TO_NUMBER(TO_CHAR(M.SENDTIME,''DD'')),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SPMSGID2,JTYPE,ORDERCPNO,PASSTHROUGH,MSGTITLE,TMPLID,MSGTYPE,ERRORMSG
                FROM MMS_TASK M
      WHERE CAST(TO_CHAR(SENDTIME,''YYYYMM'')AS INT) ='||CURYM||' AND (M.ID <='||MAXINDEX||') ';
      --DBMS_OUTPUT.PUT_LINE(PISTR);
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
   END LOOP;
END H_MMSTRANSFER;
/

CREATE OR REPLACE PROCEDURE H_TRANSFERMO
AUTHID CURRENT_USER
IS
       PRAGMA AUTONOMOUS_TRANSACTION ;
       CURRINDEX             NUMBER; --当前处理位置
       MAXINDEX              NUMBER; --此次执行的最大位置
       PROCESSFLAG           NUMBER; --处理方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推
       STR                   VARCHAR2(4000);  --动态语句
       STR_1                 VARCHAR2(1024);  --动态语句
       TABLENAME             VARCHAR2(20);    --表名
       ISEXIST               NUMBER;          --存在标志
      -- MONINDEX              NUMBER;          --月索引
       MINYM   NUMBER;
       MAXYM   NUMBER;
       CURYM   NUMBER;
       PITABLENAME VARCHAR2(20);
       PIERROR VARCHAR2(4000);


BEGIN
  --------------------VER 3.2-------------------------------------
  CURRINDEX             := 0;
  MAXINDEX              := 0;
  PROCESSFLAG           := 3;
  --MONINDEX              := 1;
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0),CAST(TO_CHAR(MIN(DELIVERTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(DELIVERTIME),'YYYYMM')AS INT) INTO CURRINDEX,MAXINDEX, MINYM,MAXYM FROM MO_TASK  WHERE  MO_TASK.DELIVERTIME <TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
  --判断是否有数据
  IF(MAXINDEX <> 0) THEN
  BEGIN
    --创建不存在的上行历史数据表
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MOTASK'||CAST(CURYM AS CHAR);
      STR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE STR INTO ISEXIST;
      --DBMS_OUTPUT.PUT_LINE(ISEXIST);
      IF ISEXIST<1 THEN
        STR:='CALL CREATETABLE (3,'||CAST(CURYM AS CHAR)||')';
        BEGIN
          EXECUTE IMMEDIATE STR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS',' 短信创建下行历史表：CREATETABLE',PIERROR);
            COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --删除临时表
          TABLENAME :='MO_TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;

       --创建临时表
       STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
              USERID VARCHAR2(11),
              SPGATE VARCHAR2(21),
              SPISUNCM NUMBER(11),
              IYMD NUMBER(11),
              IYEAR NUMBER(11),
              IMONTH NUMBER(11),
              IHOUR NUMBER(11),
              ICOUNT NUMBER(11)
       )';
       -- DBMS_OUTPUT.PUT_LINE(STR);
       BEGIN
         EXECUTE IMMEDIATE STR;
         EXCEPTION WHEN OTHERS THEN
           PIERROR:=SQLERRM;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行创建临时表：MO_TMEP_STATISTICS',PIERROR);
           COMMIT;
       END;

       --统计
       BEGIN
       STR :=' INSERT INTO ' || TABLENAME || ' (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT) SELECT USERID,SPNUMBER,UNICOM,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMMDD'')) AS IYMD,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYY'')) AS IYEAR,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''MM'')) AS MON,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''HH24'')) AS HOUR,
              COUNT(ID)
              FROM MO_TASK
              WHERE DELIVERTIME <TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'')
              GROUP BY  USERID,SPNUMBER,UNICOM,
               TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''MM'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''HH24''))';
               -- DBMS_OUTPUT.PUT_LINE(STR);
                EXECUTE IMMEDIATE STR;
         --插入或更新统计表
        STR := 'MERGE INTO MO_DATAREPORT M
                 USING  '|| TABLENAME || ' T
                 ON(M.USERID = T.USERID AND
                    M.SPGATE = T.SPGATE AND
                    M.SPISUNCM = T.SPISUNCM AND
                    M.IYMD = T.IYMD AND
                    M.IYEAR = T.IYEAR AND
                    M.IMONTH = T.IMONTH AND
                    M.IHOUR = T.IHOUR)
                 WHEN MATCHED THEN
                      UPDATE SET M.ICOUNT = T.ICOUNT
                 WHEN NOT MATCHED THEN
                      INSERT (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
                      VALUES(T.USERID,T.SPGATE,T.SPISUNCM,T.IYMD,T.IYEAR,T.IMONTH,T.IHOUR,T.ICOUNT)';
         EXECUTE IMMEDIATE STR;
         EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行汇总',PIERROR);
            COMMIT;
         END;

   SAVEPOINT A;
   --转移
   CURYM := MINYM;
   WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MOTASK'||CAST(CURYM AS CHAR);

      STR := 'INSERT INTO '||PITABLENAME||' NOLOGGING  SELECT  M.ID,"UID",USERID,SPNUMBER,SERVICEID,SENDSTATUS,DELIVERTIME,PHONE,MSGCONTENT,ECID,ORGUID,PTMSGID,TP_PID,TP_UDHI,MSGFMT,UNICOM
                                                                   FROM MO_TASK M
                                                                   WHERE (TO_NUMBER(TO_CHAR(M.DELIVERTIME,''YYYYMM'')) ='||CURYM||') AND DELIVERTIME <TO_DATE(TO_CHAR(SYSDATE - '||TO_CHAR(PROCESSFLAG)||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'')';
                    --DBMS_OUTPUT.PUT_LINE(STR);
      STR_1:= 'DELETE  FROM MO_TASK  WHERE (TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMM'')) ='||CURYM||') AND DELIVERTIME <TO_DATE(TO_CHAR(SYSDATE - '||TO_CHAR(PROCESSFLAG)||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'')';
      BEGIN
      EXECUTE IMMEDIATE STR;
      EXECUTE IMMEDIATE STR_1;
      EXCEPTION
        WHEN OTHERS THEN
          --DBMS_OUTPUT.PUT_LINE('短信上行调度异常，发生回滚！');
          ROLLBACK;
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信上行数据转移',PIERROR);
          COMMIT;
      END;
      COMMIT;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
   END LOOP;
END;
END IF;
END H_TRANSFERMO;
/


CREATE OR REPLACE PROCEDURE H_DATATRANSFER
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  PROCESSFLAG           NUMBER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值
  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行开始');
COMMIT;

--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 1;
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  PROCESSFLAG           := 3;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;


  --先汇总
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM MT_TASK  WHERE ( MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));
  IF PIMAXINDEX>0 THEN
    BEGIN
      H_STATISTICS(PROCESSFLAG);
      EXCEPTION WHEN OTHERS THEN
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总H_STATISTICS',PIERROR);
        COMMIT;
    END;

  END IF;
  --再转移
  --先根据指定USEID判断是否有值
  SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
  IF (PROCESSINGSTATUSCOUNT = 0) THEN
  BEGIN
    H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END;
  ELSE
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END IF;

  --转移符合当前时间的数据
  SELECT NVL(MAX(ID),0) INTO PIMAXINDEX  FROM MT_TASK  WHERE  MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
  IF(PICURRINDEX<PIMAXINDEX)THEN
    --创建不存在的表
    SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO  MINYM,MAXYM  FROM MT_TASK  WHERE  ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR)||')';
        BEGIN
          EXECUTE IMMEDIATE PISTR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
            COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      H_TRANSFER(PI_MININDEX,PI_CURINDEX,0,0);
      H_DELETETASK(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
        ROLLBACK;--事务回滚
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
        COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('短信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_TRANSFERMO();

   --删除文件发送请求历史表数据
   BEGIN
   DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TO_DATE(TO_CHAR(SYSDATE-60,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
   EXCEPTION WHEN OTHERS THEN
      PIERROR:=SQLERRM;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
      COMMIT;
   END;--END OF EXCEPTION


   IF TO_CHAR(SYSDATE,'DD')='01' THEN
     BEGIN
     DELETE FROM MO_WAIT_A WHERE DELIVERTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION

     BEGIN
     DELETE FROM RPT_WAIT_A WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION

     BEGIN
     DELETE FROM RPT_WAIT_B WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION
   END IF;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS, RUNFLAG) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行结束', 1);
   COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE H_MMSTRANSFERMO
AUTHID CURRENT_USER
IS
       PRAGMA AUTONOMOUS_TRANSACTION ;
       CURRINDEX             NUMBER; --当前处理位置
       MAXINDEX              NUMBER; --此次执行的最大位置
       --PROCESSFLAG           NUMBER; --处理方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推
       STR                   VARCHAR2(4000);  --动态语句
       STR_1                 VARCHAR2(1024);  --动态语句
       TABLENAME             VARCHAR2(20);    --表名
       ISEXIST               NUMBER;          --存在标志
       MINYM    NUMBER;
       MAXYM    NUMBER;
       CURYM    NUMBER;
       PITABLENAME VARCHAR2(20);
       PIERROR VARCHAR2(4000);

BEGIN
  --------------------VER 3.2-------------------------------------
  CURRINDEX             := 0;
  MAXINDEX              := 0;
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0),CAST(TO_CHAR(MIN(DELIVERTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(DELIVERTIME),'YYYYMM')AS INT)  INTO CURRINDEX,MAXINDEX,MINYM,MAXYM  FROM MMS_MO  WHERE  MMS_MO.DELIVERTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');

  --判断是否有数据
  IF(MAXINDEX <> 0) THEN
  --创建不存在的彩信上行历史表
  CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MMSMOTASK'||CAST(CURYM AS CHAR);
      STR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE STR INTO ISEXIST;
      IF ISEXIST<1 THEN
        STR:='CALL CREATETABLE (4,'||CAST(CURYM AS CHAR)||')';
        BEGIN
        EXECUTE IMMEDIATE STR;
        EXCEPTION WHEN OTHERS THEN
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS',' 彩信创建上行历史表：CREATETABLE',PIERROR);
          COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
  BEGIN
    --删除临时表
          TABLENAME :='MO_TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;

       --创建临时表
       STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
              USERID VARCHAR2(11),
              SPGATE VARCHAR2(21),
              SPISUNCM NUMBER(11),
              IYMD NUMBER(11),
              IYEAR NUMBER(11),
              IMONTH NUMBER(11),
              IHOUR NUMBER(11),
              ICOUNT NUMBER(11)
       )';
       -- DBMS_OUTPUT.PUT_LINE(STR);
       BEGIN
       EXECUTE IMMEDIATE STR;
       EXCEPTION WHEN OTHERS THEN
         PIERROR:=SQLERRM;
         INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行创建临时表：MO_TMEP_STATISTICS',PIERROR);
         COMMIT;
       END;

       BEGIN --BEGIN OF 汇总EXCEPTION
       --统计
        STR :=' INSERT INTO ' || TABLENAME || ' (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT) SELECT USERID,SPNUMBER,UNICOM,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMMDD'')) AS IYMD,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYY'')) AS IYEAR,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''MM'')) AS MON,
              TO_NUMBER(TO_CHAR(DELIVERTIME,''HH24'')) AS HOUR,
              COUNT(ID)
              FROM MMS_MO
              WHERE DELIVERTIME < TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'')
              GROUP BY  USERID,SPNUMBER,UNICOM,
               TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''MM'')),
               TO_NUMBER(TO_CHAR(DELIVERTIME,''HH24''))';
               -- DBMS_OUTPUT.PUT_LINE(STR);
                EXECUTE IMMEDIATE STR;
         --插入或更新统计表
         STR := 'MERGE INTO MMS_MODATAREPORT M
                 USING  '|| TABLENAME || ' T
                 ON(M.USERID = T.USERID AND
                    M.SPGATE = T.SPGATE AND
                    M.SPISUNCM = T.SPISUNCM AND
                    M.IYMD = T.IYMD AND
                    M.IYEAR = T.IYEAR AND
                    M.IMONTH = T.IMONTH AND
                    M.IHOUR = T.IHOUR)
                 WHEN MATCHED THEN
                      UPDATE SET M.ICOUNT = T.ICOUNT
                 WHEN NOT MATCHED THEN
                      INSERT (USERID,SPGATE,SPISUNCM,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT)
                      VALUES(T.USERID,T.SPGATE,T.SPISUNCM,T.IYMD,T.IYEAR,T.IMONTH,T.IHOUR,T.ICOUNT)';

          EXECUTE IMMEDIATE STR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行汇总',PIERROR);
         COMMIT;
         END;--END OF EXCEPTION WHEN OTHERS
   SAVEPOINT A;
   --转移
   CURYM := MINYM;
   WHILE CURYM<=MAXYM LOOP
     PITABLENAME := 'MMSMOTASK'||CAST(CURYM AS CHAR);
     STR := 'INSERT INTO '||PITABLENAME||' NOLOGGING  SELECT  M.ID,"UID",USERID,SPNUMBER,SERVICEID,SENDSTATUS,DELIVERTIME,PHONE,MSGCONTENT,ECID,ORGUID,PTMSGID,TP_PID,TP_UDHI,MSGFMT,UNICOM,MSGTYPE,MSGTITLE,PASSTHROUGH
     FROM MMS_MO M WHERE (TO_NUMBER(TO_CHAR(M.DELIVERTIME,''YYYYMM'')) ='||CURYM||') AND DELIVERTIME < TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'') ';
            --DBMS_OUTPUT.PUT_LINE(STR);
     STR_1 := 'DELETE FROM MMS_MO WHERE (TO_NUMBER(TO_CHAR(DELIVERTIME,''YYYYMM'')) ='||CURYM||') AND DELIVERTIME < TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS'') ';
     BEGIN
     EXECUTE IMMEDIATE STR;
     EXECUTE IMMEDIATE STR_1;
     EXCEPTION
       WHEN OTHERS THEN
       ROLLBACK ;
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信上行数据转移',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION WHEN OTHERS
     COMMIT;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
   END LOOP;
    END;
    END IF;
END H_MMSTRANSFERMO;
/

CREATE OR REPLACE PROCEDURE H_MMSDATATRANSF(PROCESSFLAG IN NUMBER)
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值

  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','H_MMSDATATRANSF','彩信汇总调度存储过程执行开始');
COMMIT;
--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 2;--彩信USEID=2，短信USEID=2
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  --PROCESSFLAG           := 2;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;

      --先汇总
      SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM MMS_TASK  WHERE ( MMS_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MMS_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));
      IF PIMAXINDEX>0 THEN
        BEGIN
        H_MMSSTATISTICS(PROCESSFLAG);
        EXCEPTION WHEN OTHERS THEN
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行汇总H_MMSSTATISTICS',PIERROR);
          COMMIT;
        END;--END EXCEPTION OF BEGIN
      END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PROCESSINGSTATUSCOUNT = 0) THEN
        BEGIN
        H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
        END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

      --转移符合当前时间的数据
  SELECT NVL(MAX(ID),0) INTO PIMAXINDEX FROM MMS_TASK  WHERE  MMS_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
  IF(PICURRINDEX<PIMAXINDEX)THEN
  --创建不存在的历史表
  SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO MINYM,MAXYM   FROM MMS_TASK  WHERE ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MMSTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (2,'||CAST(CURYM AS CHAR)||')';
        BEGIN
        EXECUTE IMMEDIATE PISTR;
        EXCEPTION WHEN OTHERS THEN
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行历史表创建：CREATETABLE',PIERROR);
        COMMIT;
        END;--END EXCEPTION OF BEGIN
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      H_MMSTRANSFER(PI_MININDEX,PI_CURINDEX,0,0);
      H_MMSDELETETASK(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
      ROLLBACK;--事务回滚
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行数据转移',PIERROR);
          COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('彩信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_MMSTRANSFERMO();

   --删除彩信文件发送请求历史表数据
   BEGIN
   DELETE FROM MMS_BMTREQHIS WHERE RECVTIME<TO_DATE(TO_CHAR(SYSDATE-60,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
   EXCEPTION WHEN OTHERS THEN
      PIERROR:=SQLERRM;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_BMTREQHIS表记录',PIERROR);
      COMMIT;
   END;--END OF EXCEPTION


  IF TO_CHAR(SYSDATE,'DD')='01' THEN
     BEGIN
     DELETE FROM MMS_RPT WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_RPT表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION
   END IF;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','H_MMSDATATRANSF','彩信汇总调度存储过程执行结束');
   COMMIT;
END;
/


--PROMPT
--PROMPT CREATING TRIGGER TIG_ATTIME_TASK
--PROMPT ================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_ATTIME_TASK" BEFORE
INSERT ON  "ATTIME_TASK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_ATTIME_TASK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_CHANNELMAP
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_A_CHANNELMAP" BEFORE
INSERT ON  "A_CHANNELMAP"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_CHANNELMAP.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_CMDQUE
--PROMPT =============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_A_CMDQUE" BEFORE
INSERT ON  "A_CMDQUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_CMDQUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_GWACC
--PROMPT ============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_A_GWACC" BEFORE
INSERT ON  "A_GWACCOUNT"
    FOR EACH ROW
BEGIN
IF (:NEW.PTACCUID IS NULL)
THEN
SELECT SEQ_A_GWACC.NEXTVAL INTO :NEW.PTACCUID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_GWLOGS
--PROMPT =============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_A_GWLOGS" BEFORE
INSERT ON  "A_GWLOGS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_A_GWLOGS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_SMSMSGIDMAP
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_A_SMSMSGIDMAP
  BEFORE INSERT ON A_SMSMSGIDMAP
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_A_SMSMSGIDMAP.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_A_SMSMSGIDMAP;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_A_SMSPUSHCONF
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_A_SMSPUSHCONF
  BEFORE INSERT ON A_SMSPUSHCONF
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_A_SMSPUSHCONF.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_A_SMSPUSHCONF;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_BAT_MT_REQ
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_BAT_MT_REQ" BEFORE
INSERT ON  "BATCH_MT_REQ"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_BAT_MT_REQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_BAT_MT_REQ_HIS
--PROMPT ===================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_BAT_MT_REQ_HIS" BEFORE
INSERT ON  "BATCH_MT_REQ_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_BAT_MT_REQ_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_GT_PORT_USED
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_GT_PORT_USED" BEFORE
INSERT ON  "GT_PORT_USED"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL) THEN
SELECT SEQ_GT_PORT_USED.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_HTTPERRCODE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_HTTPERRCODE
  BEFORE INSERT ON HTTPERRCODE
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_HTTPERRCODE.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_HTTPERRCODE;
/

CREATE OR REPLACE TRIGGER "TIG_INSERT_USEFEE"
AFTER INSERT ON "PB_WEBZZCMD_QUEUE"
    FOR EACH ROW
DECLARE
  V_USERID VARCHAR2(11);
  V_CMDTYPE NUMBER;
  V_CMDPARAM VARCHAR2(20);
  V_ID NUMBER;
  V_COUNT NUMBER;
  V_PUID NUMBER;
  V_PSENDNUM NUMBER;
BEGIN
  SELECT :NEW.USERID,:NEW.CMDTYPE,:NEW.CMDPARAM,:NEW.ID INTO V_USERID,V_CMDTYPE,V_CMDPARAM,V_ID FROM DUAL;
  SELECT COUNT(*) INTO V_COUNT FROM USERFEE  WHERE USERID=UPPER(TRIM(V_USERID));
  --回收费用
  IF :NEW.CMDTYPE=213 THEN
    IF V_COUNT<=0 THEN--回收费用的用户不存在时候，直接回滚，RETURN
      RAISE_APPLICATION_ERROR(-20000,'要回收费用的用户不存在！');
      RETURN;
    ELSE
      IF TO_NUMBER(:NEW.CMDPARAM)<=0 THEN --如果要回收的费用条数不能为0或者负数，回滚后返回
        RAISE_APPLICATION_ERROR(-20000,'要回收的费用条数不能为0或者负数！');
        RETURN;
      ELSE
        SELECT SENDNUM INTO V_PSENDNUM FROM USERFEE WHERE USERID=UPPER(TRIM(V_USERID));
        IF TO_NUMBER(:NEW.CMDPARAM)>V_PSENDNUM THEN--回收费用条数不能大于剩余条数
          RAISE_APPLICATION_ERROR(-20000,'要回收的费用条数不能大于剩余条数！');
          RETURN;
        ELSE
        BEGIN
          --更新USERFEE表
          UPDATE USERFEE SET SENDNUM = SENDNUM-TO_NUMBER(:NEW.CMDPARAM) WHERE USERID=UPPER(TRIM(V_USERID));
          --插入日志表
          INSERT INTO PB_WEBZZCMD_LOG ("SID",CMDTYPE,USERID,CMDPARAM,USEIP,EXECFLAG,MEMO,FEE,OPID)
          VALUES (:NEW.SID,:NEW.CMDTYPE,:NEW.USERID,:NEW.CMDPARAM,:NEW.USEIP,0,:NEW.MEMO,:NEW.FEE,:NEW.OPID);
          --删除任务队列表
          --DELETE FROM PB_WEBZZCMD_QUEUE WHERE ID=V_ID;
          EXCEPTION
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20000,'回收费用操作失败！');
            RETURN;
        END;--END OF EXCEPTION
        END IF;--END OF IF TO_NUMBER(:NEW.CMDPARAM)>V_PSENDNUM
        END IF;--END OF TO_NUMBER(:NEW.CMDPARAM)<=0
      END IF;--V_COUNT<=0
    ELSIF :NEW.CMDTYPE=113 THEN
      IF TO_NUMBER(:NEW.CMDPARAM)<=0 THEN --如果要回收的费用条数不能为0或者负数，回滚后返回
        RAISE_APPLICATION_ERROR(-20000,'要充值的费用条数不能为0或者负数！');
        RETURN;
      ELSE
        IF V_COUNT=0 THEN --要充值的用户不存在，直接插入USERFEE表
        BEGIN
          SELECT "UID" INTO V_PUID FROM USERDATA WHERE USERID=UPPER(TRIM(V_USERID));
          --插入USERFEE表
          INSERT INTO USERFEE ("UID",USERID,SENDNUM) VALUES (V_PUID,TRIM(:NEW.USERID),TO_NUMBER(:NEW.CMDPARAM));
          --插入日志表
          INSERT INTO PB_WEBZZCMD_LOG ("SID",CMDTYPE,USERID,CMDPARAM,USEIP,EXECFLAG,MEMO,FEE,OPID)
          VALUES (:NEW.SID,:NEW.CMDTYPE,:NEW.USERID,:NEW.CMDPARAM,:NEW.USEIP,0,:NEW.MEMO,:NEW.FEE,:NEW.OPID);
          --删除任务队列
          --DELETE FROM PB_WEBZZCMD_QUEUE WHERE ID=V_ID;
          EXCEPTION
            WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20000,'充值操作失败！');
            RETURN;
        END;--END OF EXCEPTION
        ELSE
          BEGIN
            --更新USERFEE表
            UPDATE USERFEE SET SENDNUM = SENDNUM+TO_NUMBER(:NEW.CMDPARAM) WHERE USERID=UPPER(TRIM(V_USERID));
            --插入日志表
            INSERT INTO PB_WEBZZCMD_LOG ("SID",CMDTYPE,USERID,CMDPARAM,USEIP,EXECFLAG,MEMO,FEE,OPID)
            VALUES (:NEW.SID,:NEW.CMDTYPE,:NEW.USERID,:NEW.CMDPARAM,:NEW.USEIP,0,:NEW.MEMO,:NEW.FEE,:NEW.OPID);
            --删除任务队列表,ORACLE，MYSQL的触发器中，不能删除触发器所在的表的数据
            --DELETE FROM PB_WEBZZCMD_QUEUE WHERE ID=V_ID;
            EXCEPTION
              WHEN OTHERS THEN
              RAISE_APPLICATION_ERROR(-20000,'充值操作失败！');
              RETURN;
          END;--END OF EXCEPTION
        END IF;--END OF V_USERID=0
      END IF;--END OF IF TO_NUMBER(:NEW.CMDPARAM)<=0
    ELSE
      RAISE_APPLICATION_ERROR(-20000,'回收/充值操作命令无效！');
      RETURN;
  END IF;--END OF :NEW.CMDTYPE=213
END INSERT_USEFEE_TRIG;
/


--PROMPT
--PROMPT CREATING TRIGGER TIG_KEYWORD_BLACK
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_KEYWORD_BLACK" BEFORE
INSERT ON  "KEYWORD_BLACK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_KEYWORD_BLACK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_BMTREQ
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_BMTREQ
  BEFORE INSERT ON MMS_BMTREQ
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_BMTREQ.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_BMTREQ;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_BMTREQHIS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_BMTREQHIS
  BEFORE INSERT ON MMS_BMTREQHIS
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_BMTREQHIS.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_BMTREQHIS;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_DATAREPORT
--PROMPT ===================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_DATAREPORT
  BEFORE INSERT ON MMS_DATAREPORT
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_DATAREPORT.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_DATAREPORT;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_LEVEL_QUEUE
--PROMPT ====================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_LEVEL_QUEUE
  BEFORE INSERT ON MMS_LEVEL_QUEUE
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_LEVEL_QUEUE.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_LEVEL_QUEUE;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_MO
--PROMPT ===========================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_MO
  BEFORE INSERT ON MMS_MO
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_MO.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_MO;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_MODATAREPORT
--PROMPT =====================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_MODATAREPORT
  BEFORE INSERT ON MMS_MODATAREPORT
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_MODATAREPORT.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_MODATAREPORT;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_RPT
--PROMPT ============================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_RPT
  BEFORE INSERT ON MMS_RPT
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_RPT.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_RPT;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_TASK
--PROMPT =============================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_TASK
  BEFORE INSERT ON MMS_TASK
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_TASK.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_TASK;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MMS_TEMPLATE
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MMS_TEMPLATE
  BEFORE INSERT ON MMS_TEMPLATE
  FOR EACH ROW
DECLARE
BEGIN
  IF (:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MMS_TEMPLATE.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END TIG_MMS_TEMPLATE;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MO_DATAREPORT
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MO_DATAREPORT" BEFORE
INSERT ON  "MO_DATAREPORT"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MO_DATAREPORT.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MO_TASK
--PROMPT ============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MO_TASK" BEFORE
INSERT ON  "MO_TASK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MO_TASK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MO_WAIT_A
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MO_WAIT_A" BEFORE
INSERT ON  "MO_WAIT_A"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MO_WAIT_A.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MO_WAIT_C
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MO_WAIT_C" BEFORE
INSERT ON  "MO_WAIT_C"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MO_WAIT_C.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_DATAREPORT
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_DATAREPORT" BEFORE
INSERT ON  "MT_DATAREPORT"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_DATAREPORT.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL0_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL0_QUEUE" BEFORE
INSERT ON  "MT_LEVEL0_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL0_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL1_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL1_QUEUE" BEFORE
INSERT ON  "MT_LEVEL1_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL1_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL2_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL2_QUEUE" BEFORE
INSERT ON  "MT_LEVEL2_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL2_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL3_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL3_QUEUE" BEFORE
INSERT ON  "MT_LEVEL3_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL3_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL4_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL4_QUEUE" BEFORE
INSERT ON  "MT_LEVEL4_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL4_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL5_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL5_QUEUE" BEFORE
INSERT ON  "MT_LEVEL5_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL5_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL6_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL6_QUEUE" BEFORE
INSERT ON  "MT_LEVEL6_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL6_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL7_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL7_QUEUE" BEFORE
INSERT ON  "MT_LEVEL7_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL7_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL8_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL8_QUEUE" BEFORE
INSERT ON  "MT_LEVEL8_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL8_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_LVL9_QUEUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_LVL9_QUEUE" BEFORE
INSERT ON  "MT_LEVEL9_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_LVL9_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_ROUTETABLE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_MT_ROUTETABLE BEFORE
INSERT ON  MT_ROUTETABLE
    FOR EACH ROW
BEGIN
    IF(:NEW.ID IS NULL)
    THEN
    SELECT SEQ_MT_ROUTETABLE.NEXTVAL INTO :NEW.ID FROM DUAL;
    END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_TASK
--PROMPT ============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_TASK" BEFORE
INSERT ON  "MT_TASK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_TASK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_TASK_C
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_TASK_C" BEFORE
INSERT ON  "MT_TASK_C"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_TASK_C.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_TIMER_QUE
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_TIMER_QUE" BEFORE
INSERT ON  "MT_TIMER_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_TIMER_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_VFY_TASK
--PROMPT ================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_VFY_TASK" BEFORE
INSERT ON  "MT_VERIFY_TASK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_VFY_TASK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_VFY_WAIT
--PROMPT ================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_VFY_WAIT" BEFORE
INSERT ON  "MT_VERIFY_WAIT"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_VFY_WAIT.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_MT_WAIT_A
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_MT_WAIT_A" BEFORE
INSERT ON  "MT_WAIT_A"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_MT_WAIT_A.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_BUFINFO
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_BUFINFO BEFORE
INSERT ON  "M_MON_BUFINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_BUFINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_BUF_HIS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_BUF_HIS BEFORE
INSERT ON  "M_MON_BUF_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_BUF_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_LOGINFO
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_LOGINFO BEFORE
INSERT ON  "M_MON_LOGINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_LOGINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_LOG_HIS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_LOG_HIS BEFORE
INSERT ON  "M_MON_LOG_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_LOG_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_MONLOG
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_MONLOG BEFORE
INSERT ON  "M_MON_MONLOG"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_MONLOG.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_MONLOG_HIS
--PROMPT =====================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_MONLOG_HIS BEFORE
INSERT ON  "M_MON_MONLOG_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_MONLOG_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_MONMSG
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_MONMSG BEFORE
INSERT ON  "M_MON_MONMSG"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_MONMSG.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_MONMSG_HIS
--PROMPT =====================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_MONMSG_HIS BEFORE
INSERT ON  "M_MON_MONMSG_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_MONMSG_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_PTINFO
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_PTINFO BEFORE
INSERT ON  "M_MON_PTINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_PTINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_PT_HIS
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_PT_HIS BEFORE
INSERT ON  "M_MON_PT_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_PT_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_SPINFO
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_SPINFO BEFORE
INSERT ON  "M_MON_SPGATEINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_SPINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_SP_HIS
--PROMPT =================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_SP_HIS BEFORE
INSERT ON  "M_MON_SPGATE_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_SP_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_SYSINFO
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_SYSINFO BEFORE
INSERT ON  "M_MON_SYSINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_SYSINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_SYS_HIS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_SYS_HIS BEFORE
INSERT ON  "M_MON_SYS_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_SYS_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_THDINFO
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_THDINFO BEFORE
INSERT ON  "M_MON_THREADINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_THDINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_THD_HIS
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_THD_HIS BEFORE
INSERT ON  "M_MON_THREAD_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_THD_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_USERINFO
--PROMPT ===================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_USERINFO BEFORE
INSERT ON  "M_MON_USERINFO"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_USERINFO.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_M_MON_USER_HIS
--PROMPT ===================================
--PROMPT
CREATE OR REPLACE TRIGGER TIG_M_MON_USER_HIS BEFORE
INSERT ON  "M_MON_USER_HIS"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_M_MON_USER_HIS.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_PBWEBZZCMDLOG
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_PBWEBZZCMDLOG" BEFORE
INSERT ON  "PB_WEBZZCMD_LOG"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL) THEN
SELECT SEQ_PBWEBZZCMDLOG.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_PBWEBZZCMDQUE
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_PBWEBZZCMDQUE" BEFORE
INSERT ON  "PB_WEBZZCMD_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL) THEN
SELECT SEQ_PBWEBZZCMDQUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_PB_LIST_BLACK
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_PB_LIST_BLACK" BEFORE
INSERT ON  "PB_LIST_BLACK"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_PB_LIST_BLACK.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_RPT_WAIT_A
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_RPT_WAIT_A" BEFORE
INSERT ON  "RPT_WAIT_A"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_RPT_WAIT_A.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_RPT_WAIT_B
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_RPT_WAIT_B" BEFORE
INSERT ON  "RPT_WAIT_B"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_RPT_WAIT_B.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_RPT_WAIT_C
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_RPT_WAIT_C" BEFORE
INSERT ON  "RPT_WAIT_C"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_RPT_WAIT_C.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/

--PROMPT
--PROMPT CREATING TRIGGER TIG_USERDATA
--PROMPT =============================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_USERDATA" BEFORE
INSERT ON  "USERDATA" FOR EACH ROW
BEGIN
IF (:NEW."UID" IS NULL) THEN
   SELECT SEQ_USERDATA.NEXTVAL INTO :NEW."UID" FROM DUAL;
END IF;
IF(:NEW.ACCOUNTTYPE = 1) THEN
    --若该用户已存在则更新其UID
    UPDATE USERFEE SET "UID"=:NEW."UID" WHERE EXISTS (SELECT USERID FROM USERFEE WHERE USERID=:NEW.USERID);
    --插入一条用户费用记录
    INSERT INTO USERFEE("UID",ECID, USERID, SENDNUM, SENDEDNUM, POSTPAYUSED, THRESHOLD)
    SELECT :NEW."UID", 1, :NEW.USERID,0,0,0,1000 FROM DUAL
    WHERE NOT EXISTS (SELECT USERID FROM USERFEE WHERE USERID=:NEW.USERID);
END IF;
END;
/


----------S_RD_MTTASKSUPP  GW_MTTASKSUPPV1-----------------
--PROMPT
--PROMPT CREATING PROCEDURE S_RD_MTTASKSUPP
--PROMPT ==================================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_MTTASKSUPPV1
(
  PIOLDMSGID IN NUMBER,
  PINEWMSGID  IN NUMBER,
  PISRCUID  IN NUMBER,
  PISRCUSRID  IN VARCHAR2,
  PISRCSPGATE  IN VARCHAR2,
  PISRCSPNUMBER IN  VARCHAR2,
  PIDESTUID  IN NUMBER,
  PIDESTUSRID  IN VARCHAR2,
  PIDESTSPGATE  IN VARCHAR2,
  PIDESTSPNUMBER  IN VARCHAR2,
  PIDESTFEEFLAG  IN NUMBER,
  PISPLITLEN  IN NUMBER,
  PIMULTILEN1  IN NUMBER,
  PIMULTILEN2  IN NUMBER,
  PINEWSIGNLEN  IN NUMBER,
  PIOLDSIGNLEN  IN NUMBER,
  PISIGNATURE  IN VARCHAR2,
  PINEWSIGNPOS IN NUMBER,
  PIOLDSIGNPOS IN NUMBER,
  PIENSPLITLEN IN NUMBER, --英文短信单条长度，小于等于0标识不支持英文短信
  PIENMULTILEN1  IN NUMBER, --英文长短信拆分长度
  PIENMULTILEN2  IN NUMBER, --英文长短信最后一条长度
  PINEWENSIGNLEN  IN NUMBER, --补发英文签名长度
  PIOLDENSIGNLEN  IN NUMBER, --原英文签名长度
  PIENSIGNATURE  IN VARCHAR2, --英文签名
  PIRECVMTTIME  IN VARCHAR2,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISENDNUM NUMBER(11);
  PIPKTOTAL NUMBER(11);
  PIPKNUM   NUMBER(11);
  PIINITMSGID NUMBER(22);
  PISINGLEMSG VARCHAR2(720);
  PILONGMSG VARCHAR2(3000);
  PITOTALCNT NUMBER(11);
  PILONGMSGLEN NUMBER(11);
  PIECID NUMBER(11);
  PIPHONE VARCHAR2(21);
  PISENDLEVEL NUMBER(11);
  PITASKID NUMBER(11);
  --PIRECVMTTIME TIMESTAMP;
  PISRCCPNO  VARCHAR2(21);
  PIDESTCPNO VARCHAR2(21);
  PITPUDHI NUMBER(11);
  PITPPID NUMBER(11);
  PILONGMSGSEQ NUMBER(11);
  PIMSGFMT NUMBER(11);
  PIUNICOM NUMBER(11);
  PIMOBILEAREA NUMBER(11);
  PISVRTYPE VARCHAR2(64);
  PIUSERMSGID NUMBER(22);
  PISENDTYPE NUMBER(11);
  PIP1 VARCHAR2(64);
  PIP2 VARCHAR2(64);
  PIP3 VARCHAR2(64);
  PIP4 VARCHAR2(64);
  PIMODULEID NUMBER(11);
  PIATTIME NUMBER(22);
  PIVALIDTIME NUMBER(22);
  PIBATCHID NUMBER(22);
  PIAREACODE NUMBER(11);
  ICOUNT NUMBER(11);
  PITEMPCNT1 NUMBER(11);
  PITEMPCNT2 NUMBER(11);

  PISPLITLEN_V NUMBER(11);
  PIMULTILEN1_V  NUMBER(11);
  PIMULTILEN2_V  NUMBER(11);
  PINEWSIGNLEN_V  NUMBER(11);
  PIOLDSIGNLEN_V  NUMBER(11);
  PISIGNATURE_V  VARCHAR2(22);
BEGIN

  /*--检查查临时表是否存在,如果存在则清空,不存在直接返回
  SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_RDMTTASK');
  IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';
  ELSE
    RETURN;
  END IF;
  */
  PILONGMSG:='';
  --PIRECVMTTIME:= SYSTIMESTAMP;
  PISRCCPNO:= SUBSTR(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE));
  PIDESTCPNO:= NVL(SUBSTR(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE)), ' ');
   --取补发帐号的费用
  SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=PIDESTUSRID;

  --每次调用存储过程时候，先清空TMP_RDMTTASK会话级别的临时表
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';

  --该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=SQL%ROWCOUNT;

  DELETE FROM TMP_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
  PITEMPCNT2:=SQL%ROWCOUNT;

  IF PITEMPCNT1 - PITEMPCNT2>0 THEN
    SELECT PKTOTAL,PKNUMBER,ECID,PHONE,SENDLEVEL,
        TASKID,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
        MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
        SENDTYPE,P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE  INTO
        PIPKTOTAL,PIPKNUM,PIECID,PIPHONE,PISENDLEVEL,
        PITASKID,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
        PIMOBILEAREA,PISVRTYPE,PITPPID,PIUSERMSGID,
        PISENDTYPE,PIP1,PIP2,PIP3,PIP4,PIMODULEID,PIATTIME,PIVALIDTIME,PIBATCHID,PIAREACODE
    FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       PIOLDSIGNLEN_V:=PIOLDENSIGNLEN;
     ELSE
       PIOLDSIGNLEN_V:=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       PISPLITLEN_V:=PIENSPLITLEN;
       PIMULTILEN1_V:=PIENMULTILEN1;
       PIMULTILEN2_V:=PIENMULTILEN2;
       PINEWSIGNLEN_V:=PINEWENSIGNLEN;
       PISIGNATURE_V:=PIENSIGNATURE;
     ELSE
       PISPLITLEN_V:=PISPLITLEN;
       PIMULTILEN1_V:=PIMULTILEN1;
       PIMULTILEN2_V:=PIMULTILEN2;
       PINEWSIGNLEN_V:=PINEWSIGNLEN;
       PISIGNATURE_V:=PISIGNATURE;
     END IF;

     if (0 = PINEWSIGNLEN_V) THEN
       PISIGNATURE_V:='';
     END IF;

     IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN--对于非长短信补发的处理
        PILONGMSG:='';
        --取短信内容
        SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
        --更新替换MSGID
        UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V; --减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := PILONGMSG||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||PILONGMSG;
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
        PIPKNUM:=1;
    /*
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN--对标准协议长短信的补发
      PILONGMSG:='';
      --取短信内容
      SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
      --更新替换MSGID
      UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
      IF (PIPKTOTAL=PIPKNUM)THEN ---如果是最后一条，去掉旧签名，加上新签名
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN; --减去签名的净长度
        PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        PILONGMSG := PILONGMSG||PISIGNATURE;
      END IF;
      PILONGMSGLEN := LENGTH(PILONGMSG);
      IF PILONGMSGLEN > 0 THEN
        --调用插入存储过程
        S_WR_MTTASKSR(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
                PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
                PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
      ELSE
        PILONGMSG:='';
      END IF;--END OF IF PILONGMSGLEN > 0
    */
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0)THEN--对非标准长短信协议的处理
      PILONGMSG:='';
      --没有补发过且通道号跟源通道号相等
      SELECT COUNT(*) INTO ICOUNT FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND TRIM(SPGATE)=PISRCSPGATE;
      IF ICOUNT>0 THEN
        --循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
        --计算起始MSGID
        PIINITMSGID := PIOLDMSGID-(PIPKNUM-1)*17179869184;
        PIPKNUM := 1;
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          --取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
           SELECT MESSAGE INTO PISINGLEMSG FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          IF (PISINGLEMSG IS NOT NULL) THEN
            --更新替换MSGID
            UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            --拼接短信内容
            PILONGMSG := PILONGMSG||PISINGLEMSG;
            PIPKNUM := PIPKNUM+1;
          ELSE
            PILONGMSG:='';
            PIPKNUM:=PIPKTOTAL;--用来跳出WHILE
          END IF;
        END LOOP;--END OF WHILE PIPKNUM <= PIPKTOTAL
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V ;--减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := PILONGMSG||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||PILONGMSG;
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
          PIPKNUM:=1;
      END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM PITMP WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND (TRIM(SPGATE)+TRIM(CPNO))=PISRCSPNUMBER)
    END  IF;--END OF IF PIPKTOTAL > 1
  END IF;--END OF IF PIPIROWCOUNT<>0
  --返回给上层数据
  OPEN OUT_CURSOR FOR
  SELECT PIDESTUID AS "UID",PINEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
  PIDESTCPNO AS CPNO,PIPHONE AS PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,1 AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
  SENDSTATUS,1 AS SENDLEVEL,
  PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
  PISVRTYPE AS SVRTYPE,PIP1 AS P1,PIP2 AS P2,PIP3 AS P3,PIP4 AS P4,PIUSERMSGID AS USERMSGID,PIMODULEID AS MODULEID,
  PIATTIME AS ATTIME,PIVALIDTIME AS VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM TMP_RDMTTASK WHERE (PILONGMSG IS NOT NULL);
END;
/

CREATE OR REPLACE PROCEDURE GW_WRRPTWAITCV1
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISPGATE       IN VARCHAR2,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PILOGINID      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRETFLAG     IN NUMBER DEFAULT 1,
    PIRECVFLAG      IN NUMBER DEFAULT 1,
    PISENDTIME      IN NUMBER DEFAULT 0
 )
AS
  ICOUNT PLS_INTEGER;
BEGIN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_C("UID", PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME,RECVFLAG, ERRORCODE,LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME)
    VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG, PIERRORCODE,PILOGINID,PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME);
  END IF;
END;
/



--PROMPT
--PROMPT CREATING TRIGGER TIG_XT_GATE_QUE
--PROMPT ================================
--PROMPT
CREATE OR REPLACE TRIGGER "TIG_XT_GATE_QUE" BEFORE
INSERT ON  "XT_GATE_QUEUE"
    FOR EACH ROW
BEGIN
IF (:NEW.ID IS NULL)
THEN
SELECT SEQ_XT_GATE_QUE.NEXTVAL INTO :NEW.ID FROM DUAL;
END IF;
END;
/



CREATE OR REPLACE PROCEDURE GW_H_STATISTIV1(PROCESSFLAG IN NUMBER,ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
   MAXIYMD NUMBER;
   DIFFDATE NUMBER;
   CURPROCESSFLAG NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11),
        BATCHID NUMBER(22),
        AREACODE NUMBER(11)

 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计
  CURPROCESSFLAG:=PROCESSFLAG;
  SELECT NVL(MAX(IYMD),20000101) INTO MAXIYMD  FROM MT_DATAREPORT;
  DIFFDATE:= TO_DATE(TO_CHAR(SYSDATE-1,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS')-to_date(MAXIYMD,'YYYY-MM-DD HH24:MI:SS') ;
  IF DIFFDATE>0 THEN
          CURPROCESSFLAG:=CURPROCESSFLAG+DIFFDATE+1;
  END IF;
 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
               IF ISP1=1 THEN
                  STR:=STR||',P1';
                ELSE
                  STR:=STR||','' '' AS P1';
                END IF;
               IF ISP2=1 THEN
                  STR:=STR||',P2';
                ELSE
                  STR:=STR||','' '' AS P2';
                END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                ELSE
                  STR:=STR||','' '' AS P3';
                END IF;
                IF ISP4=1 THEN
                  STR:=STR||',P4';
                ELSE
                  STR:=STR||','' '' AS P4';
                END IF;

               STR:=STR||',
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA,
               BATCHID,
               AREACODE
               FROM MT_TASK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
                 IF ISP1=1 THEN
                  STR:=STR||',P1';
                 END IF;
                IF ISP2=1 THEN
                  STR:=STR||',P2';
                 END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                 END IF;
                 IF ISP4=1 THEN
                  STR:=STR||',P4';
                 END IF;
               STR:=STR||',SENDTYPE,MOBILEAREA,BATCHID,AREACODE,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
        -- DBMS_OUTPUT.PUT_LINE(STR);

 EXECUTE IMMEDIATE STR;
 --插入或更新统计表
       STR:='DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MT_DATAREPORT M
       (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
       SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,
       (T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA,T.BATCHID,T.AREACODE FROM '|| TABLENAME ||'  T';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;

END GW_H_STATISTIV1;
/




CREATE OR REPLACE PROCEDURE GW_H_MMSSTATIV1(PROCESSFLAG IN NUMBER,ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11)
 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计
 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
               IF ISP1=1 THEN
                  STR:=STR||',P1';
                ELSE
                  STR:=STR||','' '' AS P1';
                END IF;
               IF ISP2=1 THEN
                  STR:=STR||',P2';
                ELSE
                  STR:=STR||','' '' AS P2';
                END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                ELSE
                  STR:=STR||','' '' AS P3';
                END IF;
                IF ISP4=1 THEN
                  STR:=STR||',P4';
                ELSE
                  STR:=STR||','' '' AS P4';
                END IF;

               STR:=STR||',TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
              NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA
               FROM MMS_TASK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
          IF ISP1=1 THEN
                  STR:=STR||',P1';
                 END IF;
                IF ISP2=1 THEN
                  STR:=STR||',P2';
                 END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                 END IF;
                 IF ISP4=1 THEN
                  STR:=STR||',P4';
                 END IF;
               STR:=STR||',SENDTYPE,MOBILEAREA,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
            --DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
--插入或更新统计表

       STR:= 'DELETE FROM MMS_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MMS_DATAREPORT
         (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA)
         SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,(T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA FROM '||TABLENAME||' T' ;

 --DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;

END GW_H_MMSSTATIV1;
/



CREATE OR REPLACE PROCEDURE GW_H_DATATRANV1(ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  PROCESSFLAG           NUMBER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值
  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV1','短信汇总调度存储过程执行开始');
COMMIT;

--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 1;
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  PROCESSFLAG           := 3;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;


  --先汇总
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM MT_TASK  WHERE ( MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));
  IF PIMAXINDEX>0 THEN
    BEGIN
      GW_H_STATISTIV1(PROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
      EXCEPTION WHEN OTHERS THEN
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV1',PIERROR);
        COMMIT;
    END;

  END IF;
  --再转移
  --先根据指定USEID判断是否有值
  SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
  IF (PROCESSINGSTATUSCOUNT = 0) THEN
  BEGIN
    H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END;
  ELSE
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END IF;

  --转移符合当前时间的数据
  SELECT NVL(MAX(ID),0) INTO PIMAXINDEX  FROM MT_TASK  WHERE  MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
  IF(PICURRINDEX<PIMAXINDEX)THEN
    --创建不存在的表
    SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO  MINYM,MAXYM  FROM MT_TASK  WHERE  ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR)||')';
        BEGIN
          EXECUTE IMMEDIATE PISTR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
            COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      H_TRANSFER(PI_MININDEX,PI_CURINDEX,0,0);
      H_DELETETASK(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
        ROLLBACK;--事务回滚
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
        COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('短信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_TRANSFERMO();

   --删除文件发送请求历史表数据
   BEGIN
   DELETE FROM BATCH_MT_REQ_HIS WHERE RECVTIME<TO_DATE(TO_CHAR(SYSDATE-60,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
   EXCEPTION WHEN OTHERS THEN
      PIERROR:=SQLERRM;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);
      COMMIT;
   END;--END OF EXCEPTION



   IF TO_CHAR(SYSDATE,'DD')='01' THEN
     BEGIN
     DELETE FROM MO_WAIT_A WHERE DELIVERTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION

     BEGIN
     DELETE FROM RPT_WAIT_A WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION

     BEGIN
     DELETE FROM RPT_WAIT_B WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION
   END IF;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS, RUNFLAG) VALUES('SMS','H_DATATRANSFER','短信汇总调度存储过程执行结束', 1);
   COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE GW_H_MMSDATATV1(PROCESSFLAG IN NUMBER,ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值

  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','GW_H_MMSDATATV1','彩信汇总调度存储过程执行开始');
COMMIT;
--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 2;--彩信USEID=2，短信USEID=2
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  --PROCESSFLAG           := 2;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;

      --先汇总
      SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM MMS_TASK  WHERE ( MMS_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MMS_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));
      IF PIMAXINDEX>0 THEN
        BEGIN
         GW_H_MMSSTATIV1(PROCESSFLAG,ISP1,ISP2,ISP3,ISP4);

        EXCEPTION WHEN OTHERS THEN
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行汇总GW_H_MMSSTATIV1',PIERROR);
          COMMIT;
        END;--END EXCEPTION OF BEGIN
      END IF;

      --再转移
      --先根据指定USEID判断是否有值
      SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
       IF (PROCESSINGSTATUSCOUNT = 0) THEN
        BEGIN
        H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
        END;
      ELSE
        SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
        FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
      END IF;

      --转移符合当前时间的数据
  SELECT NVL(MAX(ID),0) INTO PIMAXINDEX FROM MMS_TASK  WHERE  MMS_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
  IF(PICURRINDEX<PIMAXINDEX)THEN
  --创建不存在的历史表
  SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO MINYM,MAXYM   FROM MMS_TASK  WHERE ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MMSTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (2,'||CAST(CURYM AS CHAR)||')';
        BEGIN
        EXECUTE IMMEDIATE PISTR;
        EXCEPTION WHEN OTHERS THEN
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行历史表创建：CREATETABLE',PIERROR);
        COMMIT;
        END;--END EXCEPTION OF BEGIN
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      H_MMSTRANSFER(PI_MININDEX,PI_CURINDEX,0,0);
      H_MMSDELETETASK(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
      ROLLBACK;--事务回滚
          PIERROR:=SQLERRM;
          INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信下行数据转移',PIERROR);
          COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('彩信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_MMSTRANSFERMO();

   --删除彩信文件发送请求历史表数据
   BEGIN
   DELETE FROM MMS_BMTREQHIS WHERE RECVTIME<TO_DATE(TO_CHAR(SYSDATE-60,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
   EXCEPTION WHEN OTHERS THEN
      PIERROR:=SQLERRM;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_BMTREQHIS表记录',PIERROR);
      COMMIT;
   END;--END OF EXCEPTION



  IF TO_CHAR(SYSDATE,'DD')='01' THEN
     BEGIN
     DELETE FROM MMS_RPT WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     EXCEPTION WHEN OTHERS THEN
       PIERROR:=SQLERRM;
       INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('MMS','彩信删除MMS_RPT表记录',PIERROR);
       COMMIT;
     END;--END OF EXCEPTION
   END IF;

   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS, RUNFLAG) VALUES('MMS','GW_H_MMSDATATV1','彩信汇总调度存储过程执行结束',1);
   COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE GW_LOADDATA
 (FLAG IN  NUMBER,INCRES IN  NUMBER,PRETIME IN NUMBER
 ) IS
 STR  VARCHAR2(5120);
 STR1  VARCHAR2(5120) ;
 TBNAME  VARCHAR2(30) ;
 TBNAMEBAK VARCHAR2(30);
 STARTID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 ENDID  NUMBER(22) DEFAULT 0;

 CURMINID  NUMBER(22) DEFAULT 0;
 CURENDID  NUMBER(22) DEFAULT 0;
 COUNTID  NUMBER(22) DEFAULT 0;
 NUM  NUMBER(22) DEFAULT 0;
 TNUM  NUMBER(22) DEFAULT 0;
 ISSUCCES  NUMBER(11) DEFAULT 1;
 TRANLOGID  NUMBER(22) DEFAULT 0;

 I  NUMBER(22) DEFAULT 0;
 J  NUMBER(22) DEFAULT 0;
 TBNAMEERR VARCHAR2(30);
 CURMINID1  NUMBER(22) DEFAULT 0;
 PIERROR VARCHAR2(2000);
 PICODE NUMBER(11);
 EXCP_ORA_00001  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_00001,-00001);
 CURSOR c_cursor(FLAG NUMBER DEFAULT 1)  IS  SELECT  ID,STARTID,ENDID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG+4 AND ISSUCCES = 0 ;
BEGIN

  SELECT  NVL(MAX(ENDID),0)  INTO STARTID  FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG AND ISSUCCES = 1;  ----根据 上次成功转移的记录查找本次转移的开始id

 IF FLAG =1 THEN
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0),NVL(COUNT(ID),0) INTO  MINID,ENDID,COUNTID  FROM  MT_TASK  WHERE SENDTIME<=sysdate - PRETIME/(60*24);   ----转移十分钟前的数据
  TBNAME :='MT_TASK';
  TBNAMEBAK :='GW_MT_TASK_BAK';
  TBNAMEERR :='GW_MT_TASK_ERR';
  STR1 := '"ID","PTMSGID","UID","ECID","USERID","SPID","SPGATE","CPNO","PHONE","SPMSGID","RETFLAG","FEEFLAG","PKNUMBER","PKTOTAL","SENDSTATUS","SENDFLAG","RECVFLAG","DONEDATE","ERRORCODE", "SENDLEVEL","SENDTYPE","UNICOM","MOBILEAREA","SENDTIME","RECVTIME","MESSAGE", "RESENDCNT","TASKID","MSGFMT","LONGMSGSEQ","TPUDHI", "TPPID","USERMSGID", "MODULEID", "SVRTYPE" ,"P1" , "P2", "P3", "P4", "RECVMTTIME", "TRANSMTTIME","TRANSRPTTIME","SENDRPTTIME","ATTIME","VALIDTIME","BATCHID","AREACODE",0 AS FLAGMTSDOK,0 AS FLAGRPTRVOK, 0 AS FLAGRPTSDOK,sysdate AS  MTSUBMITTIME,0 AS ERRRESENDCNT,0 AS NETERRCNT,1 AS SENDRESULT,'' '' AS SPGATESEND,'' '' AS SPNUMBER,'' '' AS SENDERRCODE,'' '' AS  SUBMITDATE ';
ELSE
  RETURN;
END IF;

----如果表中无数据 则退出
IF ( 0=ENDID and 0=MINID ) THEN
  RETURN;
END IF;

-----针对 前几次 删除 不成功处理   循环读出 然后删除  更新控制表
IF MINID  < STARTID+1  THEN
  FOR v_row IN c_cursor(FLAG) LOOP
   BEGIN
    STR := 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR(v_row.STARTID)||' AND '||TO_CHAR(v_row.ENDID);
      EXECUTE IMMEDIATE STR;
      PICODE:=SQLCODE;
      EXCEPTION WHEN OTHERS THEN
      ROLLBACK;
      COMMIT; END;
    IF PICODE >=0  THEN
       UPDATE GW_TRAN_DEL_LOG SET END_TIME=sysdate ,ISSUCCES=1 WHERE ID=v_row.ID;
    END IF;
   END LOOP;
   commit;
----------把此次转移的起始id重置 根据控制表上次转移成功id 重置  把上次成功转移的最大id 复制给此次转移的最小id
  MINID := STARTID+1;
END IF;

----若此次转移的最大id 等于上次成功转移的最大id 则退出
IF  ENDID=MINID-1 THEN
  RETURN;
END IF;

SELECT CEIL((ENDID-MINID+1)/INCRES) INTO TNUM  FROM DUAL;


WHILE (NUM<TNUM) LOOP
CURMINID:=MINID+NUM*INCRES;
CURENDID:=MINID+(NUM+1)*INCRES-1;

IF NUM=TNUM-1 THEN
  CURENDID:=ENDID;
END IF;

---上批循环三次还未成功 则退出循环
IF I=3 THEN
  RETURN;
 END IF;

INSERT INTO GW_TRAN_DEL_LOG(ID,OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(SEQ_GW_TRAN_DEL_LOG.NEXTVAL,FLAG,CURMINID,CURENDID,0,sysdate,sysdate); ---1   mttask  2... 3..  4...
SELECT SEQ_GW_TRAN_DEL_LOG.CURRVAL INTO TRANLOGID FROM DUAL;


--- 转移数据 循环执行3次
I:=0;
WHILE (I<3) LOOP
    BEGIN
   PIERROR:=' ';PICODE:=0;
   STR :='INSERT  INTO '||TBNAMEBAK||' nologging SELECT '||STR1||' FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR( CURMINID)||' AND '||TO_CHAR(CURENDID);
     EXECUTE IMMEDIATE STR;
     PIERROR:=SQLERRM; PICODE:=SQLCODE;

    EXCEPTION WHEN EXCP_ORA_00001 THEN
       CURMINID1:=CURMINID;
      WHILE (CURMINID1<=CURENDID) LOOP
        BEGIN
      STR :='INSERT  INTO '||TBNAMEBAK||' nologging SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
      EXECUTE IMMEDIATE STR;
        EXCEPTION WHEN EXCP_ORA_00001 THEN
          STR :='INSERT  INTO '||TBNAMEERR||' nologging SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
           EXECUTE IMMEDIATE STR;
       WHEN OTHERS THEN
           STR :='INSERT  INTO '||TBNAMEERR||' nologging SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
           EXECUTE IMMEDIATE STR;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('LOADDATA',TBNAME||'...TOEVERY...'||TBNAMEBAK,PIERROR);
       COMMIT; END;
            STR:='DELETE FROM '||TBNAME||' WHERE ID='||TO_CHAR(CURMINID1);
            EXECUTE IMMEDIATE STR;
          CURMINID1:=CURMINID1+1;
       END LOOP;-- END  WHILE (CURMINID<=CURENDID) LOOP
    WHEN OTHERS THEN
      ROLLBACK;
      PIERROR:=SQLERRM; PICODE:=SQLCODE;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('LOADDATA',TBNAME||'...TO...'||TBNAMEBAK,PIERROR);

    END;

     IF PICODE >=0  THEN
        UPDATE GW_TRAN_DEL_LOG SET END_TIME= sysdate,ISSUCCES=1 WHERE ID=TRANLOGID;
        INSERT INTO GW_TRAN_DEL_LOG(ID,OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(SEQ_GW_TRAN_DEL_LOG.NEXTVAL,FLAG+4,CURMINID,CURENDID,0,sysdate,sysdate); ---1   mttask  2... 3..  4...
        SELECT SEQ_GW_TRAN_DEL_LOG.CURRVAL INTO TRANLOGID FROM DUAL; COMMIT;
         ------此次删除 的 控制信息
         J:=0;
        WHILE J<3 LOOP
          PICODE:=0;PIERROR:='';

            STR := 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR(CURMINID)||' AND '||TO_CHAR(CURENDID);
             BEGIN
             EXECUTE IMMEDIATE STR;
             UPDATE GW_TRAN_DEL_LOG SET END_TIME=sysdate ,ISSUCCES=1 WHERE ID=TRANLOGID;
              J :=3;
             EXCEPTION WHEN OTHERS THEN
                ROLLBACK;--事务回滚
               commit;
                J:=J+1;
             END;--EXCEPTION WHEN OTHERS THEN截止

          END LOOP;  --END WHILE J<3 LOOP
        I:=5;
      END IF;
    I:=I+1;
END LOOP;  ---END WHILE (I<3) LOOP
NUM:=NUM+1;
commit;
END LOOP;  ----END WHILE (NUM<TNUM) LOOP

END;
/

DECLARE
  ISEXIST INT;
BEGIN
SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_DEL_EACH(P_EACHCOUNT IN NUMBER,P_TYPE IN NUMBER,P_NUM OUT NUMBER)
AS
TYPE RIDARRAY IS TABLE OF ROWID INDEX BY BINARY_INTEGER;
TYPE DDARRAY IS TABLE OF VARCHAR2(50) INDEX BY BINARY_INTEGER;

V_ROWID RIDARRAY;
V_DEL_PTMSG DDARRAY;
BEGIN
    SELECT PTMSGID,ROWID BULK COLLECT INTO V_DEL_PTMSG,V_ROWID FROM TMP_DEL WHERE ROWNUM<P_EACHCOUNT;
  IF P_TYPE=1 THEN
    FORALL i IN 1..V_DEL_PTMSG.COUNT
    DELETE FROM GW_MTSDOK WHERE PTMSGID=V_DEL_PTMSG(i);
  ELSIF  P_TYPE=2 THEN
      FORALL i IN 1..V_DEL_PTMSG.COUNT
      DELETE FROM GW_RPTRVOK WHERE PTMSGID=V_DEL_PTMSG(i);
   ELSIF   P_TYPE=3 THEN
      FORALL i IN 1..V_DEL_PTMSG.COUNT
      DELETE FROM GW_RPTSDOK WHERE PTMSGID=V_DEL_PTMSG(i);
    END IF;
     FORALL i IN 1..V_ROWID.COUNT
     DELETE FROM TMP_DEL WHERE ROWID=V_ROWID(i);
   P_NUM:=V_ROWID.COUNT;

  END;
/
CREATE OR REPLACE PROCEDURE GW_DEL_DATA(P_ROWCOUNT IN NUMBER,P_EACHCOUNT IN NUMBER,P_TYPE IN NUMBER,P_NUMALL OUT NUMBER)
AS
 N_ROWCOUNT NUMBER:=0;
 N_I  NUMBER:=0;
 N_J  NUMBER:=0;
 P_NUM NUMBER:=0;
 --P_NUMALL NUMBER:=0;
 BEGIN
   P_NUMALL:=0;
   N_ROWCOUNT:=P_ROWCOUNT;
   N_J:=(P_ROWCOUNT/P_EACHCOUNT)+1;
   WHILE N_I<N_J LOOP
      GW_DEL_EACH(P_EACHCOUNT,P_TYPE,P_NUM);  ---删除数据
     COMMIT;
     N_I:=N_I+1;
     P_NUMALL:=P_NUMALL+P_NUM;
    END LOOP;
   END;
/
CREATE OR REPLACE PROCEDURE GW_UPPMTSDOK(PRETIME IN NUMBER,INCRES IN  NUMBER,STARTTIME IN VARCHAR2)
IS
 ROWS1 NUMBER(11) DEFAULT 0 ;
 LOGID NUMBER(11) DEFAULT 0 ;
 PICODE NUMBER(11);

 MAXID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 CURMINID  NUMBER(22) DEFAULT 0;
 CURMAXID  NUMBER(22) DEFAULT 0;

 I  NUMBER(11) DEFAULT 0;
 J  NUMBER(11) DEFAULT 0;
 REMAINDER  NUMBER(11) DEFAULT 0;
 MINLONG NUMBER(11) DEFAULT 0;

 ISEXIST NUMBER(11) DEFAULT 0;
 P_NUMALL NUMBER(22) DEFAULT 0;
 COUNTID NUMBER(22) DEFAULT 0;
 INCRESDEL NUMBER(22) DEFAULT 0;

 EXCP_ORA_30926  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_30926,-30926);

BEGIN

--创建临时表
 SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;



------------------更新MT_SDOK表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO MINID,MAXID  FROM GW_MTSDOK;
IF MINID=0 AND MAXID=0 THEN
RETURN;
END IF;
SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;

INCRESDEL:=INCRES+100000;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,1,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;
 ROWS1:=0;  PICODE:=0;
BEGIN
MERGE INTO  GW_MT_TASK_BAK  A USING (SELECT PTMSGID,SPMSGID,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SENDERRCODE FROM GW_MTSDOK WHERE ID<=CURMAXID AND ID>=CURMINID) B ON ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
UPDATE SET  A.SPMSGID     =B.SPMSGID ,
      A.SENDSTATUS  =A.SENDSTATUS+10,
      A.SPID        =B.SPID,
      A.TRANSMTTIME =B.TRANSMTTIME,
      A.MTSUBMITTIME=B.MTSUBMITTIME,
      A.SENDTIME    =B.SENDTIME,
      A.ERRRESENDCNT=B.ERRRESENDCNT,
      A.NETERRCNT   =B.NETERRCNT,
      A.SENDRESULT  =B.SENDRESULT,
      A.SPGATESEND  =B.SPGATESEND,
      A.SENDERRCODE =B.SENDERRCODE,
      A.FLAGMTSDOK=1 WHERE A.FLAGMTSDOK=0 ;   ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT;  PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
      MERGE INTO  GW_MT_TASK_BAK  A USING (SELECT  PTMSGID , MIN(SPMSGID) AS SPMSGID,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SPID) AS SPID,MIN(TRANSMTTIME) AS TRANSMTTIME,MIN(MTSUBMITTIME) AS MTSUBMITTIME,MIN(SENDTIME) AS SENDTIME,MIN(ERRRESENDCNT) AS ERRRESENDCNT,MIN(NETERRCNT) AS NETERRCNT,MIN(SENDRESULT) AS SENDRESULT,MIN(SPGATESEND) AS SPGATESEND,MIN(SENDERRCODE) AS SENDERRCODE  FROM  GW_MTSDOK WHERE   ID<=CURMAXID AND ID>=CURMINID GROUP BY PTMSGID )  B  on ( A.PTMSGID=B.PTMSGID)
       WHEN MATCHED THEN
       UPDATE SET    A.SPMSGID     =B.SPMSGID ,
            A.SENDSTATUS  =A.SENDSTATUS+10,
            A.SPID        =B.SPID,
            A.TRANSMTTIME =B.TRANSMTTIME,
            A.MTSUBMITTIME=B.MTSUBMITTIME,
            A.SENDTIME    =B.SENDTIME,
            A.ERRRESENDCNT=B.ERRRESENDCNT,
            A.NETERRCNT   =B.NETERRCNT,
            A.SENDRESULT  =B.SENDRESULT,
            A.SPGATESEND  =B.SPGATESEND,

            A.SENDERRCODE =B.SENDERRCODE,

            A.FLAGMTSDOK=1 WHERE  A.FLAGMTSDOK=0;
            ROWS1:=SQL%ROWCOUNT;
      UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;
   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
   INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_MTSDOK WHERE  ID<=CURMAXID AND ID>=CURMINID) GM
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGMTSDOK = 1
           and GM.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,4,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 -- DELETE FROM  GW_MTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGMTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;

  GW_DEL_DATA(INCRESDEL,10001,1,P_NUMALL);
  ROWS1:=P_NUMALL;
  IF ROWS1>=0 THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
IF MINLONG>=PRETIME THEN
     I:=J;
ELSE
     I:=I+1;
END IF;

 END LOOP;
 COMMIT;
END;
/
CREATE OR REPLACE PROCEDURE GW_UPPRPTRVOK(PRETIME IN NUMBER,INCRES IN  NUMBER,STARTTIME IN VARCHAR2)
IS
 ROWS1 NUMBER(11) DEFAULT 0 ;
 LOGID NUMBER(11) DEFAULT 0 ;
 PICODE NUMBER(11);

 MAXID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 CURMINID  NUMBER(22) DEFAULT 0;
 CURMAXID  NUMBER(22) DEFAULT 0;

 I  NUMBER(11) DEFAULT 0;
 J  NUMBER(11) DEFAULT 0;
 REMAINDER  NUMBER(11) DEFAULT 0;
  MINLONG NUMBER(11) DEFAULT 0;

 ISEXIST NUMBER(11) DEFAULT 0;
 P_NUMALL NUMBER(22) DEFAULT 0;
 COUNTID NUMBER(22) DEFAULT 0;
 INCRESDEL NUMBER(22) DEFAULT 0;

 EXCP_ORA_30926  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_30926,-30926);

BEGIN

--创建临时表
 SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;



------------------更新rpt_rvok表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTRVOK;
IF MINID=0 AND MAXID=0 THEN
RETURN;
END IF;
SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
 I:=0;
 INCRESDEL:=INCRES+100000;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,2,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;

ROWS1:=0;  PICODE:=0;
BEGIN
MERGE INTO   GW_MT_TASK_BAK  A USING (SELECT PTMSGID,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE FROM GW_RPTRVOK WHERE ID <= CURMAXID AND ID >= CURMINID) B ON ( A.PTMSGID=B.PTMSGID)
WHEN MATCHED THEN
 UPDATE SET  A.SENDSTATUS=A.SENDSTATUS+100,
      A.RECVTIME  =B.RECVTIME  ,
      A.DONEDATE  =B.DONEDATE  ,
      A.SUBMITDATE=B.SUBMITDATE,
      A.ERRORCODE =B.ERRORCODE ,

      A.FLAGRPTRVOK=1 WHERE A.FLAGRPTRVOK=0 ;             ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT; PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
MERGE INTO   GW_MT_TASK_BAK  A USING (SELECT  PTMSGID , MIN(SENDSTATUS) AS SENDSTATUS,MIN(RECVTIME) AS RECVTIME,MIN(DONEDATE) AS DONEDATE,MIN(SUBMITDATE) AS SUBMITDATE,MIN(ERRORCODE) AS ERRORCODE    FROM  GW_RPTRVOK where  ID <= CURMAXID AND ID >= CURMINID GROUP BY PTMSGID )   B  on ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
 UPDATE SET  A.SENDSTATUS=A.SENDSTATUS+100,
      A.RECVTIME  =B.RECVTIME  ,
      A.DONEDATE  =B.DONEDATE  ,
      A.SUBMITDATE=B.SUBMITDATE,
      A.ERRORCODE =B.ERRORCODE ,

      A.FLAGRPTRVOK=1  WHERE A.FLAGRPTRVOK=0;
       ROWS1:=SQL%ROWCOUNT;
    UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;

   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
 EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_RPTRVOK WHERE ID <= CURMAXID AND ID >= CURMINID) GR
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGRPTRVOK = 1
           and GR.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,5,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
  --DELETE FROM  GW_RPTRVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RPTRVOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTRVOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,2,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
    UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
IF MINLONG>=PRETIME THEN
    I:=J;
ELSE
    I:=I+1;
END IF;

 END LOOP;
COMMIT;
END;
/
CREATE OR REPLACE PROCEDURE GW_UPPRPTSDOK(PRETIME IN NUMBER,INCRES IN  NUMBER,STARTTIME IN VARCHAR2)
IS
 ROWS1 NUMBER(11) DEFAULT 0 ;
 LOGID NUMBER(11) DEFAULT 0 ;
 PICODE NUMBER(11);

 MAXID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 CURMINID  NUMBER(22) DEFAULT 0;
 CURMAXID  NUMBER(22) DEFAULT 0;

 I  NUMBER(11) DEFAULT 0;
 J  NUMBER(11) DEFAULT 0;
 REMAINDER  NUMBER(11) DEFAULT 0;

 MINLONG NUMBER(11) DEFAULT 0;

 ISEXIST NUMBER(11) DEFAULT 0;
 P_NUMALL NUMBER(22) DEFAULT 0;
 COUNTID NUMBER(22) DEFAULT 0;
 INCRESDEL NUMBER(22) DEFAULT 0;

 EXCP_ORA_30926  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_30926,-30926);

BEGIN


--创建临时表
 SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;

------------------更新GW_RPTSDOK表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0)  INTO MINID,MAXID FROM GW_RPTSDOK;
IF MINID=0 AND MAXID=0 THEN
RETURN;
END IF;

SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
 I:=0;
 INCRESDEL:=INCRES+100000;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,3,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;
ROWS1:=0;  PICODE:=0;
BEGIN
MERGE INTO  GW_MT_TASK_BAK  A using (SELECT PTMSGID,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE FROM GW_RPTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID)  B on ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
UPDATE SET   A.SENDSTATUS  =A.SENDSTATUS+1000  ,
      A.SENDFLAG    =B.SENDFLAG    ,
      A.SENDRPTTIME =B.SENDRPTTIME ,
      A.TRANSRPTTIME=B.TRANSRPTTIME,
      A.ERRORCODE   =B.ERRORCODE   ,
            A.FLAGRPTSDOK=1 WHERE  A.FLAGRPTSDOK=0 ;               ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT;  PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
MERGE INTO  GW_MT_TASK_BAK  A USING ( SELECT  PTMSGID ,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SENDFLAG) AS SENDFLAG,MIN(SENDRPTTIME) AS SENDRPTTIME ,MIN(TRANSRPTTIME) AS TRANSRPTTIME,MIN(ERRORCODE) AS ERRORCODE FROM  GW_RPTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID  GROUP BY PTMSGID )  B on ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
UPDATE SET   A.SENDSTATUS  =A.SENDSTATUS+1000  ,
      A.SENDFLAG    =B.SENDFLAG    ,
      A.SENDRPTTIME =B.SENDRPTTIME ,
      A.TRANSRPTTIME=B.TRANSRPTTIME,
      A.ERRORCODE   =B.ERRORCODE   ,
      A.FLAGRPTSDOK=1 WHERE A.FLAGRPTSDOK=0;
       ROWS1:=SQL%ROWCOUNT;
    UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;

   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的

  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_RPTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID) GR
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGRPTSDOK = 1
           and GR.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;


  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,6,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 -- DELETE FROM  GW_RPTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RPTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,3,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
IF MINLONG>=PRETIME THEN
     I:=J;
ELSE
    I:=I+1;
END IF;

 END LOOP;
 COMMIT;
END;
/


CREATE OR REPLACE PROCEDURE GW_UPPDATA_ALL(PRETIME IN NUMBER,INCRES_LOAD IN  NUMBER,INCRES IN  NUMBER)
IS
 ROWS1 NUMBER(11) DEFAULT 0 ;
 LOGID NUMBER(11) DEFAULT 0 ;
 PICODE NUMBER(11);
 MAXID  NUMBER(22) DEFAULT 0;
 CURMINID  NUMBER(22) DEFAULT 0;
 CURMAXID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 I  NUMBER(11) DEFAULT 0;
 J  NUMBER(11) DEFAULT 0;
 REMAINDER  NUMBER(11) DEFAULT 0;

 ISEXIST NUMBER(11) DEFAULT 0;
 P_NUMALL NUMBER(22) DEFAULT 0;
 COUNTID NUMBER(22) DEFAULT 0;
 INCRESDEL NUMBER(22) DEFAULT 0;

 EXCP_ORA_30926  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_30926,-30926);
BEGIN
-------转移数据


 GW_LOADDATA(1,INCRES_LOAD,PRETIME) ;

--创建临时表
 SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;
 INCRESDEL:=INCRES+100000;
 ------------------更新MT_SDOK表-------------------------------------------


SELECT NVL(MIN(ID),0),NVL(MAX(ID),0)  INTO MINID,MAXID FROM GW_MTSDOK;
SELECT  (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,1,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;

BEGIN
MERGE INTO  GW_MT_TASK_BAK  A USING (SELECT PTMSGID,SPMSGID,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SENDERRCODE FROM GW_MTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID ) B on ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
UPDATE SET  A.SPMSGID     =B.SPMSGID ,
      A.SENDSTATUS  =A.SENDSTATUS+10,
      A.SPID        =B.SPID,
      A.TRANSMTTIME =B.TRANSMTTIME,
      A.MTSUBMITTIME=B.MTSUBMITTIME,
      A.SENDTIME    =B.SENDTIME,
      A.ERRRESENDCNT=B.ERRRESENDCNT,
      A.NETERRCNT   =B.NETERRCNT,
      A.SENDRESULT  =B.SENDRESULT,
      A.SPGATESEND  =B.SPGATESEND,

      A.SENDERRCODE =B.SENDERRCODE,

      A.FLAGMTSDOK=1 WHERE A.FLAGMTSDOK=0;    ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT;  PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
       merge into  GW_MT_TASK_BAK  A using (SELECT  PTMSGID , MIN(SPMSGID) AS SPMSGID,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SPID) AS SPID,MIN(TRANSMTTIME) AS TRANSMTTIME,MIN(MTSUBMITTIME) AS MTSUBMITTIME,MIN(SENDTIME) AS SENDTIME,MIN(ERRRESENDCNT) AS ERRRESENDCNT,MIN(NETERRCNT) AS NETERRCNT,MIN(SENDRESULT) AS SENDRESULT,MIN(SPGATESEND) AS SPGATESEND,MIN(SENDERRCODE) AS SENDERRCODE  FROM  GW_MTSDOK WHERE   ID <= CURMAXID AND ID >= CURMINID GROUP BY PTMSGID )  B  on ( A.PTMSGID=B.PTMSGID)
       when matched then
       update set   A.SPMSGID     =B.SPMSGID ,
            A.SENDSTATUS  =A.SENDSTATUS+10,
            A.SPID        =B.SPID,
            A.TRANSMTTIME =B.TRANSMTTIME,
            A.MTSUBMITTIME=B.MTSUBMITTIME,
            A.SENDTIME    =B.SENDTIME,
            A.ERRRESENDCNT=B.ERRRESENDCNT,
            A.NETERRCNT   =B.NETERRCNT,
            A.SENDRESULT  =B.SENDRESULT,
            A.SPGATESEND  =B.SPGATESEND,

            A.SENDERRCODE =B.SENDERRCODE,

            A.FLAGMTSDOK=1 WHERE  A.FLAGMTSDOK=0;
            ROWS1:=SQL%ROWCOUNT;
      UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;
   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
 EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
   INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_MTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID) GM
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGMTSDOK = 1
           and GM.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,4,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;

  --DELETE FROM  GW_MTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_MTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGMTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,1,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 I:=I+1;

 END LOOP;
------------------更新rpt_rvok表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0)  INTO MINID,MAXID FROM GW_RPTRVOK;
SELECT  (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
 I:=0;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,2,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;


BEGIN
merge into  GW_MT_TASK_BAK  A using (SELECT PTMSGID,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE FROM GW_RPTRVOK WHERE ID <= CURMAXID AND ID >= CURMINID ) B on ( A.PTMSGID=B.PTMSGID)
when matched then
update set  A.SENDSTATUS=A.SENDSTATUS+100,
      A.RECVTIME  =B.RECVTIME  ,
      A.DONEDATE  =B.DONEDATE  ,
      A.SUBMITDATE=B.SUBMITDATE,
      A.ERRORCODE =B.ERRORCODE ,

      A.FLAGRPTRVOK=1 WHERE A.FLAGRPTRVOK=0 ;             ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT; PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
MERGE into  GW_MT_TASK_BAK  A using (SELECT  PTMSGID , MIN(SENDSTATUS) AS SENDSTATUS,MIN(RECVTIME) AS RECVTIME,MIN(DONEDATE) AS DONEDATE,MIN(SUBMITDATE) AS SUBMITDATE,MIN(ERRORCODE) AS ERRORCODE    FROM  GW_RPTRVOK where  ID <= CURMAXID AND ID >= CURMINID GROUP BY PTMSGID )   B  on ( A.PTMSGID=B.PTMSGID )
when MATCHED then
update set  A.SENDSTATUS=A.SENDSTATUS+100,
      A.RECVTIME  =B.RECVTIME  ,
      A.DONEDATE  =B.DONEDATE  ,
      A.SUBMITDATE=B.SUBMITDATE,
      A.ERRORCODE =B.ERRORCODE ,

      A.FLAGRPTRVOK=1  WHERE A.FLAGRPTRVOK=0;
       ROWS1:=SQL%ROWCOUNT;
    UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;

   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_RPTRVOK WHERE ID <= CURMAXID AND ID >= CURMINID) GR
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGRPTRVOK = 1
           and GR.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,5,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 -- DELETE FROM  GW_RPTRVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RPTRVOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTRVOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,2,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
    UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 I:=I+1;

 END LOOP;


 ------------------更新rpt_SDok表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0)  INTO MINID,MAXID  FROM GW_RPTSDOK;
SELECT  (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
 I:=0;
WHILE (I<J) LOOP

INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,3,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;


BEGIN
merge into  GW_MT_TASK_BAK  A using (SELECT PTMSGID,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE FROM GW_RPTSDOK WHERE ID <= CURMAXID AND ID >= CURMINID)  B on ( A.PTMSGID=B.PTMSGID )
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
      A.SENDFLAG    =B.SENDFLAG    ,
      A.SENDRPTTIME =B.SENDRPTTIME ,
      A.TRANSRPTTIME=B.TRANSRPTTIME,
      A.ERRORCODE   =B.ERRORCODE   ,
            A.FLAGRPTSDOK=1 WHERE  A.FLAGRPTSDOK=0 ;               ---批量 更新   SPMSGID(汇总不考虑)      MT_TASK_BAK增加SPMSGID
      ROWS1:=SQL%ROWCOUNT;  PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
MERGE into  GW_MT_TASK_BAK  A using ( SELECT  PTMSGID ,MIN(SENDSTATUS) AS SENDSTATUS,MIN(SENDFLAG) AS SENDFLAG,MIN(SENDRPTTIME) AS SENDRPTTIME ,MIN(TRANSRPTTIME) AS TRANSRPTTIME,MIN(ERRORCODE) AS ERRORCODE FROM  GW_RPTSDOK WHERE  ID <= CURMAXID AND ID >= CURMINID  GROUP BY PTMSGID )  B on ( A.PTMSGID=B.PTMSGID )
when matched then
update set  A.SENDSTATUS  =A.SENDSTATUS+1000  ,
      A.SENDFLAG    =B.SENDFLAG    ,
      A.SENDRPTTIME =B.SENDRPTTIME ,
      A.TRANSRPTTIME=B.TRANSRPTTIME,
      A.ERRORCODE   =B.ERRORCODE   ,
      A.FLAGRPTSDOK=1 WHERE A.FLAGRPTSDOK=0;
       ROWS1:=SQL%ROWCOUNT;
    UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;

   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
   EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_RPTSDOK WHERE  ID <= CURMAXID AND ID >= CURMINID) GR
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GW_MT_TASK_BAK.FLAGRPTSDOK = 1
           and GR.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,6,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 -- DELETE FROM  GW_RPTSDOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RPTSDOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTSDOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,3,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
   UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
  I:=I+1;

 END LOOP;

END;
/
CREATE OR REPLACE PROCEDURE GW_DEL_ERR
is
 STR VARCHAR2(3000);
 STR1 VARCHAR2(3000);
 PROCESSFLAG NUMBER(11);
 PIERROR VARCHAR2(5120);
 PICODE NUMBER(11) DEFAULT 0;
 I  NUMBER(22) DEFAULT 0;
 EXCP_ORA_00001  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_00001,-00001);
BEGIN
  PROCESSFLAG:=3;
  I:=0;
 WHILE (I<3) LOOP
    BEGIN
   STR1:=' ID,PTMSGID,SPMSGID,SENDSTATUS,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,PHONE,SENDERRCODE,TPUDHI,TPPID,PKTOTAL,PKNUMBER,LONGMSGSEQ,IN_TIME ';
   STR :='INSERT  INTO GW_MTSDOK_ERR nologging SELECT '||STR1||' FROM GW_MTSDOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') )';
   EXECUTE IMMEDIATE STR USING PROCESSFLAG;
  -- DBMS_OUTPUT.PUT_LINE(STR);
    PIERROR:=SQLERRM; PICODE:=SQLCODE;
    EXCEPTION WHEN EXCP_ORA_00001 THEN
       BEGIN
      STR := 'DELETE FROM GW_MTSDOK_ERR WHERE EXISTS (SELECT ID FROM GW_MTSDOK WHERE GW_MTSDOK.ID=GW_MTSDOK_ERR.ID) AND (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') )';
      EXECUTE IMMEDIATE STR  USING PROCESSFLAG;
      END;
    WHEN OTHERS THEN
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_MTSDOK..TO..GW_MTSDOK_ERR',PIERROR);
     COMMIT; END;
   IF PICODE >=0  THEN

      DELETE FROM GW_MTSDOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') );
      COMMIT;
      I:=3;
   END IF;
     I:=I+1;
 END LOOP;

 I:=0;
 WHILE (I<3) LOOP
    BEGIN
   STR1:='ID,PTMSGID,SPMSGID,SENDSTATUS,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE ,PHONE,SPNUMBER,IN_TIME ';
  STR :='INSERT  INTO GW_RPTRVOK_ERR nologging SELECT '||STR1||' FROM GW_RPTRVOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') )';
   EXECUTE IMMEDIATE STR USING PROCESSFLAG;
     PIERROR:=SQLERRM; PICODE:=SQLCODE;
    EXCEPTION WHEN EXCP_ORA_00001 THEN
      STR := 'DELETE FROM GW_RPTRVOK_ERR WHERE EXISTS (SELECT ID FROM GW_RPTRVOK WHERE ID=GW_RPTRVOK_ERR.ID) AND (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS ''))';
     EXECUTE IMMEDIATE STR USING PROCESSFLAG;
    WHEN OTHERS THEN
     INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_RPTRVOK..TO..GW_RPTRVOK_ERR',PIERROR);
     COMMIT; END;
   IF PICODE >=0  THEN

      DELETE FROM GW_RPTRVOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') );
      COMMIT;
      I:=3;
   END IF;
     I:=I+1;
 END LOOP;

  I:=0;
 WHILE (I<3) LOOP
    BEGIN
    STR1:=' ID,PTMSGID,SPMSGID,SENDSTATUS,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE,PHONE,SPNUMBER,IN_TIME';
   STR :='INSERT  INTO GW_RPTSDOK_ERR nologging SELECT '||STR1||' FROM GW_RPTSDOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') )';
   EXECUTE IMMEDIATE STR USING PROCESSFLAG;
     PIERROR:=SQLERRM; PICODE:=SQLCODE;
    EXCEPTION WHEN EXCP_ORA_00001 THEN
      STR := 'DELETE FROM GW_RPTSDOK_ERR WHERE EXISTS (SELECT ID FROM GW_RPTSDOK WHERE ID=GW_RPTSDOK_ERR.ID) AND (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-:1,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') )';
     EXECUTE IMMEDIATE STR USING PROCESSFLAG;
   WHEN OTHERS THEN
     INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('TRANERR','GW_RPTSDOK..TO..GW_RPTSDOK_ERR',PIERROR);
     COMMIT; END;
    IF PICODE >=0  THEN

      DELETE FROM GW_RPTSDOK WHERE (IN_TIME < TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') );
    COMMIT;
    I:=3;
   END IF;
    I:=I+1;
 END LOOP;

DELETE FROM GW_TRAN_DEL_LOG WHERE END_TIME<sysdate - 90;
DELETE FROM GW_UPD_DEL_LOG WHERE END_TIME<sysdate - 90;

DELETE FROM GW_MTSDOK_ERR WHERE IN_TIME<sysdate - 90;
DELETE FROM GW_RPTRVOK_ERR WHERE IN_TIME<sysdate - 90;
DELETE FROM GW_RPTSDOK_ERR WHERE IN_TIME<sysdate - 90;
COMMIT;
END;
/
CREATE OR REPLACE PROCEDURE GW_WR_MTSDOK
 (PIPTMSGID IN NUMBER,
  PISPMSGID IN NUMBER,
  PISENDSTATUS IN  NUMBER,
  PISPID IN VARCHAR2,
  PITRANSMTTIME IN TIMESTAMP,
  PIMTSUBMITTIME IN TIMESTAMP,
  PISENDTIME IN TIMESTAMP,
  PIERRRESENDCNT IN NUMBER,
  PINETERRCNT IN  NUMBER,
  PISENDRESULT IN  NUMBER,
  PISPGATESEND IN VARCHAR2,
  PISPNUMBER IN  VARCHAR2,
  PIPHONE IN VARCHAR2,
  PISENDERRCODE IN  VARCHAR2,
  PITPUDHI IN  NUMBER,
  PITPPID IN  NUMBER,
  PIPKTOTAL IN  NUMBER,
  PIPKNUMBER IN  NUMBER,
  PILONGMSGSEQ  IN NUMBER
 )
AS
  ICOUNT  NUMBER(11) DEFAULT 0;
BEGIN
   SELECT COUNT(PTMSGID) INTO ICOUNT  FROM GW_MTSDOK WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1  THEN
     INSERT INTO GW_MTSDOK(PTMSGID,SPMSGID,SENDSTATUS,SPID,TRANSMTTIME,MTSUBMITTIME,SENDTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,PHONE,SENDERRCODE,TPUDHI,TPPID,PKTOTAL,PKNUMBER,LONGMSGSEQ)
     VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PISPID,PITRANSMTTIME,PIMTSUBMITTIME,PISENDTIME,PIERRRESENDCNT,PINETERRCNT,PISENDRESULT,PISPGATESEND,PISPNUMBER,PIPHONE,PISENDERRCODE,PITPUDHI,PITPPID,PIPKTOTAL,PIPKNUMBER,PILONGMSGSEQ);
  END IF;
  COMMIT;
END;
/
CREATE OR REPLACE PROCEDURE GW_WR_RPTRVOK
 (   PIPTMSGID IN NUMBER ,
     PISPMSGID IN NUMBER ,
     PISENDSTATUS IN NUMBER ,
     PIRECVTIME IN TIMESTAMP ,
     PIDONEDATE IN CHAR ,
     PISUBMITDATE IN  CHAR ,
     PIERRORCODE  IN CHAR ,
     PIPHONE IN VARCHAR2 ,
     PISPNUMBER IN VARCHAR2
 )
AS
  ICOUNT  NUMBER(11) DEFAULT 0;
BEGIN
   SELECT COUNT(PTMSGID) INTO ICOUNT  FROM GW_RPTRVOK WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1  THEN
     INSERT INTO GW_RPTRVOK(PTMSGID,SPMSGID,SENDSTATUS,RECVTIME,DONEDATE,SUBMITDATE,ERRORCODE ,PHONE,SPNUMBER )
     VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PIRECVTIME,PIDONEDATE,PISUBMITDATE,PIERRORCODE ,PIPHONE,PISPNUMBER);
  END IF;
  COMMIT;
END;
/


CREATE OR REPLACE PROCEDURE GW_WR_RPTSDOK
 (  PIPTMSGID IN NUMBER ,
  PISPMSGID IN NUMBER ,
  PISENDSTATUS IN NUMBER,
  PISENDFLAG IN NUMBER,
  PISENDRPTTIME  IN TIMESTAMP ,
  PITRANSRPTTIME IN  TIMESTAMP ,
  PIERRORCODE IN CHAR ,
  PIPHONE IN VARCHAR2 ,
  PISPNUMBER IN VARCHAR2
 )
AS
  ICOUNT  NUMBER(11) DEFAULT 0;
BEGIN
   SELECT COUNT(PTMSGID) INTO ICOUNT  FROM GW_RPTSDOK WHERE PTMSGID = PIPTMSGID;
   IF ICOUNT<1  THEN
     INSERT INTO GW_RPTSDOK(PTMSGID,SPMSGID,SENDSTATUS,SENDFLAG,SENDRPTTIME,TRANSRPTTIME,ERRORCODE,PHONE,SPNUMBER)
     VALUES(PIPTMSGID,PISPMSGID,PISENDSTATUS,PISENDFLAG,PISENDRPTTIME,PITRANSRPTTIME,PIERRORCODE,PIPHONE,PISPNUMBER);
   END IF;
   COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE GW_H_DELTASKV1(MININDEX IN NUMBER,MAXINDEX IN NUMBER,PROCESSFLAG IN NUMBER,LOTSIZE IN NUMBER) IS
BEGIN
  --------------------VER 3.0-------------------------------------
        --DELETE /*+RULE*/  FROM MT_TASK M  WHERE (M.ID BETWEEN MININDEX AND MAXINDEX);
        DELETE /*+RULE*/  FROM GW_MT_TASK_BAK M  WHERE (M.ID <= MAXINDEX) ;
END GW_H_DELTASKV1;
/

CREATE OR REPLACE PROCEDURE GW_H_TRANSFERV1(MININDEX IN NUMBER,
                                     MAXINDEX IN NUMBER,
                                     PROCESSFLAG IN NUMBER,
                                     LOTSIZE IN NUMBER) IS
PISTR VARCHAR2(4000);
PITABLENAME VARCHAR2(20);
MINYM NUMBER;
MAXYM NUMBER;
CURYM NUMBER;
BEGIN
  --------------------VER 3.1-------------------------------------
   SELECT CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT) INTO MAXYM,MINYM FROM GW_MT_TASK_BAK WHERE ID BETWEEN MININDEX AND MAXINDEX;

   CURYM := MINYM;
   WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);

      PISTR:= 'INSERT INTO '||PITABLENAME||' NOLOGGING (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,
      PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,
      ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,DOWNTM,SUID1,LUID1)
      SELECT ID,TO_NUMBER(TO_CHAR(M.SENDTIME,''DD'')),USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,
      SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,
      PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,DOWNTM,SUID1,LUID1
      FROM GW_MT_TASK_BAK M
      WHERE CAST(TO_CHAR(SENDTIME,''YYYYMM'')AS INT) ='||CURYM||' AND (M.ID <='||MAXINDEX||') ';
      --DBMS_OUTPUT.PUT_LINE(PISTR);
      EXECUTE IMMEDIATE PISTR;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
   END LOOP;
END GW_H_TRANSFERV1;

/


CREATE OR REPLACE PROCEDURE GW_H_STATISTIV2(PROCESSFLAG IN NUMBER,ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
IS
   STR VARCHAR2(4000);
   TABLENAME VARCHAR2(20);
   ISEXIST NUMBER;
   MAXIYMD NUMBER;
   DIFFDATE NUMBER;
   CURPROCESSFLAG NUMBER;
BEGIN
  --------------------VER 3.2-------------------------------------
--删除临时
          TABLENAME :='TMEP_STATISTICS';
          ISEXIST:=0;
          SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME=UPPER(TABLENAME);
          IF(ISEXIST>0) THEN
            BEGIN
                  STR := 'DROP TABLE '||TABLENAME;
                  EXECUTE IMMEDIATE STR;
            END;
          END IF;
--创建临时表

      --  SPISUNCM NUMBER(11),
 STR :='CREATE GLOBAL TEMPORARY TABLE '|| TABLENAME ||'(
        USERID VARCHAR2(11),
        TASKID NUMBER(11),
        SPGATE VARCHAR2(21),
        SPISUNCM NUMBER(11),
        SPID VARCHAR2(32),
        SVRTYPE VARCHAR2(64),
        P1 VARCHAR2(64),
        P2 VARCHAR2(64),
        P3 VARCHAR2(64),
        P4 VARCHAR2(64),
        IYMD NUMBER(11),
        IYEAR NUMBER(11),
        IMONTH NUMBER(11),
        IHOUR NUMBER(11),
        ICOUNT NUMBER(11),
        SUCC NUMBER(11),
        FAIL NUMBER(11),
        NRET NUMBER(11),
        SENDTYPE NUMBER(11),
        MOBILEAREA NUMBER(11),
        BATCHID NUMBER(22),
        AREACODE NUMBER(11)

 )';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;
 --统计
  CURPROCESSFLAG:=PROCESSFLAG;
  SELECT NVL(MAX(IYMD),20000101) INTO MAXIYMD  FROM MT_DATAREPORT;
  DIFFDATE:= TO_DATE(TO_CHAR(SYSDATE-2,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS')-to_date(MAXIYMD,'YYYY-MM-DD HH24:MI:SS') ;
  IF DIFFDATE>0 THEN
          CURPROCESSFLAG:=CURPROCESSFLAG+DIFFDATE;
  END IF;
 STR:= 'INSERT INTO  '|| TABLENAME ||' (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IYEAR,IMONTH,IHOUR,ICOUNT,SUCC,FAIL,NRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
               SELECT  USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
               IF ISP1=1 THEN
                  STR:=STR||',P1';
                ELSE
                  STR:=STR||','' '' AS P1';
                END IF;
               IF ISP2=1 THEN
                  STR:=STR||',P2';
                ELSE
                  STR:=STR||','' '' AS P2';
                END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                ELSE
                  STR:=STR||','' '' AS P3';
                END IF;
                IF ISP4=1 THEN
                  STR:=STR||',P4';
                ELSE
                  STR:=STR||','' '' AS P4';
                END IF;

               STR:=STR||',
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')) AS IYMD,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')) AS IYEAR,
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')) AS MON,
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24'')) AS HOUR,
               COUNT(ID),
               NVL(COUNT(CASE TRIM(ERRORCODE) WHEN ''DELIVRD'' THEN 1 WHEN ''0'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE SUBSTR(ERRORCODE,1,3) WHEN ''E1:'' THEN 1 WHEN ''E2:'' THEN 1 ELSE NULL END),0),
               NVL(COUNT(CASE NVL(TRIM(ERRORCODE),''0'') WHEN ''0'' THEN 1 ELSE NULL END),0),
               SENDTYPE,
               MOBILEAREA,
               BATCHID,
               AREACODE
               FROM GW_MT_TASK_BAK
               WHERE  SENDTIME >=  '|| 'TO_DATE(TO_CHAR(SYSDATE-'||CURPROCESSFLAG||',''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '') '|| ' AND SENDTIME < '|| 'TO_DATE(TO_CHAR(SYSDATE,''YYYY-MM-DD''),''YYYY-MM-DD HH24:MI:SS '')' ||'
               GROUP BY USERID,TASKID,SPGATE,UNICOM,SPID,SVRTYPE';
                 IF ISP1=1 THEN
                  STR:=STR||',P1';
                 END IF;
                IF ISP2=1 THEN
                  STR:=STR||',P2';
                 END IF;
                IF ISP3=1 THEN
                  STR:=STR||',P3';
                 END IF;
                 IF ISP4=1 THEN
                  STR:=STR||',P4';
                 END IF;
               STR:=STR||',SENDTYPE,MOBILEAREA,BATCHID,AREACODE,
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYYMMDD'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''YYYY'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''MM'')),
               TO_NUMBER(TO_CHAR(SENDTIME,''HH24''))';
        -- DBMS_OUTPUT.PUT_LINE(STR);

 EXECUTE IMMEDIATE STR;
       --SELECT MIN(),MAX() INTO  FROM TMEP_STATISTICS
 --插入或更新统计表
       STR:='DELETE FROM MT_DATAREPORT WHERE EXISTS (SELECT IYMD FROM '||TABLENAME||' A WHERE A.IYMD=MT_DATAREPORT.IYMD)';
      -- EXECUTE IMMEDIATE STR;

       --STR:='DELETE FROM MT_DATAREPORT WHERE IYMD BETWEEN CAST(TO_CHAR(SYSDATE-'||PROCESSFLAG||',''YYYYMMDD'') AS INT) AND CAST(TO_CHAR(SYSDATE,''YYYYMMDD'') AS INT)' ;
       EXECUTE IMMEDIATE STR;

       STR:='INSERT INTO MT_DATAREPORT M
       (USERID,TASKID,SPGATE,SPISUNCM,SPID,SVRTYPE,P1,P2,P3,P4,IYMD,IHOUR,IMONTH,Y,ICOUNT,RSUCC,RFAIL1,RFAIL2,RNRET,SENDTYPE,MOBILEAREA,BATCHID,AREACODE)
       SELECT T.USERID,T.TASKID,T.SPGATE,T.SPISUNCM,T.SPID,T.SVRTYPE,T.P1,T.P2,T.P3,T.P4,T.IYMD,T.IHOUR,T.IMONTH,T.IYEAR,T.ICOUNT,T.SUCC,T.FAIL,
       (T.ICOUNT-T.SUCC-T.FAIL-T.NRET),T.NRET,T.SENDTYPE,T.MOBILEAREA,T.BATCHID,T.AREACODE FROM '|| TABLENAME ||'  T';

--DBMS_OUTPUT.PUT_LINE(STR);
 EXECUTE IMMEDIATE STR;

 EXECUTE IMMEDIATE  'DROP TABLE '||TABLENAME;
 COMMIT;

END ;
/


CREATE OR REPLACE PROCEDURE GW_RDMTTASKRSV1
(
  PIMAXRESNDCNT   IN NUMBER,
  PISTRMSGID     IN VARCHAR2,
  OUT_CURSOR     OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,'
  ||'RETFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDLEVEL,TPUDHI,LONGMSGSEQ,MSGFMT,MESSAGE,'
  ||'TO_DATE(TO_CHAR(RECVMTTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVMTTIME, '
  ||'SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA '
  ||'FROM GW_MT_TASK_BAK WHERE PTMSGID IN('||PISTRMSGID||') AND RESENDCNT<'||PIMAXRESNDCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

CREATE OR REPLACE PROCEDURE GW_RDMTTASKRPV1
(
  PIPTMSGID       IN NUMBER,
  PIUID           IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
  AUTHID CURRENT_USER
AS
PICOUNT NUMBER(11);
PICNT NUMBER(11);
PISQLSTR VARCHAR(256);
PIDBNAME VARCHAR(32);
PIMONTH NUMBER(11);
PICURYM NUMBER(11);

BEGIN
  PICOUNT := 0;
  PIDBNAME := 'MTTASK';
  select count(*) into PICOUNT from tab where tname ='TEMP';
  if PICOUNT=0 then
  PISQLSTR:='CREATE GLOBAL TEMPORARY TABLE TEMP(SPNUMBER VARCHAR2(21),PHONE VARCHAR2(21),
  DONEDATE CHAR(10),ERRORCODE CHAR(7),RECVRPTTIME VARCHAR2(22))ON COMMIT DELETE ROWS';
  execute immediate PISQLSTR; ----使用动态SQL语句来执行
  end if;
  --GW_RPTRVOK,MT_TASK,GW_MT_TASK_BAK,历史表
  SELECT COUNT(*) INTO PICOUNT FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID ;
  IF PICOUNT>0 THEN --查GW_RPTRVOK
    OPEN OUT_CURSOR FOR
    SELECT SPNUMBER,PHONE,DONEDATE,ERRORCODE,TO_CHAR(RECVTIME,'YYYY-MM-DD HH24:MI:SS') AS RECVRPTTIME
    FROM GW_RPTRVOK WHERE PTMSGID=PIPTMSGID ;
  ELSE
    SELECT COUNT(*) INTO PICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
    IF PICOUNT > 0 THEN --查 GW_MT_TASK_BAK
      OPEN OUT_CURSOR FOR
      SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
      TO_CHAR(SENDTIME,'YYYY-MM-DD HH24:MI:SS') AS RECVRPTTIME FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
      ELSE
        SELECT COUNT(*) INTO PICOUNT FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
        IF PICOUNT > 0 THEN --查 MT_TASK
        OPEN OUT_CURSOR FOR
        SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
        TO_CHAR(SENDTIME,'YYYY-MM-DD HH24:MI:SS') AS RECVRPTTIME FROM MT_TASK WHERE PTMSGID=PIPTMSGID AND "UID"=PIUID;
        ELSE
          --在当月历史中查询
          SELECT CAST(to_char(sysdate,'YYYYMM') AS INT) INTO PICURYM FROM DUAL;
          PIDBNAME := 'MTTASK'||TO_CHAR(PICURYM);
          PICOUNT := 0;
          PISQLSTR := 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';--=:绑定变量
          EXECUTE IMMEDIATE PISQLSTR INTO PICOUNT USING PIPTMSGID;
          IF PICOUNT > 0 THEN--查历史
            PISQLSTR := 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
            TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS'') AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
            OPEN OUT_CURSOR FOR PISQLSTR USING PIPTMSGID;
            RETURN;
            ELSE
            ----若当月历史表中没有,则遍历近三个月的历史表，如果查询到需要的记录，直接RETURN返回
            PIMONTH := 1;
            WHILE PIMONTH<3 LOOP
              --格式化数据库名称
              PIDBNAME := 'MTTASK'||TO_CHAR(ADD_MONTHS(SYSDATE,-PIMONTH),'YYYYMM');
              PICOUNT := 0;
              --判断表名是否存在
              SELECT COUNT(1) INTO PICNT FROM USER_TABLES T WHERE T.TABLE_NAME=PIDBNAME;
              IF PICNT>0 THEN
                PISQLSTR := 'SELECT COUNT(*) AS CNT FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
                EXECUTE IMMEDIATE PISQLSTR INTO PICOUNT USING PIPTMSGID;
                IF PICOUNT > 0 THEN
                  PISQLSTR := 'SELECT RTRIM(SPGATE)||RTRIM(CPNO) AS SPNUMBER,PHONE,DONEDATE,ERRORCODE,
                  TO_CHAR(SENDTIME,''YYYY-MM-DD HH24:MI:SS'') AS RECVRPTTIME FROM '||PIDBNAME||' WHERE PTMSGID=:PTMSGID';
                  OPEN OUT_CURSOR FOR PISQLSTR USING PIPTMSGID;
                  RETURN;
                END IF;
              END IF;
            PIMONTH := PIMONTH+1;
            END LOOP;
          END IF;--查历史
            --当在历史表中没有查询到需要的数据时候，返回空的记录集(最后一次遍历的表可能不存在)
            PISQLSTR:='SELECT SPNUMBER, PHONE, DONEDATE, ERRORCODE, RECVRPTTIME FROM TEMP';
            open OUT_CURSOR for PISQLSTR; ----使用动态SQL语句来执行
        END IF;--查 GW_MT_TASK_BAK
      END IF;--查MT_TASK
  END IF;--查GW_RPTRVOK
END;
/


CREATE OR REPLACE PROCEDURE GW_MTTASKSUPPV2
(
  PIOLDMSGID IN NUMBER,
  PINEWMSGID  IN NUMBER,
  PISRCUID  IN NUMBER,
  PISRCUSRID  IN VARCHAR2,
  PISRCSPGATE  IN VARCHAR2,
  PISRCSPNUMBER IN  VARCHAR2,
  PIDESTUID  IN NUMBER,
  PIDESTUSRID  IN VARCHAR2,
  PIDESTSPGATE  IN VARCHAR2,
  PIDESTSPNUMBER  IN VARCHAR2,
  PIDESTFEEFLAG  IN NUMBER,
  PISPLITLEN  IN NUMBER,
  PIMULTILEN1  IN NUMBER,
  PIMULTILEN2  IN NUMBER,
  PINEWSIGNLEN  IN NUMBER,
  PIOLDSIGNLEN  IN NUMBER,
  PISIGNATURE  IN VARCHAR2,
  PINEWSIGNPOS IN NUMBER,
  PIOLDSIGNPOS IN NUMBER,
  PIENSPLITLEN IN NUMBER, --英文短信单条长度，小于等于0标识不支持英文短信
  PIENMULTILEN1  IN NUMBER, --英文长短信拆分长度
  PIENMULTILEN2  IN NUMBER, --英文长短信最后一条长度
  PINEWENSIGNLEN  IN NUMBER, --补发英文签名长度
  PIOLDENSIGNLEN  IN NUMBER, --原英文签名长度
  PIENSIGNATURE  IN VARCHAR2, --英文签名
  PIRECVMTTIME  IN VARCHAR2,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISENDNUM NUMBER(11);
  PIPKTOTAL NUMBER(11);
  PIPKNUM   NUMBER(11);
  PIINITMSGID NUMBER(22);
  PISINGLEMSG VARCHAR2(720);
  PISINGLEMSG1 VARCHAR2(720);
  PILONGMSG VARCHAR2(3000);
  PITOTALCNT NUMBER(11);
  PILONGMSGLEN NUMBER(11);
  PIECID NUMBER(11);
  PIPHONE VARCHAR2(21);
  PISENDLEVEL NUMBER(11);
  PITASKID NUMBER(11);
  --PIRECVMTTIME TIMESTAMP;
  PISRCCPNO  VARCHAR2(21);
  PIDESTCPNO VARCHAR2(21);
  PITPUDHI NUMBER(11);
  PITPPID NUMBER(11);
  PILONGMSGSEQ NUMBER(11);
  PIMSGFMT NUMBER(11);
  PIUNICOM NUMBER(11);
  PIMOBILEAREA NUMBER(11);
  PISVRTYPE VARCHAR2(64);
  PIUSERMSGID NUMBER(22);
  PISENDTYPE NUMBER(11);
  PIP1 VARCHAR2(64);
  PIP2 VARCHAR2(64);
  PIP3 VARCHAR2(64);
  PIP4 VARCHAR2(64);
  PIMODULEID NUMBER(11);
  PIATTIME NUMBER(22);
  PIVALIDTIME NUMBER(22);
  PIBATCHID NUMBER(22);
  PIAREACODE NUMBER(11);
  ICOUNT NUMBER(11);
  PITEMPCNT1 NUMBER(11);
  PITEMPCNT2 NUMBER(11);

  PISPLITLEN_V NUMBER(11);
  PIMULTILEN1_V  NUMBER(11);
  PIMULTILEN2_V  NUMBER(11);
  PINEWSIGNLEN_V  NUMBER(11);
  PIOLDSIGNLEN_V  NUMBER(11);
  PISIGNATURE_V  VARCHAR2(22);
  PIPTMSGID_P  NUMBER(22);
BEGIN

  /*--检查查临时表是否存在,如果存在则清空,不存在直接返回
  SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_RDMTTASK');
  IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';
  ELSE
    RETURN;
  END IF;
  */
  PILONGMSG:='';
  --PIRECVMTTIME:= SYSTIMESTAMP;
  PISRCCPNO:= SUBSTR(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE));
  PIDESTCPNO:= NVL(SUBSTR(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE)), ' ');
   --取补发帐号的费用
  --SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=PIDESTUSRID;

  --每次调用存储过程时候，先清空TMP_RDMTTASK会话级别的临时表
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';

  --该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1<=0 THEN
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);
  END IF;

  DELETE FROM TMP_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
  PITEMPCNT2:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1 - PITEMPCNT2>0 THEN
    SELECT PKTOTAL,PKNUMBER,ECID,PHONE,SENDLEVEL,
        TASKID,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
        MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
        SENDTYPE,P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE  INTO
        PIPKTOTAL,PIPKNUM,PIECID,PIPHONE,PISENDLEVEL,
        PITASKID,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
        PIMOBILEAREA,PISVRTYPE,PITPPID,PIUSERMSGID,
        PISENDTYPE,PIP1,PIP2,PIP3,PIP4,PIMODULEID,PIATTIME,PIVALIDTIME,PIBATCHID,PIAREACODE
    FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       PIOLDSIGNLEN_V:=PIOLDENSIGNLEN;
     ELSE
       PIOLDSIGNLEN_V:=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       PISPLITLEN_V:=PIENSPLITLEN;
       PIMULTILEN1_V:=PIENMULTILEN1;
       PIMULTILEN2_V:=PIENMULTILEN2;
       PINEWSIGNLEN_V:=PINEWENSIGNLEN;
       PISIGNATURE_V:=PIENSIGNATURE;
     ELSE
       PISPLITLEN_V:=PISPLITLEN;
       PIMULTILEN1_V:=PIMULTILEN1;
       PIMULTILEN2_V:=PIMULTILEN2;
       PINEWSIGNLEN_V:=PINEWSIGNLEN;
       PISIGNATURE_V:=PISIGNATURE;
     END IF;

     if (0 = PINEWSIGNLEN_V) THEN
       PISIGNATURE_V:='';
     END IF;

     IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN--对于非长短信补发的处理
        PILONGMSG:='';
        --取短信内容
        SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
        --更新替换MSGID
        UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V; --减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
        PIPKNUM:=1;
    /*
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN--对标准协议长短信的补发
      PILONGMSG:='';
      --取短信内容
      SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
      --更新替换MSGID
      UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
      IF (PIPKTOTAL=PIPKNUM)THEN ---如果是最后一条，去掉旧签名，加上新签名
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN; --减去签名的净长度
        PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        PILONGMSG := PILONGMSG||PISIGNATURE;
      END IF;
      PILONGMSGLEN := LENGTH(PILONGMSG);
      IF PILONGMSGLEN > 0 THEN
        --调用插入存储过程
        S_WR_MTTASKSR(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
                PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
                PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
      ELSE
        PILONGMSG:='';
      END IF;--END OF IF PILONGMSGLEN > 0
    */
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0)THEN--对非标准长短信协议的处理
      PILONGMSG:=' ';
      --没有补发过且通道号跟源通道号相等
      SELECT COUNT(*) INTO ICOUNT FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND TRIM(SPGATE)=PISRCSPGATE;
      IF ICOUNT>0 THEN
        --循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
        --计算起始MSGID
        PIINITMSGID := PIOLDMSGID-(PIPKNUM-1)*17179869184;
        PIPKNUM := 1;
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          --取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
          BEGIN
          SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          exception
            when no_data_found then
              PISINGLEMSG := ' ';
          end;
          IF PISINGLEMSG = ' ' THEN
            --拼接短信内容
            BEGIN
            SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                PISINGLEMSG1:=' ';
            END;
            IF NVL(LENGTH(LTRIM(PISINGLEMSG1)),0)>0 THEN
             --更新替换MSGID
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG1,' ');
            UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            END IF;--IF LENGTH(PISINGLEMSG1)>0 THEN
          ELSE
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG,' ');
            UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          END IF;
            --拼接短信内容
           PIPKNUM := PIPKNUM+1;
        END LOOP;--END OF WHILE PIPKNUM <= PIPKTOTAL
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V ;--减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          S_WR_MTTASK(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
          PIPKNUM:=1;
      END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM PITMP WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND (TRIM(SPGATE)+TRIM(CPNO))=PISRCSPNUMBER)
    END  IF;--END OF IF PIPKTOTAL > 1
  END IF;--END OF IF PIPIROWCOUNT<>0
  --返回给上层数据
  PIPTMSGID_P:=PINEWMSGID;
  UPDATE TMP_RDMTTASK SET PTNEWMSGID=PIPTMSGID_P WHERE PTMSGID=PIOLDMSGID;

  OPEN OUT_CURSOR FOR
  SELECT "UID",PTNEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
  PIDESTCPNO AS CPNO,PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,1 AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
  SENDSTATUS,1 AS SENDLEVEL,
  PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,
  ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM TMP_RDMTTASK WHERE (PILONGMSG IS NOT NULL);
END;
/



--PROMPT
--PROMPT CREATING PROCEDURE S_RD_RPTWAITB
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE S_RD_RPTWAITB
(
  PIUID           IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",ORGUID,ECID,USERID,SUBMITTIME,DONETIME,PHONE,SPNUMBER,PTMSGID,ERRORCODE,USERMSGID,MODULEID ,
  TO_DATE(TO_CHAR(RECVTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVTIME , SPMSGID
  FROM RPT_WAIT_B WHERE "UID"='||PIUID||' AND ROWNUM<='||PIMAXREADCNT||'';
  --DBMS_OUTPUT.PUT_LINE(PISQLSTR);
  --EXECUTE IMMEDIATE PISQLSTR;
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_RD_RPTWAITB
--PROMPT ================================
--PROMPT S_RD_RPTWAITB------>GW_RDRPTWAITBV1
CREATE OR REPLACE PROCEDURE GW_RDRPTWAITBV1
(
  PIUID           IN NUMBER,
  PIMAXREADCNT    IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISQLSTR VARCHAR2(4000);
BEGIN
  PISQLSTR :=
  'SELECT /*+RULE*/ ID,"UID",ORGUID,ECID,USERID,SUBMITTIME,DONETIME,PHONE,SPNUMBER,PTMSGID,ERRORCODE,USERMSGID,MODULEID ,
  TO_DATE(TO_CHAR(RECVTIME, ''YYYY-MM-DD HH24:MI:SS''),''YYYY-MM-DD HH24:MI:SS'') AS RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA,RESENDCNT
  FROM RPT_WAIT_B WHERE "UID"='||PIUID||' AND ROWNUM<='||PIMAXREADCNT||'';
  --返回给上层数据
  OPEN OUT_CURSOR FOR PISQLSTR;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_RPTWAITB
--PROMPT ================================
--PROMPT  S_WR_RPTWAITB--->GW_WRRPTWAITBV1
CREATE OR REPLACE PROCEDURE GW_WRRPTWAITBV1
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PIECID         IN NUMBER,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PIUSERID       IN VARCHAR2,
    PIORGUID       IN NUMBER,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRECVTIME_P   IN VARCHAR2,
    PISPMSGID      IN NUMBER DEFAULT 0    ---- 新增的2015.10.8
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_B("UID",PTMSGID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERID,ECID,ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERID,PIECID,PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID);
  END IF;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_RPTWAITB
--PROMPT ================================
--PROMPT  GW_WRRPTWAITBV1--->GW_WRRPTWAITBV2
CREATE OR REPLACE PROCEDURE GW_WRRPTWAITBV2
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PIECID         IN NUMBER,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PIUSERID       IN VARCHAR2,
    PIORGUID       IN NUMBER,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRECVTIME_P   IN VARCHAR2,
    PISPMSGID      IN NUMBER DEFAULT 0,    ---- 新增的2015.10.8
    PIPKTOTAL      IN NUMBER DEFAULT 0    ---- 新增的2016.8.25 64BIT集群
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_B("UID",PTMSGID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERID,
    ECID,ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERID,
    PIECID,PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL);
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_WRRPTWAITBV3
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PIECID         IN NUMBER,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PIUSERID       IN VARCHAR2,
    PIORGUID       IN NUMBER,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRECVTIME_P   IN VARCHAR2,
    PISPMSGID      IN NUMBER DEFAULT 0,    ---- 新增的2015.10.8
    PIPKTOTAL      IN NUMBER DEFAULT 0,    ---- 新增的2016.8.25 64BIT集群
    PICUSTID     IN RPT_WAIT_B.CUSTID%TYPE,
    PIEXDATA    IN RPT_WAIT_B.EXDATA%TYPE
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_B("UID",PTMSGID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERID,
    ECID,ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERID,
    PIECID,PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL,PICUSTID,PIEXDATA);
  END IF;
END;
/


CREATE OR REPLACE PROCEDURE GW_WRRPTWAITCV2
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISPGATE       IN VARCHAR2,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PILOGINID      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRETFLAG     IN NUMBER DEFAULT 1,
    PIRECVFLAG      IN NUMBER DEFAULT 1,
    PISENDTIME      IN NUMBER DEFAULT 0,
    PISPMSGID      IN NUMBER DEFAULT 0 ,   ---- 新增的2015.10.8
    PIWTRPTFLAG    IN NUMBER DEFAULT 0 ,
    PIRECVTIME_P   IN VARCHAR2
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_C("UID", PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME,RECVFLAG, ERRORCODE,
    LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME)
    VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG, PIERRORCODE,PILOGINID,
    PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME);
  END IF;
END;
/

--GW_WRRPTWAITCV2--->GW_WRRPTWAITCV3
CREATE OR REPLACE PROCEDURE GW_WRRPTWAITCV3
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISPGATE       IN VARCHAR2,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PILOGINID      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRETFLAG      IN NUMBER DEFAULT 1,
    PIRECVFLAG     IN NUMBER DEFAULT 1,
    PISENDTIME     IN NUMBER DEFAULT 0,
    PISPMSGID      IN NUMBER DEFAULT 0 ,   ---- 新增的2015.10.8
    PIWTRPTFLAG    IN NUMBER DEFAULT 0 ,
    PIRECVTIME_P   IN VARCHAR2,
    PIPKTOTAL      IN NUMBER DEFAULT 0     ---- 新增的2016.08.25
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_C("UID", PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME,RECVFLAG, ERRORCODE,
    LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME,PKTOTAL)
    VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG, PIERRORCODE,PILOGINID,
    PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME,PIPKTOTAL);
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_WRRPTWAITCV4
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISPGATE       IN VARCHAR2,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PILOGINID      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRETFLAG      IN NUMBER DEFAULT 1,
    PIRECVFLAG     IN NUMBER DEFAULT 1,
    PISENDTIME     IN NUMBER DEFAULT 0,
    PISPMSGID      IN NUMBER DEFAULT 0 ,   ---- 新增的2015.10.8
    PIWTRPTFLAG    IN NUMBER DEFAULT 0 ,
    PIRECVTIME_P   IN VARCHAR2,
    PIPKTOTAL      IN NUMBER DEFAULT 0,     ---- 新增的2016.08.25
    PICUSTID     IN RPT_WAIT_C.CUSTID%TYPE,
    PIEXDATA    IN RPT_WAIT_C.EXDATA%TYPE
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_C("UID", PTMSGID, SPGATE,SPNUMBER, PHONE, SUBMITTIME, DONETIME,RECVFLAG, ERRORCODE,
    LOGINID,USERMSGID,MODULEID,RETFLAG,SENDTIME,SPMSGID,WTRPTFLAG,RECVTIME,PKTOTAL,CUSTID,EXDATA)
    VALUES(PIUID, PIPTMSGID, PISPGATE, PISPNUMBER, PIPHONE, PISUBMITTIME, PIDONETIME,PIRECVFLAG, PIERRORCODE,PILOGINID,
    PIUSERMSGID,PIMODULEID,PIRETFLAG,PISENDTIME,PISPMSGID,PIWTRPTFLAG,PIRECVTIME,PIPKTOTAL,PICUSTID,PIEXDATA);
  END IF;
END;
/
---S_WR_MTTASKC--->GW_WRMTTASKCV1
CREATE OR REPLACE PROCEDURE GW_WRMTTASKCV1
 (
  PIUID          IN NUMBER,
  PIPTMSGID      IN NUMBER,
  PISENDSTATUS   IN NUMBER,
  PIRETFLAG      IN NUMBER,
  PIPKNUMBER     IN NUMBER,
  PIPKTOTAL      IN NUMBER,
  PIPHONECOUNT   IN NUMBER,
  PIUSERID       IN VARCHAR2,
  PISPGATE       IN VARCHAR2,
  PICPNO         IN VARCHAR2,
  PIRECVMTTIME   IN VARCHAR2,
  PIPHONE        IN VARCHAR2,
  PIMESSAGE      IN VARCHAR2,
  PITPUDHI       IN NUMBER,
  PILOGINID      IN VARCHAR2,
  PITRANSMTTIME  IN TIMESTAMP,
  PIMSGFMT       IN NUMBER,
  PILONGMSGSEQ   IN NUMBER,
  PIUSERMSGID    IN NUMBER DEFAULT 0,
  PIMODULEID     IN NUMBER DEFAULT 0,
  PISENDLEVEL    IN NUMBER DEFAULT 5,
  PIVALIDTIME    IN NUMBER DEFAULT 0,
  PIUNICOM       IN NUMBER DEFAULT 0,
  PITASKID       IN NUMBER DEFAULT 0,
  PIMOBILEAREA   IN NUMBER DEFAULT 0,
  PINETERRORCNT       IN NUMBER DEFAULT 0,
  PISUBMITERRORCNT   IN NUMBER DEFAULT 0
 )
AS
--TO_DATE(NVL(PISENDTIME,' '),'YYYY-MM-DD HH24:MI:SS.FF')
ICOUNT PLS_INTEGER;
PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
    INSERT INTO MT_TASK_C("UID", LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
    SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME, TPUDHI, LONGMSGSEQ,TRANSMTTIME, MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT )
    VALUES(PIUID, PILOGINID,PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
    PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PITPUDHI, PILONGMSGSEQ,PITRANSMTTIME, PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA ,PINETERRORCNT,PISUBMITERRORCNT);
  END IF;
END;
/
CREATE OR REPLACE PROCEDURE GW_WRMTTASKCV2
 (
  PIUID          IN NUMBER,
  PIPTMSGID      IN NUMBER,
  PISENDSTATUS   IN NUMBER,
  PIRETFLAG      IN NUMBER,
  PIPKNUMBER     IN NUMBER,
  PIPKTOTAL      IN NUMBER,
  PIPHONECOUNT   IN NUMBER,
  PIUSERID       IN VARCHAR2,
  PISPGATE       IN VARCHAR2,
  PICPNO         IN VARCHAR2,
  PIRECVMTTIME   IN VARCHAR2,
  PIPHONE        IN VARCHAR2,
  PIMESSAGE      IN VARCHAR2,
  PITPUDHI       IN NUMBER,
  PILOGINID      IN VARCHAR2,
  PITRANSMTTIME  IN TIMESTAMP,
  PIMSGFMT       IN NUMBER,
  PILONGMSGSEQ   IN NUMBER,
  PIUSERMSGID    IN NUMBER DEFAULT 0,
  PIMODULEID     IN NUMBER DEFAULT 0,
  PISENDLEVEL    IN NUMBER DEFAULT 5,
  PIVALIDTIME    IN NUMBER DEFAULT 0,
  PIUNICOM       IN NUMBER DEFAULT 0,
  PITASKID       IN NUMBER DEFAULT 0,
  PIMOBILEAREA   IN NUMBER DEFAULT 0,
  PINETERRORCNT       IN NUMBER DEFAULT 0,
  PISUBMITERRORCNT   IN NUMBER DEFAULT 0,
  PICUSTID     IN MT_TASK_C.CUSTID%TYPE,
  PIEXDATA    IN MT_TASK_C.EXDATA%TYPE
 )
AS
--TO_DATE(NVL(PISENDTIME,' '),'YYYY-MM-DD HH24:MI:SS.FF')
ICOUNT PLS_INTEGER;
PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
    INSERT INTO MT_TASK_C("UID", LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
    SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME, TPUDHI, LONGMSGSEQ,TRANSMTTIME, MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT,CUSTID,EXDATA)
    VALUES(PIUID, PILOGINID,PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
    PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PITPUDHI, PILONGMSGSEQ,PITRANSMTTIME, PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA ,PINETERRORCNT,PISUBMITERRORCNT,PICUSTID,PIEXDATA);
  END IF;
END;
/




CREATE OR REPLACE PROCEDURE GW_LOADSVRTYPE
 (
 OUT_CURSOR OUT SYS_REFCURSOR
 )
AS
BEGIN
    OPEN OUT_CURSOR FOR 'SELECT BUS_ID AS SVRID,UPPER(BUS_CODE) AS SVRCODE,BUS_NAME AS SVRNAME,STATE AS SVRSTATE FROM LF_BUSMANAGER';
END;
/

--历史表加索引，当前月份之后的表（PIYM，型如201601；PICOL，要加索引的列）
CREATE OR REPLACE PROCEDURE GW_ADDHISINDEX(PIYM IN NUMBER, PICOL IN VARCHAR2)
AS
PIINDEXNAME VARCHAR2(50);
PITABLE VARCHAR2(20);
PITABLE1 VARCHAR2(20);
PISTR VARCHAR2(1000);
PICNT NUMBER(11);
V_SQL VARCHAR2(256);
CUR_TABLE SYS_REFCURSOR;
BEGIN
 PITABLE1:='MTTASK'||CAST(PIYM AS CHAR);
 V_SQL:='SELECT TABLE_NAME FROM USER_TABLES T WHERE T.TABLE_NAME LIKE ''MTTASK20%'' AND T.TABLE_NAME>='''||PITABLE1||'''';
  OPEN CUR_TABLE FOR V_SQL ;
  LOOP
      FETCH CUR_TABLE INTO PITABLE;
      EXIT WHEN CUR_TABLE%NOTFOUND;
      PIINDEXNAME :='IX_'||PITABLE||'_'||PICOL;
      SELECT COUNT (*) INTO PICNT FROM USER_INDEXES WHERE TABLE_NAME = PITABLE AND INDEX_NAME = PIINDEXNAME;
      IF PICNT=0 THEN
         PISTR:='CREATE INDEX IX_'||PITABLE||'_'||PICOL||' ON '||PITABLE||'('||PICOL||')';
         EXECUTE IMMEDIATE PISTR;
      END IF;
  END LOOP;
  CLOSE CUR_TABLE;
END;
/

--------------加载SPGATE主备绑定表
CREATE OR REPLACE PROCEDURE GW_LOADCLUBIND(P_GWNO NUMBER,OUT_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT ID,PTACCUID,GWNO,GWEIGHT FROM GW_CLUSPBIND
  WHERE PTACCUID=(SELECT PTACCUID FROM GW_CLUSPBIND WHERE GWNO=P_GWNO);
END;
/

CREATE OR REPLACE PROCEDURE GW_UPDCLUSTATS(
PI_GWTYPE     NUMBER,
PI_GWNO       NUMBER,
PI_PRIGWNO    NUMBER,
PI_OLDPRIGWNO NUMBER,
PI_RUNSTATUS  NUMBER,
PI_GWEIGHT    NUMBER,
PI_RUNWEIGHT  NUMBER,
PI_UPDTYPE    NUMBER,
OUT_CURSOR OUT SYS_REFCURSOR
)
AS
PI_ROWCNT1 NUMBER; --0表示更新失败  1表示更新成功
PI_ROWCNT2 NUMBER; --0表示更新失败  1表示更新成功
PI_UPDRESULT NUMBER; --0表示更新失败  1表示更新成功


BEGIN
   IF PI_UPDTYPE=1 THEN
      UPDATE GW_CLUSTATUS SET RUNSTATUS=PI_RUNSTATUS , GWEIGHT=PI_GWEIGHT ,
      RUNWEIGHT=PI_RUNWEIGHT , UPDTIME=SYSTIMESTAMP WHERE GWNO=PI_GWNO AND GWTYPE=PI_GWTYPE ;
      PI_ROWCNT1 := sql%rowcount;

      UPDATE GW_CLUDECISION SET RUNGWNO=PI_GWNO , RUNUPDTIME=SYSTIMESTAMP
      WHERE GWNO=PI_PRIGWNO AND GWTYPE=PI_GWTYPE AND RUNGWNO=PI_OLDPRIGWNO;
      PI_ROWCNT2 := sql%rowcount;

      IF (PI_ROWCNT1<0) OR (PI_ROWCNT2<0) THEN  --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;

      END IF;


      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,
      CN.APPLYSTATUS,GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);

   ELSIF PI_UPDTYPE=2 THEN
      UPDATE GW_CLUDECISION SET APPLYGWNO=PI_GWNO , APPLYSTATUS=1 WHERE GWNO=PI_PRIGWNO AND GWTYPE=PI_GWTYPE ;
      IF sql%rowcount<0 THEN  --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;

      END IF;

      --返回：运行主用权限的信息
      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
      GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);

   ELSIF PI_UPDTYPE=3 THEN
      UPDATE GW_CLUSTATUS SET RUNSTATUS=PI_RUNSTATUS , GWEIGHT=PI_GWEIGHT ,
      RUNWEIGHT=PI_RUNWEIGHT , UPDTIME=SYSTIMESTAMP WHERE GWNO=PI_GWNO AND GWTYPE=PI_GWTYPE ;
      PI_ROWCNT1 := sql%rowcount;

      UPDATE GW_CLUDECISION SET RUNGWNO=0 , RUNUPDTIME=SYSTIMESTAMP , APPLYGWNO=0 , APPLYSTATUS=0
      WHERE GWNO=PI_PRIGWNO AND GWTYPE=PI_GWTYPE ;
      PI_ROWCNT2 := sql%rowcount;

      IF (PI_ROWCNT1<0) OR (PI_ROWCNT2<0) THEN  --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;

      END IF;


      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
      GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);

   ELSIF PI_UPDTYPE=4 THEN
      BEGIN
      --OPEN OUT_CURSOR FOR
      --SELECT ID,GWTYPE,GWNO,RUNGWNO,RUNUPDTIME,APPLYGWNO,APPLYSTATUS FROM GW_CLUDECISION
      --WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO AND RUNGWNO=PI_OLDPRIGWNO FOR UPDATE WAIT 3;
      UPDATE GW_CLUDECISION SET RUNUPDTIME=SYSTIMESTAMP,APPLYGWNO=0,APPLYSTATUS=0 ,RUNGWNO=PI_GWNO
      WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_PRIGWNO AND RUNGWNO=PI_OLDPRIGWNO;
      PI_ROWCNT1 := sql%rowcount;
      IF PI_ROWCNT1>0 THEN
         UPDATE GW_CLUSTATUS SET RUNSTATUS=1,GWEIGHT=PI_GWEIGHT ,RUNWEIGHT=0,UPDTIME=SYSTIMESTAMP
         WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO ;
      END IF;
      EXCEPTION WHEN OTHERS THEN
         ROLLBACK;
         --OPEN OUT_CURSOR FOR SELECT 0 AS UPDRESULT FROM DUAL;

      END;

         COMMIT;
         --返回：运行主用权限的信息
         OPEN OUT_CURSOR FOR
         SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
         GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
         1 AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
         FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
         WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
         WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);

   ELSIF PI_UPDTYPE=5 THEN
      UPDATE GW_CLUDECISION SET RUNGWNO=0 , RUNUPDTIME=SYSTIMESTAMP WHERE GWNO=PI_PRIGWNO AND GWTYPE=PI_GWTYPE ;

      PI_ROWCNT1 := sql%rowcount;
      UPDATE GW_CLUSTATUS SET RUNSTATUS=0 , RUNWEIGHT=PI_GWEIGHT , GWEIGHT=PI_GWEIGHT ,
      UPDTIME=SYSTIMESTAMP WHERE GWNO=PI_GWNO AND GWTYPE=PI_GWTYPE ;

      PI_ROWCNT2 := sql%rowcount;

      IF (PI_ROWCNT1<0) OR (PI_ROWCNT2<0) THEN  --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;

      END IF;


      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
      GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);

   ELSIF PI_UPDTYPE=6 THEN
      UPDATE GW_CLUSTATUS SET RUNSTATUS=PI_RUNSTATUS , GWEIGHT=PI_GWEIGHT ,
      RUNWEIGHT=PI_RUNWEIGHT , UPDTIME=SYSTIMESTAMP WHERE GWNO=PI_GWNO AND GWTYPE=PI_GWTYPE ;


      IF sql%rowcount<0 THEN --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;

      END IF;

      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
      GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);
   ELSE
      UPDATE GW_CLUSTATUS SET RUNSTATUS=0 ,UPDTIME=SYSTIMESTAMP WHERE GWNO=PI_GWNO AND GWTYPE=PI_GWTYPE ;
      IF sql%rowcount<0 THEN --更新失败
         PI_UPDRESULT := 0;
      ELSE --更新成功
         PI_UPDRESULT := 1;
      END IF;

      OPEN OUT_CURSOR FOR
      SELECT GWCLUSTATUS.GWTYPE,GWCLUSTATUS.GWNO,GWCLUSTATUS.PRIGWNO,GWCLUSTATUS.RUNSTATUS,CN.RUNPRIGWNO,CN.APPLYGWNO,CN.APPLYSTATUS,
      GWCLUSTATUS.GWEIGHT,GWCLUSTATUS.RUNWEIGHT,TO_CHAR(GWCLUSTATUS.UPDTIME,'YYYY-MM-DD HH24:MI:SS') AS UPDTIME,
      PI_UPDRESULT AS UPDRESULT,TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD HH24:MI:SS') AS DBTIME
      FROM GW_CLUSTATUS GWCLUSTATUS,(SELECT RUNGWNO  AS RUNPRIGWNO ,APPLYGWNO ,APPLYSTATUS FROM GW_CLUDECISION
      WHERE GWNO= (SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO))CN
      WHERE PRIGWNO=( SELECT PRIGWNO FROM GW_CLUSTATUS WHERE GWTYPE=PI_GWTYPE AND GWNO=PI_GWNO);
   END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_RD_BATREQV1
 (
  PILOGINID    IN VARCHAR2,
  PIDOWNLOADFLAG IN NUMBER,
  PICLUGWNO IN NUMBER,
  OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF PIDOWNLOADFLAG=0 THEN
  OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,
    PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,
    PB.TASKTYPE,PB.BATCHID,PB.CLUPATH,PB.CLUGWNO FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS>2 AND  ERRORCODE='ACCEPTD' AND TRIM(LOCALPATH) IS NULL
    ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
  ELSE
    IF PICLUGWNO=99 THEN
    OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,
    PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,
    PB.TASKTYPE,PB.BATCHID,PB.CLUPATH,PB.CLUGWNO FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS>2 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD'
    AND TRIM(LOCALPATH) IS NOT NULL ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
    ELSE
    OPEN OUT_CURSOR FOR
    SELECT /*+RULE*/ PB.MSGID,PB.BMTMSGID,PB.USERID,PB.LOGINID,PB.USERUID,PB.SERVICETYPE,PB.SA,PB.SENDTYPE,
    PB.TASKID,PB.TITLE,PB.MSG,PB.MSGFMT,PB.REMOTEURL,TRIM(PB.LOCALPATH) AS LOCALPATH,PB.SENDLEVEL,PB.ATTIME,
    PB.VALIDTIME,PB.SVRTYPE,PB.P1,PB.P2,PB.P3,PB.P4,PB.USERMSGID,PB.MODULEID,PB.RETFLAG,PB.TOTALNUM,PB.SENDNUM,
    PB.TASKTYPE,PB.BATCHID,PB.CLUPATH,PB.CLUGWNO FROM (SELECT * FROM BATCH_MT_REQ
    WHERE UPPER(LOGINID)=UPPER(PILOGINID) AND SENDSTATUS>2 AND ATTIMEFLAG=0 AND ERRORCODE='ACCEPTD'
    AND TRIM(CLUPATH) IS NOT NULL AND TRIM(LOCALPATH) IS NOT NULL
    ORDER BY SENDLEVEL)PB WHERE ROWNUM<=1000;
    END IF;
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_UPDBATREQV1
 (
   PIUSERID     IN BATCH_MT_REQ.USERID%TYPE,
   PIUSERUID    IN BATCH_MT_REQ.USERUID%TYPE,
   PILOGINID    IN BATCH_MT_REQ.LOGINID%TYPE,
   PISENDSTATUS IN BATCH_MT_REQ.SENDSTATUS%TYPE,
   PITASKID     IN BATCH_MT_REQ.TASKID%TYPE,
   PIMSGID      IN BATCH_MT_REQ.MSGID%TYPE,
   PILOCALPATH  IN BATCH_MT_REQ.LOCALPATH%TYPE,
   PIERRORCODE  IN BATCH_MT_REQ.ERRORCODE%TYPE,
   PIBMTMSGID   IN BATCH_MT_REQ.BMTMSGID%TYPE,
   PICLUPATH    IN BATCH_MT_REQ.CLUPATH%TYPE,
   PICLUGWNO    IN BATCH_MT_REQ.CLUGWNO%TYPE,
   PITOTALNUM   IN BATCH_MT_REQ.TOTALNUM%TYPE:=0,
   PISENDNUM    IN BATCH_MT_REQ.SENDNUM%TYPE:=0,
   OUT_CURSOR   OUT SYS_REFCURSOR
 )
AS
  PIROWCOUNT NUMBER;
  BEGIN
  IF PISENDSTATUS=0 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       PIROWCOUNT:= SQL%ROWCOUNT;
       BEGIN
       INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID);
       DELETE FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       DELETE FROM ATTIME_TASK WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       EXCEPTION WHEN OTHERS THEN
         ROLLBACK;
       END;
       COMMIT;
  ELSIF PISENDSTATUS=2 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,SENDTIME=SYSTIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=3 THEN
       UPDATE BATCH_MT_REQ SET USERUID=PIUSERUID,SENDSTATUS=PISENDSTATUS,ERRORCODE=PIERRORCODE,MSGID=PIMSGID,SENDTIME=SYSTIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=4 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,LOCALPATH=PILOCALPATH,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP,TOTALNUM=PITOTALNUM,
       CLUPATH=PICLUPATH,CLUGWNO=PICLUGWNO WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID AND SENDSTATUS=3;
       PIROWCOUNT:= SQL%ROWCOUNT;
       IF PIROWCOUNT<>1 THEN
         BEGIN
           UPDATE BATCH_MT_REQ SET SENDSTATUS=0,ERRORCODE='UPDFAIL',SENDTIME=SYSTIMESTAMP WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
           INSERT INTO BATCH_MT_REQ_HIS (SELECT * FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID);
           DELETE FROM BATCH_MT_REQ WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
           DELETE FROM ATTIME_TASK WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
           EXCEPTION WHEN OTHERS THEN
             ROLLBACK;
         END;
         COMMIT;
       END IF;
  ELSIF PISENDSTATUS=5 THEN
       UPDATE BATCH_MT_REQ SET SENDSTATUS=PISENDSTATUS,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSIF PISENDSTATUS=6 THEN
       UPDATE BATCH_MT_REQ SET ERRORCODE=PIERRORCODE,SENDNUM=PISENDNUM,SENDTIME=SYSTIMESTAMP
       WHERE BMTMSGID=PIBMTMSGID AND LOGINID=PILOGINID;
       PIROWCOUNT:= SQL%ROWCOUNT;
  ELSE
    PIROWCOUNT:= 0;
  END IF;
  OPEN OUT_CURSOR FOR SELECT PIROWCOUNT AS UPDROWCOUNT FROM DUAL;
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKBAK
 (
    PIUID         IN GW_MT_TASK_BAK."UID"%TYPE,
    PIPTMSGID     IN GW_MT_TASK_BAK.PTMSGID%TYPE,
    PIECID        IN GW_MT_TASK_BAK.ECID%TYPE,
    PISENDSTATUS  IN GW_MT_TASK_BAK.SENDSTATUS%TYPE,
    PIRETFLAG     IN GW_MT_TASK_BAK.RETFLAG%TYPE,
    PIPKNUMBER    IN GW_MT_TASK_BAK.PKNUMBER%TYPE,
    PIPKTOTAL     IN GW_MT_TASK_BAK.PKTOTAL%TYPE,
    PIFEEFLAG     IN GW_MT_TASK_BAK.FEEFLAG%TYPE,
    PISENDLEVEL   IN GW_MT_TASK_BAK.SENDLEVEL%TYPE,
    PIRECVMTTIME  IN GW_MT_TASK_BAK.RECVMTTIME%TYPE,
    PIUSERID      IN GW_MT_TASK_BAK.USERID%TYPE,
    PISPGATE      IN GW_MT_TASK_BAK.SPGATE%TYPE,
    PICPNO        IN GW_MT_TASK_BAK.CPNO%TYPE,
    PIPHONE       IN GW_MT_TASK_BAK.PHONE%TYPE,
    PIMESSAGE     IN GW_MT_TASK_BAK.MESSAGE%TYPE,
    PITASKID      IN GW_MT_TASK_BAK.TASKID%TYPE,
    PIERRORCODE   IN GW_MT_TASK_BAK.ERRORCODE%TYPE,
    PITPUDHI      IN GW_MT_TASK_BAK.TPUDHI%TYPE,
    PILONGMSGSEQ  IN GW_MT_TASK_BAK.LONGMSGSEQ%TYPE,
    PIMSGFMT      IN GW_MT_TASK_BAK.MSGFMT%TYPE,
    PIUNICOM      IN GW_MT_TASK_BAK.UNICOM%TYPE,
    PIMOBILEAREA  IN GW_MT_TASK_BAK.MOBILEAREA%TYPE,
    PISVRTYPE     IN GW_MT_TASK_BAK.SVRTYPE%TYPE,
    PIP1          IN GW_MT_TASK_BAK.P1%TYPE,
    PIP2          IN GW_MT_TASK_BAK.P2%TYPE,
    PIP3          IN GW_MT_TASK_BAK.P3%TYPE,
    PIP4          IN GW_MT_TASK_BAK.P4%TYPE,
    PIUSERMSGID   IN GW_MT_TASK_BAK.USERMSGID%TYPE,
    PIMODULEID    IN GW_MT_TASK_BAK.MODULEID%TYPE,
    PIATTIME      IN GW_MT_TASK_BAK.ATTIME%TYPE,
    PIVALIDTIME   IN GW_MT_TASK_BAK.VALIDTIME%TYPE,
    PISENDTYPE    IN GW_MT_TASK_BAK.SENDTYPE%TYPE,
    PIBATCHID     IN GW_MT_TASK_BAK.BATCHID%TYPE,
    PIAREACODE    IN GW_MT_TASK_BAK.AREACODE%TYPE
 )
AS
  PICNT NUMBER;
  BEGIN
    SELECT COUNT(ID) INTO PICNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID;
  IF PICNT=0 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",PTMSGID,ECID,SENDSTATUS,RETFLAG,PKNUMBER,PKTOTAL,FEEFLAG,SENDLEVEL,
    RECVMTTIME,USERID,SPGATE,CPNO,PHONE,MESSAGE,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
    MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIPTMSGID,PIECID,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIFEEFLAG,PISENDLEVEL,PIRECVMTTIME,
    PIUSERID,PISPGATE,PICPNO,PIPHONE,PIMESSAGE,PITASKID,PIERRORCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
    PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
END;
/
CREATE OR REPLACE PROCEDURE GW_WR_MTTASKBAKV2
 (
    PIUID         IN GW_MT_TASK_BAK."UID"%TYPE,
    PIPTMSGID     IN GW_MT_TASK_BAK.PTMSGID%TYPE,
    PIECID        IN GW_MT_TASK_BAK.ECID%TYPE,
    PISENDSTATUS  IN GW_MT_TASK_BAK.SENDSTATUS%TYPE,
    PIRETFLAG     IN GW_MT_TASK_BAK.RETFLAG%TYPE,
    PIPKNUMBER    IN GW_MT_TASK_BAK.PKNUMBER%TYPE,
    PIPKTOTAL     IN GW_MT_TASK_BAK.PKTOTAL%TYPE,
    PIFEEFLAG     IN GW_MT_TASK_BAK.FEEFLAG%TYPE,
    PISENDLEVEL   IN GW_MT_TASK_BAK.SENDLEVEL%TYPE,
    PIRECVMTTIME  IN GW_MT_TASK_BAK.RECVMTTIME%TYPE,
    PIUSERID      IN GW_MT_TASK_BAK.USERID%TYPE,
    PISPGATE      IN GW_MT_TASK_BAK.SPGATE%TYPE,
    PICPNO        IN GW_MT_TASK_BAK.CPNO%TYPE,
    PIPHONE       IN GW_MT_TASK_BAK.PHONE%TYPE,
    PIMESSAGE     IN GW_MT_TASK_BAK.MESSAGE%TYPE,
    PITASKID      IN GW_MT_TASK_BAK.TASKID%TYPE,
    PIERRORCODE   IN GW_MT_TASK_BAK.ERRORCODE%TYPE,
    PITPUDHI      IN GW_MT_TASK_BAK.TPUDHI%TYPE,
    PILONGMSGSEQ  IN GW_MT_TASK_BAK.LONGMSGSEQ%TYPE,
    PIMSGFMT      IN GW_MT_TASK_BAK.MSGFMT%TYPE,
    PIUNICOM      IN GW_MT_TASK_BAK.UNICOM%TYPE,
    PIMOBILEAREA  IN GW_MT_TASK_BAK.MOBILEAREA%TYPE,
    PISVRTYPE     IN GW_MT_TASK_BAK.SVRTYPE%TYPE,
    PIP1          IN GW_MT_TASK_BAK.P1%TYPE,
    PIP2          IN GW_MT_TASK_BAK.P2%TYPE,
    PIP3          IN GW_MT_TASK_BAK.P3%TYPE,
    PIP4          IN GW_MT_TASK_BAK.P4%TYPE,
    PIUSERMSGID   IN GW_MT_TASK_BAK.USERMSGID%TYPE,
    PIMODULEID    IN GW_MT_TASK_BAK.MODULEID%TYPE,
    PIATTIME      IN GW_MT_TASK_BAK.ATTIME%TYPE,
    PIVALIDTIME   IN GW_MT_TASK_BAK.VALIDTIME%TYPE,
    PISENDTYPE    IN GW_MT_TASK_BAK.SENDTYPE%TYPE,
    PIBATCHID     IN GW_MT_TASK_BAK.BATCHID%TYPE,
    PIAREACODE    IN GW_MT_TASK_BAK.AREACODE%TYPE,
    PICUSTID     IN GW_MT_TASK_BAK.CUSTID%TYPE,
    PIEXDATA    IN GW_MT_TASK_BAK.EXDATA%TYPE,
	PISUID1    IN GW_MT_TASK_BAK.SUID1%TYPE,
	PILUID1    IN GW_MT_TASK_BAK.LUID1%TYPE
 )
AS
  PICNT NUMBER;
  BEGIN
    SELECT COUNT(ID) INTO PICNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID;
  IF PICNT=0 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",PTMSGID,ECID,SENDSTATUS,RETFLAG,PKNUMBER,PKTOTAL,FEEFLAG,SENDLEVEL,
    RECVMTTIME,USERID,SPGATE,CPNO,PHONE,MESSAGE,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
    MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
    VALUES(PIUID,PIPTMSGID,PIECID,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIFEEFLAG,PISENDLEVEL,PIRECVMTTIME,
    PIUSERID,PISPGATE,PICPNO,PIPHONE,PIMESSAGE,PITASKID,PIERRORCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
    PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
  END IF;
END;
/
CREATE OR REPLACE PROCEDURE GW_DELWAIT
AS
  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  PI_MAXINDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数
  PIERROR VARCHAR2(4000);
BEGIN
   EACHMAX:= 500000;

   --删除文件发送请求历史表数据
   SELECT MIN(ID),MAX(ID) INTO PI_MININDEX,PI_MAXINDEX FROM BATCH_MT_REQ_HIS
   WHERE RECVTIME<TO_DATE(TO_CHAR(SYSDATE-60,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');
     PI_CURINDEX:=PI_MININDEX;
     WHILE PI_CURINDEX<PI_MAXINDEX LOOP
     IF PI_MAXINDEX-PI_CURINDEX>=EACHMAX THEN
       PI_CURINDEX:=PI_CURINDEX+EACHMAX;
     ELSE
       PI_CURINDEX:=PI_MAXINDEX;
     END IF;
     BEGIN
       DELETE FROM BATCH_MT_REQ_HIS WHERE ID<=PI_CURINDEX;
       EXCEPTION WHEN OTHERS THEN
         PIERROR:=SQLERRM;
         INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除BATCH_MT_REQ_HIS表记录',PIERROR);

         COMMIT;
     END;--END OF EXCEPTION
   END LOOP;

   IF TO_CHAR(SYSDATE,'DD')='01' THEN

     SELECT MIN(ID),MAX(ID) INTO PI_MININDEX,PI_MAXINDEX FROM MO_WAIT_A
     WHERE DELIVERTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     PI_CURINDEX:=PI_MININDEX;
     WHILE PI_CURINDEX<PI_MAXINDEX LOOP
       IF PI_MAXINDEX-PI_CURINDEX>=EACHMAX THEN
         PI_CURINDEX:=PI_CURINDEX+EACHMAX;
       ELSE
         PI_CURINDEX:=PI_MAXINDEX;
       END IF;
       BEGIN
         DELETE FROM MO_WAIT_A WHERE ID<=PI_CURINDEX;
         EXCEPTION WHEN OTHERS THEN
           PIERROR:=SQLERRM;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除MO_WAIT_A表记录',PIERROR);
           COMMIT;
       END;--END OF EXCEPTION
     END LOOP;

     SELECT MIN(ID),MAX(ID) INTO PI_MININDEX,PI_MAXINDEX FROM RPT_WAIT_A
     WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     PI_CURINDEX:=PI_MININDEX;
     WHILE PI_CURINDEX<PI_MAXINDEX LOOP
       IF PI_MAXINDEX-PI_CURINDEX>=EACHMAX THEN
         PI_CURINDEX:=PI_CURINDEX+EACHMAX;
       ELSE
         PI_CURINDEX:=PI_MAXINDEX;
       END IF;
       BEGIN
         DELETE FROM RPT_WAIT_A WHERE ID<=PI_CURINDEX;
         EXCEPTION WHEN OTHERS THEN
           PIERROR:=SQLERRM;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_A表记录',PIERROR);
           COMMIT;
       END;--END OF EXCEPTION
     END LOOP;

     SELECT MIN(ID),MAX(ID) INTO PI_MININDEX,PI_MAXINDEX FROM RPT_WAIT_B
     WHERE RECVTIME<TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,-1),'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS');
     PI_CURINDEX:=PI_MININDEX;
     WHILE PI_CURINDEX<PI_MAXINDEX LOOP
       IF PI_MAXINDEX-PI_CURINDEX>=EACHMAX THEN
         PI_CURINDEX:=PI_CURINDEX+EACHMAX;
       ELSE
         PI_CURINDEX:=PI_MAXINDEX;
       END IF;
       BEGIN
         DELETE FROM RPT_WAIT_B WHERE ID<=PI_CURINDEX;
         EXCEPTION WHEN OTHERS THEN
           PIERROR:=SQLERRM;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信删除RPT_WAIT_B表记录',PIERROR);
           COMMIT;
       END;--END OF EXCEPTION
     END LOOP;
   COMMIT;
   END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_H_DATATRANV2(ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  PROCESSFLAG           NUMBER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值
  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  PI_MAXINDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV2','短信汇总调度存储过程执行开始');
COMMIT;

--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 1;
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  PROCESSFLAG           := 3;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;


  --先汇总
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM GW_MT_TASK_BAK MT_TASK WHERE ( MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));

    BEGIN
      GW_H_STATISTIV2(PROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
      EXCEPTION WHEN OTHERS THEN
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV2',PIERROR);
        COMMIT;
    END;


  --再转移
  --先根据指定USEID判断是否有值
  SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
  IF (PROCESSINGSTATUSCOUNT = 0) THEN
  BEGIN
    H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END;
  ELSE
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END IF;

  --转移符合当前时间的数据
  SELECT NVL(MIN(ID),0) INTO PIMAXINDEX  FROM GW_MT_TASK_BAK MT_TASK WHERE  MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');

IF   PIMAXINDEX>0 THEN
PIMAXINDEX:=PIMAXINDEX-1;
END IF;

IF(PICURRINDEX<PIMAXINDEX)THEN
    --创建不存在的表
    SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO  MINYM,MAXYM  FROM GW_MT_TASK_BAK   WHERE  ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR)||')';
        BEGIN
          EXECUTE IMMEDIATE PISTR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
            COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      GW_H_TRANSFERV1(PI_MININDEX,PI_CURINDEX,0,0);
      GW_H_DELTASKV1(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
        ROLLBACK;--事务回滚
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
        COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('短信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_TRANSFERMO();
   GW_DELWAIT();
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS, RUNFLAG) VALUES('SMS','GW_H_DATATRANV2','短信汇总调度存储过程执行结束', 1);
      COMMIT;

END;
/

CREATE OR REPLACE PROCEDURE GW_H_DATATRANV3(ISP1 IN NUMBER,ISP2 IN NUMBER,ISP3 IN NUMBER,ISP4 IN NUMBER)
AUTHID CURRENT_USER
AS
  PRAGMA AUTONOMOUS_TRANSACTION ;
  PROCESSINGSTATUSCOUNT NUMBER; --PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
  PIUSEID                 NUMBER; --使用哪一个USEID作为当前状态处理
  PICURRINDEX             NUMBER; --当前处理位置
  PIMAXINDEX              NUMBER; --此次执行的最大位置
  COUNTSTATUS           NUMBER; --统计状态0:正常,1:错误
  DISTRACTSTATUS        NUMBER; --数据转移状态0:正常,1:错误
  DELETESTATUS          NUMBER; --删除状态0:正常,1:错误
  PROCESSFLAG           NUMBER; --转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,
  --异常退出
  COUNTEXCEPTION        NUMBER; --允许统计异常最大值
  DISTRACTEXCEPTION     NUMBER; --允许数据转移异常最大值
  DELETEEXCEPTION       NUMBER; --允许删除数据异常最大值
  ALLEXCEPTION          NUMBER; --允许所有异常最大值
  --批量转移临时变量
  PI_CURINDEX           NUMBER;
  PI_MININDEX           NUMBER;
  PI_MAXINDEX           NUMBER;
  EACHMAX               NUMBER; --每次处理最大数

  MAXYM  NUMBER;
  MINYM  NUMBER;
  CURYM  NUMBER;
  PITBNUM NUMBER;
  PITABLENAME VARCHAR2(20);
  PISTR VARCHAR2(256);
  PIERROR VARCHAR2(4000);

BEGIN
--------------------VER 3.2-------------------------------------
INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV3','短信汇总调度存储过程执行开始');
COMMIT;

--初始化
  PROCESSINGSTATUSCOUNT := 0;
  PIUSEID                 := 1;
  PICURRINDEX             := 0;
  PIMAXINDEX              := 0;
  COUNTSTATUS           := 1;
  DISTRACTSTATUS        := 1;
  DELETESTATUS          := 1;
  PROCESSFLAG           := 3;
  EACHMAX               := 500000;
  COUNTEXCEPTION        := 5;
  DISTRACTEXCEPTION     := 5;
  DELETEEXCEPTION       := 5;
  ALLEXCEPTION          := 10;


  --先汇总
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO PICURRINDEX,PIMAXINDEX  FROM GW_MT_TASK_BAK MT_TASK WHERE ( MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ') AND MT_TASK.SENDTIME < TO_DATE(TO_CHAR(SYSDATE,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS '));

    BEGIN
      GW_H_STATISTIV3(PROCESSFLAG,ISP1,ISP2,ISP3,ISP4);
      EXCEPTION WHEN OTHERS THEN
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV3',PIERROR);
        COMMIT;
    END;


  --再转移
  --先根据指定USEID判断是否有值
  SELECT COUNT(USEID) INTO PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  --如果没有先初始化PROCESSINGSTATUS,否则取当表中值
  IF (PROCESSINGSTATUSCOUNT = 0) THEN
  BEGIN
    H_PROCESSSTATUS(PIUSEID,0,0,0,0,0);
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END;
  ELSE
    SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    INTO PICURRINDEX,PIMAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS
    FROM PROCESSINGSTATUS WHERE USEID = PIUSEID;
  END IF;

  --转移符合当前时间的数据
  SELECT NVL(MIN(ID),0) INTO PIMAXINDEX  FROM GW_MT_TASK_BAK MT_TASK WHERE  MT_TASK.SENDTIME >= TO_DATE(TO_CHAR(SYSDATE-PROCESSFLAG,'YYYY-MM-DD'),'YYYY-MM-DD HH24:MI:SS ');

IF   PIMAXINDEX>0 THEN
PIMAXINDEX:=PIMAXINDEX-1;
END IF;

IF(PICURRINDEX<PIMAXINDEX)THEN
    --创建不存在的表
    SELECT CAST(TO_CHAR(MIN(SENDTIME),'YYYYMM')AS INT),CAST(TO_CHAR(MAX(SENDTIME),'YYYYMM')AS INT) INTO  MINYM,MAXYM  FROM GW_MT_TASK_BAK   WHERE  ID<=PIMAXINDEX;
    CURYM := MINYM;
    WHILE CURYM<=MAXYM LOOP
      PITABLENAME := 'MTTASK'||CAST(CURYM AS CHAR);
      PISTR:='SELECT COUNT(1) AS CNT FROM USER_TABLES T WHERE T.TABLE_NAME='''||PITABLENAME||'''';
      EXECUTE IMMEDIATE PISTR INTO PITBNUM;
      IF PITBNUM<1 THEN
        PISTR:='CALL CREATETABLE (1,'||CAST(CURYM AS CHAR)||')';
        BEGIN
          EXECUTE IMMEDIATE PISTR;
          EXCEPTION WHEN OTHERS THEN
            PIERROR:=SQLERRM;
            INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE',PIERROR);
            COMMIT;
        END;
      END IF;

      IF CAST(SUBSTR(CAST(CURYM AS CHAR),5,2) AS INT)=12 THEN
        CURYM := CAST(CAST(CAST(SUBSTR(CAST(CURYM AS CHAR),1,4)AS INT)+1 AS CHAR)||'01' AS INT);
      ELSE
        CURYM := CURYM+1;
      END IF;
    END LOOP;
    --转移数据
    IF (PIMAXINDEX-PICURRINDEX>=EACHMAX) THEN
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PI_MININDEX+EACHMAX;
    ELSE
      PI_MININDEX:=PICURRINDEX;
      PI_CURINDEX:=PIMAXINDEX;
    END IF;
    SAVEPOINT A;
    WHILE (PI_MININDEX < PIMAXINDEX) LOOP
      --跳到此处重复执行
      <<LABEL_LOCAL_ERROR>>
      BEGIN
      GW_H_TRANSFERV1(PI_MININDEX,PI_CURINDEX,0,0);
      GW_H_DELTASKV1(PI_MININDEX,PI_CURINDEX,PROCESSFLAG,0);
      H_PROCESSSTATUS(PIUSEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
      EXCEPTION WHEN OTHERS THEN
        ROLLBACK;--事务回滚
        PIERROR:=SQLERRM;
        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移',PIERROR);
        COMMIT;
      DISTRACTEXCEPTION := DISTRACTEXCEPTION - 1;
      ALLEXCEPTION      := ALLEXCEPTION - 1;
      DBMS_OUTPUT.PUT_LINE('您还有'||DISTRACTEXCEPTION||'次(数据转移)机会,共'||ALLEXCEPTION||'次机会');
      IF(DISTRACTEXCEPTION <= 0 OR ALLEXCEPTION <= 0) THEN
         --DBMS_OUTPUT.PUT_LINE('短信下行调度异常，发生回滚！');
         RETURN;
      ELSE
         GOTO LABEL_LOCAL_ERROR;
      END IF;
      END;--EXCEPTION WHEN OTHERS THEN截止
      IF (PIMAXINDEX-PI_CURINDEX>=EACHMAX) THEN
        PI_CURINDEX:=PI_CURINDEX+EACHMAX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      ELSE
        PI_CURINDEX:=PIMAXINDEX;
        PI_MININDEX:=PI_MININDEX+EACHMAX;
      END IF;
      COMMIT ;--事务提交
   END LOOP;
   END IF;
   -- 执行上行统计
   H_TRANSFERMO();
   GW_DELWAIT();
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS, RUNFLAG) VALUES('SMS','GW_H_DATATRANV3','短信汇总调度存储过程执行结束', 1);
      COMMIT;

END;
/
CREATE OR REPLACE PROCEDURE GW_LOADDATAV1
 (FLAG IN  NUMBER,INCRES IN  NUMBER,PRETIME IN NUMBER
 ) IS
 STR  VARCHAR2(5120);
 STR1  VARCHAR2(5120) ;
 STR2  VARCHAR2(5120) ;
 TBNAME  VARCHAR2(30) ;
 TBNAMEBAK VARCHAR2(30);
 STARTID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 ENDID  NUMBER(22) DEFAULT 0;

 CURMINID  NUMBER(22) DEFAULT 0;
 CURENDID  NUMBER(22) DEFAULT 0;
 COUNTID  NUMBER(22) DEFAULT 0;
 NUM  NUMBER(22) DEFAULT 0;
 TNUM  NUMBER(22) DEFAULT 0;
 ISSUCCES  NUMBER(11) DEFAULT 1;
 TRANLOGID  NUMBER(22) DEFAULT 0;

 I  NUMBER(22) DEFAULT 0;
 J  NUMBER(22) DEFAULT 0;
 TBNAMEERR VARCHAR2(30);
 CURMINID1  NUMBER(22) DEFAULT 0;
 PIERROR VARCHAR2(2000);
 PICODE NUMBER(11);
 EXCP_ORA_00001  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_00001,-00001);
 CURSOR c_cursor(FLAG NUMBER DEFAULT 1)  IS  SELECT  ID,STARTID,ENDID FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG+4 AND ISSUCCES = 0 ;
BEGIN

  SELECT  NVL(MAX(ENDID),0)  INTO STARTID  FROM GW_TRAN_DEL_LOG WHERE OPRTYPE=FLAG AND ISSUCCES = 1;  ----根据 上次成功转移的记录查找本次转移的开始id

 IF FLAG =1 THEN
  SELECT NVL(MIN(ID),0),NVL(MAX(ID),0),NVL(COUNT(ID),0) INTO  MINID,ENDID,COUNTID  FROM  MT_TASK  WHERE SENDTIME<=sysdate - PRETIME/(60*24);   ----转移十分钟前的数据
  TBNAME :='MT_TASK';
  TBNAMEBAK :='GW_MT_TASK_BAK';
  TBNAMEERR :='GW_MT_TASK_ERR';
  STR2:='( PTMSGID , "UID" , ECID , USERID , SPID , SPGATE , CPNO , PHONE , SPMSGID , RETFLAG , FEEFLAG , PKNUMBER , PKTOTAL , SENDSTATUS ,SENDFLAG , RECVFLAG , DONEDATE , ERRORCODE ,  SENDLEVEL , SENDTYPE , UNICOM , MOBILEAREA , SENDTIME , RECVTIME , MESSAGE ,  RESENDCNT , TASKID , MSGFMT , LONGMSGSEQ , TPUDHI ,  TPPID , USERMSGID ,  MODULEID ,  SVRTYPE  , P1  ,  P2 ,  P3 ,  P4 ,  RECVMTTIME ,  TRANSMTTIME , TRANSRPTTIME , SENDRPTTIME , ATTIME , VALIDTIME , BATCHID , AREACODE ,FLAGMTSDOK,FLAGRPTRVOK,FLAGRPTSDOK,MTSUBMITTIME,ERRRESENDCNT,NETERRCNT,SENDRESULT,SPGATESEND,SPNUMBER,SENDERRCODE,SUBMITDATE )';
  STR1 := '"PTMSGID","UID","ECID","USERID","SPID","SPGATE","CPNO","PHONE","SPMSGID","RETFLAG","FEEFLAG","PKNUMBER","PKTOTAL","SENDSTATUS","SENDFLAG","RECVFLAG","DONEDATE","ERRORCODE", "SENDLEVEL","SENDTYPE","UNICOM","MOBILEAREA","SENDTIME","RECVTIME","MESSAGE", "RESENDCNT","TASKID","MSGFMT","LONGMSGSEQ","TPUDHI", "TPPID","USERMSGID", "MODULEID", "SVRTYPE" ,"P1" , "P2", "P3", "P4", "RECVMTTIME", "TRANSMTTIME","TRANSRPTTIME","SENDRPTTIME","ATTIME","VALIDTIME","BATCHID","AREACODE",0 AS FLAGMTSDOK,0 AS FLAGRPTRVOK, 0 AS FLAGRPTSDOK,sysdate AS  MTSUBMITTIME,0 AS ERRRESENDCNT,0 AS NETERRCNT,1 AS SENDRESULT,'' '' AS SPGATESEND,'' '' AS SPNUMBER,'' '' AS SENDERRCODE,'' '' AS  SUBMITDATE ';
ELSE
  RETURN;
END IF;

----如果表中无数据 则退出
IF ( 0=ENDID and 0=MINID ) THEN
  RETURN;
END IF;

-----针对 前几次 删除 不成功处理   循环读出 然后删除  更新控制表
IF MINID  < STARTID+1  THEN
  FOR v_row IN c_cursor(FLAG) LOOP
   BEGIN
    STR := 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR(v_row.STARTID)||' AND '||TO_CHAR(v_row.ENDID);
      EXECUTE IMMEDIATE STR;
      PICODE:=SQLCODE;
      EXCEPTION WHEN OTHERS THEN
      ROLLBACK;
      COMMIT; END;
    IF PICODE >=0  THEN
       UPDATE GW_TRAN_DEL_LOG SET END_TIME=sysdate ,ISSUCCES=1 WHERE ID=v_row.ID;
    END IF;
   END LOOP;
   commit;
----------把此次转移的起始id重置 根据控制表上次转移成功id 重置  把上次成功转移的最大id 复制给此次转移的最小id
  MINID := STARTID+1;
END IF;

----若此次转移的最大id 等于上次成功转移的最大id 则退出
IF  ENDID=MINID-1 THEN
  RETURN;
END IF;

SELECT CEIL((ENDID-MINID+1)/INCRES) INTO TNUM  FROM DUAL;


WHILE (NUM<TNUM) LOOP
CURMINID:=MINID+NUM*INCRES;
CURENDID:=MINID+(NUM+1)*INCRES-1;

IF NUM=TNUM-1 THEN
  CURENDID:=ENDID;
END IF;

---上批循环三次还未成功 则退出循环
IF I=3 THEN
  RETURN;
 END IF;

INSERT INTO GW_TRAN_DEL_LOG(ID,OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(SEQ_GW_TRAN_DEL_LOG.NEXTVAL,FLAG,CURMINID,CURENDID,0,sysdate,sysdate); ---1   mttask  2... 3..  4...
SELECT SEQ_GW_TRAN_DEL_LOG.CURRVAL INTO TRANLOGID FROM DUAL;


--- 转移数据 循环执行3次
I:=0;
WHILE (I<3) LOOP
    BEGIN
   PIERROR:=' ';PICODE:=0;
   STR :='INSERT  INTO '||TBNAMEBAK||STR2||'  SELECT '||STR1||' FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR( CURMINID)||' AND '||TO_CHAR(CURENDID);

     EXECUTE IMMEDIATE STR;
     PIERROR:=SQLERRM; PICODE:=SQLCODE;

    EXCEPTION WHEN EXCP_ORA_00001 THEN
       CURMINID1:=CURMINID;
      WHILE (CURMINID1<=CURENDID) LOOP
        BEGIN
      STR :='INSERT  INTO '||TBNAMEBAK||STR2||'  SELECT '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
      EXECUTE IMMEDIATE STR;
        EXCEPTION WHEN EXCP_ORA_00001 THEN
          STR :='INSERT  INTO '||TBNAMEERR||' nologging  SELECT ID, '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
           EXECUTE IMMEDIATE STR;
       WHEN OTHERS THEN
           STR :='INSERT  INTO '||TBNAMEERR||' nologging   SELECT ID, '||STR1||' FROM '||TBNAME||' WHERE ID = '||TO_CHAR( CURMINID1);
           EXECUTE IMMEDIATE STR;
           INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('LOADDATA',TBNAME||'...TOEVERY...'||TBNAMEBAK,PIERROR);
       COMMIT; END;
            STR:='DELETE FROM '||TBNAME||' WHERE ID='||TO_CHAR(CURMINID1);
            EXECUTE IMMEDIATE STR;
          CURMINID1:=CURMINID1+1;
       END LOOP;-- END  WHILE (CURMINID<=CURENDID) LOOP
    WHEN OTHERS THEN
      ROLLBACK;
      PIERROR:=SQLERRM; PICODE:=SQLCODE;
      INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('LOADDATA',TBNAME||'...TO...'||TBNAMEBAK,PIERROR);

    END;

     IF PICODE >=0  THEN
        UPDATE GW_TRAN_DEL_LOG SET END_TIME= sysdate,ISSUCCES=1 WHERE ID=TRANLOGID;
        INSERT INTO GW_TRAN_DEL_LOG(ID,OPRTYPE,STARTID,ENDID,ISSUCCES,IN_TIME, END_TIME) values(SEQ_GW_TRAN_DEL_LOG.NEXTVAL,FLAG+4,CURMINID,CURENDID,0,sysdate,sysdate); ---1   mttask  2... 3..  4...
        SELECT SEQ_GW_TRAN_DEL_LOG.CURRVAL INTO TRANLOGID FROM DUAL; COMMIT;
         ------此次删除 的 控制信息
         J:=0;
        WHILE J<3 LOOP
          PICODE:=0;PIERROR:='';

            STR := 'DELETE FROM '||TBNAME||' WHERE ID BETWEEN '||TO_CHAR(CURMINID)||' AND '||TO_CHAR(CURENDID);
             BEGIN
             EXECUTE IMMEDIATE STR;
             UPDATE GW_TRAN_DEL_LOG SET END_TIME=sysdate ,ISSUCCES=1 WHERE ID=TRANLOGID;
              J :=3;
             EXCEPTION WHEN OTHERS THEN
                ROLLBACK;--事务回滚
               commit;
                J:=J+1;
             END;--EXCEPTION WHEN OTHERS THEN截止

          END LOOP;  --END WHILE J<3 LOOP
        I:=5;
      END IF;
    I:=I+1;
END LOOP;  ---END WHILE (I<3) LOOP
NUM:=NUM+1;
commit;
END LOOP;  ----END WHILE (NUM<TNUM) LOOP

END;
/
CREATE OR REPLACE PROCEDURE GW_UPPDATAMODE2(PRETIME IN NUMBER,INCRES_LOAD IN NUMBER,INCRES_UPP IN NUMBER)
AS
STARTTIME VARCHAR2(21);
MINLONG NUMBER;
I NUMBER;
BEGIN
I:=0;
WHILE (I<3) LOOP
 STARTTIME:=TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS');
 GW_LOADDATAV1(1,INCRES_LOAD,PRETIME) ;
 MINLONG:=FLOOR((SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
IF MINLONG>=PRETIME THEN
   I:=I+1;
ELSE
   GW_UPPMTSDOK(PRETIME,INCRES_UPP,STARTTIME);
    MINLONG:= FLOOR((SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
   IF MINLONG>=PRETIME THEN
   I:=I+1;
   ELSE
     GW_UPPRPTRVOK(PRETIME,INCRES_UPP,STARTTIME);
      MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:mi:ss'))*24*60);
      IF MINLONG>=PRETIME THEN
         I:=I+1;
     ELSE
           GW_UPPRPTSDOK(PRETIME,INCRES_UPP,STARTTIME);
           MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:mi:ss'))*24*60);
            IF MINLONG>=PRETIME THEN
              I:=I+1;
            ELSE
               I:=5;
            END IF;
     END IF;
  END IF;
END IF;
END LOOP;
END;
/
--PROMPT
--PROMPT CREATING PROCEDURE GW_WR_MTTASKV1
--PROMPT ==============================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_WR_MTTASKV1
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PISPLITLEN_P   IN NUMBER,
    PIMULTILEN1_P  IN NUMBER,
    PIMULTILEN2_P  IN NUMBER,
    PISIGNLEN_P    IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1      IN VARCHAR2,
    PIP2      IN VARCHAR2,
    PIP3      IN VARCHAR2,
    PIP4      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0
 )
AS
--临时变量
PITMPMSGID NUMBER(22,0);
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR(21);
PISTRSPLIT VARCHAR(2);
PILEN PLS_INTEGER;
PIRESULTMSG VARCHAR(720);
PIPKNUM PLS_INTEGER;
PITMPNUM PLS_INTEGER;
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIRECVMTTIME_P TIMESTAMP(6);
PIPTMSGID_P NUMBER(22,0);

PISPLITLEN PLS_INTEGER;
PIMULTILEN1 PLS_INTEGER;
PIMULTILEN2 PLS_INTEGER;
PISIGNLEN PLS_INTEGER;

BEGIN
--变量赋值
PILEN := LENGTH(PIMESSAGE)-PISIGNLEN_P;
PITMPNUM := 0;
PIPKNUM := 1;
PISTRSPLIT := ',';
PISHOUJI_P :=PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;


IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
--清空临时表,如果临时表不存在直接返回不处理
/*SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASK');
IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASK';
ELSE
  RETURN;
END IF;
*/
--验证手机号合法性
IF (PISHOUJI_P IS NULL) THEN
  PISHOUJI_P := ' ';
END IF;
IF /*(PISHOUJI_P IS NULL) OR */(PIPHONECOUNT < 1) THEN
   RETURN;
END IF;

--变量赋值
IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
  PISPLITLEN:=140;
  PIMULTILEN1:=134;
  PIMULTILEN2:=134;
  PISIGNLEN:=0;
ELSE
  PISPLITLEN  :=PISPLITLEN_P;
  PIMULTILEN1 :=PIMULTILEN1_P;
  PIMULTILEN2 :=PIMULTILEN2_P;
  PISIGNLEN   :=PISIGNLEN_P;
END IF;
IF PIMSGFMT=25 THEN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
    RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
    UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
    PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
    PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
  RETURN;
END IF;
IF PIPHONECOUNT = 1 --单发
THEN
 SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  --IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
  IF ICOUNT<1 THEN
    IF PIPKTOTAL = 1 THEN
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
      PIRETFLAG,PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
      PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
    ELSE
      PIPKNUM := 1;
      PITMPMSGID := PIPTMSGID_P;
      IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
        PIRESULTMSG := SUBSTR(PIMESSAGE,1,PISPLITLEN);
        PITMPMSGID := PITMPMSGID;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID, PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
        PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
        PITMPMSGID := PITMPMSGID+17179869184;
        PIPKNUM := PIPKNUM+1;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
      ELSE
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          IF PIPKNUM = PIPKTOTAL THEN
             PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
             PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSIF PIPKNUM = PIPKTOTAL-1 THEN
            IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
               PITMPNUM := PILEN-1;
               --DBMS_OUTPUT.PUT_LINE('123');
            ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
               PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
               --DBMS_OUTPUT.PUT_LINE('456');
            END IF;
            PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
               --DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
          END IF;
          ICOUNT:=0;
          SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
          IF ICOUNT<1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
            PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
          --EXECUTE IMMEDIATE STR;
          PIPKNUM := PIPKNUM+1;
        END LOOP;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
      END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
      A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASK A;
      COMMIT;
    END IF;--END IF OF IF PIPKTOTAL = 1
  --ELSE  --MSGID存在是写入MSGIDTEST表
  --  INSERT INTO MSGIDTEST(MSGID) VALUES(PIPTMSGID);
  END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID_P)
ELSE --群发
    PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  IF PIPKTOTAL < 1 THEN--没有短信内容
    RETURN;
  END IF;

  IF PIPKTOTAL >= 1 --需要拆分长短信
  THEN
    WHILE PILOCATION <> 0 LOOP--拆分手机号码
        PISTART := PILOCATION;
        PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
      IF PILOCATION > 0 THEN
        PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);--拆分后的字符
        IF (PIRESULTPHONE IS NULL) THEN
          PIRESULTPHONE := ' ';
        END IF;
        PITMPMSGID := PIPTMSGID_P;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          IF PIPKTOTAL = 1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIMESSAGE,PISENDSTATUS,
            PIRETFLAG, PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          ELSE
            PIPKNUM := 1;
            IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
              PIRESULTMSG := SUBSTR(PIMESSAGE,1, PISPLITLEN);--拆分后的字符
              PITMPMSGID := PITMPMSGID;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID, PISPGATE,PICPNO,PIRESULTPHONE, PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG, PIPKNUM, PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF;
              PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
              PITMPMSGID := PITMPMSGID+17179869184;
              PIPKNUM := PIPKNUM+1;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
            ELSE
              WHILE PIPKNUM <= PIPKTOTAL LOOP--PIPKNUM:1    PIPKTOTAL 2
                IF PIPKNUM = PIPKTOTAL THEN
                  PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSIF PIPKNUM = PIPKTOTAL-1 THEN
                  IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
                    PITMPNUM := PILEN-1;
                  ELSE
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                    PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
                     ----第一条
                  END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSE
                  PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
                ICOUNT:=0;
                SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
                IF ICOUNT<1 THEN
                  INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                  RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                  PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                  PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
                END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
                PIPKNUM := PIPKNUM+1;
              END LOOP;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
            END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
          END  IF;--END IF OF IF PIPKTOTAL = 1
        END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
        PIPTMSGID_P := PIPTMSGID_P+1;
      END  IF; --END IF OF IF PILOCATION > 0
    END LOOP; --END WHILE OF WHILE PILOCATION <> 0
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
      A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASK A;
      COMMIT;
   END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --单发
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKV2
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PISPLITLEN_P   IN NUMBER,
    PIMULTILEN1_P  IN NUMBER,
    PIMULTILEN2_P  IN NUMBER,
    PISIGNLEN_P    IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1      IN VARCHAR2,
    PIP2      IN VARCHAR2,
    PIP3      IN VARCHAR2,
    PIP4      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2
 )
AS
--临时变量
PITMPMSGID NUMBER(22,0);
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR(21);
PISTRSPLIT VARCHAR(2);
PILEN PLS_INTEGER;
PIRESULTMSG VARCHAR(720);
PIPKNUM PLS_INTEGER;
PITMPNUM PLS_INTEGER;
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIRECVMTTIME_P TIMESTAMP(6);
PIPTMSGID_P NUMBER(22,0);

PISPLITLEN PLS_INTEGER;
PIMULTILEN1 PLS_INTEGER;
PIMULTILEN2 PLS_INTEGER;
PISIGNLEN PLS_INTEGER;

BEGIN
--变量赋值
PILEN := LENGTH(PIMESSAGE)-PISIGNLEN_P;
PITMPNUM := 0;
PIPKNUM := 1;
PISTRSPLIT := ',';
PISHOUJI_P :=PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;


IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
--清空临时表,如果临时表不存在直接返回不处理
/*SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASK');
IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASK';
ELSE
  RETURN;
END IF;
*/
--验证手机号合法性
IF (PISHOUJI_P IS NULL) THEN
  PISHOUJI_P := ' ';
END IF;
IF /*(PISHOUJI_P IS NULL) OR */(PIPHONECOUNT < 1) THEN
   RETURN;
END IF;

--变量赋值
IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
  PISPLITLEN:=140;
  PIMULTILEN1:=134;
  PIMULTILEN2:=134;
  PISIGNLEN:=0;
ELSE
  PISPLITLEN  :=PISPLITLEN_P;
  PIMULTILEN1 :=PIMULTILEN1_P;
  PIMULTILEN2 :=PIMULTILEN2_P;
  PISIGNLEN   :=PISIGNLEN_P;
END IF;
IF PIMSGFMT=25 THEN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
    RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
    UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
    PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
    PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
  RETURN;
END IF;
IF PIPHONECOUNT = 1 --单发
THEN
 SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  --IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
  IF ICOUNT<1 THEN
    IF PIPKTOTAL = 1 THEN
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
      PIRETFLAG,PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
      PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
    ELSE
      PIPKNUM := 1;
      PITMPMSGID := PIPTMSGID_P;
      IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
        PIRESULTMSG := SUBSTR(PIMESSAGE,1,PISPLITLEN);
        PITMPMSGID := PITMPMSGID;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID, PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
        PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
        PITMPMSGID := PITMPMSGID+17179869184;
        PIPKNUM := PIPKNUM+1;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
      ELSE
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          IF PIPKNUM = PIPKTOTAL THEN
             PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
             PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSIF PIPKNUM = PIPKTOTAL-1 THEN
            IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
               PITMPNUM := PILEN-1;
               --DBMS_OUTPUT.PUT_LINE('123');
            ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
               PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
               --DBMS_OUTPUT.PUT_LINE('456');
            END IF;
            PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
               --DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
          END IF;
          ICOUNT:=0;
          SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
          IF ICOUNT<1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
            PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
          --EXECUTE IMMEDIATE STR;
          PIPKNUM := PIPKNUM+1;
        END LOOP;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
      END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
      A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM TMP_MTTASK A;
      COMMIT;
    END IF;--END IF OF IF PIPKTOTAL = 1
  --ELSE  --MSGID存在是写入MSGIDTEST表
  --  INSERT INTO MSGIDTEST(MSGID) VALUES(PIPTMSGID);
  END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID_P)
ELSE --群发
    PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  IF PIPKTOTAL < 1 THEN--没有短信内容
    RETURN;
  END IF;

  IF PIPKTOTAL >= 1 --需要拆分长短信
  THEN
    WHILE PILOCATION <> 0 LOOP--拆分手机号码
        PISTART := PILOCATION;
        PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
      IF PILOCATION > 0 THEN
        PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);--拆分后的字符
        IF (PIRESULTPHONE IS NULL) THEN
          PIRESULTPHONE := ' ';
        END IF;
        PITMPMSGID := PIPTMSGID_P;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          IF PIPKTOTAL = 1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIMESSAGE,PISENDSTATUS,
            PIRETFLAG, PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          ELSE
            PIPKNUM := 1;
            IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
              PIRESULTMSG := SUBSTR(PIMESSAGE,1, PISPLITLEN);--拆分后的字符
              PITMPMSGID := PITMPMSGID;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID, PISPGATE,PICPNO,PIRESULTPHONE, PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG, PIPKNUM, PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF;
              PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
              PITMPMSGID := PITMPMSGID+17179869184;
              PIPKNUM := PIPKNUM+1;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
            ELSE
              WHILE PIPKNUM <= PIPKTOTAL LOOP--PIPKNUM:1    PIPKTOTAL 2
                IF PIPKNUM = PIPKTOTAL THEN
                  PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSIF PIPKNUM = PIPKTOTAL-1 THEN
                  IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
                    PITMPNUM := PILEN-1;
                  ELSE
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                    PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
                     ----第一条
                  END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSE
                  PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
                ICOUNT:=0;
                SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
                IF ICOUNT<1 THEN
                  INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                  RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                  PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                  PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
                END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
                PIPKNUM := PIPKNUM+1;
              END LOOP;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
            END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
          END  IF;--END IF OF IF PIPKTOTAL = 1
        END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
        PIPTMSGID_P := PIPTMSGID_P+1;
      END  IF; --END IF OF IF PILOCATION > 0
    END LOOP; --END WHILE OF WHILE PILOCATION <> 0
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
      A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM TMP_MTTASK A;
      COMMIT;
   END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --单发
END;

/

--PROMPT
--PROMPT CREATING PROCEDURE S_WR_MTTASKSR
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_WR_MTTASKSRV1
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1           IN VARCHAR2,
    PIP2           IN VARCHAR2,
    PIP3           IN VARCHAR2,
    PIP4           IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0
 )
AS
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR2(21);
PISTRSPLIT VARCHAR2(2);
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIPTMSGID_P NUMBER(22,0);

BEGIN

PISTRSPLIT := ',';
PISHOUJI_P := PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;

IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
/*
SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASKSR');
IF ICOUNT>0 THEN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
ELSE
  RETURN;
END IF;
*/
IF (PISHOUJI_P IS NULL) THEN
   PISHOUJI_P := ' ';
END IF;
IF (PIPHONECOUNT < 1) THEN--手机号码为空
  RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--单发
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
    RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
    MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
    VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI_P, PIPTMSGID_P, PIMESSAGE,PISENDSTATUS,
    PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
    PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,
    PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
  END IF;
ELSE --群发
  PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
  PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
    IF PILOCATION > 0 THEN
      PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);
      IF (PIRESULTPHONE IS NULL) THEN
        PIRESULTPHONE := ' ';
      END IF;
      ICOUNT:=0;
      SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;

      IF ICOUNT<1 THEN
        INSERT INTO TMP_MTTASKSR("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
        RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
        MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
        VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PIPTMSGID_P,PIMESSAGE,PISENDSTATUS,PIRETFLAG,
        PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,
        PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
      END IF;
      PIPTMSGID_P := PIPTMSGID_P+1;
    END IF;
  END LOOP;
  INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS, RETFLAG,
  PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE)
  SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
  A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
  A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE FROM TMP_MTTASKSR A;
  COMMIT;
END IF;
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKSRV2
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1           IN VARCHAR2,
    PIP2           IN VARCHAR2,
    PIP3           IN VARCHAR2,
    PIP4           IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2
 )
AS
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR2(21);
PISTRSPLIT VARCHAR2(2);
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIPTMSGID_P NUMBER(22,0);

BEGIN

PISTRSPLIT := ',';
PISHOUJI_P := PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;

IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
/*
SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASKSR');
IF ICOUNT>0 THEN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
ELSE
  RETURN;
END IF;
*/
IF (PISHOUJI_P IS NULL) THEN
   PISHOUJI_P := ' ';
END IF;
IF (PIPHONECOUNT < 1) THEN--手机号码为空
  RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--单发
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
    RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
    MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
    VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI_P, PIPTMSGID_P, PIMESSAGE,PISENDSTATUS,
    PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
    PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,
    PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
  END IF;
ELSE --群发
  PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
  PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
    IF PILOCATION > 0 THEN
      PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);
      IF (PIRESULTPHONE IS NULL) THEN
        PIRESULTPHONE := ' ';
      END IF;
      ICOUNT:=0;
      SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;

      IF ICOUNT<1 THEN
        INSERT INTO TMP_MTTASKSR("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
        RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
        MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
        VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PIPTMSGID_P,PIMESSAGE,PISENDSTATUS,PIRETFLAG,
        PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,
        PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
      END IF;
      PIPTMSGID_P := PIPTMSGID_P+1;
    END IF;
  END LOOP;
  INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS, RETFLAG,
  PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
  SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
  A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
  A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA FROM TMP_MTTASKSR A;
  COMMIT;
END IF;
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
END;
/


--PROMPT
--PROMPT CREATING PROCEDURE GW_MTTASKSUPPV3
--PROMPT ================================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_MTTASKSUPPV3
(
  PIOLDMSGID IN NUMBER,
  PINEWMSGID  IN NUMBER,
  PISRCUID  IN NUMBER,
  PISRCUSRID  IN VARCHAR2,
  PISRCSPGATE  IN VARCHAR2,
  PISRCSPNUMBER IN  VARCHAR2,
  PIDESTUID  IN NUMBER,
  PIDESTUSRID  IN VARCHAR2,
  PIDESTSPGATE  IN VARCHAR2,
  PIDESTSPNUMBER  IN VARCHAR2,
  PIDESTFEEFLAG  IN NUMBER,
  PISPLITLEN  IN NUMBER,
  PIMULTILEN1  IN NUMBER,
  PIMULTILEN2  IN NUMBER,
  PINEWSIGNLEN  IN NUMBER,
  PIOLDSIGNLEN  IN NUMBER,
  PISIGNATURE  IN VARCHAR2,
  PINEWSIGNPOS IN NUMBER,
  PIOLDSIGNPOS IN NUMBER,
  PIENSPLITLEN IN NUMBER, --英文短信单条长度，小于等于0标识不支持英文短信
  PIENMULTILEN1  IN NUMBER, --英文长短信拆分长度
  PIENMULTILEN2  IN NUMBER, --英文长短信最后一条长度
  PINEWENSIGNLEN  IN NUMBER, --补发英文签名长度
  PIOLDENSIGNLEN  IN NUMBER, --原英文签名长度
  PIENSIGNATURE  IN VARCHAR2, --英文签名
  PIRECVMTTIME  IN VARCHAR2,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISENDNUM NUMBER(11);
  PIPKTOTAL NUMBER(11);
  PIPKNUM   NUMBER(11);
  PIINITMSGID NUMBER(22);
  PISINGLEMSG VARCHAR2(720);
  PISINGLEMSG1 VARCHAR2(720);
  PILONGMSG VARCHAR2(3000);
  PITOTALCNT NUMBER(11);
  PILONGMSGLEN NUMBER(11);
  PIECID NUMBER(11);
  PIPHONE VARCHAR2(21);
  PISENDLEVEL NUMBER(11);
  PITASKID NUMBER(11);
  --PIRECVMTTIME TIMESTAMP;
  PISRCCPNO  VARCHAR2(21);
  PIDESTCPNO VARCHAR2(21);
  PITPUDHI NUMBER(11);
  PITPPID NUMBER(11);
  PILONGMSGSEQ NUMBER(11);
  PIMSGFMT NUMBER(11);
  PIUNICOM NUMBER(11);
  PIMOBILEAREA NUMBER(11);
  PISVRTYPE VARCHAR2(64);
  PIUSERMSGID NUMBER(22);
  PISENDTYPE NUMBER(11);
  PIP1 VARCHAR2(64);
  PIP2 VARCHAR2(64);
  PIP3 VARCHAR2(64);
  PIP4 VARCHAR2(64);
  PIMODULEID NUMBER(11);
  PIATTIME NUMBER(22);
  PIVALIDTIME NUMBER(22);
  PIBATCHID NUMBER(22);
  PIAREACODE NUMBER(11);
  ICOUNT NUMBER(11);
  PITEMPCNT1 NUMBER(11);
  PITEMPCNT2 NUMBER(11);

  PISPLITLEN_V NUMBER(11);
  PIMULTILEN1_V  NUMBER(11);
  PIMULTILEN2_V  NUMBER(11);
  PINEWSIGNLEN_V  NUMBER(11);
  PIOLDSIGNLEN_V  NUMBER(11);
  PISIGNATURE_V  VARCHAR2(22);
  PIPTMSGID_P  NUMBER(22);
BEGIN

  /*--检查查临时表是否存在,如果存在则清空,不存在直接返回
  SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_RDMTTASK');
  IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';
  ELSE
    RETURN;
  END IF;
  */
  PILONGMSG:='';
  --PIRECVMTTIME:= SYSTIMESTAMP;
  PISRCCPNO:= SUBSTR(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE));
  PIDESTCPNO:= NVL(SUBSTR(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE)), ' ');
   --取补发帐号的费用
  --SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=PIDESTUSRID;

  --每次调用存储过程时候，先清空TMP_RDMTTASK会话级别的临时表
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';

  --该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1<=0 THEN
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE
  FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);
  END IF;

  DELETE FROM TMP_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
  PITEMPCNT2:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1 - PITEMPCNT2>0 THEN
    SELECT PKTOTAL,PKNUMBER,ECID,PHONE,SENDLEVEL,
        TASKID,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
        MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
        SENDTYPE,P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE  INTO
        PIPKTOTAL,PIPKNUM,PIECID,PIPHONE,PISENDLEVEL,
        PITASKID,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
        PIMOBILEAREA,PISVRTYPE,PITPPID,PIUSERMSGID,
        PISENDTYPE,PIP1,PIP2,PIP3,PIP4,PIMODULEID,PIATTIME,PIVALIDTIME,PIBATCHID,PIAREACODE
    FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       PIOLDSIGNLEN_V:=PIOLDENSIGNLEN;
     ELSE
       PIOLDSIGNLEN_V:=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       PISPLITLEN_V:=PIENSPLITLEN;
       PIMULTILEN1_V:=PIENMULTILEN1;
       PIMULTILEN2_V:=PIENMULTILEN2;
       PINEWSIGNLEN_V:=PINEWENSIGNLEN;
       PISIGNATURE_V:=PIENSIGNATURE;
     ELSE
       PISPLITLEN_V:=PISPLITLEN;
       PIMULTILEN1_V:=PIMULTILEN1;
       PIMULTILEN2_V:=PIMULTILEN2;
       PINEWSIGNLEN_V:=PINEWSIGNLEN;
       PISIGNATURE_V:=PISIGNATURE;
     END IF;

     if (0 = PINEWSIGNLEN_V) THEN
       PISIGNATURE_V:='';
     END IF;

     IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN--对于非长短信补发的处理
        PILONGMSG:='';
        --取短信内容
        SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
        --更新替换MSGID
        UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V; --减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          GW_WR_MTTASKV1(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
        PIPKNUM:=1;
    /*
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN--对标准协议长短信的补发
      PILONGMSG:='';
      --取短信内容
      SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
      --更新替换MSGID
      UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
      IF (PIPKTOTAL=PIPKNUM)THEN ---如果是最后一条，去掉旧签名，加上新签名
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN; --减去签名的净长度
        PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        PILONGMSG := PILONGMSG||PISIGNATURE;
      END IF;
      PILONGMSGLEN := LENGTH(PILONGMSG);
      IF PILONGMSGLEN > 0 THEN
        --调用插入存储过程
        GW_WR_MTTASKSRV1(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
                PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
                PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
      ELSE
        PILONGMSG:='';
      END IF;--END OF IF PILONGMSGLEN > 0
    */
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0)THEN--对非标准长短信协议的处理
      PILONGMSG:=' ';
      --没有补发过且通道号跟源通道号相等
      SELECT COUNT(*) INTO ICOUNT FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND TRIM(SPGATE)=PISRCSPGATE;
      IF ICOUNT>0 THEN
        --循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
        --计算起始MSGID
        PIINITMSGID := PIOLDMSGID-(PIPKNUM-1)*17179869184;
        PIPKNUM := 1;
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          --取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
          BEGIN
          SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          exception
            when no_data_found then
              PISINGLEMSG := ' ';
          end;
          IF PISINGLEMSG = ' ' THEN
            --拼接短信内容
            BEGIN
            SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                PISINGLEMSG1:=' ';
            END;
            IF NVL(LENGTH(LTRIM(PISINGLEMSG1)),0)>0 THEN
             --更新替换MSGID
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG1,' ');
            UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            END IF;--IF LENGTH(PISINGLEMSG1)>0 THEN
          ELSE
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG,' ');
            UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          END IF;
            --拼接短信内容
           PIPKNUM := PIPKNUM+1;
        END LOOP;--END OF WHILE PIPKNUM <= PIPKTOTAL
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V ;--减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          GW_WR_MTTASKV1(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
          PIPKNUM:=1;
      END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM PITMP WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND (TRIM(SPGATE)+TRIM(CPNO))=PISRCSPNUMBER)
    END  IF;--END OF IF PIPKTOTAL > 1
  END IF;--END OF IF PIPIROWCOUNT<>0
  --返回给上层数据
  PIPTMSGID_P:=PINEWMSGID;
  UPDATE TMP_RDMTTASK SET PTNEWMSGID=PIPTMSGID_P WHERE PTMSGID=PIOLDMSGID;

  OPEN OUT_CURSOR FOR
  SELECT "UID",PTNEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
  PIDESTCPNO AS CPNO,PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,1 AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
  SENDSTATUS,1 AS SENDLEVEL,
  PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,
  ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE FROM TMP_RDMTTASK WHERE (PILONGMSG IS NOT NULL);
END;
/
CREATE OR REPLACE PROCEDURE GW_MTTASKSUPPV4
(
  PIOLDMSGID IN NUMBER,
  PINEWMSGID  IN NUMBER,
  PISRCUID  IN NUMBER,
  PISRCUSRID  IN VARCHAR2,
  PISRCSPGATE  IN VARCHAR2,
  PISRCSPNUMBER IN  VARCHAR2,
  PIDESTUID  IN NUMBER,
  PIDESTUSRID  IN VARCHAR2,
  PIDESTSPGATE  IN VARCHAR2,
  PIDESTSPNUMBER  IN VARCHAR2,
  PIDESTFEEFLAG  IN NUMBER,
  PISPLITLEN  IN NUMBER,
  PIMULTILEN1  IN NUMBER,
  PIMULTILEN2  IN NUMBER,
  PINEWSIGNLEN  IN NUMBER,
  PIOLDSIGNLEN  IN NUMBER,
  PISIGNATURE  IN VARCHAR2,
  PINEWSIGNPOS IN NUMBER,
  PIOLDSIGNPOS IN NUMBER,
  PIENSPLITLEN IN NUMBER, --英文短信单条长度，小于等于0标识不支持英文短信
  PIENMULTILEN1  IN NUMBER, --英文长短信拆分长度
  PIENMULTILEN2  IN NUMBER, --英文长短信最后一条长度
  PINEWENSIGNLEN  IN NUMBER, --补发英文签名长度
  PIOLDENSIGNLEN  IN NUMBER, --原英文签名长度
  PIENSIGNATURE  IN VARCHAR2, --英文签名
  PIRECVMTTIME  IN VARCHAR2,
  OUT_CURSOR      OUT SYS_REFCURSOR
  )
AS
  PISENDNUM NUMBER(11);
  PIPKTOTAL NUMBER(11);
  PIPKNUM   NUMBER(11);
  PIINITMSGID NUMBER(22);
  PISINGLEMSG VARCHAR2(720);
  PISINGLEMSG1 VARCHAR2(720);
  PILONGMSG VARCHAR2(3000);
  PITOTALCNT NUMBER(11);
  PILONGMSGLEN NUMBER(11);
  PIECID NUMBER(11);
  PIPHONE VARCHAR2(21);
  PISENDLEVEL NUMBER(11);
  PITASKID NUMBER(11);
  --PIRECVMTTIME TIMESTAMP;
  PISRCCPNO  VARCHAR2(21);
  PIDESTCPNO VARCHAR2(21);
  PITPUDHI NUMBER(11);
  PITPPID NUMBER(11);
  PILONGMSGSEQ NUMBER(11);
  PIMSGFMT NUMBER(11);
  PIUNICOM NUMBER(11);
  PIMOBILEAREA NUMBER(11);
  PISVRTYPE VARCHAR2(64);
  PIUSERMSGID NUMBER(22);
  PISENDTYPE NUMBER(11);
  PIP1 VARCHAR2(64);
  PIP2 VARCHAR2(64);
  PIP3 VARCHAR2(64);
  PIP4 VARCHAR2(64);
  PIMODULEID NUMBER(11);
  PIATTIME NUMBER(22);
  PIVALIDTIME NUMBER(22);
  PIBATCHID NUMBER(22);
  PIAREACODE NUMBER(11);
  PICUSTID VARCHAR2(64);
  PIEXDATA VARCHAR2(64);

  ICOUNT NUMBER(11);
  PITEMPCNT1 NUMBER(11);
  PITEMPCNT2 NUMBER(11);

  PISPLITLEN_V NUMBER(11);
  PIMULTILEN1_V  NUMBER(11);
  PIMULTILEN2_V  NUMBER(11);
  PINEWSIGNLEN_V  NUMBER(11);
  PIOLDSIGNLEN_V  NUMBER(11);
  PISIGNATURE_V  VARCHAR2(60);
  PIPTMSGID_P  NUMBER(22);
BEGIN

  /*--检查查临时表是否存在,如果存在则清空,不存在直接返回
  SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_RDMTTASK');
  IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';
  ELSE
    RETURN;
  END IF;
  */
  PILONGMSG:='';
  --PIRECVMTTIME:= SYSTIMESTAMP;
  PISRCCPNO:= SUBSTR(PISRCSPNUMBER,LENGTH(PISRCSPGATE)+1,LENGTH(PISRCSPNUMBER)-LENGTH(PISRCSPGATE));
  PIDESTCPNO:= NVL(SUBSTR(PIDESTSPNUMBER,LENGTH(PIDESTSPGATE)+1,LENGTH(PIDESTSPNUMBER)-LENGTH(PIDESTSPGATE)), ' ');
   --取补发帐号的费用
  --SELECT SENDNUM INTO PISENDNUM FROM USERFEE WHERE USERID=PIDESTUSRID;

  --每次调用存储过程时候，先清空TMP_RDMTTASK会话级别的临时表
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_RDMTTASK';

  --该模式可以把原始MSGID返给用户--用旧的MSGID复制一份记录插入临时表
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
  FROM GW_MT_TASK_BAK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1<=0 THEN
  INSERT INTO TMP_RDMTTASK("UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
  SELECT "UID",PTMSGID,ECID,TASKID,USERID,SPGATE,CPNO,PHONE,
  SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,2,SENDFLAG,RECVFLAG,
  DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,RESENDCNT,RECVMTTIME,RECVTIME,
  MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
  P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,'',''
  FROM MT_TASK WHERE PTMSGID=PIOLDMSGID AND USERID=PISRCUSRID AND MSGFMT IN (0,8,15) AND RESENDCNT<1 AND INSTR(TRIM(SPGATE)||TRIM(CPNO),PISRCSPNUMBER)=1 ;
  PITEMPCNT1:=NVL(SQL%ROWCOUNT,0);
  END IF;

  DELETE FROM TMP_RDMTTASK WHERE UNICOM=5 AND MSGFMT=0;
  PITEMPCNT2:=NVL(SQL%ROWCOUNT,0);

  IF PITEMPCNT1 - PITEMPCNT2>0 THEN
    SELECT PKTOTAL,PKNUMBER,ECID,PHONE,SENDLEVEL,
        TASKID,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
        MOBILEAREA,SVRTYPE,TPPID,USERMSGID,
        SENDTYPE,P1,P2,P3,P4,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA  INTO
        PIPKTOTAL,PIPKNUM,PIECID,PIPHONE,PISENDLEVEL,
        PITASKID,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
        PIMOBILEAREA,PISVRTYPE,PITPPID,PIUSERMSGID,
        PISENDTYPE,PIP1,PIP2,PIP3,PIP4,PIMODULEID,PIATTIME,PIVALIDTIME,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA
    FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
    --如果原信息内容编码为0且英文签名长度大于等于0 按英文短信处理
     IF (0 = PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
       PIOLDSIGNLEN_V:=PIOLDENSIGNLEN;
     ELSE
       PIOLDSIGNLEN_V:=PIOLDSIGNLEN;
     END IF; --IF (0 == PIMSGFMT AND 0 <= PIOLDENSIGNLEN) THEN
     --如果原信息内容编码为0且补发路由单条长度大于0表示支持英文短信
     IF (0 = PIMSGFMT AND 0 < PIENSPLITLEN) THEN
       PISPLITLEN_V:=PIENSPLITLEN;
       PIMULTILEN1_V:=PIENMULTILEN1;
       PIMULTILEN2_V:=PIENMULTILEN2;
       PINEWSIGNLEN_V:=PINEWENSIGNLEN;
       PISIGNATURE_V:=PIENSIGNATURE;
     ELSE
       PISPLITLEN_V:=PISPLITLEN;
       PIMULTILEN1_V:=PIMULTILEN1;
       PIMULTILEN2_V:=PIMULTILEN2;
       PINEWSIGNLEN_V:=PINEWSIGNLEN;
       PISIGNATURE_V:=PISIGNATURE;
     END IF;

     if (0 = PINEWSIGNLEN_V) THEN
       PISIGNATURE_V:='';
     END IF;

     IF (PIPKTOTAL <= 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2)) THEN--对于非长短信补发的处理
        PILONGMSG:='';
        --取短信内容
        SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
        --更新替换MSGID
        UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V; --减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          GW_WR_MTTASKV2(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
        PIPKNUM:=1;
    /*
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=1) THEN--对标准协议长短信的补发
      PILONGMSG:='';
      --取短信内容
      SELECT MESSAGE INTO PILONGMSG FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID;
      --更新替换MSGID
      UPDATE MT_TASK SET PTMSGID=PINEWMSGID,RESENDCNT=1 WHERE PTMSGID=PIOLDMSGID;
      IF (PIPKTOTAL=PIPKNUM)THEN ---如果是最后一条，去掉旧签名，加上新签名
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN; --减去签名的净长度
        PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        PILONGMSG := PILONGMSG||PISIGNATURE;
      END IF;
      PILONGMSGLEN := LENGTH(PILONGMSG);
      IF PILONGMSGLEN > 0 THEN
        --调用插入存储过程
        GW_WR_MTTASKSRV2(PIDESTUID,PIOLDMSGID,2,1,PIPKTOTAL,1,PIECID,
                PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,TO_CHAR(PIRECVMTTIME, 'YYYY-MM-DD HH24:MI:SS'),PILONGMSG,
                PIPHONE,PIDESTFEEFLAG,PIPKNUM,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,
                PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
      ELSE
        PILONGMSG:='';
      END IF;--END OF IF PILONGMSGLEN > 0
    */
    ELSIF (PIPKTOTAL > 1 AND ((PIPKTOTAL <= PISENDNUM AND PIDESTFEEFLAG=1) OR PIDESTFEEFLAG=2) AND PITPUDHI=0)THEN--对非标准长短信协议的处理
      PILONGMSG:=' ';
      --没有补发过且通道号跟源通道号相等
      SELECT COUNT(*) INTO ICOUNT FROM TMP_RDMTTASK WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND TRIM(SPGATE)=PISRCSPGATE;
      IF ICOUNT>0 THEN
        --循环处理旧的几条短信，并且用新的MSGID更新旧的MSGID,然后调用存储过程用旧的MSGID生成新的几条短信，并返回旧的MSGID
        --计算起始MSGID
        PIINITMSGID := PIOLDMSGID-(PIPKNUM-1)*17179869184;
        PIPKNUM := 1;
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          --取短信内容 --若长短信中间的某条缺失，则不补发(暂不考虑)
          BEGIN
          SELECT MESSAGE INTO PISINGLEMSG FROM GW_MT_TASK_BAK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          exception
            when no_data_found then
              PISINGLEMSG := ' ';
          end;
          IF PISINGLEMSG = ' ' THEN
            --拼接短信内容
            BEGIN
            SELECT MESSAGE INTO PISINGLEMSG1 FROM MT_TASK WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                PISINGLEMSG1:=' ';
            END;
            IF NVL(LENGTH(LTRIM(PISINGLEMSG1)),0)>0 THEN
             --更新替换MSGID
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG1,' ');
            UPDATE MT_TASK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
            END IF;--IF LENGTH(PISINGLEMSG1)>0 THEN
          ELSE
            PILONGMSG := NVL(PILONGMSG,' ')||NVL(PISINGLEMSG,' ');
            UPDATE GW_MT_TASK_BAK SET RESENDCNT=1 WHERE PTMSGID=PIINITMSGID+(PIPKNUM-1)*17179869184;
          END IF;
            --拼接短信内容
           PIPKNUM := PIPKNUM+1;
        END LOOP;--END OF WHILE PIPKNUM <= PIPKTOTAL
        PILONGMSGLEN := LENGTH(PILONGMSG)-PIOLDSIGNLEN_V ;--减去签名的净长度

        IF PIOLDSIGNPOS=0 THEN--去掉原短信的签名
          PILONGMSG:=SUBSTR(PILONGMSG,1,PILONGMSGLEN);
        ELSE
          PILONGMSG:=SUBSTR(PILONGMSG,1+PIOLDSIGNLEN_V,PILONGMSGLEN);
        END IF;

        PILONGMSGLEN := LENGTH(PILONGMSG);
        IF PILONGMSGLEN > 0 THEN
          --计算拆分条数
          IF PILONGMSGLEN<=PISPLITLEN_V THEN
          PIPKTOTAL:=1;
          ELSE
          PIPKTOTAL:=TRUNC(1+(PILONGMSGLEN-PIMULTILEN2_V+PIMULTILEN1_V-1)/(PIMULTILEN1_V));
          END IF;--END OF IF PILONGMSGLEN<=PISPLITLEN

          IF PINEWSIGNPOS=0 THEN--增加新的签名
            PILONGMSG := TRIM(PILONGMSG)||PISIGNATURE_V;
          ELSE
            PILONGMSG := PISIGNATURE_V||TRIM(PILONGMSG);
          END IF;

          --调用插入存储过程
          GW_WR_MTTASKV2(PIDESTUID,PINEWMSGID,2,1,PIPKTOTAL,1,
                  PISPLITLEN_V,PIMULTILEN1_V,PIMULTILEN2_V,PINEWSIGNLEN_V,PIECID,
                  PIDESTUSRID,PIDESTSPGATE,PIDESTCPNO,PIRECVMTTIME,PILONGMSG,
                  PIPHONE,PIDESTFEEFLAG,PISENDLEVEL,PITASKID,' ',PITPUDHI,
                  PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PIPKNUM,PISVRTYPE,
                  PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA);
        ELSE
          PILONGMSG:='';
        END IF;--END OF IF PILONGMSGLEN > 0
          PIPKNUM:=1;
      END IF;--END OF IF EXISTS(SELECT COUNT(*) FROM PITMP WHERE PTMSGID=PIOLDMSGID AND RESENDCNT<1 AND (TRIM(SPGATE)+TRIM(CPNO))=PISRCSPNUMBER)
    END  IF;--END OF IF PIPKTOTAL > 1
  END IF;--END OF IF PIPIROWCOUNT<>0
  --返回给上层数据
  PIPTMSGID_P:=PINEWMSGID;
  UPDATE TMP_RDMTTASK SET PTNEWMSGID=PIPTMSGID_P WHERE PTMSGID=PIOLDMSGID;

  OPEN OUT_CURSOR FOR
  SELECT "UID",PTNEWMSGID AS PTMSGID,ECID,TASKID,PIDESTUSRID AS USERID,PIDESTSPGATE AS SPGATE,
  PIDESTCPNO AS CPNO,PHONE,RETFLAG,PIDESTFEEFLAG AS FEEFLAG,1 AS PKNUMBER,PIPKTOTAL AS PKTOTAL,
  SENDSTATUS,1 AS SENDLEVEL,
  PILONGMSG AS MESSAGE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,
  SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,
  ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA FROM TMP_RDMTTASK WHERE (PILONGMSG IS NOT NULL);
END;
/


CREATE OR REPLACE PROCEDURE GW_LOADBASEPARA
(
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
     SELECT ID,FUNNAME,CMDTYPE,ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE,CREATETIME,MODIFTIME,RESERVE  FROM GW_BASEPARA;
END;
/
CREATE OR REPLACE PROCEDURE GW_LOADPROTOMTCH
(
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
       SELECT GP.ID,GP.ECID,GP.FUNTYPE,GP.FUNNAME,GP.CMDTYPE,GP.CARGNAME,GP.MARGNAME,GP.CARGTYPE,GP.CARGVALUE,GP.BELONGTYPE,GP.BELONG,GP.CREATETIME,GP.MODIFTIME,GP.RESERVE,GB.RETTYPE,GB.STATUS,GB.CFUNNAME
       FROM GW_PROTOMTCH GP, GW_BASEPROTOCOL GB
       WHERE GP.FUNTYPE=GB.FUNTYPE AND GP.FUNNAME=GB.FUNNAME AND GP.CMDTYPE=GB.CMDTYPE AND GP.ECID=GB.ECID AND GB.STATUS=1;
END;
/
CREATE OR REPLACE PROCEDURE GW_GETALLUSRINFOV1
 (
  PISPTYPE   IN   NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT CASE WHEN B."UID" IS NULL THEN A."UID" ELSE B."UID" END AS SVRID,A."UID",A.USERID,A.USERTYPE,A.USERPRIVILEGE,A.STATUS,A.USERPASSWORD,A.LOGINIP,
  A.STAFFNAME AS CORPNAME,A.SENDTYPE AS FAILURERATE,A.SENDTMSPAN,A.FORBIDTMSPAN,
  A.SPEEDLIMIT,A.MAXDAYNUM,A.SUBMITCNT,A.ACCOUNTTYPE,A.FEEFLAG,A.RISELEVEL,A.TRANSMOTYPE,A.TRANSRPTYPE,
  GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,GU.
    PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT
  FROM USERDATA A LEFT JOIN (SELECT "UID",USERID FROM USERDATA WHERE BITAND(USERPRIVILEGE,2) = 2 AND USERDATA.ACCOUNTTYPE=PISPTYPE) B
  ON (A.LOGINID = B.USERID) OR B.USERID IS NULL
  INNER JOIN   GW_USERPROPERTY GU ON GU.USERID=A.USERID
  WHERE A.STATUS=0 AND A.USERTYPE=0 AND A.ACCOUNTTYPE=PISPTYPE ;
END;
/

CREATE OR REPLACE PROCEDURE GW_GETURLBINDV1
 (
  PIUID           IN NUMBER,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  IF (PIUID=0) THEN
     OPEN OUT_CURSOR FOR
     SELECT UD."UID",UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
     CASE WHEN ((RTRIM(UD.MOURL) IS NOT NULL) AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE ' ' END AS MOURL,
     CASE WHEN ((RTRIM(UD.RPTURL) IS NOT NULL) AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE ' ' END AS RPTURL,
     GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
     GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST,UD.PUSHVERSION
     FROM USERDATA UD INNER JOIN   GW_USERPROPERTY GU ON GU.USERID=UD.USERID
     WHERE UD.USERTYPE=0 AND UD.STATUS=0
     AND (((RTRIM(UD.MOURL) IS NOT NULL) AND UD.TRANSMOTYPE=2) OR ((RTRIM(UD.RPTURL) IS NOT NULL) AND UD.TRANSRPTYPE=2))
     AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD."UID";

  ELSE
     OPEN OUT_CURSOR FOR
     SELECT UD."UID",UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
     CASE WHEN ((RTRIM(UD.MOURL) IS NOT NULL) AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE ' ' END AS MOURL,
     CASE WHEN ((RTRIM(UD.RPTURL) IS NOT NULL) AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE ' ' END AS RPTURL,
     GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
     GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST,UD.PUSHVERSION
     FROM USERDATA UD INNER JOIN   GW_USERPROPERTY GU ON GU.USERID=UD.USERID
      WHERE UD."UID"=PIUID AND UD.USERTYPE=0 AND UD.STATUS=0
     AND (((RTRIM(UD.MOURL) IS NOT NULL) AND UD.TRANSMOTYPE=2) OR ((RTRIM(UD.RPTURL) IS NOT NULL) AND UD.TRANSRPTYPE=2))
     AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD."UID";
  END IF;
END;
/


--加载退订命令表GW_TDCMD
CREATE OR REPLACE PROCEDURE GW_LOADTDCMD
 (
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
     OPEN OUT_CURSOR FOR
     SELECT TD_CMD,MATCHTYPE FROM GW_TDCMD ;
END;
/


/* 
 自动添加黑名单功能存储过程，
 1.根据参数从GW_TDCMD表中获取退订指令相关策略信息。
 2.根据GW_TDCMD表的策略信息决定是否需要添加黑名单，如果需要，在检测PB_LIST_BLACK表中是否已经存在对应的黑名单数据。不存在则添加黑名单，存在则无需重复添加。
 3.再向GW_TDCMD_HIS表添加一条记录
*/
CREATE OR REPLACE PROCEDURE GW_ADDPBLISTBLACK (
PI_PHONE IN NUMBER,
PITD_CMD IN VARCHAR2,
PIUSERID IN VARCHAR2,
PISPNUMBER IN VARCHAR2,
PISVRTYPE IN VARCHAR2,
PI_ECID IN NUMBER,
PI_MO_MSGID IN NUMBER
)
AS
 PI_PB_USERID VARCHAR2(11) ;
 PI_PB_SPNUMBER VARCHAR2(21) ;
 PI_PB_SVRTYPE VARCHAR2(64) ;
 PI_PB_CROPCODE VARCHAR2(64) ;
 PI_OPTYPE NUMBER(4);
 PI_CNT NUMBER(11);
 PI_CNT1 NUMBER(11);
 PI_TD_CMD VARCHAR2(64);
 PI_USERID VARCHAR2(11);
 PI_SPNUMBER VARCHAR2(21);
 PI_SVRTYPE VARCHAR2(64);
BEGIN
PI_TD_CMD := COALESCE(PITD_CMD,' ');
PI_USERID := COALESCE(PIUSERID,' ');
PI_SPNUMBER := COALESCE(PISPNUMBER,' ');
PI_SVRTYPE := COALESCE(PISVRTYPE,' ');
--根据GW_TDCMD表的策略信息判断是否需要添加黑名单
SELECT COUNT(ID) INTO PI_CNT FROM GW_TDCMD WHERE (UPPER(TD_CMD)=UPPER(PI_TD_CMD)) AND (TD_USERID=PI_USERID OR TD_USERID='000000')
AND (TD_SPNUMBER=' ' OR (PI_SPNUMBER LIKE TD_SPNUMBER||'%' )) AND (TD_ECID=PI_ECID OR TD_ECID=0)
AND (PB_SVRTYPE=PI_SVRTYPE OR PB_SVRTYPE=' ') AND STATUS=0;

IF PI_CNT>=1 THEN
--需要添加黑名单，读取策略信息
SELECT  PB_USERID,PB_SPNUMBER,PB_SVRTYPE,PB_CROPCODE,OPTYPE
INTO PI_PB_USERID, PI_PB_SPNUMBER, PI_PB_SVRTYPE, PI_PB_CROPCODE, PI_OPTYPE
FROM GW_TDCMD WHERE (UPPER(TD_CMD)=UPPER(PI_TD_CMD)) AND (TD_USERID=PI_USERID OR TD_USERID='000000')
AND (TD_SPNUMBER=' ' OR (PI_SPNUMBER LIKE TD_SPNUMBER||'%' )) AND (TD_ECID=PI_ECID OR TD_ECID=0)
AND (PB_SVRTYPE=PI_SVRTYPE OR PB_SVRTYPE=' ') AND STATUS=0 AND ROWNUM<=1;

--判断PB_LIST_BLAK表中是否已经存在对应的黑名单数据，不存在则添加
SELECT COUNT(ID) INTO PI_CNT1 FROM PB_LIST_BLACK WHERE USERID=PI_PB_USERID AND SPGATE=' ' AND SPNUMBER=PI_PB_SPNUMBER AND PHONE=PI_PHONE
AND SVRTYPE=PI_PB_SVRTYPE AND CORPCODE=PI_PB_CROPCODE AND OPTYPE=1;

IF PI_CNT1=0 THEN
INSERT INTO PB_LIST_BLACK(USERID,SPGATE,SPNUMBER,PHONE,OPTYPE,OPTTIME,MSG,SVRTYPE,SPISUNCM,CORPCODE,BLTYPE)
VALUES(PI_PB_USERID,' ',PI_PB_SPNUMBER,PI_PHONE,PI_OPTYPE,SYSTIMESTAMP,' ',PI_PB_SVRTYPE,0,PI_PB_CROPCODE,1);
--再向GW_TDCMD_HIS表添加一条记录
INSERT INTO GW_TDCMD_HIS(TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID,OPTYPE,MO_MSGID,TD_TIME)
VALUES(PI_PHONE,PI_TD_CMD,PI_USERID,PI_SPNUMBER,PI_ECID,PI_OPTYPE,PI_MO_MSGID,SYSTIMESTAMP);
END IF;
END IF;
END ;
/


CREATE OR REPLACE PROCEDURE GW_LOADPUSHPROMH
(
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
    SELECT GP.ID,GP.ECID,GP.USERID,GP.PUSHFLAG,GP.CMDTYPE,GP.CARGNAME,GP.CARGTYPE,GP.MARGNAME,GP.CARGVALUE,GP.BELONGTYPE,GP.BELONG,GP.RESERVE,GB.RETTYPE,GB.STATUS
    FROM GW_PUSHPROTOMTCH GP,(SELECT ECID,CMDTYPE,STATUS,CASE WHEN FUNNAME='MO' THEN 1 WHEN FUNNAME='RPT' THEN 2 ELSE 0 END AS  PUSHFLAG,RETTYPE FROM GW_BASEPROTOCOL) GB
   WHERE  GP.CMDTYPE=GB.CMDTYPE AND GP.ECID=GB.ECID AND GP.PUSHFLAG=GB.PUSHFLAG AND GB.STATUS=1;
END;
/

CREATE OR REPLACE PROCEDURE GW_LOADPUSHPROCOL
(
 OUT_CURSOR OUT SYS_REFCURSOR
)
AS
BEGIN
  OPEN OUT_CURSOR FOR
      SELECT ID,ECID,USERID,RSPCMD,CARGNAME,RSPSTATUS,CRSPFMT,CARGVALUE  FROM GW_PUSHRSPROTOCOL;
END;
/

CREATE OR REPLACE PROCEDURE GW_LOADGTCONNINFO
 (
  P_PIPTACCID           IN VARCHAR2,
  PISPTYPE        IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
    SELECT  ID,PTID,GATEID,CONNTYPE,PTACCID,IP,PORT,LINKCNT,SPEEDLIMIT,LINKLEVEL,LINKSTATUS,PING,MINLINKS,KEEPCONN,RECONNCNT,RELOGINCNT,SWITCHMAINIP,TESTMETHOD,TESTTIMES,ABNORMALONG,ABNORMALTMS
    FROM GW_GATECONNINFO WHERE PTACCID=P_PIPTACCID;

END;

/

CREATE OR REPLACE PROCEDURE GW_LOADUSRFEE
 (
  PISPTYPE           IN NUMBER,
  OUT_CURSOR      OUT SYS_REFCURSOR
 )
AS
BEGIN
  OPEN OUT_CURSOR FOR
  SELECT F."UID",F.SENDNUM,F.USERID FROM USERFEE F
  INNER JOIN USERDATA U ON F.USERID=U.USERID
  WHERE U.USERTYPE=0 AND U.STATUS=0 AND U.ACCOUNTTYPE=PISPTYPE;
END;
/

--PROMPT
--PROMPT CREATING PROCEDURE GW_UPD_MOTASKV1
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_UPD_MOTASKV1
 (
    PIPTMSGID     IN NUMBER,
    PISENDSTATUS  IN PLS_INTEGER,
    PIUID         IN PLS_INTEGER,
    PIECID        IN PLS_INTEGER,
    PIUSERID      IN VARCHAR2,
    PIRESENDCNT     IN NUMBER
 )
AS
BEGIN

  IF PIUID=0 AND PIECID=0 AND (PIUSERID IS NULL) THEN
    UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,RESENDCNT=PIRESENDCNT WHERE PTMSGID = PIPTMSGID;
  ELSE
    UPDATE MO_TASK SET SENDSTATUS=PISENDSTATUS,"UID"=PIUID,ECID=PIECID,
    USERID=PIUSERID,RESENDCNT=PIRESENDCNT WHERE PTMSGID=PIPTMSGID;
  END IF;
END;
/


CREATE OR REPLACE PROCEDURE GW_WRRPTWAITBV4
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PIECID         IN NUMBER,
    PISPNUMBER     IN VARCHAR2,
    PIPHONE        IN VARCHAR2,
    PISUBMITTIME   IN VARCHAR2,
    PIDONETIME     IN VARCHAR2,
    PIERRORCODE    IN VARCHAR2,
    PIUSERID       IN VARCHAR2,
    PIORGUID       IN NUMBER,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIRECVTIME_P   IN VARCHAR2,
    PISPMSGID      IN NUMBER DEFAULT 0,    ---- 新增的2015.10.8
    PIPKTOTAL      IN NUMBER DEFAULT 0,    ---- 新增的2016.8.25 64BIT集群
    PICUSTID       IN RPT_WAIT_B.CUSTID%TYPE,
    PIEXDATA       IN RPT_WAIT_B.EXDATA%TYPE,
    PIRESENDCNT    IN RPT_WAIT_B.RESENDCNT%TYPE
 )
AS
  ICOUNT PLS_INTEGER;
  PIRECVTIME TIMESTAMP(6);
BEGIN
  IF PIRECVTIME_P IS NULL THEN
     PIRECVTIME:=SYSTIMESTAMP;
  ELSE
     PIRECVTIME:=TO_TIMESTAMP(PIRECVTIME_P,'YYYY-MM-DD HH24:MI:SS.FF');
  END IF;

  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM RPT_WAIT_B WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO RPT_WAIT_B("UID",PTMSGID,SPNUMBER,PHONE,SUBMITTIME,DONETIME,ERRORCODE,USERID,
    ECID,ORGUID,USERMSGID,MODULEID,RECVTIME,SPMSGID,PKTOTAL,CUSTID,EXDATA,RESENDCNT)
    VALUES(PIUID,PIPTMSGID,PISPNUMBER,PIPHONE,PISUBMITTIME,PIDONETIME,PIERRORCODE,PIUSERID,
    PIECID,PIORGUID,PIUSERMSGID,PIMODULEID,PIRECVTIME,PISPMSGID,PIPKTOTAL,PICUSTID,PIEXDATA,PIRESENDCNT);
  END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RMSRPT_RVOK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_RMSRPT_RVOK(
  ID         NUMBER(20) NOT NULL,
  USERID     VARCHAR(6) DEFAULT '' '' NOT NULL,
  USERUID    INT DEFAULT 0 NOT NULL,
  PTMSGID    NUMBER(20) DEFAULT 0 NOT NULL,
  SPNUMBER   VARCHAR(21) DEFAULT '' '' NOT NULL,
  PHONE   	 VARCHAR(21) DEFAULT '' '' NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT '' '' NOT NULL,
  MOBILEAREA INT DEFAULT 0 NOT NULL,
  MOBILETYPE NUMBER(3) DEFAULT 0 NOT NULL,
  SENDSTATUS NUMBER(3) DEFAULT 0 NOT NULL,
  FIRSTDOWNTM TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ENDDOWNTM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNRPTOKTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNTRANSRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVRDNRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MOBILECOUNTRY VARCHAR(10) DEFAULT '' '' NOT NULL,
  ECID VARCHAR(10) DEFAULT '' '' NOT NULL,
  MSGTYPE NUMBER(3) DEFAULT 0 NOT NULL,
  IN_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RMSRPT_RVOK
	  ADD CONSTRAINT PK_GWRMSRPTRVOK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOK_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOK_PTMSGID ON GW_RMSRPT_RVOK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOK_RECVRDNRPTTM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOK_RECVRDNRPTTM ON GW_RMSRPT_RVOK(RECVRDNRPTTM)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK') AND T.INDEX_NAME = UPPER('IX_GWMTSDOK_IN_TIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTSDOK_IN_TIME ON GW_RMSRPT_RVOK(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RMSRPT_RVOK_ERR';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_RMSRPT_RVOK_ERR(
  ID         NUMBER(20) NOT NULL,
  USERID     VARCHAR(6) DEFAULT '' '' NOT NULL,
  USERUID    INT DEFAULT 0 NOT NULL,
  PTMSGID    NUMBER(20) DEFAULT 0 NOT NULL,
  SPNUMBER   VARCHAR(21) DEFAULT '' '' NOT NULL,
  PHONE   	 VARCHAR(21) DEFAULT '' '' NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT '' '' NOT NULL,
  MOBILEAREA INT DEFAULT 0 NOT NULL,
  MOBILETYPE NUMBER(3) DEFAULT 0 NOT NULL,
  SENDSTATUS NUMBER(3) DEFAULT 0 NOT NULL,
  FIRSTDOWNTM TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ENDDOWNTM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNRPTOKTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNTRANSRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVRDNRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MOBILECOUNTRY VARCHAR(10) DEFAULT '' '' NOT NULL,
  ECID VARCHAR(10) DEFAULT '' '' NOT NULL,
  MSGTYPE NUMBER(3) DEFAULT 0 NOT NULL,
  IN_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_ERR') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RMSRPT_RVOK_ERR
	  ADD CONSTRAINT PK_GWRMSRPTRVOKERR PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_ERR') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOKERR_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOKERR_PTMSGID ON GW_RMSRPT_RVOK_ERR(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_ERR') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOKERR_RECVRDNRPTTM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOKERR_RECVRDNRPTTM ON GW_RMSRPT_RVOK_ERR(RECVRDNRPTTM)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_ERR') AND T.INDEX_NAME = UPPER('IX_GWMTSDOKERR_IN_TIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWMTSDOKERR_IN_TIME ON GW_RMSRPT_RVOK_ERR(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM USER_TABLES WHERE TABLE_NAME='GW_RMSRPT_RVOK_BAK';
  IF VERSION = 0 THEN
	EXECUTE IMMEDIATE '
CREATE TABLE GW_RMSRPT_RVOK_BAK(
  ID         NUMBER(20) NOT NULL,
  USERID     VARCHAR(6) DEFAULT '' '' NOT NULL,
  USERUID    INT DEFAULT 0 NOT NULL,
  PTMSGID    NUMBER(20) DEFAULT 0 NOT NULL,
  SPNUMBER   VARCHAR(21) DEFAULT '' '' NOT NULL,
  PHONE   	 VARCHAR(21) DEFAULT '' '' NOT NULL,
  ERRORCODE  CHAR(7) DEFAULT '' '' NOT NULL,
  MOBILEAREA INT DEFAULT 0 NOT NULL,
  MOBILETYPE NUMBER(3) DEFAULT 0 NOT NULL,
  SENDSTATUS NUMBER(3) DEFAULT 0 NOT NULL,
  FIRSTDOWNTM TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  ENDDOWNTM   TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNRPTOKTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RDNTRANSRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  RECVRDNRPTTM  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL,
  MOBILECOUNTRY VARCHAR(10) DEFAULT '' '' NOT NULL,
  ECID VARCHAR(10) DEFAULT '' '' NOT NULL,
  MSGTYPE NUMBER(3) DEFAULT 0 NOT NULL,
  IN_TIME  TIMESTAMP(6) DEFAULT SYSTIMESTAMP NOT NULL
) TABLESPACE TBSSMSACC
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )';
  END IF;
END;
/

DECLARE 
PCOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO PCOUNT FROM USER_CONSTRAINTS T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_BAK') AND T.CONSTRAINT_TYPE = 'P';     
	IF PCOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'ALTER TABLE GW_RMSRPT_RVOK_BAK
	  ADD CONSTRAINT PK_GWRMSRPTRVOKBAK PRIMARY KEY (ID)
	  USING INDEX
	  TABLESPACE TBSSVRINDEX
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_BAK') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOKBAK_PTMSGID');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOKBAK_PTMSGID ON GW_RMSRPT_RVOK_BAK(PTMSGID)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_BAK') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOKBAK_RECVRDNRPTTM');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOKBAK_RECVRDNRPTTM ON GW_RMSRPT_RVOK_BAK(RECVRDNRPTTM)
	  TABLESPACE TBMTINDEX_PTMSGID
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

DECLARE 
ICOUNT NUMBER;  
BEGIN 
	SELECT COUNT(1) INTO ICOUNT FROM USER_INDEXES T WHERE T.TABLE_NAME = UPPER('GW_RMSRPT_RVOK_BAK') AND T.INDEX_NAME = UPPER('IX_GWRPTRVOKBAK_IN_TIME');     
	IF ICOUNT  = 0 THEN 
	EXECUTE IMMEDIATE
	'CREATE INDEX IX_GWRPTRVOKBAK_IN_TIME ON GW_RMSRPT_RVOK_BAK(IN_TIME)
	  TABLESPACE TBSSVRINDEX   REVERSE
	  PCTFREE 10
	  INITRANS 2
	  MAXTRANS 255
	  STORAGE
	  (
		INITIAL 64K
		MINEXTENTS 1
		MAXEXTENTS UNLIMITED
	  )';
	END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_RMSRPT_RVOK
 (
  PIUSERID IN VARCHAR2,
  PIUSERUID IN VARCHAR2,
  PIPTMSGID IN NUMBER,
  PISPNUMBER IN VARCHAR2,
  PIPHONE IN VARCHAR2,
  PIERRORCODE IN VARCHAR2,
  PIMOBILEAREA IN VARCHAR2,
  PIMOBILETYPE IN NUMBER,
  PISENDSTATUS IN NUMBER,
  PIFIRSTDOWNTM IN TIMESTAMP,
  PIENDDOWNTM IN TIMESTAMP,
  PIRDNRPTOKTM IN TIMESTAMP,
  PIRDNTRANSRPTTM IN TIMESTAMP,
  PIRECVRDNRPTTM IN TIMESTAMP,
  PIMOBILECOUNTRY  IN VARCHAR2,
  PIECID  IN VARCHAR2,
  PIMSGTYPE IN NUMBER
 )
AS
  ICOUNT PLS_INTEGER;
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_RMSRPT_RVOK WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    INSERT INTO GW_RMSRPT_RVOK(USERID,USERUID,PTMSGID,SPNUMBER,PHONE,ERRORCODE,MOBILEAREA,MOBILETYPE,SENDSTATUS,FIRSTDOWNTM,ENDDOWNTM,RDNRPTOKTM,RDNTRANSRPTTM,RECVRDNRPTTM,MOBILECOUNTRY,ECID,MSGTYPE )
     VALUES(PIUSERID,PIUSERUID,PIPTMSGID,PISPNUMBER,PIPHONE,PIERRORCODE,PIMOBILEAREA,PIMOBILETYPE,PISENDSTATUS,PIFIRSTDOWNTM,PIENDDOWNTM,PIRDNRPTOKTM,PIRDNTRANSRPTTM,PIRECVRDNRPTTM,PIMOBILECOUNTRY,PIECID,PIMSGTYPE);
  END IF;
END;
/

CREATE OR REPLACE PROCEDURE GW_UPPRMSRPTRVOK(PRETIME IN NUMBER,INCRES IN  NUMBER,STARTTIME IN VARCHAR2)
IS
 ROWS1 NUMBER(11) DEFAULT 0 ;
 LOGID NUMBER(11) DEFAULT 0 ;
 PICODE NUMBER(11);

 MAXID  NUMBER(22) DEFAULT 0;
 MINID  NUMBER(22) DEFAULT 0;
 CURMINID  NUMBER(22) DEFAULT 0;
 CURMAXID  NUMBER(22) DEFAULT 0;

 I  NUMBER(11) DEFAULT 0;
 J  NUMBER(11) DEFAULT 0;
 REMAINDER  NUMBER(11) DEFAULT 0;
  MINLONG NUMBER(11) DEFAULT 0;

 ISEXIST NUMBER(11) DEFAULT 0;
 P_NUMALL NUMBER(22) DEFAULT 0;
 COUNTID NUMBER(22) DEFAULT 0;
 INCRESDEL NUMBER(22) DEFAULT 0;

 EXCP_ORA_30926  EXCEPTION;
 PRAGMA EXCEPTION_INIT(EXCP_ORA_30926,-30926);

BEGIN

--创建临时表
 SELECT COUNT(TABLE_NAME) INTO ISEXIST FROM USER_TABLES WHERE TABLE_NAME='TMP_DEL';
  IF(ISEXIST>0) THEN
    BEGIN
          EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
    END;
   ELSE
     EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_DEL(PTMSGID NUMBER(22)) ON COMMIT PRESERVE ROWS';
  END IF;



------------------更新GW_RMSRPT_RVOK表-------------------------------------------

SELECT NVL(MIN(ID),0),NVL(MAX(ID),0) INTO MINID,MAXID FROM GW_RPTRVOK;
IF MINID=0 AND MAXID=0 THEN
RETURN;
END IF;
SELECT (MAXID-MINID+1)/INCRES,MOD((MAXID-MINID+1),INCRES) INTO J,REMAINDER  FROM DUAL;
IF REMAINDER<>0 THEN
 J:=J+1;END IF;
 I:=0;
 INCRESDEL:=INCRES+100000;
WHILE (I<J) LOOP
INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,7,1,0,0,sysdate,sysdate);
SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
 CURMINID:=MINID+INCRES*I;
 CURMAXID:=CURMINID+INCRES-1;
IF I=J-1 THEN
   CURMAXID:=MAXID;
END IF;

ROWS1:=0;  PICODE:=0;
BEGIN
MERGE INTO   GW_MT_TASK_BAK  A USING (SELECT PTMSGID,FIRSTDOWNTM,ERRORCODE FROM GW_RMSRPT_RVOK WHERE ID <= CURMAXID AND ID >= CURMINID) B ON ( A.PTMSGID=B.PTMSGID)
WHEN MATCHED THEN
 UPDATE SET  A.ERRORCODE2=B.ERRORCODE,
             A.DOWNTM=B.FIRSTDOWNTM;
      ROWS1:=SQL%ROWCOUNT; PICODE:=SQLCODE;
   EXCEPTION WHEN EXCP_ORA_30926 THEN
    --------------若有重复的 则去重 更新
MERGE INTO   GW_MT_TASK_BAK  A USING (SELECT  PTMSGID,FIRSTDOWNTM,ERRORCODE FROM  GW_RMSRPT_RVOK where  ID <= CURMAXID AND ID >= CURMINID GROUP BY PTMSGID )   B  on ( A.PTMSGID=B.PTMSGID )
WHEN MATCHED THEN
 UPDATE SET  A.ERRORCODE2=B.ERRORCODE,
             A.DOWNTM=B.FIRSTDOWNTM;
       ROWS1:=SQL%ROWCOUNT;
    UPDATE GW_UPD_DEL_LOG SET UPTYPE=2,COUNTID=ROWS1, ISSUCCES=1,END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
  WHEN OTHERS THEN
   ROLLBACK; END;

   IF PICODE>=0 THEN
      UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID  AND ISSUCCES=0;
   END IF;
  COMMIT;

 -------------删除更新成功的
 EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_DEL';
INSERT INTO TMP_DEL
SELECT PTMSGID
  FROM (SELECT  PTMSGID FROM GW_RMSRPT_RVOK WHERE ID <= CURMAXID AND ID >= CURMINID) GR
 WHERE EXISTS (SELECT PTMSGID
          FROM GW_MT_TASK_BAK
         WHERE GR.PTMSGID = GW_MT_TASK_BAK.PTMSGID) ;

  INSERT INTO GW_UPD_DEL_LOG(ID,OPRTYPE,UPTYPE,COUNTID,ISSUCCES,IN_TIME,END_TIME) VALUES(SEQ_GW_UPD_DEL_LOG.NEXTVAL,8,0,0,0,sysdate,sysdate);
  SELECT SEQ_GW_UPD_DEL_LOG.CURRVAL INTO LOGID FROM DUAL;
  --DELETE FROM  GW_RMSRPT_RVOK WHERE EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE GW_RMSRPT_RVOK.PTMSGID =GW_MT_TASK_BAK.PTMSGID AND GW_MT_TASK_BAK.FLAGRPTRVOK=1 ) AND ID >= CURMINID AND ID <= CURMAXID;
  GW_DEL_DATA(INCRESDEL,10001,2,P_NUMALL);
  ROWS1:=P_NUMALL;

  IF ROWS1>=0 THEN
    UPDATE GW_UPD_DEL_LOG SET COUNTID=ROWS1,ISSUCCES=1, END_TIME=sysdate WHERE ID=LOGID;
  END IF;
 COMMIT;
 MINLONG:=FLOOR(TO_NUMBER(SYSDATE-TO_DATE(STARTTIME,'YYYY-MM-DD HH24:MI:SS'))*24*60);
IF MINLONG>=PRETIME THEN
    I:=J;
ELSE
    I:=I+1;
END IF;

 END LOOP;
COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKV5
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PISPLITLEN_P   IN NUMBER,
    PIMULTILEN1_P  IN NUMBER,
    PIMULTILEN2_P  IN NUMBER,
    PISIGNLEN_P    IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1      IN VARCHAR2,
    PIP2      IN VARCHAR2,
    PIP3      IN VARCHAR2,
    PIP4      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2,
  PISUID1       IN VARCHAR2,
  PILUID1       IN VARCHAR2
 )
AS
--临时变量
PITMPMSGID NUMBER(22,0);
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR(21);
PISTRSPLIT VARCHAR(2);
PILEN PLS_INTEGER;
PIRESULTMSG VARCHAR(720);
PIPKNUM PLS_INTEGER;
PITMPNUM PLS_INTEGER;
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIRECVMTTIME_P TIMESTAMP(6);
PIPTMSGID_P NUMBER(22,0);

PISPLITLEN PLS_INTEGER;
PIMULTILEN1 PLS_INTEGER;
PIMULTILEN2 PLS_INTEGER;
PISIGNLEN PLS_INTEGER;

BEGIN
--变量赋值
PILEN := LENGTH(PIMESSAGE)-PISIGNLEN_P;
PITMPNUM := 0;
PIPKNUM := 1;
PISTRSPLIT := ',';
PISHOUJI_P :=PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;


IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
--清空临时表,如果临时表不存在直接返回不处理
/*SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASK');
IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASK';
ELSE
  RETURN;
END IF;
*/
--验证手机号合法性
IF (PISHOUJI_P IS NULL) THEN
  PISHOUJI_P := ' ';
END IF;
IF /*(PISHOUJI_P IS NULL) OR */(PIPHONECOUNT < 1) THEN
   RETURN;
END IF;

--变量赋值
IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
  PISPLITLEN:=140;
  PIMULTILEN1:=134;
  PIMULTILEN2:=134;
  PISIGNLEN:=0;
ELSE
  PISPLITLEN  :=PISPLITLEN_P;
  PIMULTILEN1 :=PIMULTILEN1_P;
  PIMULTILEN2 :=PIMULTILEN2_P;
  PISIGNLEN   :=PISIGNLEN_P;
END IF;
IF PIMSGFMT=25 THEN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
    RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
    UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
    PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
    PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
  END IF;
  RETURN;
END IF;
IF PIPHONECOUNT = 1 --单发
THEN
 SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  --IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
  IF ICOUNT<1 THEN
    IF PIPKTOTAL = 1 THEN
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
      VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
      PIRETFLAG,PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
      PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
    ELSE
      PIPKNUM := 1;
      PITMPMSGID := PIPTMSGID_P;
      IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
        PIRESULTMSG := SUBSTR(PIMESSAGE,1,PISPLITLEN);
        PITMPMSGID := PITMPMSGID;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID, PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
        PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
        PITMPMSGID := PITMPMSGID+17179869184;
        PIPKNUM := PIPKNUM+1;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
      ELSE
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          IF PIPKNUM = PIPKTOTAL THEN
             PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
             PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSIF PIPKNUM = PIPKTOTAL-1 THEN
            IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
               PITMPNUM := PILEN-1;
               --DBMS_OUTPUT.PUT_LINE('123');
            ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
               PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
               --DBMS_OUTPUT.PUT_LINE('456');
            END IF;
            PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
               --DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
          END IF;
          ICOUNT:=0;
          SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
          IF ICOUNT<1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
            PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
          --EXECUTE IMMEDIATE STR;
          PIPKNUM := PIPKNUM+1;
        END LOOP;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
      END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
      A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1 FROM TMP_MTTASK A;
      COMMIT;
    END IF;--END IF OF IF PIPKTOTAL = 1
  --ELSE  --MSGID存在是写入MSGIDTEST表
  --  INSERT INTO MSGIDTEST(MSGID) VALUES(PIPTMSGID);
  END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID_P)
ELSE --群发
    PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  IF PIPKTOTAL < 1 THEN--没有短信内容
    RETURN;
  END IF;

  IF PIPKTOTAL >= 1 --需要拆分长短信
  THEN
    WHILE PILOCATION <> 0 LOOP--拆分手机号码
        PISTART := PILOCATION;
        PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
      IF PILOCATION > 0 THEN
        PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);--拆分后的字符
        IF (PIRESULTPHONE IS NULL) THEN
          PIRESULTPHONE := ' ';
        END IF;
        PITMPMSGID := PIPTMSGID_P;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          IF PIPKTOTAL = 1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIMESSAGE,PISENDSTATUS,
            PIRETFLAG, PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          ELSE
            PIPKNUM := 1;
            IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
              PIRESULTMSG := SUBSTR(PIMESSAGE,1, PISPLITLEN);--拆分后的字符
              PITMPMSGID := PITMPMSGID;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID, PISPGATE,PICPNO,PIRESULTPHONE, PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG, PIPKNUM, PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF;
              PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
              PITMPMSGID := PITMPMSGID+17179869184;
              PIPKNUM := PIPKNUM+1;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
            ELSE
              WHILE PIPKNUM <= PIPKTOTAL LOOP--PIPKNUM:1    PIPKTOTAL 2
                IF PIPKNUM = PIPKTOTAL THEN
                  PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSIF PIPKNUM = PIPKTOTAL-1 THEN
                  IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
                    PITMPNUM := PILEN-1;
                  ELSE
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                    PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
                     ----第一条
                  END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSE
                  PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
                ICOUNT:=0;
                SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
                IF ICOUNT<1 THEN
                  INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                  RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                  PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                  PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
                END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
                PIPKNUM := PIPKNUM+1;
              END LOOP;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
            END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
          END  IF;--END IF OF IF PIPKTOTAL = 1
        END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
        PIPTMSGID_P := PIPTMSGID_P+1;
      END  IF; --END IF OF IF PILOCATION > 0
    END LOOP; --END WHILE OF WHILE PILOCATION <> 0
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
      A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1 FROM TMP_MTTASK A;
      COMMIT;
   END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --单发
END;

/


CREATE OR REPLACE PROCEDURE GW_WR_MTTASKV4
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PISPLITLEN_P   IN NUMBER,
    PIMULTILEN1_P  IN NUMBER,
    PIMULTILEN2_P  IN NUMBER,
    PISIGNLEN_P    IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1      IN VARCHAR2,
    PIP2      IN VARCHAR2,
    PIP3      IN VARCHAR2,
    PIP4      IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2,
	PILONGMSG 	   IN VARCHAR2,
	PITMPLID	   IN NUMBER,
	PICHGRADE	   IN NUMBER,
	PIMSGTYPE	   IN NUMBER,
	PIRMSVALIDTM   IN NUMBER,
	PIRMSRPTFLAG   IN NUMBER,
	PIPROTOCOLVER  IN NUMBER,
    PITMPLTYPE	  IN NUMBER,
    PITITLE        IN VARCHAR2,
    PISHOWAY       IN VARCHAR2,
    PIDLDWAY       IN NUMBER,
    PIDLDNEY       IN NUMBER,
    PIISFREE       IN NUMBER,
    PISHOWTIME     IN NUMBER,
	PISUID1		   IN VARCHAR2,
	PILUID1		   IN VARCHAR2
 )
AS
--临时变量
PITMPMSGID NUMBER(22,0);
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR(21);
PISTRSPLIT VARCHAR(2);
PILEN PLS_INTEGER;
PIRESULTMSG VARCHAR(720);
PIPKNUM PLS_INTEGER;
PITMPNUM PLS_INTEGER;
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIRECVMTTIME_P TIMESTAMP(6);
PIPTMSGID_P NUMBER(22,0);

PISPLITLEN PLS_INTEGER;
PIMULTILEN1 PLS_INTEGER;
PIMULTILEN2 PLS_INTEGER;
PISIGNLEN PLS_INTEGER;

BEGIN
--变量赋值
PILEN := LENGTH(PILONGMSG)-PISIGNLEN_P;
PITMPNUM := 0;
PIPKNUM := 1;
PISTRSPLIT := ',';
PISHOUJI_P :=PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;


IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
--清空临时表,如果临时表不存在直接返回不处理
/*SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASK');
IF ICOUNT>0 THEN
    EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASK';
ELSE
  RETURN;
END IF;
*/
--验证手机号合法性
IF (PISHOUJI_P IS NULL) THEN
  PISHOUJI_P := ' ';
END IF;
IF /*(PISHOUJI_P IS NULL) OR */(PIPHONECOUNT < 1) THEN
   RETURN;
END IF;

--变量赋值
IF PIMSGFMT=4 OR PIMSGFMT=248 OR PIMSGFMT=246 THEN
  PISPLITLEN:=140;
  PIMULTILEN1:=134;
  PIMULTILEN2:=134;
  PISIGNLEN:=0;
ELSE
  PISPLITLEN  :=PISPLITLEN_P;
  PIMULTILEN1 :=PIMULTILEN1_P;
  PIMULTILEN2 :=PIMULTILEN2_P;
  PISIGNLEN   :=PISIGNLEN_P;
END IF;
IF PIMSGFMT=25 THEN
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
    RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
    UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
    VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
    PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
    PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  RETURN;
END IF;
IF PIPHONECOUNT = 1 --单发
THEN
 SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  --IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PIPTMSGID_P)
  IF ICOUNT<1 THEN
    IF PIPKTOTAL = 1 THEN
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PIPTMSGID_P,NVL(PIMESSAGE,' '),PISENDSTATUS,
      PIRETFLAG,PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
      PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
    ELSE
      PIPKNUM := 1;
      PITMPMSGID := PIPTMSGID_P;
      IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
        PIRESULTMSG := SUBSTR(PIMESSAGE,1,PISPLITLEN);
        PITMPMSGID := PITMPMSGID;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID, PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
        PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
        PITMPMSGID := PITMPMSGID+17179869184;
        PIPKNUM := PIPKNUM+1;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
          RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
          UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
          VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
          PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
          PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
        END IF;
      ELSE
        WHILE PIPKNUM <= PIPKTOTAL LOOP
          IF PIPKNUM = PIPKTOTAL THEN
             PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
             PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSIF PIPKNUM = PIPKTOTAL-1 THEN
            IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
               PITMPNUM := PILEN-1;
               --DBMS_OUTPUT.PUT_LINE('123');
            ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
               PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
               --DBMS_OUTPUT.PUT_LINE('456');
            END IF;
            PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
          ELSE
               PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
               PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
               --DBMS_OUTPUT.PUT_LINE(PIRESULTMSG);
          END IF;
          ICOUNT:=0;
          SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
          IF ICOUNT<1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PISHOUJI_P,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
            PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
          --EXECUTE IMMEDIATE STR;
          PIPKNUM := PIPKNUM+1;
        END LOOP;--END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
      END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1;
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,
      A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1 FROM TMP_MTTASK A;
      COMMIT;
    END IF;--END IF OF IF PIPKTOTAL = 1
  --ELSE  --MSGID存在是写入MSGIDTEST表
  --  INSERT INTO MSGIDTEST(MSGID) VALUES(PIPTMSGID);
  END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PIPTMSGID_P)
ELSE --群发
    PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  IF PIPKTOTAL < 1 THEN--没有短信内容
    RETURN;
  END IF;

  IF PIPKTOTAL >= 1 --需要拆分长短信
  THEN
    WHILE PILOCATION <> 0 LOOP--拆分手机号码
        PISTART := PILOCATION;
        PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
      IF PILOCATION > 0 THEN
        PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);--拆分后的字符
        IF (PIRESULTPHONE IS NULL) THEN
          PIRESULTPHONE := ' ';
        END IF;
        PITMPMSGID := PIPTMSGID_P;
        ICOUNT:=0;
        SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
        IF ICOUNT<1 THEN
          IF PIPKTOTAL = 1 THEN
            INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
            RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
            UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
            VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIMESSAGE,PISENDSTATUS,
            PIRETFLAG, PIPKTOTAL,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
            PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
          ELSE
            PIPKNUM := 1;
            IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1 THEN
              PIRESULTMSG := SUBSTR(PIMESSAGE,1, PISPLITLEN);--拆分后的字符
              PITMPMSGID := PITMPMSGID;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID, PISPGATE,PICPNO,PIRESULTPHONE, PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG, PIPKNUM, PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF;
              PIRESULTMSG := SUBSTR(PIMESSAGE,PISPLITLEN+1, PILEN-PISPLITLEN+PISIGNLEN);
              PITMPMSGID := PITMPMSGID+17179869184;
              PIPKNUM := PIPKNUM+1;
              ICOUNT:=0;
              SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
              IF ICOUNT<1 THEN
                INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
              END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
            ELSE
              WHILE PIPKNUM <= PIPKTOTAL LOOP--PIPKNUM:1    PIPKTOTAL 2
                IF PIPKNUM = PIPKTOTAL THEN
                  PIRESULTMSG := SUBSTR(PIMESSAGE,PITMPNUM+1, PIMULTILEN2+PISIGNLEN);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSIF PIPKNUM = PIPKTOTAL-1 THEN
                  IF ((PILEN-(PIPKNUM-1)*PIMULTILEN1) > PIMULTILEN2) AND ((PILEN-(PIPKNUM-1)*PIMULTILEN1) <= PIMULTILEN1) THEN
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PILEN-(PIPKNUM-1)*PIMULTILEN1-1);
                    PITMPNUM := PILEN-1;
                  ELSE
                    PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                    PITMPNUM := (PIPKNUM-1)*PIMULTILEN1+PIMULTILEN1;
                     ----第一条
                  END IF; --END IF OF PILEN-(PIPKNUM-1)*PIMULTILEN1 > PIMULTILEN2 AND PILEN-(PIPKNUM-1)*PIMULTILEN1 <= PIMULTILEN1
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                ELSE
                  PIRESULTMSG := SUBSTR(PIMESSAGE,(PIPKNUM-1)*PIMULTILEN1+1, PIMULTILEN1);
                  PITMPMSGID := PIPTMSGID_P+(PIPKNUM-1)*17179869184;
                END IF; --END IF OF IF PIPKNUM = PIPKTOTAL
                ICOUNT:=0;
                SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID;
                IF ICOUNT<1 THEN
                  INSERT INTO TMP_MTTASK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
                  RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
                  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
                  VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PITMPMSGID,PIRESULTMSG,PISENDSTATUS,
                  PIRETFLAG,PIPKNUM,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,
                  PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
                END IF;--END IF OF IF NOT EXISTS(SELECT PTMSGID FROM MT_TASK WHERE PTMSGID = PITMPMSGID)
                PIPKNUM := PIPKNUM+1;
              END LOOP;-- END WHILE OF WHILE PIPKNUM <= PIPKTOTAL
            END IF;--END IF OF IF PIPKTOTAL = 2 AND PILEN <= PIMULTILEN1
          END  IF;--END IF OF IF PIPKTOTAL = 1
        END IF; --END IF OF IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = PITMPMSGID)
        PIPTMSGID_P := PIPTMSGID_P+1;
      END  IF; --END IF OF IF PILOCATION > 0
    END LOOP; --END WHILE OF WHILE PILOCATION <> 0
      INSERT INTO GW_MT_TASK_BAK("UID",USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
      RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
      UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
      SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,NVL(A.MESSAGE,' '),A.SENDSTATUS,A.RETFLAG,
      A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
      A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1 FROM TMP_MTTASK A;
      COMMIT;
   END IF; --END IF OF IF PIPKTOTAL >= 1
END IF; --END IF OF IF PIPHONECOUNT = 1 --单发
END;

/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKSRV4
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1           IN VARCHAR2,
    PIP2           IN VARCHAR2,
    PIP3           IN VARCHAR2,
    PIP4           IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2,
	PILONGMSG 	   IN VARCHAR2,
	PITMPLID	   IN NUMBER,
	PICHGRADE	   IN NUMBER,
	PIMSGTYPE	   IN NUMBER,
	PIRMSVALIDTM   IN NUMBER,
	PIRMSRPTFLAG   IN NUMBER,
	PIPROTOCOLVER  IN NUMBER,
    PITMPLTYPE	  IN NUMBER,
    PITITLE        IN VARCHAR2,
    PISHOWAY       IN VARCHAR2,
    PIDLDWAY       IN NUMBER,
    PIDLDNEY       IN NUMBER,
    PIISFREE       IN NUMBER,
    PISHOWTIME     IN NUMBER,
	PISUID1        IN VARCHAR2,
	PILUID1        IN VARCHAR2
 )
AS
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR2(21);
PISTRSPLIT VARCHAR2(2);
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIPTMSGID_P NUMBER(22,0);

BEGIN

PISTRSPLIT := ',';
PISHOUJI_P := PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;

IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
/*
SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASKSR');
IF ICOUNT>0 THEN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
ELSE
  RETURN;
END IF;
*/
IF (PISHOUJI_P IS NULL) THEN
   PISHOUJI_P := ' ';
END IF;
IF (PIPHONECOUNT < 1) THEN--手机号码为空
  RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--单发
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
    RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
    MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
    VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI_P, PIPTMSGID_P, PIMESSAGE,PISENDSTATUS,
    PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
    PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,
    PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
ELSE --群发
  PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
  PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
    IF PILOCATION > 0 THEN
      PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);
      IF (PIRESULTPHONE IS NULL) THEN
        PIRESULTPHONE := ' ';
      END IF;
      ICOUNT:=0;
      SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;

      IF ICOUNT<1 THEN
        INSERT INTO TMP_MTTASKSR("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
        RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
        MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
        VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PIPTMSGID_P,PIMESSAGE,PISENDSTATUS,PIRETFLAG,
        PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,
        PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
      END IF;
      PIPTMSGID_P := PIPTMSGID_P+1;
    END IF;
  END LOOP;
  INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS, RETFLAG,
  PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
  SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
  A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
  A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1 FROM TMP_MTTASKSR A;
  COMMIT;
END IF;
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTTASKSRV5
 (
    PIUID          IN NUMBER,
    PIPTMSGID      IN NUMBER,
    PISENDSTATUS   IN NUMBER,
    PIRETFLAG      IN NUMBER,
    PIPKTOTAL      IN NUMBER,
    PIPHONECOUNT   IN NUMBER,
    PIECID         IN NUMBER,
    PIUSERID       IN VARCHAR2,
    PISPGATE       IN VARCHAR2,
    PICPNO         IN VARCHAR2,
    PIRECVMTTIME   IN VARCHAR2,
    PIMESSAGE      IN VARCHAR2,
    PISHOUJI       IN VARCHAR2,
    PIFEEFLAG      IN NUMBER,
    PIPKNUMBER     IN NUMBER,
    PISENDLEVEL    IN NUMBER,
    PITASKID       IN NUMBER,
    PIERCODE       IN VARCHAR2,
    PITPUDHI       IN NUMBER,
    PILONGMSGSEQ   IN NUMBER,
    PIMSGFMT       IN NUMBER,
    PIUNICOM       IN NUMBER,
    PIMOBILEAREA   IN NUMBER,
    PISVRTYPE      IN VARCHAR2,
    PIP1           IN VARCHAR2,
    PIP2           IN VARCHAR2,
    PIP3           IN VARCHAR2,
    PIP4           IN VARCHAR2,
    PIUSERMSGID    IN NUMBER DEFAULT 0,
    PIMODULEID     IN NUMBER DEFAULT 0,
    PIATTIME       IN NUMBER DEFAULT 0,
    PIVALIDTIME    IN NUMBER DEFAULT 0,
    PISENDTYPE     IN NUMBER DEFAULT 1,
    PIBATCHID      IN NUMBER DEFAULT 0,
    PIAREACODE     IN NUMBER DEFAULT 0,
    PICUSTID       IN VARCHAR2,
    PIEXDATA       IN VARCHAR2,
	PISUID1        IN VARCHAR2,
	PILUID1        IN VARCHAR2
 )
AS
PILOCATION PLS_INTEGER;
PISTART PLS_INTEGER;
PIRESULTPHONE VARCHAR2(21);
PISTRSPLIT VARCHAR2(2);
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
PISHOUJI_P VARCHAR2(3500);
PIPTMSGID_P NUMBER(22,0);

BEGIN

PISTRSPLIT := ',';
PISHOUJI_P := PISHOUJI;
PIPTMSGID_P:=PIPTMSGID;

IF PIRECVMTTIME IS NULL THEN
   PIRECVMTTIME_P:=SYSTIMESTAMP;
ELSE
   PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
END IF;
/*
SELECT  COUNT(*) INTO ICOUNT FROM USER_TABLES T WHERE UPPER(T.TABLE_NAME)=UPPER('TMP_MTTASKSR');
IF ICOUNT>0 THEN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
ELSE
  RETURN;
END IF;
*/
IF (PISHOUJI_P IS NULL) THEN
   PISHOUJI_P := ' ';
END IF;
IF (PIPHONECOUNT < 1) THEN--手机号码为空
  RETURN;
END IF;

IF PIPHONECOUNT = 1 THEN--单发
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;
  IF ICOUNT<1 THEN
    INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
    RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
    MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
    VALUES(PIUID,PIUSERID, PISPGATE, PICPNO, PISHOUJI_P, PIPTMSGID_P, PIMESSAGE,PISENDSTATUS,
    PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PIECID, PIFEEFLAG, PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,
    PILONGMSGSEQ,PIMSGFMT,PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,
    PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1);
  END IF;
ELSE --群发
  PISHOUJI_P := PISTRSPLIT||PISHOUJI_P||PISTRSPLIT;
  PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT);
  WHILE PILOCATION <> 0 LOOP--拆分手机号码
    PISTART := PILOCATION;
    PILOCATION := INSTR(PISHOUJI_P,PISTRSPLIT,PISTART+1);
    IF PILOCATION > 0 THEN
      PIRESULTPHONE := SUBSTR(PISHOUJI_P,PISTART+1,PILOCATION-PISTART-1);
      IF (PIRESULTPHONE IS NULL) THEN
        PIRESULTPHONE := ' ';
      END IF;
      ICOUNT:=0;
      SELECT COUNT(PTMSGID) INTO ICOUNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID_P;

      IF ICOUNT<1 THEN
        INSERT INTO TMP_MTTASKSR("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS,
        RETFLAG, PKNUMBER, PKTOTAL, RECVMTTIME,ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,
        MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE)
        VALUES(PIUID,PIUSERID,PISPGATE,PICPNO,PIRESULTPHONE,PIPTMSGID_P,PIMESSAGE,PISENDSTATUS,PIRETFLAG,
        PIPKNUMBER,PIPKTOTAL,PIRECVMTTIME_P,PIECID,PIFEEFLAG,PISENDLEVEL,PITASKID,PIERCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,
        PIUNICOM,PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE);
      END IF;
      PIPTMSGID_P := PIPTMSGID_P+1;
    END IF;
  END LOOP;
  INSERT INTO GW_MT_TASK_BAK("UID",USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE,SENDSTATUS, RETFLAG,
  PKNUMBER, PKTOTAL, RECVMTTIME, ECID, FEEFLAG, SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,
  UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1)
  SELECT A."UID",A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
  A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,
  A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1 FROM TMP_MTTASKSR A;
  COMMIT;
END IF;
  EXECUTE IMMEDIATE 'TRUNCATE TABLE TMP_MTTASKSR';
END;
/

CREATE OR REPLACE PROCEDURE GW_WR_MTLVLQUEV4
 (
   PIUID        IN NUMBER,
   PIPTMSGID    IN NUMBER,
   PIRETFLAG    IN NUMBER,
   PIPKTOTAL    IN NUMBER,
   PIPHONECOUNT IN NUMBER,
   PISENDSTATUS IN NUMBER,
   PISPLITFLAG  IN NUMBER,
   PIECID       IN NUMBER,
   PIUSERID     IN VARCHAR2,
   PISPGATE     IN VARCHAR2,
   PICPNO       IN VARCHAR2,
   PIRECVMTTIME IN VARCHAR2,
   PIPHONE      IN VARCHAR2,
   PIMESSAGE    IN VARCHAR2,
   PIFEEFLAG    IN NUMBER,
   PIDESTUID    IN NUMBER,
   PILOGINUID   IN NUMBER,
   PIPKNUMBER   IN NUMBER,
   PISENDLEVEL  IN NUMBER,
   PITPUDHI     IN NUMBER,
   PITASKID     IN NUMBER,
   PILONGMSGSEQ IN NUMBER,
   PIMSGFMT     IN NUMBER,
   PITOTALCOUNT IN NUMBER,
   PISVRTYPE      IN VARCHAR2,
   PIP1           IN VARCHAR2,
   PIP2           IN VARCHAR2,
   PIP3           IN VARCHAR2,
   PIP4           IN VARCHAR2,
   PIUSERMSGID    IN NUMBER DEFAULT 0,
   PIMODULEID     IN NUMBER DEFAULT 0,
   PIATTIME       IN NUMBER DEFAULT 0,
   PIVALIDTIME    IN NUMBER DEFAULT 0,
   PISENDTYPE     IN NUMBER DEFAULT 1,
   PIBATCHID      IN NUMBER DEFAULT 0,
   PIAREACODE     IN NUMBER DEFAULT 0,
   PICUSTID       IN MT_LEVEL0_QUEUE.CUSTID%TYPE,
   PIEXDATA       IN MT_LEVEL0_QUEUE.EXDATA%TYPE,
   PILONGMSG 	  IN VARCHAR2,
   PITMPLID	   	  IN NUMBER,
   PICHGRADE	  IN NUMBER,
   PIMSGTYPE	  IN NUMBER,
   PIRMSVALIDTM   IN NUMBER,
   PIPROTOCOLVER  IN NUMBER,
   PITMPLTYPE	  IN NUMBER,
   PITITLE        IN VARCHAR2,
   PISHOWAY       IN VARCHAR2,
   PIDLDWAY       IN NUMBER,
   PIDLDNEY       IN NUMBER,
   PIISFREE       IN NUMBER,
   PISHOWTIME     IN NUMBER,
   PISUID1		  IN VARCHAR2,
   PILUID1		  IN VARCHAR2,
   PITABLENO   	  IN NUMBER
 )
AS
PIRECVMTTIME_P TIMESTAMP(6);
ICOUNT PLS_INTEGER;
BEGIN
  IF PITABLENO = 0 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL0_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL0_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 1 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL1_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL1_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 2 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL2_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL2_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 3 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL3_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL3_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 4 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL4_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL4_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 5 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL5_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL5_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 6 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL6_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL6_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 7 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL7_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL7_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 8 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL8_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL8_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
  ELSIF PITABLENO = 9 THEN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_LEVEL9_QUEUE WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
       INSERT INTO /*+APPEND*/ MT_LEVEL9_QUEUE("UID", USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
       PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,
       MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME,SUID1,LUID1)
       VALUES(PIUID, PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE, PIRETFLAG, PIPKTOTAL, PITOTALCOUNT, PIPHONECOUNT,
       PIRECVMTTIME_P, PISENDSTATUS, PISPLITFLAG, PIECID, PIFEEFLAG, PIDESTUID,PILOGINUID,PIPKNUMBER,PITPUDHI,PISENDLEVEL,PITASKID,
       PILONGMSGSEQ,PIMSGFMT,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME,PISUID1,PILUID1);
  END IF;
END IF;
END;
/


CREATE OR REPLACE PROCEDURE GW_WRMTTASKCV3
 (
  PIUID          IN NUMBER,
  PIPTMSGID      IN NUMBER,
  PISENDSTATUS   IN NUMBER,
  PIRETFLAG      IN NUMBER,
  PIPKNUMBER     IN NUMBER,
  PIPKTOTAL      IN NUMBER,
  PIPHONECOUNT   IN NUMBER,
  PIUSERID       IN VARCHAR2,
  PISPGATE       IN VARCHAR2,
  PICPNO         IN VARCHAR2,
  PIRECVMTTIME   IN VARCHAR2,
  PIPHONE        IN VARCHAR2,
  PIMESSAGE      IN VARCHAR2,
  PITPUDHI       IN NUMBER,
  PILOGINID      IN VARCHAR2,
  PITRANSMTTIME  IN TIMESTAMP,
  PIMSGFMT       IN NUMBER,
  PILONGMSGSEQ   IN NUMBER,
  PIUSERMSGID    IN NUMBER DEFAULT 0,
  PIMODULEID     IN NUMBER DEFAULT 0,
  PISENDLEVEL    IN NUMBER DEFAULT 5,
  PIVALIDTIME    IN NUMBER DEFAULT 0,
  PIUNICOM       IN NUMBER DEFAULT 0,
  PITASKID       IN NUMBER DEFAULT 0,
  PIMOBILEAREA   IN NUMBER DEFAULT 0,
  PINETERRORCNT       IN NUMBER DEFAULT 0,
  PISUBMITERRORCNT   IN NUMBER DEFAULT 0,
  PICUSTID     IN MT_TASK_C.CUSTID%TYPE,
  PIEXDATA    IN MT_TASK_C.EXDATA%TYPE,
  P_MSGTYPE   IN NUMBER DEFAULT 0,
  P_VALIDTM   IN NUMBER DEFAULT 0,
  P_TMPLID   IN NUMBER DEFAULT 0,
  P_PROTOCOLVER   IN NUMBER DEFAULT 0,
  P_TITLE      IN VARCHAR2,
  P_SHOWAY      IN VARCHAR2,
  P_DLDWAY   IN NUMBER DEFAULT 0,
  P_DLDNEY   IN NUMBER DEFAULT 0,
  P_ISFREE   IN NUMBER DEFAULT 0,
  P_SHOWTIME   IN NUMBER DEFAULT 0
 )
AS
--TO_DATE(NVL(PISENDTIME,' '),'YYYY-MM-DD HH24:MI:SS.FF')
ICOUNT PLS_INTEGER;
PIRECVMTTIME_P TIMESTAMP(6);
BEGIN
  ICOUNT:=0;
  SELECT COUNT(PTMSGID) INTO ICOUNT FROM MT_TASK_C WHERE PTMSGID = PIPTMSGID;
  IF ICOUNT<1 THEN
    IF (PIRECVMTTIME IS NULL) THEN
       PIRECVMTTIME_P:=SYSTIMESTAMP;
    ELSE
       PIRECVMTTIME_P:=TO_TIMESTAMP(PIRECVMTTIME,'YYYY-MM-DD HH24:MI:SS.FF');
    END IF;
    INSERT INTO MT_TASK_C("UID", LOGINID, USERID, SPGATE, CPNO, SHOUJI, PTMSGID, MESSAGE,
    SENDSTATUS, RETFLAG, PKNUMBER, PKTOTAL, SENDTIME, TPUDHI, LONGMSGSEQ,TRANSMTTIME, MSGFMT,USERMSGID,MODULEID,SENDLEVEL,VALIDTIME,UNICOM ,TASKID ,MOBILEAREA,NETERRORCNT,SUBMITERRORCNT,CUSTID,EXDATA,MSGTYPE,VALIDTM,TMPLID,PROTOCOLVER,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME)
    VALUES(PIUID, PILOGINID,PIUSERID, PISPGATE, PICPNO, PIPHONE, PIPTMSGID, PIMESSAGE,
    PISENDSTATUS, PIRETFLAG, PIPKNUMBER, PIPKTOTAL, PIRECVMTTIME_P, PITPUDHI, PILONGMSGSEQ,PITRANSMTTIME, PIMSGFMT,PIUSERMSGID,PIMODULEID,PISENDLEVEL,PIVALIDTIME,PIUNICOM ,PITASKID ,PIMOBILEAREA ,PINETERRORCNT,PISUBMITERRORCNT,PICUSTID,PIEXDATA,P_MSGTYPE,P_VALIDTM,P_TMPLID,P_PROTOCOLVER,P_TITLE,P_SHOWAY,P_DLDWAY,P_DLDNEY,P_ISFREE,P_SHOWTIME);
  END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_TAB_COLS WHERE TABLE_NAME='GT_PORT_USED' AND COLUMN_NAME='SIGNSTR';
IF I=1 THEN
   EXECUTE IMMEDIATE 'ALTER TABLE GT_PORT_USED MODIFY (SIGNSTR VARCHAR2(60))';
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_TAB_COLS WHERE TABLE_NAME='GT_PORT_USED' AND COLUMN_NAME='ENSIGNSTR';
IF I=1 THEN
   EXECUTE IMMEDIATE 'ALTER TABLE GT_PORT_USED MODIFY (ENSIGNSTR VARCHAR2(60))';
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_TAB_COLS WHERE TABLE_NAME='XT_GATE_QUEUE' AND COLUMN_NAME='SIGNSTR';
IF I=1 THEN
   EXECUTE IMMEDIATE 'ALTER TABLE XT_GATE_QUEUE MODIFY (SIGNSTR VARCHAR2(60))';
END IF;
END;
/

DECLARE I INT;
BEGIN
SELECT COUNT(*) INTO I FROM USER_TAB_COLS WHERE TABLE_NAME='XT_GATE_QUEUE' AND COLUMN_NAME='ENSIGNSTR';
IF I=1 THEN
   EXECUTE IMMEDIATE 'ALTER TABLE XT_GATE_QUEUE MODIFY (ENSIGNSTR VARCHAR2(60))';
END IF;
END;
/

-------------------增加版本信息-------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM VERSION_CMPP WHERE VERSION='4.06.06';
  IF VERSION < 1 THEN
    INSERT INTO VERSION_CMPP (VERSION,VERSIONDATE,UPGRADETIME)
    VALUES ('4.06.06',TO_CHAR(SYSDATE,'YYYY-MM-DD'),TO_CHAR(SYSDATE,'HH24:MI:SS'));
  END IF;
  COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE COMPILE_PROCEDURE
AS
V_SQL VARCHAR2(2000);
BEGIN

  FOR V IN (SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE IN ('PROCEDURE','TRIGGER') AND STATUS='INVALID' AND OBJECT_NAME NOT LIKE '%BIN$%')
    LOOP
      V_SQL:= 'ALTER  '||V.OBJECT_TYPE||' '|| V.OBJECT_NAME||' COMPILE';
      EXECUTE IMMEDIATE V_SQL;
    END LOOP;
END;
/
CALL COMPILE_PROCEDURE();
/

-------------------增加版本信息-------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM VERSION_CMPP WHERE VERSION='4.06.07';
  IF VERSION < 1 THEN
    INSERT INTO VERSION_CMPP (VERSION,VERSIONDATE,UPGRADETIME)
    VALUES ('4.06.07',TO_CHAR(SYSDATE,'YYYY-MM-DD'),TO_CHAR(SYSDATE,'HH24:MI:SS'));
  END IF;
  COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE COMPILE_PROCEDURE
AS
V_SQL VARCHAR2(2000);
BEGIN

  FOR V IN (SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE IN ('PROCEDURE','TRIGGER') AND STATUS='INVALID' AND OBJECT_NAME NOT LIKE '%BIN$%')
    LOOP
      V_SQL:= 'ALTER  '||V.OBJECT_TYPE||' '|| V.OBJECT_NAME||' COMPILE';
      EXECUTE IMMEDIATE V_SQL;
    END LOOP;
END;
/
CALL COMPILE_PROCEDURE();
/

--PROMPT
--PROMPT CREATING PROCEDURE GW_WR_MTTASKBAKV3
--PROMPT ===============================
--PROMPT
CREATE OR REPLACE PROCEDURE GW_WR_MTTASKBAKV3
 (
    PIUID         IN GW_MT_TASK_BAK."UID"%TYPE,
    PIPTMSGID     IN GW_MT_TASK_BAK.PTMSGID%TYPE,
    PIECID        IN GW_MT_TASK_BAK.ECID%TYPE,
    PISENDSTATUS  IN GW_MT_TASK_BAK.SENDSTATUS%TYPE,
    PIRETFLAG     IN GW_MT_TASK_BAK.RETFLAG%TYPE,
    PIPKNUMBER    IN GW_MT_TASK_BAK.PKNUMBER%TYPE,
    PIPKTOTAL     IN GW_MT_TASK_BAK.PKTOTAL%TYPE,
    PIFEEFLAG     IN GW_MT_TASK_BAK.FEEFLAG%TYPE,
    PISENDLEVEL   IN GW_MT_TASK_BAK.SENDLEVEL%TYPE,
    PIRECVMTTIME  IN GW_MT_TASK_BAK.RECVMTTIME%TYPE,
    PIUSERID      IN GW_MT_TASK_BAK.USERID%TYPE,
    PISPGATE      IN GW_MT_TASK_BAK.SPGATE%TYPE,
    PICPNO        IN GW_MT_TASK_BAK.CPNO%TYPE,
    PIPHONE       IN GW_MT_TASK_BAK.PHONE%TYPE,
    PIMESSAGE     IN GW_MT_TASK_BAK.MESSAGE%TYPE,
    PITASKID      IN GW_MT_TASK_BAK.TASKID%TYPE,
    PIERRORCODE   IN GW_MT_TASK_BAK.ERRORCODE%TYPE,
    PITPUDHI      IN GW_MT_TASK_BAK.TPUDHI%TYPE,
    PILONGMSGSEQ  IN GW_MT_TASK_BAK.LONGMSGSEQ%TYPE,
    PIMSGFMT      IN GW_MT_TASK_BAK.MSGFMT%TYPE,
    PIUNICOM      IN GW_MT_TASK_BAK.UNICOM%TYPE,
    PIMOBILEAREA  IN GW_MT_TASK_BAK.MOBILEAREA%TYPE,
    PISVRTYPE     IN GW_MT_TASK_BAK.SVRTYPE%TYPE,
    PIP1          IN GW_MT_TASK_BAK.P1%TYPE,
    PIP2          IN GW_MT_TASK_BAK.P2%TYPE,
    PIP3          IN GW_MT_TASK_BAK.P3%TYPE,
    PIP4          IN GW_MT_TASK_BAK.P4%TYPE,
    PIUSERMSGID   IN GW_MT_TASK_BAK.USERMSGID%TYPE,
    PIMODULEID    IN GW_MT_TASK_BAK.MODULEID%TYPE,
    PIATTIME      IN GW_MT_TASK_BAK.ATTIME%TYPE,
    PIVALIDTIME   IN GW_MT_TASK_BAK.VALIDTIME%TYPE,
    PISENDTYPE    IN GW_MT_TASK_BAK.SENDTYPE%TYPE,
    PIBATCHID     IN GW_MT_TASK_BAK.BATCHID%TYPE,
    PIAREACODE    IN GW_MT_TASK_BAK.AREACODE%TYPE,
    PICUSTID     IN GW_MT_TASK_BAK.CUSTID%TYPE,
    PIEXDATA    IN GW_MT_TASK_BAK.EXDATA%TYPE,
	PISUID1    IN GW_MT_TASK_BAK.SUID1%TYPE,
	PILUID1    IN GW_MT_TASK_BAK.LUID1%TYPE,
	PILONGMSG 	  IN GW_MT_TASK_BAK.LONGMSG%TYPE,
    PITMPLID 	  IN GW_MT_TASK_BAK.TMPLID %TYPE,
    PICHGRADE     IN GW_MT_TASK_BAK.CHGRADE%TYPE,
    PIMSGTYPE     IN GW_MT_TASK_BAK.MSGTYPE%TYPE,
    PIRMSVALIDTM  IN GW_MT_TASK_BAK.RMSVALIDTM%TYPE,
    PIRMSRPTFLAG  IN GW_MT_TASK_BAK.RMSRPTFLAG%TYPE,
    PIPROTOCOLVER IN GW_MT_TASK_BAK.PROTOCOLVER%TYPE,
    PITMPLTYPE    IN GW_MT_TASK_BAK.TMPLTYPE%TYPE,
    PITITLE 	  IN GW_MT_TASK_BAK.TITLE%TYPE,
    PISHOWAY      IN GW_MT_TASK_BAK.SHOWAY%TYPE,
    PIDLDWAY 	  IN GW_MT_TASK_BAK.DLDWAY%TYPE,
    PIDLDNEY 	  IN GW_MT_TASK_BAK.DLDNEY%TYPE,
    PIISFREE 	  IN GW_MT_TASK_BAK.ISFREE%TYPE,
    PISHOWTIME 	  IN GW_MT_TASK_BAK.SHOWTIME%TYPE
 )
AS
  PICNT NUMBER;
  BEGIN
    SELECT COUNT(ID) INTO PICNT FROM GW_MT_TASK_BAK WHERE PTMSGID=PIPTMSGID;
  IF PICNT=0 THEN	---不存在则往GW_MT_TASK_BAK表里插入数据
    INSERT INTO GW_MT_TASK_BAK("UID",PTMSGID,ECID,SENDSTATUS,RETFLAG,PKNUMBER,PKTOTAL,FEEFLAG,SENDLEVEL,
    RECVMTTIME,USERID,SPGATE,CPNO,PHONE,MESSAGE,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,
    MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA,SUID1,LUID1,
	LONGMSG,TMPLID,CHGRADE,MSGTYPE,RMSVALIDTM,RMSRPTFLAG,PROTOCOLVER,TMPLTYPE,TITLE,SHOWAY,DLDWAY,DLDNEY,ISFREE,SHOWTIME)
    VALUES(PIUID,PIPTMSGID,PIECID,PISENDSTATUS,PIRETFLAG,PIPKNUMBER,PIPKTOTAL,PIFEEFLAG,PISENDLEVEL,PIRECVMTTIME,
    PIUSERID,PISPGATE,PICPNO,PIPHONE,PIMESSAGE,PITASKID,PIERRORCODE,PITPUDHI,PILONGMSGSEQ,PIMSGFMT,PIUNICOM,
    PIMOBILEAREA,PISVRTYPE,PIP1,PIP2,PIP3,PIP4,PIUSERMSGID,PIMODULEID,PIATTIME,PIVALIDTIME,PISENDTYPE,PIBATCHID,PIAREACODE,PICUSTID,PIEXDATA,PISUID1,PILUID1,
	PILONGMSG,PITMPLID,PICHGRADE,PIMSGTYPE,PIRMSVALIDTM,PIRMSRPTFLAG,PIPROTOCOLVER,PITMPLTYPE,PITITLE,PISHOWAY,PIDLDWAY,PIDLDNEY,PIISFREE,PISHOWTIME);
  END IF;
END;
/

-------------------增加版本信息-------------------------------------------
DECLARE
  VERSION INT;
BEGIN
  SELECT COUNT(*) INTO VERSION FROM VERSION_CMPP WHERE VERSION='4.06.08';
  IF VERSION < 1 THEN
    INSERT INTO VERSION_CMPP (VERSION,VERSIONDATE,UPGRADETIME)
    VALUES ('4.06.08',TO_CHAR(SYSDATE,'YYYY-MM-DD'),TO_CHAR(SYSDATE,'HH24:MI:SS'));
  END IF;
  COMMIT;
END;
/

CREATE OR REPLACE PROCEDURE COMPILE_PROCEDURE
AS
V_SQL VARCHAR2(2000);
BEGIN

  FOR V IN (SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE IN ('PROCEDURE','TRIGGER') AND STATUS='INVALID' AND OBJECT_NAME NOT LIKE '%BIN$%')
    LOOP
      V_SQL:= 'ALTER  '||V.OBJECT_TYPE||' '|| V.OBJECT_NAME||' COMPILE';
      EXECUTE IMMEDIATE V_SQL;
    END LOOP;
END;
/
CALL COMPILE_PROCEDURE();
/