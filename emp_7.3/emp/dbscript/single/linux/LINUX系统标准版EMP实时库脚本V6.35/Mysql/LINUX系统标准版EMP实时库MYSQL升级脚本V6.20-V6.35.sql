/*****V6.20-V6.21 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.21',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

/*网关升级脚本(V4.04.06-V4.05.02)START*/

DELIMITER ;;
DROP PROCEDURE IF EXISTS COLUMNADD; 
CREATE DEFINER=`root`@`%` PROCEDURE `COLUMNADD`(TBNAME VARCHAR(15),COLNAME VARCHAR(32),COLTYPE VARCHAR(64))
BEGIN
DECLARE  CURRENTDATABASE VARCHAR(100);
DECLARE  P_STR VARCHAR(300);
SELECT DATABASE() INTO CURRENTDATABASE;
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA=CURRENTDATABASE AND TABLE_NAME = TBNAME AND COLUMN_NAME =COLNAME) THEN  
   SET P_STR= CONCAT('ALTER TABLE ',TBNAME,' ADD ',COLNAME ,' ',COLTYPE);
   SET @SQL = P_STR;
   PREPARE STMT FROM @SQL;
   EXECUTE STMT;
   DEALLOCATE PREPARE STMT;
END IF; 
END;;
DELIMITER ;

CALL COLUMNADD('GW_USERPROPERTY','CACERTNAME','VARCHAR(256)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('GW_USERPROPERTY','VERIFYPEER','TINYINT      NOT NULL  DEFAULT 1');
CALL COLUMNADD('GW_USERPROPERTY','VERIFYHOST','TINYINT      NOT NULL  DEFAULT 1');

CALL COLUMNADD('MT_LEVEL1_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL1_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL1_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL1_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );


CALL COLUMNADD('MT_LEVEL2_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL2_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL2_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL2_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );


CALL COLUMNADD('MT_LEVEL3_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL3_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL3_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL3_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );

CALL COLUMNADD('MT_LEVEL4_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL4_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL4_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL4_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );


CALL COLUMNADD('MT_LEVEL5_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL5_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL5_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL5_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );

CALL COLUMNADD('MT_LEVEL6_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL6_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL6_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL6_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );

CALL COLUMNADD('MT_LEVEL7_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL7_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL7_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL7_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );

CALL COLUMNADD('MT_LEVEL8_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL8_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL8_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL8_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );

CALL COLUMNADD('MT_LEVEL9_QUEUE','CUSTID','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL9_QUEUE','EXDATA','VARCHAR(64)     NOT NULL  DEFAULT ''''');
CALL COLUMNADD('MT_LEVEL9_QUEUE','ATTIME',' BIGINT(20)  NOT NULL DEFAULT ''0'' AFTER MODULEID ' );
CALL COLUMNADD('MT_LEVEL9_QUEUE','VALIDTIME',' BIGINT(20) NOT NULL DEFAULT ''0'' AFTER ATTIME ' );


CREATE TABLE IF NOT  EXISTS `GW_TDCMD` (
  `ID` INT(11) NOT NULL AUTO_INCREMENT,
  `TD_CMD` VARCHAR(64)  NOT NULL  DEFAULT 'TD',
  `TD_USERID` VARCHAR(11) NOT NULL DEFAULT '000000',
  `TD_SPNUMBER` VARCHAR(21) NOT NULL DEFAULT ' ' ,
  `TD_ECID` INT(11) NOT NULL DEFAULT 0,
  `TD_TIMES` INT(11) NOT NULL DEFAULT 1,
  `MATCHTYPE` TINYINT NOT NULL DEFAULT 0,
  `OPTYPE` TINYINT NOT NULL DEFAULT 0,
  `PB_USERID` VARCHAR(11) NOT NULL DEFAULT '000000',
  `PB_SPNUMBER` VARCHAR(11) NOT NULL DEFAULT ' ',
  `PB_SVRTYPE` VARCHAR(64)  NOT NULL  DEFAULT ' ',
  `PB_CROPCODE` VARCHAR(64)  NOT NULL  DEFAULT ' ',
  `STATUS` TINYINT NOT NULL DEFAULT 0,
   PRIMARY KEY  (`ID`),
   KEY `IDX_CUSE`(`TD_CMD`,`TD_USERID`,`TD_SPNUMBER`,`TD_ECID`)
) ENGINE=INNODB DEFAULT CHARSET=GBK COMMENT='退订指令表';

CREATE TABLE IF NOT  EXISTS `GW_TDCMD_HIS` (
  `ID` INT(11) NOT NULL AUTO_INCREMENT,
  `TD_PHONE`  BIGINT(20) NOT NULL DEFAULT 0,
  `TD_CMD` VARCHAR(64)  NOT NULL  DEFAULT 'TD',
  `TD_USERID` VARCHAR(11) NOT NULL DEFAULT '000000',
  `TD_SPNUMBER` VARCHAR(21) NOT NULL DEFAULT ' ' ,
  `TD_ECID` INT(11) NOT NULL DEFAULT 0,
  `OPTYPE` TINYINT NOT NULL DEFAULT 0,
  `MO_MSGID` BIGINT(20) NOT NULL DEFAULT 0,
  `TD_TIME` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
   PRIMARY KEY  (`ID`),
   KEY `IDX_PCUSE`(`TD_PHONE`,`TD_CMD`,`TD_USERID`,`TD_SPNUMBER`,`TD_ECID`)
) ENGINE=INNODB DEFAULT CHARSET=GBK COMMENT='上行退订操作历史记录表';



INSERT INTO A_PROTOCOLTMPL (PROTOCOLCODE, PROTOCOL, PROTOCOLPARAM)
SELECT 8, 'SMPP3X', 'EXPIREHOUR=24;OUTDBGINFO=3;RETURNMOUDHI=0' FROM DUAL WHERE NOT EXISTS (SELECT PROTOCOLCODE FROM A_PROTOCOLTMPL WHERE PROTOCOLCODE=8);

REPLACE INTO A_GWPARAMCONF(PARAMITEM, PARAMNAME,  PARAMMEMO,PARAMATTRIBUTE, VALUERANGE,DEFAULTVALUE,  CONTROLTYPE, GWTYPE) 
VALUES('FILTERB01TDMO', '开启上行退订功能',  '是否开启上行回复退订，手机号自动添加黑名单功能 (0不启用、1启用)',1, '0,1','0',1,4000);
INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'FILTERB01TDMO','0' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='FILTERB01TDMO' AND  GWTYPE=4000) AND  GWTYPE=4000;

REPLACE INTO A_GWPARAMCONF(PARAMITEM, PARAMNAME,  PARAMMEMO,PARAMATTRIBUTE, VALUERANGE,DEFAULTVALUE,  CONTROLTYPE, GWTYPE) 
VALUES('QUERY01SPDCTRL', '开启查询接口控速',  '对频繁调用获取上行、状态报告、查费接口进行控速(0不启用、1启用)',1, '0,1','1',1,4000);
INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'QUERY01SPDCTRL','1' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='QUERY01SPDCTRL' AND  GWTYPE=4000) AND  GWTYPE=4000;

REPLACE INTO A_GWPARAMCONF(PARAMITEM, PARAMNAME,  PARAMMEMO,PARAMATTRIBUTE, VALUERANGE,DEFAULTVALUE,  CONTROLTYPE, GWTYPE) 
VALUES('QUERY02FREQ', '允许调用查询接口频率',  '在无数据获取时，允许连续调用查询接口的频率(1-120/秒/次)',1, '1-120','10',0,4000);
INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'QUERY02FREQ','10' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='QUERY02FREQ' AND  GWTYPE=4000) AND  GWTYPE=4000;

REPLACE INTO A_GWPARAMCONF(PARAMITEM, PARAMNAME,  PARAMMEMO,PARAMATTRIBUTE, VALUERANGE,DEFAULTVALUE,  CONTROLTYPE, GWTYPE) 
VALUES('QUERY03DELAY', '查询延时回应时长',  '当频繁调用查询接口时，网关对查询回应延时回应(1-120/秒)',1, '1-120','30',0,4000);
INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'QUERY03DELAY','30' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='QUERY03DELAY' AND  GWTYPE=4000) AND  GWTYPE=4000;

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_GETURLBINDV1;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_GETURLBINDV1`(
   PIUID INT, 
    PISPTYPE INT 
    )
BEGIN
	IF PIUID=0 THEN ##加载所有绑定了URL的帐号
		SELECT UD.UID,UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
		CASE WHEN (IFNULL(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE '' END AS MOURL,
		CASE WHEN (IFNULL(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE '' END AS RPTURL,
		GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
		GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,UD.PUSHVERSION,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST 
		FROM USERDATA UD INNER JOIN 	GW_USERPROPERTY GU ON GU.USERID=UD.USERID WHERE UD.USERTYPE=0 AND UD.STATUS=0 
		AND ((IFNULL(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) OR (IFNULL(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2)) 
		AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD.UID;
	ELSE ##加载指定UID的URL绑定情况
		SELECT UD.UID,UD.USERID,UD.USERPASSWORD AS PWD,UD.MTURL,
		CASE WHEN (IFNULL(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) THEN UD.MOURL ELSE '' END AS MOURL,
		CASE WHEN (IFNULL(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2) THEN UD.RPTURL ELSE '' END AS RPTURL,
		GU.ECID,GU.PWDENCODE,GU.PWDENCODESTR,GU.MSGCODE,GU.MSGENCODE,GU.PUSHMOFMT,GU.PUSHRPTFMT,GU.PUSHPWDENCODE,GU.PUSHPWDENCODESTR,GU.PUSHMSGCODE,GU.PUSHMSGENCODE,
		GU.PUSHFAILCNT,GU.PUSHSLIDEWND,GU.PUSHMOMAXCNT,GU.PUSHRPTMAXCNT,GU.GETMOMAXCNT,GU.GETRPTMAXCNT,UD.PUSHVERSION,GU.CACERTNAME,GU.VERIFYPEER,GU.VERIFYHOST 
		FROM USERDATA UD INNER JOIN 	GW_USERPROPERTY GU ON GU.USERID=UD.USERID WHERE UD.UID=PIUID AND UD.USERTYPE=0 AND UD.STATUS=0 
		AND ((IFNULL(UD.MOURL,'')<>'' AND UD.TRANSMOTYPE=2) OR (IFNULL(UD.RPTURL,'')<>'' AND UD.TRANSRPTYPE=2))
		AND UD.ACCOUNTTYPE=PISPTYPE ORDER BY UD.UID;
		END IF;
END;;
DELIMITER ;

##加载GW_TDCMD表TD_CMD、MATCHTYPE字段的存储过程
DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_LOADTDCMD;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_LOADTDCMD`(
   PIMAXID BIGINT ,
PIMAXCOLNUM INT
    )
BEGIN
        DECLARE PI_SQLSTR VARCHAR(2000);
	SET PI_SQLSTR = CONCAT('SELECT ID,TD_CMD,MATCHTYPE FROM GW_TDCMD WHERE ID>',PIMAXID, ' ORDER BY ID ASC LIMIT 0, ',PIMAXCOLNUM);
	 SET @SQL = PI_SQLSTR;
         PREPARE SL FROM @SQL;
         EXECUTE SL;
END;;
DELIMITER ;

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_ADDPBLISTBLACK;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_ADDPBLISTBLACK`(
PIPHONE BIGINT,
PITDCMD VARCHAR(64),
PIUSERID VARCHAR(11),
PISPNUMBER VARCHAR(21),
PISVRTYPE VARCHAR(64),
PIECID INT,
PIMOMSGID BIGINT)

BEGIN

DECLARE PIOPTYPE TINYINT;      
DECLARE PIPBUSERID VARCHAR(11);
DECLARE PIPBSPNUMBER VARCHAR(21);
DECLARE PIPBSVRTYPE VARCHAR(64);
DECLARE PIPBCROPCODE VARCHAR(64);

	
	##表的策略信息决定是否需要添加黑名单
        IF EXISTS(SELECT * FROM GW_TDCMD WHERE TD_CMD=PITDCMD AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0) THEN
             SELECT OPTYPE,PB_USERID,PB_SPNUMBER,PB_SVRTYPE,PB_CROPCODE  INTO PIOPTYPE,PIPBUSERID,PIPBSPNUMBER,PIPBSVRTYPE,PIPBCROPCODE  FROM GW_TDCMD WHERE TD_CMD=PITDCMD AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0 LIMIT 0,1;     

	
		 ##PB_LIST_BLACK表中是否已经存在对应的黑名单数据
		IF NOT EXISTS(SELECT * FROM PB_LIST_BLACK WHERE USERID=PIPBUSERID AND SPGATE='' AND SPNUMBER=PIPBSPNUMBER AND PHONE=PIPHONE AND SVRTYPE=PIPBSVRTYPE AND CORPCODE=PIPBCROPCODE) THEN
		   INSERT INTO PB_LIST_BLACK(USERID,SPGATE,SPNUMBER,PHONE,OPTYPE,OPTTIME,MSG,SVRTYPE,SPISUNCM,CORPCODE,BLTYPE)
		          VALUES(PIPBUSERID,'',PIPBSPNUMBER,PIPHONE,PIOPTYPE,NOW(),'',PIPBSVRTYPE,0,PIPBCROPCODE,1);
		   INSERT INTO GW_TDCMD_HIS(TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID,OPTYPE,MO_MSGID,TD_TIME)
		          VALUES(PIPHONE,PITDCMD,PIUSERID,PISPNUMBER,PIECID,PIOPTYPE,PIMOMSGID,NOW());
                END IF;	
  

        END IF;	
END;;
DELIMITER ;

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_RD_MTLVLQUEV1;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_RD_MTLVLQUEV1`(P_DESTUID INT,
	P_SENDLEVEL INT,
	P_MAXREADCNT INT,
	P_STRUID VARCHAR(4000),P_CURTIME BIGINT,P_TABLENO INT)
BEGIN
    DECLARE P_SQLSTR VARCHAR(4000);
    DECLARE P_TABNAME VARCHAR(20);
    SET P_CURTIME = IFNULL(P_CURTIME, 0);
    IF  P_TABLENO>=0  AND   P_TABLENO<=9 THEN 
       SET P_TABNAME=CONCAT('MT_LEVEL',  CONVERT(P_TABLENO,CHAR(1)),'_QUEUE');
    ELSE
       SET P_TABNAME='MT_LEVEL0_QUEUE';
    END IF;
    SET P_SQLSTR = 'SELECT ID,UID,DESTUID,LOGINUID,ECID,TASKID,FEEFLAG,USERID,SPGATE,CPNO,PHONE,PTMSGID,RETFLAG,TPUDHI,PKNUMBER,PKTOTAL,SENDSTATUS,';
    SET P_SQLSTR = CONCAT(P_SQLSTR,'PHONECOUNT,SPLITFLAG,SENDLEVEL,LONGMSGSEQ,MSGFMT,MESSAGE,SENDTIME AS RECVMTTIME,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA  FROM ',P_TABNAME);
    SET P_SQLSTR = CONCAT(P_SQLSTR,' WHERE DESTUID=', P_DESTUID,' AND UID NOT IN (',P_STRUID,') AND (ATTIME<=',P_CURTIME,' OR ATTIME<0) ');
    SET P_SQLSTR = CONCAT(P_SQLSTR,' AND SENDLEVEL=',P_SENDLEVEL,' LIMIT ',P_MAXREADCNT);

    SET @SQL = P_SQLSTR;
   PREPARE SL FROM @SQL;
    
  EXECUTE SL;

    DEALLOCATE PREPARE SL;
END;;
DELIMITER ;



-- ----------------------------
-- PROCEDURE STRUCTURE FOR S_STATREMAIN
-- ----------------------------
DELIMITER ;;
DROP PROCEDURE  IF EXISTS S_STATREMAIN;
CREATE DEFINER=`root`@`%` PROCEDURE `S_STATREMAIN`(P_PICMD INT)
BEGIN
    CASE P_PICMD
  WHEN 100 THEN
  #--汇总MT_LEVEL0_QUEUE中各帐号数据
 #--前端滞留
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, UID FROM (SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL0_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL1_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL2_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL3_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL4_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL5_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL6_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL7_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL8_QUEUE WHERE UID>0
UNION ALL SELECT UID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL9_QUEUE WHERE UID>0) MQ  GROUP BY UID,SENDLEVEL;
  #--后端滞留
  WHEN 110 THEN
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, DESTUID AS UID FROM (SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL0_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL1_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL2_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL3_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL4_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL5_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL6_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL7_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL8_QUEUE WHERE DESTUID>0
UNION ALL SELECT DESTUID,SENDLEVEL,TOTALCOUNT FROM MT_LEVEL9_QUEUE WHERE DESTUID>0)  MQ GROUP BY DESTUID,SENDLEVEL;
  #--代理滞留
  #--ELSE IF PICMD=120 
  #--SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, LOGINUID AS UID FROM MT_LEVEL0_QUEUE WHERE LOGINUID>0 AND UID<>LOGINUID GROUP BY LOGINUID,SENDLEVEL;

  #--汇总MT_TIMER_QUEUE中各帐号数据
  #--前端滞留
  WHEN 200 THEN
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, UID FROM MT_TIMER_QUEUE WHERE UID>0 GROUP BY UID,SENDLEVEL;
  #--后端滞留
  WHEN 210 THEN
    SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, DESTUID AS UID FROM MT_TIMER_QUEUE WHERE DESTUID>0 GROUP BY DESTUID,SENDLEVEL;
  #--代理滞留
  #--ELSIF PICMD=220 
  #--SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, SENDLEVEL AS LEVEL, LOGINUID AS UID FROM MT_TIMER_QUEUE WHERE LOGINUID>0 AND UID<>LOGINUID GROUP BY LOGINUID,SENDLEVEL;

  #--汇总MO_TASK中各帐号数据
 #--前端滞留
  WHEN 300 THEN
   SELECT COUNT(UID) AS REMAINEDNUM, 0 AS LEVEL, UID FROM MO_TASK WHERE SENDSTATUS=1 AND UID>0 AND ORGUID>0 GROUP BY UID;
 # --后端滞留
  WHEN 310 THEN
   SELECT COUNT(UID) AS REMAINEDNUM, 0 AS LEVEL, ORGUID AS UID FROM MO_TASK WHERE SENDSTATUS=1 AND ORGUID>0 GROUP BY ORGUID;

  #--汇总RPT_WAIT_B中各帐号数据
  #--前端滞留
  WHEN 401 THEN
   SELECT COUNT(UID) AS REMAINEDNUM, 1 AS LEVEL, UID FROM RPT_WAIT_B WHERE UID>0 AND ORGUID>0 GROUP BY UID;
  #--后端滞留
  WHEN 411 THEN
   SELECT COUNT(UID) AS REMAINEDNUM, 1 AS LEVEL, ORGUID AS UID FROM RPT_WAIT_B WHERE ORGUID>0 GROUP BY ORGUID;
  
  WHEN 501 THEN
   SELECT SUM(TOTALCOUNT) AS REMAINEDNUM, 0 AS LEVEL,USERUID AS UID FROM MT_WAIT_A WHERE USERUID>0 GROUP BY USERUID;
   
  WHEN 502 THEN
   SELECT SUM(TOTALNUM-SENDNUM) AS REMAINEDNUM, 0 AS LEVEL,USERUID AS UID FROM BATCH_MT_REQ WHERE USERUID>0 GROUP BY USERUID;
   
  ELSE
   SELECT 0 AS REMAINEDNUM, 0 AS LEVEL, 0 AS UID;
    END CASE;
END;;
DELIMITER ;


DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_WR_MTLVLQUEV2`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_WR_MTLVLQUEV2`(P_PIUID        INT,
   P_PIPTMSGID    BIGINT,
   P_PIRETFLAG    TINYINT UNSIGNED,
   P_PIPKTOTAL    TINYINT UNSIGNED,
   P_PIPHONECOUNT INT,
   P_PISENDSTATUS TINYINT UNSIGNED,
   P_PISPLITFLAG  TINYINT UNSIGNED,
   P_PIECID       INT,
   P_PIUSERID     VARCHAR(11),
   P_PISPGATE     VARCHAR(21),
   P_PICPNO       VARCHAR(21),
   P_PIRECVMTTIME DATETIME,
   P_PIPHONE      VARCHAR(3500),
   P_PIMESSAGE    VARCHAR(3000) CHARSET 'GBK',
   P_PIFEEFLAG    TINYINT UNSIGNED,
   P_PIDESTUID    INT,
   P_PILOGINUID   INT,
   P_PIPKNUMBER   TINYINT UNSIGNED,
   P_PISENDLEVEL  TINYINT UNSIGNED,
   P_PITPUDHI     TINYINT UNSIGNED,
   P_PITASKID     INT,
   P_PILONGMSGSEQ TINYINT UNSIGNED,
   P_PIMSGFMT     TINYINT UNSIGNED,
   P_PITOTALCOUNT INT,
   P_SVRTYPE VARCHAR(64),
   P_P1 VARCHAR(64),
   P_P2 VARCHAR(64),
   P_P3 VARCHAR(64),
   P_P4 VARCHAR(64),
   P_USERMSGID BIGINT,
   P_MODULEID INT,
   P_ATTIME BIGINT,
   P_VALIDTIME BIGINT,
   P_SENDTYPE INT,
   P_BATCHID BIGINT,
   P_AREACODE INT,
   P_CUSTID VARCHAR(64),
  P_EXDATA VARCHAR(64),
P_TABLENO INT)
BEGIN
            DECLARE P_STR NVARCHAR(4000);
            DECLARE P_TMP_PIPTMSGID BIGINT;
           DECLARE P_TABNAME VARCHAR(20);
   
         IF  P_TABLENO>=0  AND   P_TABLENO<=9 THEN 
             SET P_TABNAME=CONCAT('MT_LEVEL',  CONVERT(P_TABLENO,CHAR(1)),'_QUEUE');
         ELSE
             SET P_TABNAME='MT_LEVEL0_QUEUE';
         END IF;

             SET P_STR = CONCAT('SELECT COUNT(*)  INTO @P_TMP_PIPTMSGID  FROM ', P_TABNAME,'  WHERE PTMSGID=',P_PIPTMSGID);
             SET @SQL=P_STR;
         PREPARE SL FROM @SQL;
         EXECUTE SL;
         DEALLOCATE PREPARE SL;
	SET P_TMP_PIPTMSGID=@P_TMP_PIPTMSGID;
        IF P_TMP_PIPTMSGID=0 THEN
	     SET P_STR = CONCAT('INSERT INTO ',P_TABNAME,'(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(',P_PIUID,',''',P_PIUSERID,''',''',P_PISPGATE,''',''',P_PICPNO,''',''', P_PIPHONE,''',' );
         SET P_STR = CONCAT(P_STR, P_PIPTMSGID,',''', P_PIMESSAGE,''',', P_PIRETFLAG,',', P_PIPKTOTAL,',', P_PITOTALCOUNT,',',
	   P_PIPHONECOUNT,',''',P_PIRECVMTTIME,''',', P_PISENDSTATUS,',', P_PISPLITFLAG,',',P_PIECID,',', P_PIFEEFLAG,',',P_PIDESTUID,',',P_PILOGINUID,',',P_PIPKNUMBER,',',
	P_PITPUDHI,',',P_PISENDLEVEL,',',P_PITASKID,',',P_PILONGMSGSEQ,',',P_PIMSGFMT,',''',P_SVRTYPE,''',''',P_P1,''',''',P_P2,''',''',P_P3,''',''',P_P4,''',',P_USERMSGID,',',P_MODULEID,',',P_ATTIME,',',P_VALIDTIME,',',P_SENDTYPE,',',P_BATCHID,',',P_AREACODE,',''',P_CUSTID,''',''',P_EXDATA,''')' );
        SET @SQL=P_STR;
         PREPARE SL FROM @SQL;
         EXECUTE SL;
         DEALLOCATE PREPARE SL;
    END IF;
END;;
DELIMITER ;


DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_H_TRANSFERV1`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_H_TRANSFERV1`(P_MININDEX BIGINT,P_MAXINDEX BIGINT,P_PROCESSFLAG INT,P_LOTSIZE INT)
BEGIN

	DECLARE P_STR VARCHAR(4000);
	DECLARE P_TABLENAME VARCHAR(20);
        DECLARE   CURYM INT;
        DECLARE   MINYM INT;
        DECLARE   MAXYM INT;

        #转移
        SELECT CAST(DATE_FORMAT(MIN(SENDTIME) ,'%Y%m') AS SIGNED) ,CAST(DATE_FORMAT(MAX(SENDTIME) ,'%Y%m') AS SIGNED)  INTO MINYM,MAXYM FROM GW_MT_TASK_BAK WHERE ID BETWEEN P_MININDEX AND P_MAXINDEX;
        SET CURYM = MINYM;
        WHILE CURYM<=MAXYM DO

	SET P_TABLENAME = CONCAT('MTTASK',CURYM );
        SET P_STR = CONCAT('INSERT  INTO ',P_TABLENAME,
			 ' (ID,MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA)
                          SELECT ID, DATE_FORMAT(M.SENDTIME,''%d'') AS MDAY,USERID,SPGATE,CPNO,PHONE,SPMSGID,RETFLAG,FEEFLAG,PKNUMBER,PKTOTAL,SENDSTATUS,SENDFLAG,RECVFLAG,DONEDATE,ERRORCODE,SENDLEVEL,SENDTYPE,UNICOM,SENDTIME,RECVTIME,MESSAGE,TASKID,ECID,PTMSGID,MOBILEAREA,SPID,SVRTYPE,
                          P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,BATCHID,AREACODE,CUSTID,EXDATA
                          FROM GW_MT_TASK_BAK M WHERE CAST(DATE_FORMAT(SENDTIME,''%Y%m'') AS SIGNED)=',CURYM,' AND ID<=',P_MAXINDEX);
#SELECT P_STR;
	SET @SQL=P_STR;
         PREPARE SL FROM @SQL;
         EXECUTE SL;
         DEALLOCATE PREPARE SL;

          IF CAST(SUBSTRING(CAST(CURYM AS CHAR(6)),5,2) AS SIGNED)=12 THEN
                SET CURYM = CAST(CONCAT(CAST(CAST(SUBSTRING(CAST(CURYM AS CHAR(6)),1,4)AS SIGNED)+1 AS CHAR(4)),'01' )AS SIGNED);
          ELSE
               SET CURYM = CURYM+1  ;
          END IF;
        END WHILE;
END;;
DELIMITER ;

DELETE FROM GW_BASEPARA WHERE ID BETWEEN 259 AND 264;
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(259,'RPT',1,'rptreq',3600,'状态报告主动推送',1); 
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(260,'RPT',2,'rptrsp',3600,'rptrsp',1); 
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(261,'RPT',3,'rptrsp',3600,'rptrsp',1); 

INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(262,'MO',1,'moreq',64,'XML中moreq描述',1);  
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(263,'MO',2,'morsp',64,'morsp',1);  
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(264,'MO',3,'morsp',64,'morsp',1); 

DELETE FROM GW_BASEPARA WHERE ID BETWEEN 265 AND 266;
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(265,'RPT',1,'rpt',3600,'rpt',1); 
INSERT INTO GW_BASEPARA(ID,FUNNAME,CMDTYPE, ARGNAME,ARGVALUELEN,ARGDES,ARGTYPE)
            VALUES(266,'MO',1,'mo',64,'mo',1); 
CALL S_WR_VERINFO('4.05.01');
REPLACE INTO A_GWPARAMCONF(PARAMITEM, PARAMNAME,  PARAMMEMO,PARAMATTRIBUTE, VALUERANGE,DEFAULTVALUE,  CONTROLTYPE, GWTYPE) 
VALUES('QUERY04TIMES', '频繁调用次数',  '连续频繁调用次数超过设置值后开启延时回应 (1-100次，默认10次)',2, '1-100','10',0,4000);
INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'QUERY04TIMES','10' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='QUERY04TIMES' AND  GWTYPE=4000) AND  GWTYPE=4000;


UPDATE A_GWPARAMCONF SET PARAMMEMO='对频繁调用获取上行、状态报告接口进行控速(0不启用、1启用)' WHERE PARAMITEM='QUERY01SPDCTRL' AND GWTYPE=4000;
UPDATE A_GWPARAMCONF SET PARAMMEMO='在无数据获取时，允许连续调用查询接口的频率(1-120/秒/次，默认3秒)',DEFAULTVALUE='3' WHERE PARAMITEM='QUERY02FREQ' AND GWTYPE=4000;
UPDATE A_GWPARAMVALUE SET PARAMVALUE=3 WHERE  GWTYPE=4000 AND PARAMITEM='QUERY02FREQ';
UPDATE A_GWPARAMCONF SET PARAMMEMO='当频繁调用查询接口时，网关对查询回应延时回应(1-120/秒)，默认5秒',DEFAULTVALUE='5' WHERE PARAMITEM='QUERY03DELAY' AND GWTYPE=4000;
UPDATE A_GWPARAMVALUE SET PARAMVALUE=5 WHERE  GWTYPE=4000 AND PARAMITEM='QUERY03DELAY';

UPDATE A_GWPARAMCONF SET PARAMMEMO='运营商协议，CMPP-移动,SGIP-联通,SMGP-电信,SMPP-国际协议',DEFAULTVALUE='1-0-0-0',VALUERANGE='CMPP,SMGP,SGIP,SMPP' WHERE PARAMITEM='STARTSVRPROTOCOL' AND GWTYPE=4000;

REPLACE INTO A_GWPARAMCONF (PARAMITEM, PARAMNAME, PARAMATTRIBUTE, PARAMMEMO, DEFAULTVALUE, VALUERANGE, CONTROLTYPE, GWTYPE)
VALUES ('SMPPPORT', 'SMPP监听端口', 0, '移动运营商SMPP监听端口', '8891', ' ', 0, 4000);

INSERT INTO A_GWPARAMVALUE(GWNO, GWTYPE, PARAMITEM, PARAMVALUE)
SELECT DISTINCT GWNO,4000,'SMPPPORT','8891' FROM A_GWPARAMVALUE 
WHERE  NOT EXISTS(SELECT * FROM A_GWPARAMVALUE WHERE PARAMITEM='SMPPPORT' AND  GWTYPE=4000) AND  GWTYPE=4000;
CALL S_WR_VERINFO('4.05.02');


/*网关升级脚本(V4.04.06-V4.05.02)END  */


/*EMP脚本START*/


INSERT LF_PRIVILEGE (PRIVILEGE_ID, RESOURCE_ID, OPERATE_ID, COMMENTS, PRIV_CODE, MENUNAME, MODNAME, MENUCODE, MENUSITE) 
SELECT 2834, 13, 1, '查看', '1900-1470-0', '接入账号查看权限', '网关前端配置', '1900-1470', '/pgb_accessPri.htm' FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_PRIVILEGE WHERE PRIVILEGE_ID=2834);

INSERT LF_PRIVILEGE (PRIVILEGE_ID, RESOURCE_ID, OPERATE_ID, COMMENTS, PRIV_CODE, MENUNAME, MODNAME, MENUCODE, MENUSITE) 
SELECT 2842, 13, NULL, '关系绑定', '1900-1470-1', '接入账号查看权限', '网关前端配置', '1900-1470', NULL FROM DUAL
WHERE NOT EXISTS(SELECT * FROM LF_PRIVILEGE WHERE PRIVILEGE_ID=2842);

INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 1, 2834 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=1 AND PRIVILEGE_ID=2834);
INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 2, 2834 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=2 AND PRIVILEGE_ID=2834);
INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 4, 2834 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=4 AND PRIVILEGE_ID=2834);

INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 1, 2842 FROM DUAL WHERE NOT EXISTS(SELECT * FROM LF_IMPOWER WHERE PRIVILEGE_ID=2842 AND ROLE_ID=1);
INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 2, 2842 FROM DUAL WHERE NOT EXISTS(SELECT * FROM LF_IMPOWER WHERE PRIVILEGE_ID=2842 AND ROLE_ID=2);
INSERT LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 4, 2842 FROM DUAL WHERE NOT EXISTS(SELECT * FROM LF_IMPOWER WHERE PRIVILEGE_ID=2842 AND ROLE_ID=4);

/*下行记录查询权限*/
DROP TABLE IF EXISTS `LF_MT_PRI`;
CREATE TABLE `LF_MT_PRI` (
	ID	BIGINT(20) NOT NULL AUTO_INCREMENT,/*标识列ID*/
	SPUSERID VARCHAR(32) DEFAULT '' NOT NULL,/*发送账号*/
	USER_ID BIGINT DEFAULT 0 NOT NULL,/*操作员USERID*/
	CREATETIME DATETIME DEFAULT '0000-00-00 00:00:00' NOT NULL,/*创建时间*/
	CREATE_USERID BIGINT DEFAULT 0 NOT NULL,/*创建者USERID*/
	CORP_CODE VARCHAR(64) DEFAULT '' NOT NULL, /*企业编码*/
  PRIMARY KEY (`ID`)
) ENGINE=INNODB DEFAULT CHARSET=UTF8;


-- ----------------------------
-- PROCEDURE STRUCTURE FOR `COSTRECOVERY`
-- ----------------------------
DROP PROCEDURE IF EXISTS `COSTRECOVERY`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `COSTRECOVERY`(VARSYSDEPID BIGINT,VARDEPID BIGINT,VARUSERNAME VARCHAR(100),VARCOUNT INT,VARCORPCODE VARCHAR(100),VARCOATTYPE INT,OUT VARRETURNCOUNT INT)
TOP:
BEGIN      
	 DECLARE VARPARENTID BIGINT;
	 DECLARE VARBLCOUNT BIGINT;
   DECLARE P_ERR  INT DEFAULT 0;
	 DECLARE CONTINUE HANDLER FOR SQLEXCEPTION,NOT FOUND SET P_ERR=1;
	 IF VARCOUNT = 0 OR VARCOUNT IS NULL THEN
        /*短信充值/回收数目不能为空*/
         SET VARRETURNCOUNT=-2;
         LEAVE TOP;
   END IF;
   START TRANSACTION;
   /*判断是否为ADMIN，ADMIN为顶级机构的操作员*/
   IF VARUSERNAME<>'admin' THEN
        SET VARPARENTID=VARSYSDEPID;
   ELSE
        SELECT SUPERIOR_ID INTO VARPARENTID  FROM LF_DEP WHERE DEP_ID=VARDEPID;
   END IF;
   IF P_ERR=1 THEN
         	/*获取操作员上级机构失败*/
         	SET VARRETURNCOUNT=-3;
         	ROLLBACK;
         	LEAVE TOP;
	 END IF;
	  
	 IF VARUSERNAME<>'admin' OR (VARUSERNAME='admin' AND VARDEPID<>VARSYSDEPID) THEN
         /*充值*/
         IF VARCOATTYPE=1 THEN
            UPDATE LF_DEP_USER_BALANCE SET SMS_BALANCE=SMS_BALANCE-VARCOUNT WHERE CORP_CODE=VARCORPCODE AND SMS_BALANCE>=VARCOUNT AND TARGET_ID=VARPARENTID;
          	IF ROW_COUNT()=0 THEN
                 SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
                 IF P_ERR=1 THEN
									/*获取用户短信余额记录失败*/
									SET VARRETURNCOUNT=-6;
									ROLLBACK;
									LEAVE TOP;
								 END IF;
                  
                 IF VARBLCOUNT=0 THEN
                    /*机构下没有可用短信余额*/
                    SET VARRETURNCOUNT=-4;
                 ELSE
										/*充值数据大于短信可分配余额*/
                    SET VARRETURNCOUNT=-5;
                 END IF;
                 ROLLBACK;
                 LEAVE TOP;
             END IF;
         ELSE
           /*回收*/
           /*回收将回收的加到父及机构上*/
           UPDATE LF_DEP_USER_BALANCE SET SMS_BALANCE=SMS_BALANCE+VARCOUNT WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
           IF ROW_COUNT()=0 THEN
               SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
               IF P_ERR=1 THEN
                   /*获取用户短信余额记录失败*/
                   SET VARRETURNCOUNT=-6;
                   ROLLBACK;
                   LEAVE TOP;
				       END IF;
               IF VARBLCOUNT=0 THEN
                  /*机构下没有可用短信余额*/
                  SET VARRETURNCOUNT=-4;
                  ROLLBACK;
                  LEAVE TOP;
               END IF;
             END IF;
           END IF;
      END IF;
	  /*充值*/
      IF VARCOATTYPE=1 THEN
        UPDATE LF_DEP_USER_BALANCE SET SMS_BALANCE=SMS_BALANCE+VARCOUNT WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARDEPID;
        IF ROW_COUNT()=0 THEN
          /*如果子的机构没有充过值则插入一条充值记录*/
          INSERT INTO LF_DEP_USER_BALANCE(TARGET_ID,SMS_BALANCE,SMS_COUNT,MMS_BALANCE,MMS_COUNT,CORP_CODE)
           VALUES(VARDEPID,VARCOUNT,0,0,0,VARCORPCODE);
        END IF;
      ELSE
          UPDATE LF_DEP_USER_BALANCE SET SMS_BALANCE=SMS_BALANCE-VARCOUNT WHERE CORP_CODE=VARCORPCODE AND SMS_BALANCE>=VARCOUNT AND TARGET_ID=VARDEPID;
          IF ROW_COUNT()=0 THEN
              SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARDEPID;
              IF P_ERR=1 THEN
              /*获取用户短信余额记录失败*/
               SET VARRETURNCOUNT=-6;
               ROLLBACK;
               LEAVE TOP;
							END IF;
              IF VARBLCOUNT=0 THEN
                /*机构没有进行充值过*/
                SET VARRETURNCOUNT=-7;
              ELSE
                /*回收短信数大于机构可分配数目*/
                SET VARRETURNCOUNT=-5;
              END IF;
              ROLLBACK;
              LEAVE TOP;
          END IF;
       END IF;
      /*短信充值/回收成功*/
      SET VARRETURNCOUNT=0;
      COMMIT;
END
;;
DELIMITER ;

-- ----------------------------
-- PROCEDURE STRUCTURE FOR `MMSCOSTRECOVERY`
-- ----------------------------
DROP PROCEDURE IF EXISTS `MMSCOSTRECOVERY`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `MMSCOSTRECOVERY`(VARSYSDEPID BIGINT,VARDEPID BIGINT,VARUSERNAME VARCHAR(100),VARCOUNT INT,VARCORPCODE VARCHAR(100),VARCOATTYPE INT,OUT VARRETURNCOUNT INT)
TOP:
BEGIN      
	 DECLARE VARPARENTID BIGINT;
	 DECLARE VARBLCOUNT BIGINT;
   DECLARE P_ERR  INT DEFAULT 0;
	 DECLARE CONTINUE HANDLER FOR SQLEXCEPTION,NOT FOUND SET P_ERR=1;
	 IF VARCOUNT = 0 OR VARCOUNT IS NULL THEN
        /*彩信充值/回收数目不能为空*/
         SET VARRETURNCOUNT=-2;
         LEAVE TOP;
   END IF;
   START TRANSACTION;
   /*判断是否为ADMIN，ADMIN为顶级机构的操作员*/
   IF VARUSERNAME<>'admin' THEN
        SET VARPARENTID=VARSYSDEPID;
   ELSE
        SELECT SUPERIOR_ID INTO VARPARENTID  FROM LF_DEP WHERE DEP_ID=VARDEPID;
   END IF;
   IF P_ERR=1 THEN
         	/*获取操作员上级机构失败*/
         	SET VARRETURNCOUNT=-3;
         	ROLLBACK;
         	LEAVE TOP;
	 END IF;
	  
	 IF VARUSERNAME<>'admin' OR (VARUSERNAME='admin' AND VARDEPID<>VARSYSDEPID) THEN
         /*充值*/
         IF VARCOATTYPE=1 THEN
            UPDATE LF_DEP_USER_BALANCE SET MMS_BALANCE=MMS_BALANCE-VARCOUNT WHERE CORP_CODE=VARCORPCODE AND MMS_BALANCE>=VARCOUNT AND TARGET_ID=VARPARENTID;
          	IF ROW_COUNT()=0 THEN
                 SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
                 IF P_ERR=1 THEN
									/*获取用户彩信余额记录失败*/
									SET VARRETURNCOUNT=-6;
									ROLLBACK;
									LEAVE TOP;
								 END IF;
                  
                 IF VARBLCOUNT=0 THEN
                    /*机构下没有可用彩信余额*/
                    SET VARRETURNCOUNT=-4;
                 ELSE
										/*充值数据大于彩信可分配余额*/
                    SET VARRETURNCOUNT=-5;
                 END IF;
                 ROLLBACK;
                 LEAVE TOP;
             END IF;
         ELSE
           /*回收*/
           /*回收将回收的加到父及机构上*/
           UPDATE LF_DEP_USER_BALANCE SET MMS_BALANCE=MMS_BALANCE+VARCOUNT WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
           IF ROW_COUNT()=0 THEN
               SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARPARENTID;
               IF P_ERR=1 THEN
                   /*获取用户彩信余额记录失败*/
                   SET VARRETURNCOUNT=-6;
                   ROLLBACK;
                   LEAVE TOP;
				       END IF;
               IF VARBLCOUNT=0 THEN
                  /*机构下没有可用彩信余额*/
                  SET VARRETURNCOUNT=-4;
                  ROLLBACK;
                  LEAVE TOP;
               END IF;
             END IF;
           END IF;
      END IF;
	  /*充值*/
      IF VARCOATTYPE=1 THEN
        UPDATE LF_DEP_USER_BALANCE SET MMS_BALANCE=MMS_BALANCE+VARCOUNT WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARDEPID;
        IF ROW_COUNT()=0 THEN
          /*如果子的机构没有充过值则插入一条充值记录*/
          INSERT INTO LF_DEP_USER_BALANCE(TARGET_ID,SMS_BALANCE,SMS_COUNT,MMS_BALANCE,MMS_COUNT,CORP_CODE)
           VALUES(VARDEPID,0,0,VARCOUNT,0,VARCORPCODE);
        END IF;
      ELSE
          UPDATE LF_DEP_USER_BALANCE SET MMS_BALANCE=MMS_BALANCE-VARCOUNT WHERE CORP_CODE=VARCORPCODE AND MMS_BALANCE>=VARCOUNT AND TARGET_ID=VARDEPID;
          IF ROW_COUNT()=0 THEN
              SELECT COUNT(BL_ID) INTO VARBLCOUNT FROM LF_DEP_USER_BALANCE  WHERE CORP_CODE=VARCORPCODE AND TARGET_ID=VARDEPID;
              IF P_ERR=1 THEN
              /*获取用户彩信余额记录失败*/
               SET VARRETURNCOUNT=-6;
               ROLLBACK;
               LEAVE TOP;
							END IF;
              IF VARBLCOUNT=0 THEN
                /*机构没有进行充值过*/
                SET VARRETURNCOUNT=-7;
              ELSE
                /*回收彩信数大于机构可分配数目*/
                SET VARRETURNCOUNT=-5;
              END IF;
              ROLLBACK;
              LEAVE TOP;
          END IF;
       END IF;
      /*彩信充值/回收成功*/
      SET VARRETURNCOUNT=0;
      COMMIT;
END
;;
DELIMITER ;

/*EMP脚本END  */
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;

CALL LF_PVERV0('6.6.0.330','6.21','8.4.1.153','6.1.21.313',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.19-V6.21 END*/


/*****V6.21-V6.22 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.22',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.330';

/*网关升级脚本(V4.05.02-V4.05.03)START*/
DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_WR_MTLVLQUEV2`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_WR_MTLVLQUEV2`(P_PIUID        INT,
   P_PIPTMSGID    BIGINT,
   P_PIRETFLAG    TINYINT UNSIGNED,
   P_PIPKTOTAL    TINYINT UNSIGNED,
   P_PIPHONECOUNT INT,
   P_PISENDSTATUS TINYINT UNSIGNED,
   P_PISPLITFLAG  TINYINT UNSIGNED,
   P_PIECID       INT,
   P_PIUSERID     VARCHAR(11),
   P_PISPGATE     VARCHAR(21),
   P_PICPNO       VARCHAR(21),
   P_PIRECVMTTIME DATETIME,
   P_PIPHONE      VARCHAR(3500),
   P_PIMESSAGE    VARCHAR(3000) CHARSET 'GBK',
   P_PIFEEFLAG    TINYINT UNSIGNED,
   P_PIDESTUID    INT,
   P_PILOGINUID   INT,
   P_PIPKNUMBER   TINYINT UNSIGNED,
   P_PISENDLEVEL  TINYINT UNSIGNED,
   P_PITPUDHI     TINYINT UNSIGNED,
   P_PITASKID     INT,
   P_PILONGMSGSEQ TINYINT UNSIGNED,
   P_PIMSGFMT     TINYINT UNSIGNED,
   P_PITOTALCOUNT INT,
   P_SVRTYPE VARCHAR(64),
   P_P1 VARCHAR(64),
   P_P2 VARCHAR(64),
   P_P3 VARCHAR(64),
   P_P4 VARCHAR(64),
   P_USERMSGID BIGINT,
   P_MODULEID INT,
   P_ATTIME BIGINT,
   P_VALIDTIME BIGINT,
   P_SENDTYPE INT,
   P_BATCHID BIGINT,
   P_AREACODE INT,
   P_CUSTID VARCHAR(64),
	 P_EXDATA VARCHAR(64))
BEGIN
    CASE P_TABLENO
WHEN 0 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 1 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL1_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL1_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 2 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL2_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL2_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 3 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL3_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL3_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 4 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL4_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL4_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 5 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL5_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL5_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 6 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL6_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL6_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 7 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL7_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL7_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 8 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL8_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL8_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 9 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL9_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL9_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
END CASE;
END;;
DELIMITER ;

CALL S_WR_VERINFO('4.05.03');
/*网关升级脚本(V4.05.02-V4.05.03)END*/

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;


CALL LF_PVERV0('6.6.0.331','6.22','8.4.1.153','6.1.21.313',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.21-V6.22 END*/


/*****V6.22-V6.23 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.23',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.331';

/*Lf_Corp表新增字段 是否开启上行退订功能 默认值为0  0不启动  1是启用*/
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE ADDCOL() 
BEGIN
IF NOT EXISTS(SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA=DATABASE() AND COLUMN_NAME='ISOPENTD' AND TABLE_NAME='LF_CORP') THEN
	ALTER TABLE LF_CORP ADD ISOPENTD INT DEFAULT 0 NOT NULL;
END IF;
END;;
DELIMITER ;
CALL ADDCOL();
DROP PROCEDURE ADDCOL;


DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;


CALL LF_PVERV0('6.6.0.332','6.23','8.4.1.153','6.1.21.313',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.22-V6.23 END*/


/*****V6.23-V6.25 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.25',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.332';


/*网关升级脚本(V4.05.03-V4.05.04)START*/

DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_WR_MTLVLQUEV2`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_WR_MTLVLQUEV2`(P_PIUID        INT,
   P_PIPTMSGID    BIGINT,
   P_PIRETFLAG    TINYINT UNSIGNED,
   P_PIPKTOTAL    TINYINT UNSIGNED,
   P_PIPHONECOUNT INT,
   P_PISENDSTATUS TINYINT UNSIGNED,
   P_PISPLITFLAG  TINYINT UNSIGNED,
   P_PIECID       INT,
   P_PIUSERID     VARCHAR(11),
   P_PISPGATE     VARCHAR(21),
   P_PICPNO       VARCHAR(21),
   P_PIRECVMTTIME DATETIME,
   P_PIPHONE      VARCHAR(3500),
   P_PIMESSAGE    VARCHAR(3000) CHARSET 'GBK',
   P_PIFEEFLAG    TINYINT UNSIGNED,
   P_PIDESTUID    INT,
   P_PILOGINUID   INT,
   P_PIPKNUMBER   TINYINT UNSIGNED,
   P_PISENDLEVEL  TINYINT UNSIGNED,
   P_PITPUDHI     TINYINT UNSIGNED,
   P_PITASKID     INT,
   P_PILONGMSGSEQ TINYINT UNSIGNED,
   P_PIMSGFMT     TINYINT UNSIGNED,
   P_PITOTALCOUNT INT,
   P_SVRTYPE VARCHAR(64),
   P_P1 VARCHAR(64),
   P_P2 VARCHAR(64),
   P_P3 VARCHAR(64),
   P_P4 VARCHAR(64),
   P_USERMSGID BIGINT,
   P_MODULEID INT,
   P_ATTIME BIGINT,
   P_VALIDTIME BIGINT,
   P_SENDTYPE INT,
   P_BATCHID BIGINT,
   P_AREACODE INT,
   P_CUSTID VARCHAR(64),
	 P_EXDATA VARCHAR(64),
	 P_TABLENO INT)
BEGIN
    CASE P_TABLENO
WHEN 0 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL0_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL0_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 1 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL1_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL1_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 2 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL2_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL2_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 3 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL3_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL3_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 4 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL4_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL4_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 5 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL5_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL5_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 6 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL6_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL6_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 7 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL7_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL7_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 8 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL8_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL8_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
WHEN 9 THEN
  IF NOT EXISTS (SELECT PTMSGID FROM MT_LEVEL9_QUEUE WHERE PTMSGID=P_PIPTMSGID) THEN
	   INSERT INTO MT_LEVEL9_QUEUE(UID, USERID, SPGATE, CPNO, PHONE, PTMSGID, MESSAGE, RETFLAG, PKTOTAL, TOTALCOUNT,
	   PHONECOUNT, SENDTIME, SENDSTATUS, SPLITFLAG, ECID, FEEFLAG,DESTUID,LOGINUID,PKNUMBER,TPUDHI,SENDLEVEL,TASKID,LONGMSGSEQ,MSGFMT,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
	   VALUES(P_PIUID, P_PIUSERID, P_PISPGATE, P_PICPNO, P_PIPHONE, P_PIPTMSGID, P_PIMESSAGE, P_PIRETFLAG, P_PIPKTOTAL, P_PITOTALCOUNT,
	   P_PIPHONECOUNT,P_PIRECVMTTIME, P_PISENDSTATUS, P_PISPLITFLAG, P_PIECID, P_PIFEEFLAG, P_PIDESTUID,P_PILOGINUID,P_PIPKNUMBER,
	   P_PITPUDHI,P_PISENDLEVEL,P_PITASKID,P_PILONGMSGSEQ,P_PIMSGFMT,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
  END IF;
END CASE;
END;;
DELIMITER ;

UPDATE A_GWPARAMCONF SET PARAMATTRIBUTE=2 WHERE PARAMITEM='SMPPPORT' AND GWTYPE=4000;

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_ADDPBLISTBLACK;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_ADDPBLISTBLACK`(
PIPHONE BIGINT,
PITDCMD VARCHAR(64),
PIUSERID VARCHAR(11),
PISPNUMBER VARCHAR(21),
PISVRTYPE VARCHAR(64),
PIECID INT,
PIMOMSGID BIGINT)

BEGIN

DECLARE PIOPTYPE TINYINT;      
DECLARE PIPBUSERID VARCHAR(11);
DECLARE PIPBSPNUMBER VARCHAR(21);
DECLARE PIPBSVRTYPE VARCHAR(64);
DECLARE PIPBCROPCODE VARCHAR(64);

	
	##表的策略信息决定是否需要添加黑名单
        IF EXISTS(SELECT * FROM GW_TDCMD WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0) THEN
             SELECT OPTYPE,PB_USERID,PB_SPNUMBER,PB_SVRTYPE,PB_CROPCODE  INTO PIOPTYPE,PIPBUSERID,PIPBSPNUMBER,PIPBSVRTYPE,PIPBCROPCODE  FROM GW_TDCMD WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0 LIMIT 0,1;     

	
		 ##PB_LIST_BLACK表中是否已经存在对应的黑名单数据
		IF NOT EXISTS(SELECT * FROM PB_LIST_BLACK WHERE USERID=PIPBUSERID AND SPGATE='' AND SPNUMBER=PIPBSPNUMBER AND PHONE=PIPHONE AND SVRTYPE=PIPBSVRTYPE AND CORPCODE=PIPBCROPCODE) THEN
		   INSERT INTO PB_LIST_BLACK(USERID,SPGATE,SPNUMBER,PHONE,OPTYPE,OPTTIME,MSG,SVRTYPE,SPISUNCM,CORPCODE,BLTYPE)
		          VALUES(PIPBUSERID,'',PIPBSPNUMBER,PIPHONE,PIOPTYPE,NOW(),'',PIPBSVRTYPE,0,PIPBCROPCODE,1);
		   INSERT INTO GW_TDCMD_HIS(TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID,OPTYPE,MO_MSGID,TD_TIME)
		          VALUES(PIPHONE,PITDCMD,PIUSERID,PISPNUMBER,PIECID,PIOPTYPE,PIMOMSGID,NOW());
                END IF;	
        END IF;	
END;;
DELIMITER ;

UPDATE A_PROTOCOLTMPL SET PROTOCOLPARAM='EXPIREHOUR=24;OUTDBGINFO=3;RETURNMOUDHI=0;SRCTON=1;SRCNPI=1;DESTTON=1;DESTNPI=1;MSGIDENCODE=16'  
WHERE PROTOCOLCODE=8 AND PROTOCOL='SMPP3X';

CALL S_WR_VERINFO('4.05.04');

/*网关升级脚本(V4.05.03-V4.05.04)END */


DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;


CALL LF_PVERV0('6.6.0.333','6.25','8.4.4.157','6.1.21.313',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.23-V6.25 END*/

/*****V6.25-V6.26 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.26',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.333';
/*网关升级脚本(V4.05.04-V4.05.05)START */

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_ADDPBLISTBLACK;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_ADDPBLISTBLACK`(
PIPHONE BIGINT,
PITDCMD VARCHAR(64),
PIUSERID VARCHAR(11),
PISPNUMBER VARCHAR(21),
PISVRTYPE VARCHAR(64),
PIECID INT,
PIMOMSGID BIGINT)

BEGIN
DECLARE PIOPTYPE TINYINT;      
DECLARE PIPBUSERID VARCHAR(11);
DECLARE PIPBSPNUMBER VARCHAR(21);
DECLARE PIPBSVRTYPE VARCHAR(64);
DECLARE PIPBCROPCODE VARCHAR(64);

	##表的策略信息决定是否需要添加黑名单
        IF EXISTS(SELECT * FROM GW_TDCMD WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0) THEN
             SELECT OPTYPE,PB_USERID,PB_SPNUMBER,PB_SVRTYPE,PB_CROPCODE  INTO PIOPTYPE,PIPBUSERID,PIPBSPNUMBER,PIPBSVRTYPE,PIPBCROPCODE  FROM GW_TDCMD WHERE UPPER(TD_CMD)=UPPER(PITDCMD) AND (TD_USERID=PIUSERID OR TD_USERID='000000') AND (TD_SPNUMBER='' OR ( PISPNUMBER LIKE CONCAT(TD_SPNUMBER,'%'))) AND (TD_ECID=PIECID OR TD_ECID=0) AND (PB_SVRTYPE=PISVRTYPE OR PB_SVRTYPE='') AND STATUS=0 LIMIT 0,1;     

	
		 ##PB_LIST_BLACK表中是否已经存在对应的黑名单数据
		IF NOT EXISTS(SELECT * FROM PB_LIST_BLACK WHERE USERID=PIPBUSERID AND SPGATE='' AND SPNUMBER=PIPBSPNUMBER AND PHONE=PIPHONE AND SVRTYPE=PIPBSVRTYPE AND CORPCODE=PIPBCROPCODE AND OPTYPE=1) THEN
		   INSERT INTO PB_LIST_BLACK(USERID,SPGATE,SPNUMBER,PHONE,OPTYPE,OPTTIME,MSG,SVRTYPE,SPISUNCM,CORPCODE,BLTYPE)
		          VALUES(PIPBUSERID,'',PIPBSPNUMBER,PIPHONE,PIOPTYPE,NOW(),'',PIPBSVRTYPE,0,PIPBCROPCODE,1);
		   INSERT INTO GW_TDCMD_HIS(TD_PHONE,TD_CMD,TD_USERID,TD_SPNUMBER,TD_ECID,OPTYPE,MO_MSGID,TD_TIME)
		          VALUES(PIPHONE,PITDCMD,PIUSERID,PISPNUMBER,PIECID,PIOPTYPE,PIMOMSGID,NOW());
                END IF;	
        END IF;	
END;;
DELIMITER ;

CALL S_WR_VERINFO('4.05.05');

/*网关升级脚本(V4.05.04-V4.05.05)END */


DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;


CALL LF_PVERV0('6.6.0.335','6.26','8.4.5.158','6.1.21.313',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.25-V6.26 END*/

/*****V6.26-V6.27 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.27',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.335';

DELETE FROM LF_USER2ROLE WHERE USER_ID=1;

/*网关升级脚本(V4.05.05-V4.05.06)START */
DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_WR_MTTASKV2`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_WR_MTTASKV2`(
P_UID INT,	
P_PTMSGID BIGINT,
	P_SENDSTATUS TINYINT UNSIGNED,
	P_RETFLAG TINYINT UNSIGNED,
	P_PKTOTAL TINYINT UNSIGNED,
	P_PHONECOUNT INT,
	P_SPLITLEN TINYINT UNSIGNED,
	P_MULTILEN1 TINYINT UNSIGNED,
	P_MULTILEN2 TINYINT UNSIGNED,
	P_SIGNLEN TINYINT UNSIGNED,
	P_ECID INT,
	P_USERID VARCHAR(11), 
P_SPGATE VARCHAR(21),
	P_CPNO VARCHAR(21),
	P_RECVMTTIME DATETIME,
	P_MESSAGE VARCHAR(3000)  CHARSET 'GBK',
	P_SHOUJI VARCHAR(3500),
	P_FEEFLAG TINYINT UNSIGNED,
	P_SENDLEVEL TINYINT UNSIGNED,
	P_TASKID INT,
	P_ERRORCODE CHAR(7),
	P_TPUDHI TINYINT UNSIGNED,
	P_LONGMSGSEQ TINYINT UNSIGNED,
	P_MSGFMT TINYINT UNSIGNED,
	P_UNICOM TINYINT UNSIGNED,
  P_MOBILEAREA INT UNSIGNED, 
  P_PKNUMBER TINYINT UNSIGNED,
  P_SVRTYPE VARCHAR(64),
  P_P1 VARCHAR(64),
  P_P2 VARCHAR(64),
  P_P3 VARCHAR(64),
  P_P4 VARCHAR(64),
  P_USERMSGID BIGINT,
  P_MODULEID INT,
  P_ATTIME BIGINT,
  P_VALIDTIME BIGINT,
  P_SENDTYPE TINYINT UNSIGNED,
  P_BATCHID BIGINT,
  P_AREACODE INT,
  P_CUSTID VARCHAR(64),
	P_EXDATA VARCHAR(64))
  TOP:BEGIN
    DECLARE P_TMPMSGID BIGINT;
	DECLARE P_LOCATION INT;
	DECLARE P_START INT;
	DECLARE P_RESULTPHONE VARCHAR(21); #存储拆分后的字符
	DECLARE P_STRSPLIT VARCHAR(2);
	DECLARE P_LEN INT;
	DECLARE P_RESULTMSG VARCHAR(3000); #存储拆分后的字符
	DECLARE P_PKNUM INT;
	DECLARE P_TMPNUM INT;

    CREATE TEMPORARY TABLE IF NOT EXISTS P_TMP_WRMTTASKV2(UID INT,USERID VARCHAR(11),SPGATE VARCHAR(21),CPNO VARCHAR(21),
						PHONE VARCHAR(21),PTMSGID BIGINT,MESSAGE VARCHAR(3000),
						SENDSTATUS TINYINT,RETFLAG TINYINT,PKNUMBER TINYINT,
						PKTOTAL TINYINT,RECVMTTIME DATETIME,ECID INT,FEEFLAG TINYINT,
						SENDLEVEL TINYINT,TASKID INT,ERRORCODE CHAR(7),TPUDHI TINYINT,
						LONGMSGSEQ TINYINT,MSGFMT TINYINT,UNICOM TINYINT,MOBILEAREA INT,
						SVRTYPE VARCHAR(64),P1 VARCHAR(64),P2 VARCHAR(64),P3 VARCHAR(64),
						P4 VARCHAR(64),USERMSGID BIGINT,MODULEID INT,ATTIME BIGINT,VALIDTIME BIGINT,SENDTYPE INT,AREACODE INT,CUSTID VARCHAR(64),EXDATA VARCHAR(64));

	TRUNCATE TABLE P_TMP_WRMTTASKV2;

    SET P_LEN = CHAR_LENGTH(P_MESSAGE)-P_SIGNLEN;
	SET P_TMPNUM = 0;
	SET P_PKNUM = 1;
	SET P_STRSPLIT = ',';

    IF P_PHONECOUNT < 1 THEN #手机个数为0
		LEAVE TOP;
    END IF;

	IF P_MSGFMT=4 OR P_MSGFMT=248 OR P_MSGFMT=246 THEN
		SET P_SPLITLEN=140;
		SET P_MULTILEN1=134;
		SET P_MULTILEN2=134;
		SET P_SIGNLEN=0;
	END IF;

	IF P_MSGFMT=25 THEN
		IF NOT EXISTS (SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID=P_PTMSGID) THEN
		   INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
		   RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
		   VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_SHOUJI,P_PTMSGID,P_MESSAGE,P_SENDSTATUS,P_RETFLAG, P_PKNUMBER,P_PKTOTAL,
		   P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM, P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
        END IF;
	END IF;

	IF P_PHONECOUNT = 1 THEN #单发
        IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_PTMSGID) THEN
            IF P_PKTOTAL = 1 THEN
        		INSERT GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
        		RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,
        		P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
        		VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_SHOUJI,P_PTMSGID,P_MESSAGE,P_SENDSTATUS,
        		P_RETFLAG,P_PKTOTAL,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,
        		P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA);
            ELSE
        		SET P_PKNUM = 1;
        		SET P_TMPMSGID = P_PTMSGID;
                IF P_PKTOTAL = 2 AND P_LEN <= P_MULTILEN1 THEN
    				SET P_RESULTMSG = SUBSTRING(P_MESSAGE,1,P_SPLITLEN);#拆分后的字符
    				SET P_TMPMSGID = P_TMPMSGID;
    				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_PTMSGID) THEN
        				INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,
        				RETFLAG,PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
        				VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_SHOUJI,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,
        				P_RETFLAG,P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
    				END IF;

    				SET P_RESULTMSG = SUBSTRING(P_MESSAGE,P_SPLITLEN+1,P_LEN-P_SPLITLEN+P_SIGNLEN);#拆分后的字符
    				SET P_TMPMSGID = P_TMPMSGID+17179869184;
    				SET P_PKNUM = P_PKNUM+1;
    				IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_PTMSGID) THEN
        				INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
        				PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
        				VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_SHOUJI,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,P_RETFLAG,
        				P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
                    END IF;
                ELSE
                    WHILE P_PKNUM <= P_PKTOTAL DO
						IF P_PKNUM = P_PKTOTAL THEN
							SET P_RESULTMSG = SUBSTRING(P_MESSAGE,P_TMPNUM+1,P_MULTILEN2+P_SIGNLEN);#拆分后的字符
							SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
							#PRINT P_RESULTMSG
						ELSEIF P_PKNUM = P_PKTOTAL-1 THEN
							IF P_LEN-(P_PKNUM-1)*P_MULTILEN1 > P_MULTILEN2 AND P_LEN-(P_PKNUM-1)*P_MULTILEN1 <= P_MULTILEN1 THEN
								SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_LEN-(P_PKNUM-1)*P_MULTILEN1-1);
								SET P_TMPNUM = P_LEN-1;
							ELSE
								SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_MULTILEN1);
								SET P_TMPNUM = (P_PKNUM-1)*P_MULTILEN1+P_MULTILEN1;
						    END IF;

							SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
						ELSE
							SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_MULTILEN1);#拆分后的字符
							#PRINT P_RESULTMSG
							SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
						END IF;

						IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_TMPMSGID) THEN
    						INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
    						PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
    						VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_SHOUJI,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,P_RETFLAG,
    						P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
                        END IF;

						SET P_PKNUM = P_PKNUM+1;

                    END WHILE;
                END IF;
            		INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
            		PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
            		SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
            		A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,P_BATCHID,P_AREACODE,P_CUSTID,P_EXDATA FROM P_TMP_WRMTTASKV2 A;
                END IF;
            
		END IF;
	ELSE #群发
		SET P_SHOUJI = CONCAT(P_STRSPLIT , P_SHOUJI , P_STRSPLIT);
		SET P_LOCATION = LOCATE(P_STRSPLIT,P_SHOUJI);

		IF P_PKTOTAL < 1 THEN #没有短信内容
			LEAVE TOP;
        END IF;

		IF P_PKTOTAL >= 1 THEN #需要拆分长短信
			WHILE P_LOCATION <> 0 DO #拆分手机号码
				SET P_START = P_LOCATION;
				SET P_LOCATION = LOCATE(P_STRSPLIT,P_SHOUJI,P_START+1);
				IF P_LOCATION > 0 THEN
					SET P_RESULTPHONE = SUBSTRING(P_SHOUJI,P_START+1,P_LOCATION-P_START-1);#拆分后的字符
					#PRINT P_RESULTPHONE
					#IF P_RESULTPHONE <> ''
					SET P_TMPMSGID = P_PTMSGID;
					IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_TMPMSGID) THEN
						IF P_PKTOTAL = 1 THEN
							INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
							PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
							VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_RESULTPHONE,P_TMPMSGID,P_MESSAGE,P_SENDSTATUS,P_RETFLAG,
							P_PKTOTAL,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
						ELSE
							SET P_PKNUM = 1;
							#SET P_TOTALSPLITNUM = P_PKTOTAL-1
							IF P_PKTOTAL = 2 AND P_LEN <= P_MULTILEN1 THEN
								SET P_RESULTMSG = SUBSTRING(P_MESSAGE,1,P_SPLITLEN);#拆分后的字符
								SET P_TMPMSGID = P_TMPMSGID;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_TMPMSGID) THEN
    								INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
    								PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
    								VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_RESULTPHONE,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,P_RETFLAG,
    								P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
                                END IF;

								SET P_RESULTMSG = SUBSTRING(P_MESSAGE,P_SPLITLEN+1,P_LEN-P_SPLITLEN+P_SIGNLEN);#拆分后的字符
								SET P_TMPMSGID = P_TMPMSGID+17179869184;
								SET P_PKNUM = P_PKNUM+1;
								IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_TMPMSGID) THEN
    								INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
    								PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
    								VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_RESULTPHONE,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,P_RETFLAG,
    								P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
								END IF;
                             ELSE
								WHILE P_PKNUM <= P_PKTOTAL DO
									IF P_PKNUM = P_PKTOTAL THEN
										SET P_RESULTMSG = SUBSTRING(P_MESSAGE,P_TMPNUM+1,P_MULTILEN2+P_SIGNLEN);#拆分后的字符
										SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
									ELSEIF P_PKNUM = P_PKTOTAL-1 THEN
										IF P_LEN-(P_PKNUM-1)*P_MULTILEN1 > P_MULTILEN2 AND P_LEN-(P_PKNUM-1)*P_MULTILEN1 <= P_MULTILEN1 THEN
											SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_LEN-(P_PKNUM-1)*P_MULTILEN1-1);
											SET P_TMPNUM = P_LEN-1;
										ELSE
											SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_MULTILEN1);
											SET P_TMPNUM = (P_PKNUM-1)*P_MULTILEN1+P_MULTILEN1;
										END IF;
										SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
									ELSE
										SET P_RESULTMSG = SUBSTRING(P_MESSAGE,(P_PKNUM-1)*P_MULTILEN1+1,P_MULTILEN1);#拆分后的字符
										#PRINT P_RESULTMSG
										SET P_TMPMSGID = P_PTMSGID+(P_PKNUM-1)*17179869184;
									END IF;
									IF NOT EXISTS(SELECT PTMSGID FROM GW_MT_TASK_BAK WHERE PTMSGID = P_TMPMSGID) THEN
    									INSERT P_TMP_WRMTTASKV2(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
    									PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,AREACODE,CUSTID,EXDATA)
    									VALUES(P_UID,P_USERID,P_SPGATE,P_CPNO,P_RESULTPHONE,P_TMPMSGID,P_RESULTMSG,P_SENDSTATUS,P_RETFLAG,
    									P_PKNUM,P_PKTOTAL,P_RECVMTTIME,P_ECID,P_FEEFLAG,P_SENDLEVEL,P_TASKID,P_ERRORCODE,P_TPUDHI,P_LONGMSGSEQ,P_MSGFMT,P_UNICOM,P_MOBILEAREA,P_SVRTYPE,P_P1,P_P2,P_P3,P_P4,P_USERMSGID,P_MODULEID,P_ATTIME,P_VALIDTIME,P_SENDTYPE,P_AREACODE,P_CUSTID,P_EXDATA);
									END IF;
                                    SET P_PKNUM = P_PKNUM+1;
								END WHILE;
                             END IF; #END OF P_PKTOTAL = 2
						  END IF; # END OF P_PKTOTAL = 1
					   END	IF;	#NOT EXISTS(SELECT
					   SET P_PTMSGID = P_PTMSGID+1;
                   END IF;
				END WHILE;
			END IF;

			INSERT INTO GW_MT_TASK_BAK(UID,USERID,SPGATE,CPNO,PHONE,PTMSGID,MESSAGE,SENDSTATUS,RETFLAG,
			PKNUMBER,PKTOTAL,RECVMTTIME,ECID,FEEFLAG,SENDLEVEL,TASKID,ERRORCODE,TPUDHI,LONGMSGSEQ,MSGFMT,UNICOM,MOBILEAREA,SVRTYPE,P1,P2,P3,P4,USERMSGID,MODULEID,ATTIME,VALIDTIME,SENDTYPE,BATCHID,AREACODE,CUSTID,EXDATA)
			SELECT A.UID,A.USERID,A.SPGATE,A.CPNO,A.PHONE,A.PTMSGID,A.MESSAGE,A.SENDSTATUS,A.RETFLAG,
			A.PKNUMBER,A.PKTOTAL,A.RECVMTTIME,A.ECID,A.FEEFLAG,A.SENDLEVEL,A.TASKID,A.ERRORCODE,A.TPUDHI,A.LONGMSGSEQ,A.MSGFMT,A.UNICOM,A.MOBILEAREA,A.SVRTYPE,A.P1,A.P2,A.P3,A.P4,A.USERMSGID,A.MODULEID,A.ATTIME,A.VALIDTIME,A.SENDTYPE,P_BATCHID,A.AREACODE,A.CUSTID,A.EXDATA FROM P_TMP_WRMTTASKV2 A;
	  END IF;
END;;
DELIMITER ;

DELIMITER ;;
DROP PROCEDURE  IF EXISTS GW_LOADTDCMD;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_LOADTDCMD`()
BEGIN
        DECLARE PI_SQLSTR VARCHAR(2000);
	SET PI_SQLSTR = 'SELECT TD_CMD,MATCHTYPE FROM GW_TDCMD';
	 SET @SQL = PI_SQLSTR;
         PREPARE SL FROM @SQL;
         EXECUTE SL;
END;;
DELIMITER ;

CALL S_WR_VERINFO('4.05.06');

/*网关升级脚本(V4.05.05-V4.05.06)END */


DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.336','6.27','8.4.8.161','6.1.22.315',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.26-V6.27 END*/


/*****V6.27-V6.28 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.28',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.336';

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.337','6.28','8.4.10.163','6.1.22.315',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.27-V6.28 END*/


/*****V6.28-V6.29 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.29',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.337';

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.338','6.29','8.4.10.163','6.1.22.315',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.28-V6.29 END*/


/*****V6.29-V6.30 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.30',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.338';

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.339','6.30','8.4.10.163','6.1.23.316',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.29-V6.30 END*/


/*****V6.30-V6.31 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.31',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.339';


/*代理账号管理*/
INSERT INTO LF_PRIVILEGE (PRIVILEGE_ID, RESOURCE_ID, OPERATE_ID, COMMENTS, PRIV_CODE, MENUNAME, MODNAME, MENUCODE, MENUSITE) 
SELECT 2845, 13, 1, '查看', '1900-1480-0', '代理账号管理', '网关前端配置', '1900-1480', '/pag_proxyMage.htm' FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_PRIVILEGE WHERE PRIVILEGE_ID=2845);

/*代理账号管理*/
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 1, 2845 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=1 AND PRIVILEGE_ID=2845);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 2, 2845 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=2 AND PRIVILEGE_ID=2845);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 4, 2845 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=4 AND PRIVILEGE_ID=2845);

/*代理账号管理 新增权限*/
INSERT INTO LF_PRIVILEGE (PRIVILEGE_ID, RESOURCE_ID, OPERATE_ID, COMMENTS, PRIV_CODE, MENUNAME, MODNAME, MENUCODE, MENUSITE) 
SELECT 2846, 13, NULL, '新增', '1900-1480-1', '代理账号管理', '网关前端配置', '1900-1480', NULL FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_PRIVILEGE WHERE PRIVILEGE_ID=2846);

/*代理账号管理 新增权限*/
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 1, 2846 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=1 AND PRIVILEGE_ID=2846);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 2, 2846 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=2 AND PRIVILEGE_ID=2846);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 4, 2846 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=4 AND PRIVILEGE_ID=2846);


/*代理账号管理 修改权限*/
INSERT INTO LF_PRIVILEGE (PRIVILEGE_ID, RESOURCE_ID, OPERATE_ID, COMMENTS, PRIV_CODE, MENUNAME, MODNAME, MENUCODE, MENUSITE) 
SELECT 2847, 13, NULL, '修改', '1900-1480-2', '代理账号管理', '网关前端配置', '1900-1480', NULL FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_PRIVILEGE WHERE PRIVILEGE_ID=2847);

/*代理账号管理 修改权限*/
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 1, 2847 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=1 AND PRIVILEGE_ID=2847);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 2, 2847 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=2 AND PRIVILEGE_ID=2847);
INSERT INTO LF_IMPOWER (ROLE_ID, PRIVILEGE_ID) SELECT 4, 2847 FROM DUAL
WHERE NOT EXISTS (SELECT * FROM LF_IMPOWER WHERE ROLE_ID=4 AND PRIVILEGE_ID=2847);


DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.340','6.31','8.4.10.163','6.1.23.316',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.30-V6.31 END*/


/*****V6.31-V6.32 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.32',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.340';

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.341','6.32','8.4.10.163','6.1.23.316',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.31-V6.32 END*/


/*****V6.32-V6.33 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'EMPWEB更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.33',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.341';

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.342','6.33','8.4.10.163','6.1.23.316',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.32-V6.33 END*/


/*****V6.33-V6.35 START*/
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    DBVERSIONSTR VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
    IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
    /*EMP产品数据库版本信息表*/
    INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
    VALUES(DBVERSIONSTR,NOW(),NOW(),NUM,TOTALSTR,1,'网关包更改');
    END IF;
END
;; DELIMITER ;
CALL LF_PVERV0('6.35',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;

UPDATE LF_VERSION_HIS SET ISRELEASE=0 WHERE VERSION='6.5.0.342';

/*V4.05.06-V4.05.07 START*/

DELIMITER ;;
DROP PROCEDURE IF EXISTS `GW_H_DATATRANV2`;
CREATE DEFINER=`root`@`%` PROCEDURE `GW_H_DATATRANV2`(ISP1 INT,ISP2 INT,ISP3 INT,ISP4 INT)
TOP:
BEGIN
	DECLARE  P_COUNTINFO INT;
	DECLARE  P_PROCESSINGSTATUSCOUNT  INT; #PROCESSINGSTATUS表记录数(根据USEID设置值判断,为1正常)
	DECLARE  P_USEID                 INT; #使用哪一个USEID作为当前状态处理
	DECLARE  P_CURRINDEX             BIGINT; #当前处理位置
	DECLARE  P_MAXINDEX              BIGINT; #此次执行的最大位置
	DECLARE  P_COUNTSTATUS           INT; #统计状态0:正常,1:错误
	DECLARE  P_DISTRACTSTATUS        INT; #数据转移状态0:正常,1:错误
	DECLARE  P_DELETESTATUS          INT; #删除状态0:正常,1:错误
	DECLARE  P_PROCESSFLAG           INT; #转移方式0:处理今天（含今天)以前的，1为前一天以前的 ,2为前二天以前的...以此类推,

        DECLARE   MINYM INT;                  
        DECLARE   MAXYM INT;                  
        DECLARE   CURYM INT;                  
        DECLARE   TABLENAME       VARCHAR(20);
        DECLARE   STR       VARCHAR(4000) ;  
        DECLARE   P_ISEXIST  INT;

	#异常退出
	DECLARE  P_COUNTEXCEPTION        INT;#允许统计异常最大值
	DECLARE  P_DISTRACTEXCEPTION     INT; #允许数据转移异常最大值
	DECLARE  P_DELETEEXCEPTION       INT; #允许删除数据异常最大值
	DECLARE  P_ALLEXCEPTION          INT; #允许所有异常最大值

       ##批量转移临时变量
       DECLARE PI_CURINDEX           BIGINT;
       DECLARE PI_MAXINDEX           BIGINT;
       DECLARE PI_MININDEX           BIGINT;
       DECLARE EACHMAX               INT; ##每次处理最大数
  DECLARE MAXIYMD INT;
  DECLARE DIFFDATE INT;
DECLARE P_PROCESSFLAGHZ INT;
       ##异常代码
        DECLARE P_ERR  INT DEFAULT 0;
        DECLARE CONTINUE  HANDLER FOR SQLEXCEPTION,NOT FOUND SET P_ERR=1;
	#初始化
	SET P_PROCESSINGSTATUSCOUNT = 0;
	SET P_USEID                 = 1;
	SET P_CURRINDEX             = 0;
	SET P_MAXINDEX              = 0;
	SET P_COUNTSTATUS           = 1;
	SET P_DISTRACTSTATUS        = 1;
	SET P_DELETESTATUS          = 1;
	SET P_PROCESSFLAG           = 3;
	SET EACHMAX               = 500000;
	SET P_COUNTEXCEPTION        = 5;
	SET P_DISTRACTEXCEPTION     = 5;
	SET P_DELETEEXCEPTION       = 5;
	SET P_ALLEXCEPTION          = 10;

        INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','GW_H_DATATRANV2','短信汇总调度存储过程执行开始');
	#1.先汇总
          SET P_PROCESSFLAGHZ=P_PROCESSFLAG;
          SELECT IFNULL(MAX(IYMD),20000101) INTO MAXIYMD  FROM MT_DATAREPORT;
  SET   DIFFDATE=TO_DAYS(DATE_SUB(CURDATE(),INTERVAL 2 DAY)) -TO_DAYS(DATE_FORMAT(MAXIYMD, '%Y-%m-%d')) ; 
 IF DIFFDATE>0 THEN
  SET   P_PROCESSFLAGHZ=P_PROCESSFLAG+DIFFDATE;
END IF;
	SELECT COUNT(ID) INTO P_COUNTINFO FROM GW_MT_TASK_BAK  WHERE  SENDTIME  >= (DATE_SUB(CURDATE(),INTERVAL P_PROCESSFLAGHZ DAY)) AND SENDTIME <CURDATE() ;

	IF P_COUNTINFO>0 THEN
                SET P_ERR=0; 
		CALL GW_H_STATISTIV2(P_PROCESSFLAGHZ,ISP1,ISP2,ISP3,ISP4);
                IF P_ERR=1 THEN 
                   INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行汇总GW_H_STATISTIV2','汇总出现异常');
                END IF;
	END IF;
	#2.再转移
	#先根据指定USEID判断是否有值
	SELECT COUNT(USEID) INTO P_PROCESSINGSTATUSCOUNT FROM PROCESSINGSTATUS WHERE USEID = P_USEID;
	#如果没有先初始化PROCESSINGSTATUS,否则取当表中值
	IF P_PROCESSINGSTATUSCOUNT = 0 THEN
         BEGIN
		CALL H_PROCESSSTATUS(P_USEID,0,0,0,0,0)	;
               SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS INTO P_CURRINDEX, P_MAXINDEX,P_COUNTSTATUS,P_DISTRACTSTATUS,P_DELETESTATUS FROM  PROCESSINGSTATUS WHERE USEID =P_USEID ;
        END;
	ELSE
		SELECT CURRINDEX,MAXINDEX,COUNTSTATUS,DISTRACTSTATUS,DELETESTATUS INTO P_CURRINDEX, P_MAXINDEX,P_COUNTSTATUS,P_DISTRACTSTATUS,P_DELETESTATUS FROM  PROCESSINGSTATUS WHERE USEID =P_USEID ;
        END IF;
      

	SELECT MIN(ID) INTO P_MAXINDEX FROM GW_MT_TASK_BAK  WHERE   SENDTIME >= (DATE_SUB(CURDATE(),INTERVAL P_PROCESSFLAG DAY));
  	IF P_MAXINDEX >0 THEN
		SET P_MAXINDEX =P_MAXINDEX -1;
	END IF;
             ##判断是否存在未转移的数据
        IF P_CURRINDEX<P_MAXINDEX THEN
             ##创建不存在的历史表
             SELECT CAST(DATE_FORMAT(MIN(SENDTIME),'%Y%m') AS SIGNED), CAST(DATE_FORMAT(MAX(SENDTIME),'%Y%m') AS SIGNED)  INTO MINYM, MAXYM  FROM GW_MT_TASK_BAK  WHERE  ID<=P_MAXINDEX;
             SET CURYM = MINYM;
             WHILE CURYM<=MAXYM DO
                  SET TABLENAME =CONCAT( 'MTTASK',CURYM)	;
                  SELECT COUNT(1)  INTO P_ISEXIST FROM `INFORMATION_SCHEMA`.`TABLES` WHERE `TABLE_SCHEMA`=DATABASE() AND `TABLE_NAME`=TABLENAME ;
                  IF P_ISEXIST=0 THEN
                       SET P_ERR=0;
                      CALL CREATETABLE(1,CURYM);
                      IF P_ERR=1 THEN 
                         INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行历史表创建：CREATETABLE','创建历史表出现异常');
                      END IF;
                  END IF;

                  IF CAST(SUBSTRING(CAST(CURYM AS CHAR(6)),5,2) AS SIGNED)=12 THEN
                      SET CURYM = CAST(CONCAT(CAST(CAST(SUBSTRING(CAST(CURYM AS CHAR(6)),1,4)AS SIGNED)+1 AS CHAR(4)),'01' )AS SIGNED);
                  ELSE
                      SET CURYM = CURYM+1  ;
                  END IF;
            END WHILE;
             ##转移数据
             SET P_ERR=0;
	   IF (P_MAXINDEX-P_CURRINDEX>=EACHMAX) THEN
              SET PI_MININDEX=P_CURRINDEX;
              SET PI_CURINDEX=PI_MININDEX+EACHMAX;
           ELSE
              SET PI_MININDEX=P_CURRINDEX;
              SET PI_CURINDEX=P_MAXINDEX;
           END IF;
          WHILE (PI_MININDEX <P_MAXINDEX) DO
               START TRANSACTION;
                SAVEPOINT A;
                CALL GW_H_TRANSFERV1(PI_MININDEX,PI_CURINDEX,0,0);              
                CALL GW_H_DELTASKV1(PI_MININDEX,PI_CURINDEX,0,0);
                CALL H_PROCESSSTATUS(P_USEID,PI_CURINDEX,PI_CURINDEX,0,0,0);
		IF P_ERR = 1 THEN
                BEGIN
                    ROLLBACK TO  SAVEPOINT A;
                    INSERT INTO TRANS_LOG(USETYPE, TRANSNAME, TSTATUS) VALUES('SMS','短信下行数据转移','下行数据转移出现异常');
                    SET P_DISTRACTEXCEPTION = P_DISTRACTEXCEPTION - 1;
                    SET P_ALLEXCEPTION      = P_ALLEXCEPTION - 1;                                      
                    IF P_DISTRACTEXCEPTION <= 0 OR P_ALLEXCEPTION <= 0 THEN
                       LEAVE TOP;
                   END IF;
               END;
               ELSE
                 IF (P_MAXINDEX-PI_CURINDEX>=EACHMAX) THEN
                    SET PI_CURINDEX=PI_CURINDEX+EACHMAX;
                    SET PI_MININDEX=PI_MININDEX+EACHMAX;
                 ELSE
                    SET PI_CURINDEX=P_MAXINDEX;
                    SET PI_MININDEX=PI_MININDEX+EACHMAX;
                 END IF;
                 COMMIT;
              END IF;
        END WHILE;
        END IF;

        #5.执行上行统计
CALL  H_TRANSFERMO();
##删除RPT_WAIT_A,RPT_WAIT_B,MO_WAIT_A,BATCH_MT_REQ_HIS
CALL GW_DELWAIT();
END TOP;;
DELIMITER ;

CALL S_WR_VERINFO('4.05.07');

/*V4.05.06-V4.05.07 END*/

DROP PROCEDURE IF EXISTS `LF_PVERV0`;
DELIMITER ;;
CREATE DEFINER=`root`@`%`  PROCEDURE `LF_PVERV0`(
    VERSIONSTR VARCHAR(32),
    DBVERSIONSTR VARCHAR(32),
    WBSVERSION VARCHAR(32),
    SPGATEVERSION VARCHAR(32),
    NUM INT,
    TOTALSTR INT
)
BEGIN
		/*EMP产品版本记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=VERSIONSTR WHERE PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=WBSVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION SET UPDATETIME=NOW(),VERSION=SPGATEVERSION WHERE PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		/*EMP产品版本历史记录*/
		/*EMP-WEB*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO,ISRELEASE,VERSIONINFO)
			VALUES(1000,1000,VERSIONSTR,NOW(),NOW(),'EMP-WEB',1,'1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW(),ISRELEASE=1,VERSIONINFO='1、EMP接入需支持SMPP3.4国际标准接口，包括客户侧接入和连接运营商侧；<br />2、支持手机上行指令加入全局黑名单，同时提供开关设置；<br />3、文件缓存优化；<br />4、查询接口调用频率限制；<br />5、LINUX系统下使用非root用户安装部署；<br />6、LINUX部署工具优化及增加进程守护。<br />' WHERE VERSION=VERSIONSTR AND PRODUCT_ID=1000 AND PROCESS_ID=1000;
		END IF;
		/*EMP_GATEWAY*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,2000,WBSVERSION,NOW(),NOW(),'EMP_GATEWAY');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=WBSVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=2000;
		END IF;
		/*SMT_SPGATE*/
		IF NOT EXISTS(SELECT * FROM LF_VERSION_HIS WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000) THEN
			INSERT INTO LF_VERSION_HIS(PRODUCT_ID,PROCESS_ID,VERSION,UPDATETIME,CREATETIME,MEMO)
			VALUES(1000,3000,SPGATEVERSION,NOW(),NOW(),'SMT_SPGATE');
		ELSE
			UPDATE LF_VERSION_HIS SET UPDATETIME=NOW() WHERE VERSION=SPGATEVERSION AND PRODUCT_ID=1000 AND PROCESS_ID=3000;
		END IF;
		IF NOT EXISTS(SELECT * FROM LF_DB_SCRIPT WHERE VERSION=DBVERSIONSTR) THEN
			/*EMP产品数据库版本信息表*/
			INSERT INTO LF_DB_SCRIPT(VERSION,UPDATETIME,CREATETIME,CURRENT_NO,TOTAL,STATE,MEMO)
			VALUES(DBVERSIONSTR,NOW(),NOW(),@NUM,@TOTAL,2,'网关包更改');
		ELSE
			UPDATE LF_DB_SCRIPT SET STATE=2,UPDATETIME=NOW(),MEMO='网关包更改' WHERE  VERSION=DBVERSIONSTR AND CURRENT_NO=@NUM AND TOTAL=@TOTAL;
		END IF;
END;; 
DELIMITER ;
CALL LF_PVERV0('6.6.0.343','6.35','8.4.10.163','6.1.23.316',1,1);
DROP PROCEDURE IF EXISTS `LF_PVERV0`;
/*****V6.33-V6.35 END*/